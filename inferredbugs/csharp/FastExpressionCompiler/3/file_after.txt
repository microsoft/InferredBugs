// <auto-generated/>
/*
The MIT License (MIT)

Copyright (c) 2016-2020 Maksim Volkau

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
*/

// ReSharper disable CoVariantArrayConversion
/*
// Lists the target platforms that are Not supported by FEC - simplifies the direct referencing of Expression.cs file
// Don't forget to uncomment #endif at the end of file

#if !PCL && !NET35 && !NET40 && !NET403 && !NETSTANDARD1_0 && !NETSTANDARD1_1 && !NETSTANDARD1_2 && !NETCOREAPP1_0 && !NETCOREAPP1_1
#define SUPPORTS_FAST_EXPRESSION_COMPILER
#endif

#if SUPPORTS_FAST_EXPRESSION_COMPILER
*/
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Linq.Expressions;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Text;
using SysExpr = System.Linq.Expressions.Expression;

namespace FastExpressionCompiler.LightExpression
{
#pragma warning disable CS1591 // Missing XML comment for publicly visible type or member

    /// <summary>Facade for constructing Expression.</summary>
    public abstract class Expression
    {
        /// <summary>Expression node type.</summary>
        public abstract ExpressionType NodeType { get; }

        /// <summary>All expressions should have a Type.</summary>
        public abstract Type Type { get; }

        protected internal abstract Expression Accept(ExpressionVisitor visitor);

        protected internal virtual Expression VisitChildren(ExpressionVisitor visitor) => this;

        public SysExpr ToExpression()
        {
            var exprsConverted = new LiveCountArray<LightAndSysExpr>(Tools.Empty<LightAndSysExpr>());
            return ToExpression(ref exprsConverted);
        }

        /// <summary>Converts back to the respective System Expression
        /// by first checking if `this` expression is already contained in the `exprsConverted` collection</summary>
        internal SysExpr ToExpression(ref LiveCountArray<LightAndSysExpr> exprsConverted)
        {
            var i = exprsConverted.Count - 1;
            while (i != -1 && !ReferenceEquals(exprsConverted.Items[i].LightExpr, this)) --i;
            if (i != -1)
                return (SysExpr)exprsConverted.Items[i].SysExpr;

            var sysExpr = CreateSysExpression(ref exprsConverted);

            ref var item = ref exprsConverted.PushSlot();
            item.LightExpr = this;
            item.SysExpr = sysExpr;
            return sysExpr;
        }

        internal abstract SysExpr CreateSysExpression(ref LiveCountArray<LightAndSysExpr> convertedExpressions);

        /// <summary>Code printer with the provided configuration</summary>
        public abstract StringBuilder CreateExpressionString(StringBuilder sb, List<Expression> uniqueExprs,
            int lineIdent = 0, bool stripNamespace = false, Func<Type, string, string> printType = null, int identSpaces = 2);

        // Searches first for the expression reference in `uniqueExprs` and adds the reference to expression by index, 
        // otherwise delegates to `CreateExpressionCodeString`
        internal StringBuilder ToExpressionString(StringBuilder sb, List<Expression> uniqueExprs,
            int lineIdent = 0, bool stripNamespace = false, Func<Type, string, string> printType = null, int identSpaces = 2)
        {
            var i = uniqueExprs.Count - 1;
            while (i != -1 && !ReferenceEquals(uniqueExprs[i], this)) --i;
            if (i != -1)
                return sb.Append("e[").Append(i).Append(']');

            uniqueExprs.Add(this);
            sb.Append("e[").Append(uniqueExprs.Count - 1).Append("]=");
            return CreateExpressionString(sb, uniqueExprs, lineIdent, stripNamespace, printType, identSpaces);
        }

        /// <summary>Prints the expression in its constructing syntax - helpful to get it from debug and put into the code for test,
        /// e.g. <code><![CDATA[ var expr = Lambda(New(typeof(X).GetTypeInfo().DeclaredConstructors.ToArray()[1]), Parameter(typeof(X), "x")) ]]></code>.</summary>
        public string ToExpressionString()
        {
            var sb = new StringBuilder(1024);
            sb.Append("var expr = ");
            var e = new List<Expression>();
            sb = CreateExpressionString(sb, e, 2).Append(';');
            sb.Insert(0, $"var e = new Expression[{e.Count}]; // unique expressions{System.Environment.NewLine}");
            return sb.ToString();
        }

        /// <summary>Tries to convert to the correct C# code which expression is representing.</summary>
        public string ToCSharpString() =>
            ToCSharpString(new StringBuilder(1024), 4, true).Append(';').ToString();

        /// <summary>Code printer with the provided configuration</summary>
        public virtual StringBuilder ToCSharpString(StringBuilder sb,
            int lineIdent = 0, bool stripNamespace = false, Func<Type, string, string> printType = null, int identSpaces = 4) =>
            sb.Append(ToString()); // falling back ToString and hoping for the best 

        /// <summary>Converts to Expression and outputs its as string</summary>
        public override string ToString() => ToExpression().ToString();

        /// <summary>Reduces the Expression to simple ones</summary>
        public virtual Expression Reduce() => this;

        internal static SysExpr[] ToExpressions(IReadOnlyList<Expression> exprs, ref LiveCountArray<LightAndSysExpr> exprsConverted)
        {
            if (exprs.Count == 0)
                return Tools.Empty<SysExpr>();

            if (exprs.Count == 1)
                return new[] { exprs[0].ToExpression(ref exprsConverted) };

            var result = new SysExpr[exprs.Count];
            for (var i = 0; i < result.Length; ++i)
                result[i] = exprs[i].ToExpression(ref exprsConverted);
            return result;
        }

        public static ParameterExpression Parameter(Type type, string name = null)
        {
            var isByRef = type.IsByRef;
            return isByRef
                ? new ByRefParameterExpression(type.GetElementType(), name)
                : new ParameterExpression(type, name);
        }

        public static ParameterExpression Variable(Type type, string name = null) =>
            new ParameterExpression(type, name);

        public static readonly ConstantExpression NullConstant = new TypedConstantExpression(null, typeof(object));
        public static readonly ConstantExpression FalseConstant = new ConstantExpression(false);
        public static readonly ConstantExpression TrueConstant = new ConstantExpression(true);
        public static readonly ConstantExpression ZeroConstant = new ConstantExpression(0);

        public static ConstantExpression Constant(bool value) =>
            value ? TrueConstant : FalseConstant;

        public static ConstantExpression Constant(int value) =>
            value == 0 ? ZeroConstant : new TypedConstantExpression<int>(value);

        public static ConstantExpression Constant<T>(T value) =>
            new TypedConstantExpression<T>(value);

        public static ConstantExpression Constant(object value)
        {
            if (value == null)
                return NullConstant;

            if (value is bool b)
                return b ? TrueConstant : FalseConstant;

            if (value is int n)
                return n == 0 ? ZeroConstant : new TypedConstantExpression<int>(n);

            return new ConstantExpression(value);
        }

        public static ConstantExpression Constant(object value, Type type) =>
            new TypedConstantExpression(value, type);

        public static NewExpression New(Type type)
        {
            if (type.IsValueType())
                return new NewValueTypeExpression(type);

            foreach (var x in type.GetTypeInfo().DeclaredConstructors)
                if (x.GetParameters().Length == 0)
                    return new NewExpression(x);

            throw new ArgumentException($"The type {type} is missing the default constructor");
        }

        public static NewExpression New(ConstructorInfo ctor, params Expression[] arguments) =>
            arguments == null || arguments.Length == 0 ? new NewExpression(ctor) : new ManyArgumentsNewExpression(ctor, arguments);

        public static NewExpression New(ConstructorInfo ctor, IEnumerable<Expression> arguments)
        {
            var args = arguments.AsReadOnlyList();
            return args == null || args.Count == 0 ? new NewExpression(ctor) : new ManyArgumentsNewExpression(ctor, args);
        }

        public static NewExpression New(ConstructorInfo ctor) => new NewExpression(ctor);

        public static NewExpression New(ConstructorInfo ctor, Expression arg) =>
            new OneArgumentNewExpression(ctor, arg);

        public static NewExpression New(ConstructorInfo ctor, Expression arg0, Expression arg1) =>
            new TwoArgumentsNewExpression(ctor, arg0, arg1);

        public static NewExpression New(ConstructorInfo ctor, Expression arg0, Expression arg1, Expression arg2) =>
            new ThreeArgumentsNewExpression(ctor, arg0, arg1, arg2);

        public static NewExpression New(ConstructorInfo ctor,
            Expression arg0, Expression arg1, Expression arg2, Expression arg3) =>
            new FourArgumentsNewExpression(ctor, arg0, arg1, arg2, arg3);

        public static NewExpression New(ConstructorInfo ctor,
            Expression arg0, Expression arg1, Expression arg2, Expression arg3, Expression arg4) =>
            new FiveArgumentsNewExpression(ctor, arg0, arg1, arg2, arg3, arg4);

        public static MethodCallExpression Call(MethodInfo method, params Expression[] arguments)
        {
            if (arguments == null || arguments.Length == 0)
                return new MethodCallExpression(method);
            return new ManyArgumentsMethodCallExpression(method, arguments);
        }

        public static MethodCallExpression Call(MethodInfo method, IEnumerable<Expression> arguments)
        {
            var args = arguments.AsReadOnlyList();
            if (args == null || args.Count == 0)
                return new MethodCallExpression(method);
            return new ManyArgumentsMethodCallExpression(method, args);
        }

        public static MethodCallExpression Call(Expression instance, MethodInfo method, params Expression[] arguments)
        {
            if (arguments == null || arguments.Length == 0)
                return new InstanceMethodCallExpression(instance, method);
            return new InstanceManyArgumentsMethodCallExpression(instance, method, arguments);
        }

        public static MethodCallExpression Call(Expression instance, MethodInfo method, IEnumerable<Expression> arguments)
        {
            var args = arguments.AsReadOnlyList();
            if (args == null || args.Count == 0)
                return new InstanceMethodCallExpression(instance, method);
            return new InstanceManyArgumentsMethodCallExpression(instance, method, args);
        }

        public static MethodCallExpression Call(Type type, string methodName, Type[] typeArguments, params Expression[] arguments)
        {
            if (arguments == null || arguments.Length == 0)
                return new MethodCallExpression(type.FindMethod(methodName, typeArguments, arguments, isStatic: true));
            return new ManyArgumentsMethodCallExpression(type.FindMethod(methodName, typeArguments, arguments, isStatic: true), arguments);
        }

        public static MethodCallExpression Call(Type type, string methodName, Type[] typeArguments, IEnumerable<Expression> arguments)
        {
            var args = arguments.AsReadOnlyList();
            if (args == null || args.Count == 0)
                return new MethodCallExpression(type.FindMethod(methodName, typeArguments, args, isStatic: true));
            return new ManyArgumentsMethodCallExpression(type.FindMethod(methodName, typeArguments, args, isStatic: true), args);
        }

        public static MethodCallExpression Call(Expression instance, string methodName, Type[] typeArguments, params Expression[] arguments)
        {
            if (arguments == null || arguments.Length == 0)
                return new InstanceMethodCallExpression(instance, instance.Type.FindMethod(methodName, typeArguments, arguments));
            return new InstanceManyArgumentsMethodCallExpression(instance, instance.Type.FindMethod(methodName, typeArguments, arguments), arguments);
        }

        public static MethodCallExpression Call(Expression instance, string methodName, Type[] typeArguments, IEnumerable<Expression> arguments)
        {
            var args = arguments.AsReadOnlyList();
            if (args == null || args.Count == 0)
                return new InstanceMethodCallExpression(instance, instance.Type.FindMethod(methodName, typeArguments, args));
            return new InstanceManyArgumentsMethodCallExpression(instance, instance.Type.FindMethod(methodName, typeArguments, args), args);
        }

        public static MethodCallExpression Call(MethodInfo method) =>
            new MethodCallExpression(method);

        public static MethodCallExpression Call(Expression instance, MethodInfo method) =>
            instance == null
            ? new MethodCallExpression(method)
            : new InstanceMethodCallExpression(instance, method);

        public static MethodCallExpression Call(MethodInfo method, Expression argument) =>
            new OneArgumentMethodCallExpression(method, argument);

        public static MethodCallExpression Call(Expression instance, MethodInfo method, Expression argument) =>
            instance == null
            ? new OneArgumentMethodCallExpression(method, argument)
            : new InstanceOneArgumentMethodCallExpression(instance, method, argument);

        public static MethodCallExpression Call(MethodInfo method, Expression arg0, Expression arg1) =>
            new TwoArgumentsMethodCallExpression(method, arg0, arg1);

        public static MethodCallExpression Call(Expression instance, MethodInfo method, Expression arg0, Expression arg1) =>
            instance == null
            ? new TwoArgumentsMethodCallExpression(method, arg0, arg1)
            : new InstanceTwoArgumentsMethodCallExpression(instance, method, arg0, arg1);

        public static MethodCallExpression Call(MethodInfo method, Expression arg0, Expression arg1, Expression arg2) =>
            new ThreeArgumentsMethodCallExpression(method, arg0, arg1, arg2);

        public static MethodCallExpression Call(Expression instance, MethodInfo method, Expression arg0, Expression arg1, Expression arg2) =>
            instance == null
            ? new ThreeArgumentsMethodCallExpression(method, arg0, arg1, arg2)
            : new InstanceThreeArgumentsMethodCallExpression(instance, method, arg0, arg1, arg2);

        public static MethodCallExpression Call(MethodInfo method,
            Expression arg0, Expression arg1, Expression arg2, Expression arg3) =>
            new FourArgumentsMethodCallExpression(method, arg0, arg1, arg2, arg3);

        public static MethodCallExpression Call(Expression instance, MethodInfo method,
            Expression arg0, Expression arg1, Expression arg2, Expression arg3) =>
            instance == null
                ? new FourArgumentsMethodCallExpression(method, arg0, arg1, arg2, arg3)
                : new InstanceFourArgumentsMethodCallExpression(instance, method, arg0, arg1, arg2, arg3);

        public static MethodCallExpression Call(MethodInfo method,
            Expression arg0, Expression arg1, Expression arg2, Expression arg3, Expression arg4) =>
            new FiveArgumentsMethodCallExpression(method, arg0, arg1, arg2, arg3, arg4);

        public static MethodCallExpression Call(Expression instance, MethodInfo method,
            Expression arg0, Expression arg1, Expression arg2, Expression arg3, Expression arg4) =>
            instance == null
            ? new FiveArgumentsMethodCallExpression(method, arg0, arg1, arg2, arg3, arg4)
            : new InstanceFiveArgumentsMethodCallExpression(instance, method, arg0, arg1, arg2, arg3, arg4);

        public static Expression CallIfNotNull(Expression instance, MethodInfo method) =>
            CallIfNotNull(instance, method, Tools.Empty<Expression>());

        public static Expression CallIfNotNull(Expression instance, MethodInfo method, IEnumerable<Expression> arguments)
        {
            var instanceVar = Parameter(instance.Type, "x");
            return Block(
                instanceVar,
                Assign(instanceVar, instance),
                Condition(
                    Equal(instanceVar, Constant(null, instance.Type)),
                    Constant(null),
                    Call(instanceVar, method, arguments),
                    method.ReturnType));
        }

        public static MemberExpression Property(PropertyInfo property) =>
            new PropertyExpression(property);

        public static MemberExpression Property(Expression instance, PropertyInfo property) =>
            instance == null
                ? new PropertyExpression(property)
                : new InstancePropertyExpression(instance, property);

        public static MemberExpression Property(Expression expression, string propertyName) =>
            Property(expression, expression.Type.FindProperty(propertyName)
                ?? throw new ArgumentException($"Declared property with the name '{propertyName}' is not found in '{expression.Type}'", nameof(propertyName)));

        public static IndexExpression Property(Expression instance, PropertyInfo indexer, params Expression[] arguments) =>
            new IndexExpression(instance, indexer, arguments);

        public static IndexExpression Property(Expression instance, PropertyInfo indexer, IEnumerable<Expression> arguments) =>
            new IndexExpression(instance, indexer, arguments.AsReadOnlyList());

        public static MemberExpression PropertyOrField(Expression expression, string memberName) =>
            expression.Type.FindProperty(memberName) != null
                ? (MemberExpression)Property(expression, expression.Type.FindProperty(memberName)
                    ?? throw new ArgumentException($"Declared property with the name '{memberName}' is not found in '{expression.Type}'", nameof(memberName)))
                : Field(expression, expression.Type.FindField(memberName)
                    ?? throw new ArgumentException($"Declared field with the name '{memberName}' is not found '{expression.Type}'", nameof(memberName)));

        public static MemberExpression MakeMemberAccess(Expression expression, MemberInfo member)
        {
            if (member is FieldInfo field)
                return Field(expression, field);
            if (member is PropertyInfo property)
                return Property(expression, property);
            throw new ArgumentException($"Member is not field or property: {member}", nameof(member));
        }

        public static IndexExpression MakeIndex(Expression instance, PropertyInfo indexer, IEnumerable<Expression> arguments) =>
            indexer != null ? Property(instance, indexer, arguments) : ArrayAccess(instance, arguments);

        public static IndexExpression ArrayAccess(Expression array, params Expression[] indexes) =>
            new IndexExpression(array, null, indexes);

        public static IndexExpression ArrayAccess(Expression array, IEnumerable<Expression> indexes) =>
            new IndexExpression(array, null, indexes.AsReadOnlyList());

        public static MemberExpression Field(FieldInfo field) =>
            new FieldExpression(field);

        public static MemberExpression Field(Expression instance, FieldInfo field) =>
            instance == null
                ? new FieldExpression(field)
                : new InstanceFieldExpression(instance, field);

        public static MemberExpression Field(Expression instance, string fieldName) =>
            Field(instance, instance.Type.FindField(fieldName));

        /// <summary>Creates a UnaryExpression that represents a bitwise complement operation.</summary>
        public static UnaryExpression Not(Expression expression) =>
            new UnaryExpression(ExpressionType.Not, expression);

        /// <summary>Creates a UnaryExpression that represents an explicit reference or boxing conversion where null is supplied if the conversion fails.</summary>
        public static UnaryExpression TypeAs(Expression expression, Type type) =>
            new TypedUnaryExpression(ExpressionType.TypeAs, expression, type);

        public static TypeBinaryExpression TypeEqual(Expression operand, Type type) =>
            new TypeBinaryExpression(ExpressionType.TypeEqual, operand, type);

        public static TypeBinaryExpression TypeIs(Expression operand, Type type) =>
            new TypeBinaryExpression(ExpressionType.TypeIs, operand, type);

        /// <summary>Creates a UnaryExpression that represents an expression for obtaining the length of a one-dimensional array.</summary>
        public static UnaryExpression ArrayLength(Expression array) =>
            new TypedUnaryExpression<int>(ExpressionType.ArrayLength, array);

        /// <summary>Creates a UnaryExpression that represents a type conversion operation.</summary>
        public static UnaryExpression Convert(Expression expression, Type type) =>
            new TypedUnaryExpression(ExpressionType.Convert, expression, type);

        /// <summary>Creates a UnaryExpression that represents a type conversion operation.</summary>
        public static UnaryExpression Convert<TTo>(Expression expression) =>
            new TypedUnaryExpression<TTo>(ExpressionType.Convert, expression);

        /// <summary>Creates a UnaryExpression that represents a conversion operation for which the implementing method is specified.</summary>
        public static UnaryExpression Convert(Expression expression, Type type, MethodInfo method) =>
            new ConvertWithMethodUnaryExpression(ExpressionType.Convert, expression, type, method);

        /// <summary>Creates a UnaryExpression that represents a conversion operation that throws an exception if the target type is overflowed.</summary>
        public static UnaryExpression ConvertChecked(Expression expression, Type type) =>
            new TypedUnaryExpression(ExpressionType.ConvertChecked, expression, type);

        /// <summary>Creates a UnaryExpression that represents a conversion operation that throws an exception if the target type is overflowed and for which the implementing method is specified.</summary>
        public static UnaryExpression ConvertChecked(Expression expression, Type type, MethodInfo method) =>
            new ConvertWithMethodUnaryExpression(ExpressionType.ConvertChecked, expression, type, method);

        /// <summary>Creates a UnaryExpression that represents the decrementing of the expression by 1.</summary>
        public static UnaryExpression Decrement(Expression expression) =>
            new UnaryExpression(ExpressionType.Decrement, expression);

        /// <summary>Creates a UnaryExpression that represents the incrementing of the expression value by 1.</summary>
        public static UnaryExpression Increment(Expression expression) =>
            new UnaryExpression(ExpressionType.Increment, expression);

        /// <summary>Returns whether the expression evaluates to false.</summary>
        public static UnaryExpression IsFalse(Expression expression) =>
            new TypedUnaryExpression<bool>(ExpressionType.IsFalse, expression);

        /// <summary>Returns whether the expression evaluates to true.</summary>
        public static UnaryExpression IsTrue(Expression expression) =>
            new TypedUnaryExpression<bool>(ExpressionType.IsTrue, expression);

        /// <summary>Creates a UnaryExpression, given an operand, by calling the appropriate factory method.</summary>
        public static UnaryExpression MakeUnary(ExpressionType unaryType, Expression operand, Type type) =>
            type == null
                ? new UnaryExpression(unaryType, operand)
                : new TypedUnaryExpression(unaryType, operand, type);

        /// <summary>Creates a UnaryExpression that represents an arithmetic negation operation.</summary>
        public static UnaryExpression Negate(Expression expression) =>
            new UnaryExpression(ExpressionType.Negate, expression);

        /// <summary>Creates a UnaryExpression that represents an arithmetic negation operation that has overflow checking.</summary>
        public static UnaryExpression NegateChecked(Expression expression) =>
            new UnaryExpression(ExpressionType.NegateChecked, expression);

        /// <summary>Returns the expression representing the ones complement.</summary>
        public static UnaryExpression OnesComplement(Expression expression) =>
            new UnaryExpression(ExpressionType.OnesComplement, expression);

        /// <summary>Creates a UnaryExpression that increments the expression by 1 and assigns the result back to the expression.</summary>
        public static UnaryExpression PreIncrementAssign(Expression expression) =>
            new UnaryExpression(ExpressionType.PreIncrementAssign, expression);

        /// <summary>Creates a UnaryExpression that represents the assignment of the expression followed by a subsequent increment by 1 of the original expression.</summary>
        public static UnaryExpression PostIncrementAssign(Expression expression) =>
            new UnaryExpression(ExpressionType.PostIncrementAssign, expression);

        /// <summary>Creates a UnaryExpression that decrements the expression by 1 and assigns the result back to the expression.</summary>
        public static UnaryExpression PreDecrementAssign(Expression expression) =>
            new UnaryExpression(ExpressionType.PreDecrementAssign, expression);

        /// <summary>Creates a UnaryExpression that represents the assignment of the expression followed by a subsequent decrement by 1 of the original expression.</summary>
        public static UnaryExpression PostDecrementAssign(Expression expression) =>
            new UnaryExpression(ExpressionType.PostDecrementAssign, expression);

        /// <summary>Creates a UnaryExpression that represents an expression that has a constant value of type Expression.</summary>
        public static UnaryExpression Quote(Expression expression) =>
            new UnaryExpression(ExpressionType.Quote, expression);

        /// <summary>Creates a UnaryExpression that represents a unary plus operation.</summary>
        public static UnaryExpression UnaryPlus(Expression expression) =>
            new UnaryExpression(ExpressionType.UnaryPlus, expression);

        /// <summary>Creates a UnaryExpression that represents an explicit unboxing.</summary>
        public static UnaryExpression Unbox(Expression expression, Type type) =>
            new TypedUnaryExpression(ExpressionType.Unbox, expression, type);

        public static LambdaExpression Lambda(Expression body) =>
            new LambdaExpression(Tools.GetFuncOrActionType(body.Type), body);

        public static LambdaExpression Lambda(Type delegateType, Expression body)
        {
            if (delegateType == null || delegateType == typeof(Delegate))
                return new LambdaExpression(Tools.GetFuncOrActionType(body.Type), body);
            var returnType = GetDelegateReturnType(delegateType);
            if (returnType == body.Type)
                return new LambdaExpression(delegateType, body);
            return new TypedReturnLambdaExpression(delegateType, body, returnType);
        }

        public static LambdaExpression Lambda(Type delegateType, Expression body, Type returnType)
        {
            if (delegateType == null || delegateType == typeof(Delegate))
                delegateType = Tools.GetFuncOrActionType(returnType);
            if (returnType == body.Type)
                return new LambdaExpression(delegateType, body);
            return new TypedReturnLambdaExpression(delegateType, body, returnType);
        }

        public static LambdaExpression Lambda(Expression body, params ParameterExpression[] parameters) =>
            parameters == null || parameters.Length == 0
                ? new LambdaExpression(Tools.GetFuncOrActionType(body.Type), body)
                : new ManyParametersLambdaExpression(Tools.GetFuncOrActionType(Tools.GetParamTypes(parameters), body.Type), body, 
                    parameters);

        public static LambdaExpression Lambda(Expression body, ParameterExpression[] parameters, Type returnType)
        {
            if (returnType == body.Type)
                Lambda(body, parameters);
            var delegateType = Tools.GetFuncOrActionType(Tools.GetParamTypes(parameters), returnType);
            return new ManyParametersTypedReturnLambdaExpression(delegateType, body, parameters, returnType);
        }

        public static LambdaExpression Lambda(Type delegateType, Expression body, params ParameterExpression[] parameters)
        {
            if (delegateType == null || delegateType == typeof(Delegate))
                return Lambda(body, parameters);
            var returnType = GetDelegateReturnType(delegateType);
            if (returnType == body.Type)
                return new ManyParametersLambdaExpression(delegateType, body, parameters);
            return new ManyParametersTypedReturnLambdaExpression(delegateType, body, parameters, returnType);
        }

        public static LambdaExpression Lambda(Type delegateType, Expression body, ParameterExpression[] parameters, Type returnType) =>
            delegateType == null || delegateType == typeof(Delegate)
                ? Lambda(body, parameters, returnType)
            : returnType == body.Type
                ? new ManyParametersLambdaExpression(delegateType, body, parameters)
                : (LambdaExpression)new ManyParametersTypedReturnLambdaExpression(delegateType, body, parameters, returnType);

        public static Expression<TDelegate> Lambda<TDelegate>(Expression body, Type returnType) where TDelegate : System.Delegate =>
            returnType == body.Type
                ? new Expression<TDelegate>(body)
                : new TypedReturnExpression<TDelegate>(body, returnType);

        public static Expression<TDelegate> Lambda<TDelegate>(Expression body) where TDelegate : System.Delegate =>
            Lambda<TDelegate>(body, GetDelegateReturnType(typeof(TDelegate)));

        public static Expression<TDelegate> Lambda<TDelegate>(Expression body, ParameterExpression[] parameters, Type returnType) where TDelegate : System.Delegate =>
            parameters == null || parameters.Length == 0
                ? Lambda<TDelegate>(body, returnType)
            : returnType == body.Type
                ? new ManyParametersExpression<TDelegate>(body, parameters)
                : (Expression<TDelegate>)new ManyParametersTypedReturnExpression<TDelegate>(body, parameters, returnType);

        public static Expression<TDelegate> Lambda<TDelegate>(Expression body, params ParameterExpression[] parameters) where TDelegate : System.Delegate =>
            Lambda<TDelegate>(body, parameters, GetDelegateReturnType(typeof(TDelegate)));

        /// <summary><paramref name="name"/> is ignored for now, the method is just for compatibility with SysExpression</summary>
        public static Expression<TDelegate> Lambda<TDelegate>(Expression body, string name, params ParameterExpression[] parameters) where TDelegate : System.Delegate =>
            Lambda<TDelegate>(body, parameters, GetDelegateReturnType(typeof(TDelegate)));

        private static Type GetDelegateReturnType(Type delegateType)
        {
            var typeInfo = delegateType.GetTypeInfo();
            if (typeInfo.IsGenericType)
            {
                var typeArguments = typeInfo.GenericTypeArguments;
                var index = typeArguments.Length - 1;
                var typeDef = typeInfo.GetGenericTypeDefinition();
                if (typeDef == FuncTypes[index])
                    return typeArguments[index];

                if (typeDef == ActionTypes[index])
                    return typeof(void);
            }
            else if (delegateType == typeof(Action))
                return typeof(void);

            return delegateType.FindDelegateInvokeMethod().ReturnType;
        }

        internal static readonly Type[] FuncTypes =
        {
            typeof(Func<>), typeof(Func<,>), typeof(Func<,,>), typeof(Func<,,,>), typeof(Func<,,,,>),
            typeof(Func<,,,,,>), typeof(Func<,,,,,,>), typeof(Func<,,,,,,,>)
        };

        internal static readonly Type[] ActionTypes =
        {
            typeof(Action<>), typeof(Action<,>), typeof(Action<,,>), typeof(Action<,,,>),
            typeof(Action<,,,,>), typeof(Action<,,,,,>), typeof(Action<,,,,,,>)
        };

        /// <summary>Creates a BinaryExpression that represents applying an array index operator to an array of rank one.</summary>
        /// <param name="array">A Expression to set the Left property equal to.</param>
        /// <param name="index">A Expression to set the Right property equal to.</param>
        /// <returns>A BinaryExpression that has the NodeType property equal to ArrayIndex and the Left and Right properties set to the specified values.</returns>
        public static BinaryExpression ArrayIndex(Expression array, Expression index) =>
            new ArrayIndexExpression(array, index, array.Type.GetElementType());

        public static MethodCallExpression ArrayIndex(Expression array, IEnumerable<Expression> indexes) =>
            Call(array, array.Type.GetMethod("Get", BindingFlags.Public | BindingFlags.Instance), indexes.AsReadOnlyList());

        public static MethodCallExpression ArrayIndex(Expression array, params Expression[] indexes) =>
            Call(array, array.Type.GetMethod("Get", BindingFlags.Public | BindingFlags.Instance), indexes);

        public static MemberAssignment Bind(MemberInfo member, Expression expression) =>
            new MemberAssignment(member, expression);

        public static MemberMemberBinding MemberBind(MemberInfo member, params MemberBinding[] bindings) =>
            new MemberMemberBinding(member, bindings);
 
        public static MemberMemberBinding MemberBind(MemberInfo member, IEnumerable<MemberBinding> bindings) =>
            new MemberMemberBinding(member, bindings.AsReadOnlyList());
 
        public static MemberListBinding ListBind(MemberInfo member, params ElementInit[] initializers) =>
            new MemberListBinding(member, initializers);
 
        public static MemberListBinding ListBind(MemberInfo member, IEnumerable<ElementInit> initializers) =>
            new MemberListBinding(member, initializers.AsReadOnlyList());

        public static MemberInitExpression MemberInit(NewExpression newExpr, params MemberBinding[] bindings) =>
            new MemberInitExpression(newExpr, bindings);

        /// <summary>Does not present in System Expression. Enables member assignment on existing instance expression.</summary>
        public static MemberInitExpression MemberInit(Expression instanceExpr, params MemberBinding[] assignments) =>
            new MemberInitExpression(instanceExpr, assignments);

        public static NewArrayExpression NewArrayInit(Type type, params Expression[] initializers) =>
            new NewArrayExpression(ExpressionType.NewArrayInit, type.MakeArrayType(), initializers);

        public static NewArrayExpression MakeArrayBounds(Type type, IReadOnlyList<Expression> bounds) =>
            new NewArrayExpression(ExpressionType.NewArrayBounds,
                bounds.Count == 1 ? type.MakeArrayType() : type.MakeArrayType(bounds.Count),
                bounds);

        public static NewArrayExpression NewArrayBounds(Type type, params Expression[] bounds) =>
            MakeArrayBounds(type, (IReadOnlyList<Expression>)bounds);

        public static NewArrayExpression NewArrayBounds(Type type, IEnumerable<Expression> bounds) =>
            MakeArrayBounds(type, bounds.AsReadOnlyList());

        /// <summary>Creates a BinaryExpression that represents an assignment operation.</summary>
        public static BinaryExpression Assign(Expression left, Expression right) =>
            new AssignBinaryExpression(ExpressionType.Assign, left, right);

        /// <summary>Creates a BinaryExpression that represents raising an expression to a power and assigning the result back to the expression.</summary>
        public static BinaryExpression PowerAssign(Expression left, Expression right) =>
            new AssignBinaryExpression(ExpressionType.PowerAssign, left, right);

        /// <summary>Creates a BinaryExpression that represents an addition assignment operation that does not have overflow checking.</summary>
        public static BinaryExpression AddAssign(Expression left, Expression right) =>
            new AssignBinaryExpression(ExpressionType.AddAssign, left, right);

        /// <summary>Creates a BinaryExpression that represents an addition assignment operation that has overflow checking.</summary>
        public static BinaryExpression AddAssignChecked(Expression left, Expression right) =>
            new AssignBinaryExpression(ExpressionType.AddAssignChecked, left, right);

        /// <summary>Creates a BinaryExpression that represents a bitwise AND assignment operation.</summary>
        public static BinaryExpression AndAssign(Expression left, Expression right) =>
            new AssignBinaryExpression(ExpressionType.AndAssign, left, right);

        public static BinaryExpression ExclusiveOrAssign(Expression left, Expression right) =>
            new AssignBinaryExpression(ExpressionType.ExclusiveOrAssign, left, right);

        /// <summary>Creates a BinaryExpression that represents a bitwise XOR assignment operation.</summary>
        public static BinaryExpression LeftShiftAssign(Expression left, Expression right) =>
            new AssignBinaryExpression(ExpressionType.LeftShiftAssign, left, right);

        /// <summary>Creates a BinaryExpression that represents a remainder assignment operation.</summary>
        public static BinaryExpression ModuloAssign(Expression left, Expression right) =>
            new AssignBinaryExpression(ExpressionType.ModuloAssign, left, right);

        /// <summary>Creates a BinaryExpression that represents a bitwise OR assignment operation.</summary>
        public static BinaryExpression OrAssign(Expression left, Expression right) =>
            new AssignBinaryExpression(ExpressionType.OrAssign, left, right);

        /// <summary>Creates a BinaryExpression that represents a bitwise right-shift assignment operation.</summary>
        public static BinaryExpression RightShiftAssign(Expression left, Expression right) =>
            new AssignBinaryExpression(ExpressionType.RightShiftAssign, left, right);

        /// <summary>Creates a BinaryExpression that represents a subtraction assignment operation that does not have overflow checking.</summary>
        public static BinaryExpression SubtractAssign(Expression left, Expression right) =>
            new AssignBinaryExpression(ExpressionType.SubtractAssign, left, right);

        /// <summary>Creates a BinaryExpression that represents a subtraction assignment operation that has overflow checking.</summary>
        public static BinaryExpression SubtractAssignChecked(Expression left, Expression right) =>
            new AssignBinaryExpression(ExpressionType.SubtractAssignChecked, left, right);

        /// <summary>Creates a BinaryExpression that represents a multiplication assignment operation that does not have overflow checking.</summary>
        public static BinaryExpression MultiplyAssign(Expression left, Expression right) =>
            new AssignBinaryExpression(ExpressionType.MultiplyAssign, left, right);

        /// <summary>Creates a BinaryExpression that represents a multiplication assignment operation that has overflow checking.</summary>
        public static BinaryExpression MultiplyAssignChecked(Expression left, Expression right) =>
            new AssignBinaryExpression(ExpressionType.MultiplyAssignChecked, left, right);

        /// <summary>Creates a BinaryExpression that represents a division assignment operation that does not have overflow checking.</summary>
        public static BinaryExpression DivideAssign(Expression left, Expression right) =>
            new AssignBinaryExpression(ExpressionType.DivideAssign, left, right);

        public static ElementInit ElementInit(MethodInfo addMethod, params Expression[] arguments) =>
            new ElementInit(addMethod, arguments);

        public static ElementInit ElementInit(MethodInfo addMethod, IEnumerable<Expression> arguments) =>
            new ElementInit(addMethod, arguments.AsReadOnlyList());

        public static InvocationExpression Invoke(LambdaExpression expression) =>
            new InvocationExpression(expression);

        public static InvocationExpression Invoke(LambdaExpression expression, Expression arg0) =>
            new ManyArgumentsInvocationExpression(expression, new[] { arg0 });

        public static InvocationExpression Invoke(Expression expression, Expression arg0) =>
            expression is LambdaExpression
                ? new ManyArgumentsInvocationExpression(expression, new[] { arg0 })
                : new TypedManyArgumentsInvocationExpression(expression, new[] { arg0 }, expression.Type.FindDelegateInvokeMethod().ReturnType);

        public static InvocationExpression Invoke(Expression expression, IEnumerable<Expression> args) =>
            expression is LambdaExpression
                ? new ManyArgumentsInvocationExpression(expression, args.AsReadOnlyList())
                : new TypedManyArgumentsInvocationExpression(expression, args.AsReadOnlyList(), expression.Type.FindDelegateInvokeMethod().ReturnType);
        public static InvocationExpression Invoke(Expression lambda, params Expression[] args) =>
            Invoke(lambda, (IEnumerable<Expression>)args);

        public static ConditionalExpression Condition(Expression test, Expression ifTrue, Expression ifFalse) =>
            new WithFalseBranchConditionalExpression(test, ifTrue, ifFalse);

        public static ConditionalExpression Condition(Expression test, Expression ifTrue, Expression ifFalse, Type type) =>
            new TypedWithFalseBranchConditionalExpression(test, ifTrue, ifFalse, type);

        public static ConditionalExpression IfThen(Expression test, Expression ifTrue) =>
            new ConditionalExpression(test, ifTrue); // absence of ifFalse automatically mean void type of all expression

        public static ConditionalExpression IfThenElse(Expression test, Expression ifTrue, Expression ifFalse) =>
            new VoidWithFalseBranchConditionalExpression(test, ifTrue, ifFalse);

        public static readonly DefaultExpression VoidDefault = new DefaultExpression(typeof(void));

        public static DefaultExpression Empty() => VoidDefault;

        public static DefaultExpression Default(Type type) =>
            type == typeof(void) ? VoidDefault : new DefaultExpression(type);

        /// <summary>Creates a BinaryExpression that represents an arithmetic addition operation that does not have overflow checking.</summary>
        public static BinaryExpression Add(Expression left, Expression right) =>
            new LeftTypedBinaryExpression(ExpressionType.Add, left, right);

        /// <summary>Creates a BinaryExpression that represents an arithmetic addition operation that has overflow checking.</summary>
        public static BinaryExpression AddChecked(Expression left, Expression right) =>
            new LeftTypedBinaryExpression(ExpressionType.AddChecked, left, right);

        /// <summary>Creates a BinaryExpression that represents a bitwise XOR operation.</summary>
        public static BinaryExpression ExclusiveOr(Expression left, Expression right) =>
            new LeftTypedBinaryExpression(ExpressionType.ExclusiveOr, left, right);

        /// <summary>Creates a BinaryExpression that represents a bitwise left-shift operation.</summary>
        public static BinaryExpression LeftShift(Expression left, Expression right) =>
            new LeftTypedBinaryExpression(ExpressionType.LeftShift, left, right);

        /// <summary>Creates a BinaryExpression that represents an arithmetic remainder operation.</summary>
        public static BinaryExpression Modulo(Expression left, Expression right) =>
            new LeftTypedBinaryExpression(ExpressionType.Modulo, left, right);

        // note: @note it should be a `LeftTypedBinaryExpression` and not `LogicalBinaryExpression` so that it works both for logical and bitwise context
        /// <summary>Creates a BinaryExpression that represents a bitwise OR operation.</summary>
        public static BinaryExpression Or(Expression left, Expression right) =>
            new LeftTypedBinaryExpression(ExpressionType.Or, left, right);

        /// <summary>Creates a BinaryExpression that represents a bitwise right-shift operation.</summary>
        public static BinaryExpression RightShift(Expression left, Expression right) =>
            new LeftTypedBinaryExpression(ExpressionType.RightShift, left, right);

        /// <summary>Creates a BinaryExpression that represents an arithmetic subtraction operation that does not have overflow checking.</summary>
        public static BinaryExpression Subtract(Expression left, Expression right) =>
            new LeftTypedBinaryExpression(ExpressionType.Subtract, left, right);

        /// <summary>Creates a BinaryExpression that represents an arithmetic subtraction operation that has overflow checking.</summary>
        public static BinaryExpression SubtractChecked(Expression left, Expression right) =>
            new LeftTypedBinaryExpression(ExpressionType.SubtractChecked, left, right);

        /// <summary>Creates a BinaryExpression that represents an arithmetic multiplication operation that does not have overflow checking.</summary>
        public static BinaryExpression Multiply(Expression left, Expression right) =>
            new LeftTypedBinaryExpression(ExpressionType.Multiply, left, right);

        /// <summary>Creates a BinaryExpression that represents an arithmetic multiplication operation that has overflow checking.</summary>
        public static BinaryExpression MultiplyChecked(Expression left, Expression right) =>
            new LeftTypedBinaryExpression(ExpressionType.MultiplyChecked, left, right);

        /// <summary>Creates a BinaryExpression that represents an arithmetic division operation.</summary>
        public static BinaryExpression Divide(Expression left, Expression right) =>
            new LeftTypedBinaryExpression(ExpressionType.Divide, left, right);

        /// <summary>Creates a BinaryExpression that represents raising a number to a power.</summary>
        public static BinaryExpression Power(Expression left, Expression right) =>
            new LeftTypedBinaryExpression(ExpressionType.Power, left, right);

        /// <summary>Creates a BinaryExpression that represents a bitwise AND operation.</summary>
        public static BinaryExpression And(Expression left, Expression right) =>
            new LogicalBinaryExpression(ExpressionType.And, left, right);

        /// <summary>Creates a BinaryExpression that represents a conditional AND operation that evaluates the second operand only if the first operand evaluates to true.</summary>
        public static BinaryExpression AndAlso(Expression left, Expression right) =>
            new LogicalBinaryExpression(ExpressionType.AndAlso, left, right);

        /// <summary>Creates a BinaryExpression that represents a conditional OR operation that evaluates the second operand only if the first operand evaluates to false.</summary>
        public static BinaryExpression OrElse(Expression left, Expression right) =>
            new LogicalBinaryExpression(ExpressionType.OrElse, left, right);

        /// <summary>Creates a BinaryExpression that represents an equality comparison.</summary>
        public static BinaryExpression Equal(Expression left, Expression right) =>
            new LogicalBinaryExpression(ExpressionType.Equal, left, right);

        /// <summary>Creates a BinaryExpression that represents a "greater than" numeric comparison.</summary>
        public static BinaryExpression GreaterThan(Expression left, Expression right) =>
            new LogicalBinaryExpression(ExpressionType.GreaterThan, left, right);

        /// <summary>Creates a BinaryExpression that represents a "greater than or equal" numeric comparison.</summary>
        public static BinaryExpression GreaterThanOrEqual(Expression left, Expression right) =>
            new LogicalBinaryExpression(ExpressionType.GreaterThanOrEqual, left, right);

        /// <summary>Creates a BinaryExpression that represents a "less than" numeric comparison.</summary>
        public static BinaryExpression LessThan(Expression left, Expression right) =>
            new LogicalBinaryExpression(ExpressionType.LessThan, left, right);

        /// <summary>Creates a BinaryExpression that represents a " less than or equal" numeric comparison.</summary>
        public static BinaryExpression LessThanOrEqual(Expression left, Expression right) =>
            new LogicalBinaryExpression(ExpressionType.LessThanOrEqual, left, right);

        /// <summary>Creates a BinaryExpression that represents an inequality comparison.</summary>
        public static BinaryExpression NotEqual(Expression left, Expression right) =>
            new LogicalBinaryExpression(ExpressionType.NotEqual, left, right);

        public static BlockExpression Block(IEnumerable<Expression> expressions) =>
            new BlockExpression(expressions.AsReadOnlyList());

        public static BlockExpression Block(params Expression[] expressions) =>
            new BlockExpression(expressions);

        public static BlockExpression Block(IEnumerable<ParameterExpression> variables, params Expression[] expressions) =>
            new ManyVariablesBlockExpression(variables.AsReadOnlyList(), expressions);

        public static BlockExpression Block(IEnumerable<ParameterExpression> variables, IEnumerable<Expression> expressions) =>
            new ManyVariablesBlockExpression(variables.AsReadOnlyList(), expressions.AsReadOnlyList());

        public static BlockExpression Block(Type type, IEnumerable<ParameterExpression> variables, params Expression[] expressions) =>
            new TypedManyVariablesBlockExpression(type, variables.AsReadOnlyList(), expressions);

        public static BlockExpression Block(Type type, IEnumerable<ParameterExpression> variables, IEnumerable<Expression> expressions) =>
            new TypedManyVariablesBlockExpression(type, variables.AsReadOnlyList(), expressions.AsReadOnlyList());

        public static Expression Block(ParameterExpression variable, Expression expression1, Expression expression2) =>
            new ManyVariablesBlockExpression(new[] { variable }, new[] { expression1, expression2 });

        public static BlockExpression MakeBlock(Type type, IEnumerable<ParameterExpression> variables, IEnumerable<Expression> expressions)
        {
            var vars = variables.AsReadOnlyList();
            var exprs = expressions.AsReadOnlyList();
            var result = exprs[exprs.Count - 1];
            if (result.Type == type)
            {
                if (vars == null || vars.Count == 0)
                    return new BlockExpression(exprs);
                return new ManyVariablesBlockExpression(vars, exprs);
            }

            if (vars == null || vars.Count == 0)
                return new TypedBlockExpression(type, exprs);
            return new TypedManyVariablesBlockExpression(type, vars, exprs);
        }

        public static Expression DebugInfo(SymbolDocumentInfo doc, 
            int startLine, int startColumn, int endLine, int endColumn) =>
            new DebugInfoExpression(doc, startLine, startColumn, endLine, endColumn);

        /// <summary>
        /// Creates a LoopExpression with the given body and (optional) break target.
        /// </summary>
        /// <param name="body">The body of the loop.</param>
        /// <param name="break">The break target used by the loop body, if required.</param>
        /// <returns>The created LoopExpression.</returns>
        public static LoopExpression Loop(Expression body, LabelTarget @break = null) =>
            @break == null ? new LoopExpression(body, null, null) : new LoopExpression(body, @break, null);

        /// <summary>
        /// Creates a LoopExpression with the given body.
        /// </summary>
        /// <param name="body">The body of the loop.</param>
        /// <param name="break">The break target used by the loop body.</param>
        /// <param name="continue">The continue target used by the loop body.</param>
        /// <returns>The created LoopExpression.</returns>
        public static LoopExpression Loop(Expression body, LabelTarget @break, LabelTarget @continue) =>
            new LoopExpression(body, @break, @continue);

        public static TryExpression TryCatch(Expression body, params CatchBlock[] handlers) =>
            new TryExpression(body, handlers);

        public static TryExpression TryCatchFinally(Expression body, Expression @finally, params CatchBlock[] handlers) =>
            new WithFinallyTryExpression(body, handlers, @finally);

        public static TryExpression TryFinally(Expression body, Expression @finally) =>
            new WithFinallyTryExpression(body, null, @finally);

        public static CatchBlock Catch(ParameterExpression variable, Expression body) =>
            new CatchBlock(variable, body, null, variable.Type);

        public static CatchBlock Catch(Type test, Expression body) =>
            new CatchBlock(null, body, null, test);

        /// <summary>Creates a UnaryExpression that represents a throwing of an exception.</summary>
        /// <param name="value">An Expression to set the Operand property equal to.</param>
        /// <returns>A UnaryExpression that represents the exception.</returns>
        public static UnaryExpression Throw(Expression value) =>
            new VoidUnaryExpression(ExpressionType.Throw, value);

        /// <summary>Creates a UnaryExpression that represents a throwing of an exception with a given type.</summary>
        /// <param name="value">An Expression to set the Operand property equal to.</param>
        /// <param name="type">The Type of the expression.</param>
        /// <returns>A UnaryExpression that represents the exception.</returns>
        public static UnaryExpression Throw(Expression value, Type type) =>
            new TypedUnaryExpression(ExpressionType.Throw, value, type);

        public static LabelExpression Label(LabelTarget target) =>
            new LabelExpression(target);

        public static LabelExpression Label(LabelTarget target, Expression defaultValue) =>
            defaultValue == null
            ? new LabelExpression(target)
            : new WithDefaultValueLabelExpression(target, defaultValue);

        public static LabelTarget Label() => new LabelTarget();

        public static LabelTarget Label(Type type) =>
            type == null
            ? new LabelTarget()
            : new TypedLabelTarget(type);

        public static LabelTarget Label(string name) =>
            name == null
            ? new LabelTarget()
            : new NamedLabelTarget(name);

        public static LabelTarget Label(Type type, string name)
        {
            if (type == null)
                return name == null
                    ? new LabelTarget()
                    : new NamedLabelTarget(name);
            if (name == null)
                return new TypedLabelTarget(type);
            return new TypedNamedLabelTarget(type, name);
        }

        /// <summary>Creates a <see cref="BinaryExpression" />, given the left and right operands, by calling an appropriate factory method.</summary>
        public static BinaryExpression MakeBinary(ExpressionType binaryType, Expression left, Expression right)
        {
            switch (binaryType)
            {
                case ExpressionType.Add: return Add(left, right);
                case ExpressionType.AddChecked: return AddChecked(left, right);
                case ExpressionType.Subtract: return Subtract(left, right);
                case ExpressionType.SubtractChecked: return SubtractChecked(left, right);
                case ExpressionType.Multiply: return Multiply(left, right);
                case ExpressionType.MultiplyChecked: return MultiplyChecked(left, right);
                case ExpressionType.Divide: return Divide(left, right);
                case ExpressionType.Modulo: return Modulo(left, right);
                case ExpressionType.Power: return Power(left, right);
                case ExpressionType.And: return And(left, right);
                case ExpressionType.AndAlso: return AndAlso(left, right);
                case ExpressionType.Or: return Or(left, right);
                case ExpressionType.OrElse: return OrElse(left, right);
                case ExpressionType.LessThan: return LessThan(left, right);
                case ExpressionType.LessThanOrEqual: return LessThanOrEqual(left, right);
                case ExpressionType.GreaterThan: return GreaterThan(left, right);
                case ExpressionType.GreaterThanOrEqual: return GreaterThanOrEqual(left, right);
                case ExpressionType.Equal: return Equal(left, right);
                case ExpressionType.NotEqual: return NotEqual(left, right);
                case ExpressionType.ExclusiveOr: return ExclusiveOr(left, right);
                case ExpressionType.Coalesce: return Coalesce(left, right);
                case ExpressionType.ArrayIndex: return ArrayIndex(left, right);
                case ExpressionType.RightShift: return RightShift(left, right);
                case ExpressionType.LeftShift: return LeftShift(left, right);
                case ExpressionType.Assign: return Assign(left, right);
                case ExpressionType.AddAssign: return AddAssign(left, right);
                case ExpressionType.AndAssign: return AndAssign(left, right);
                case ExpressionType.DivideAssign: return DivideAssign(left, right);
                case ExpressionType.ExclusiveOrAssign: return ExclusiveOrAssign(left, right);
                case ExpressionType.LeftShiftAssign: return LeftShiftAssign(left, right);
                case ExpressionType.ModuloAssign: return ModuloAssign(left, right);
                case ExpressionType.MultiplyAssign: return MultiplyAssign(left, right);
                case ExpressionType.OrAssign: return OrAssign(left, right);
                case ExpressionType.PowerAssign: return PowerAssign(left, right);
                case ExpressionType.RightShiftAssign: return RightShiftAssign(left, right);
                case ExpressionType.SubtractAssign: return SubtractAssign(left, right);
                case ExpressionType.AddAssignChecked: return AddAssignChecked(left, right);
                case ExpressionType.SubtractAssignChecked: return SubtractAssignChecked(left, right);
                case ExpressionType.MultiplyAssignChecked: return MultiplyAssignChecked(left, right);
                default: throw new ArgumentException($"Unhandled binary node type: `{binaryType}`");
            }
        }

        public static GotoExpression MakeGoto(GotoExpressionKind kind, LabelTarget target, Expression value, Type type)
        {
            switch (kind)
            {
                case GotoExpressionKind.Return:
                    if (value == null && type == null)
                        return new ReturnGotoExpression(target);
                    if (value == null)
                        return new ReturnTypedGotoExpression(target, type);
                    if (type == null)
                        return new ReturnValueGotoExpression(target, value);
                    return new ReturnTypedValueGotoExpression(target, value, type);
                case GotoExpressionKind.Break:
                    if (value == null && type == null)
                        return new BreakGotoExpression(target);
                    if (value == null)
                        return new BreakTypedGotoExpression(target, type);
                    if (type == null)
                        return new BreakValueGotoExpression(target, value);
                    return new BreakTypedValueGotoExpression(target, value, type);
                case GotoExpressionKind.Continue:
                    return type == null
                        ? new ContinueGotoExpression(target)
                        : (GotoExpression)new ContinueTypedGotoExpression(target, type);
                case GotoExpressionKind.Goto:
                default:
                    if (value == null && type == null)
                        return new GotoExpression(target);
                    if (value == null)
                        return new TypedGotoExpression(target, type);
                    if (type == null)
                        return new ValueGotoExpression(target, value);
                    return new TypedValueGotoExpression(target, value, type);
            }
        }

        public static GotoExpression Goto(LabelTarget target) => new GotoExpression(target);

        public static GotoExpression Goto(LabelTarget target, Expression value) =>
            value == null ? new GotoExpression(target) : new ValueGotoExpression(target, value);

        public static GotoExpression Goto(LabelTarget target, Type type) =>
            type == null ? new GotoExpression(target) : new TypedGotoExpression(target, type);

        public static GotoExpression Goto(LabelTarget target, Expression value, Type type) =>
            MakeGoto(GotoExpressionKind.Goto, target, value, type);

        public static GotoExpression Break(LabelTarget target) => new BreakGotoExpression(target);

        public static GotoExpression Break(LabelTarget target, Expression value) =>
            value == null
                ? new BreakGotoExpression(target)
                : (GotoExpression)new BreakValueGotoExpression(target, value);

        public static GotoExpression Break(LabelTarget target, Type type) =>
            type == null
                ? new BreakGotoExpression(target)
                : (GotoExpression)new BreakTypedGotoExpression(target, type);

        public static GotoExpression Break(LabelTarget target, Expression value, Type type) =>
            MakeGoto(GotoExpressionKind.Break, target, value, type);

        public static GotoExpression Continue(LabelTarget target) =>
            new ContinueGotoExpression(target);

        public static GotoExpression Continue(LabelTarget target, Type type) =>
            type == null ? new ContinueGotoExpression(target) : (GotoExpression)new ContinueTypedGotoExpression(target, type);

        public static GotoExpression Return(LabelTarget target) =>
            new ReturnGotoExpression(target);

        public static GotoExpression Return(LabelTarget target, Type type) =>
            type == null
            ? new ReturnGotoExpression(target)
            : (GotoExpression)new ReturnTypedGotoExpression(target, type);

        public static GotoExpression Return(LabelTarget target, Expression value) =>
            value == null
            ? new ReturnGotoExpression(target)
            : (GotoExpression)new ReturnValueGotoExpression(target, value);

        public static GotoExpression Return(LabelTarget target, Expression value, Type type) =>
            MakeGoto(GotoExpressionKind.Return, target, value, type);

        public static SwitchExpression Switch(Expression switchValue, Expression defaultBody, params SwitchCase[] cases) =>
            new SwitchExpression(defaultBody.Type, switchValue, defaultBody, null, cases);

        public static SwitchExpression Switch(Expression switchValue, Expression defaultBody, MethodInfo comparison, params SwitchCase[] cases) =>
            new SwitchExpression(defaultBody.Type, switchValue, defaultBody, comparison, cases);

        public static SwitchExpression Switch(Type type, Expression switchValue, Expression defaultBody, MethodInfo comparison, params SwitchCase[] cases) =>
            new SwitchExpression(type, switchValue, defaultBody, comparison, cases);

        public static SwitchExpression Switch(Type type, Expression switchValue, Expression defaultBody, MethodInfo comparison, IEnumerable<SwitchCase> cases) =>
            new SwitchExpression(type, switchValue, defaultBody, comparison, cases.AsArray());

        public static SwitchExpression Switch(Expression switchValue, params SwitchCase[] cases) =>
            new SwitchExpression(null, switchValue, null, null, cases);

        public static SwitchCase SwitchCase(Expression body, IEnumerable<Expression> testValues) =>
            new SwitchCase(body, testValues);

        public static SwitchCase SwitchCase(Expression body, params Expression[] testValues) =>
            new SwitchCase(body, testValues);

        /// <summary>Creates a BinaryExpression that represents a reference equality comparison.</summary>
        public static BinaryExpression ReferenceEqual(Expression left, Expression right) =>
            new LogicalBinaryExpression(ExpressionType.Equal, left, right);

        /// <summary>Creates a BinaryExpression that represents a reference inequality comparison.</summary>
        public static BinaryExpression ReferenceNotEqual(Expression left, Expression right) =>
            new LogicalBinaryExpression(ExpressionType.NotEqual, left, right);

        /// <summary>Creates a BinaryExpression that represents a coalescing operation.</summary>
        public static BinaryExpression Coalesce(Expression left, Expression right) =>
            new CoalesceBinaryExpression(left, right, GetCoalesceType(left.Type, right.Type));

        /// <summary>Creates a BinaryExpression that represents a coalescing operation.</summary>
        public static BinaryExpression Coalesce(Expression left, Expression right, Type type) =>
            new CoalesceBinaryExpression(left, right, type);

        /// <summary>Creates a BinaryExpression that represents a coalescing operation, given a conversion function.</summary>
        public static BinaryExpression Coalesce(Expression left, Expression right, LambdaExpression conversion) =>
            conversion == null
                ? Coalesce(left, right)
                : new CoalesceConversionBinaryExpression(left, right, conversion);

        private static Type GetCoalesceType(Type left, Type right)
        {
            var leftTypeInfo = left.GetTypeInfo();
            if (leftTypeInfo.IsGenericType && leftTypeInfo.GetGenericTypeDefinition() == typeof(Nullable<>))
                left = leftTypeInfo.GenericTypeArguments[0];

            if (right == left)
                return left;

            if (leftTypeInfo.IsAssignableFrom(right.GetTypeInfo()) ||
                right.IsImplicitlyBoxingConvertibleTo(left) ||
                right.IsImplicitlyNumericConvertibleTo(left))
                return left;

            if (right.GetTypeInfo().IsAssignableFrom(leftTypeInfo) ||
                left.IsImplicitlyBoxingConvertibleTo(right) ||
                left.IsImplicitlyNumericConvertibleTo(right))
                return right;

            throw new ArgumentException($"Unable to coalesce arguments of left type of {left} and right type of {right}.");
        }

        public static SymbolDocumentInfo SymbolDocument(string fileName) =>
            new SymbolDocumentInfo(fileName);
    }

    internal struct LightAndSysExpr
    {
        public object LightExpr;
        public object SysExpr;
    }

    internal static class TypeTools
    {
        internal static Type GetNonRefType(this Type type) => type.IsByRef ? type.GetElementType() : type;

        internal static int GetFirstIndex<T>(this IReadOnlyList<T> source, T item)
        {
            if (source.Count != 0)
                for (var i = 0; i < source.Count; ++i)
                    if (ReferenceEquals(source[i], item))
                        return i;
            return -1;
        }

        internal static bool IsImplicitlyBoxingConvertibleTo(this Type source, Type target) =>
            source.GetTypeInfo().IsValueType &&
            (target == typeof(object) ||
             target == typeof(ValueType)) ||
             source.GetTypeInfo().IsEnum && target == typeof(Enum);

        internal static PropertyInfo FindProperty(this Type type, string propertyName)
        {
            var properties = type.GetTypeInfo().DeclaredProperties.AsArray();
            for (var i = 0; i < properties.Length; i++)
                if (properties[i].Name == propertyName)
                    return properties[i];

            return type.GetTypeInfo().BaseType?.FindProperty(propertyName);
        }

        internal static FieldInfo FindField(this Type type, string fieldName)
        {
            var fields = type.GetTypeInfo().DeclaredFields.AsArray();
            for (var i = 0; i < fields.Length; i++)
                if (fields[i].Name == fieldName)
                    return fields[i];

            return type.GetTypeInfo().BaseType?.FindField(fieldName);
        }

        internal static MethodInfo FindMethod(this Type type,
            string methodName, Type[] typeArgs, IReadOnlyList<Expression> args, bool isStatic = false)
        {
            var methods = type.GetTypeInfo().DeclaredMethods.AsArray();
            for (var i = 0; i < methods.Length; i++)
            {
                var m = methods[i];
                if (isStatic == m.IsStatic && methodName == m.Name)
                {
                    typeArgs = typeArgs ?? Type.EmptyTypes;
                    var mTypeArgs = m.GetGenericArguments();

                    if (typeArgs.Length == mTypeArgs.Length &&
                        (typeArgs.Length == 0 || AreTypesTheSame(typeArgs, mTypeArgs)))
                    {
                        args = args ?? Tools.Empty<Expression>();
                        var pars = m.GetParameters();
                        if (args.Count == pars.Length &&
                            (args.Count == 0 || AreArgExpressionsAndParamsOfTheSameType(args, pars)))
                            return m;
                    }
                }
            }

            return type.GetTypeInfo().BaseType?.FindMethod(methodName, typeArgs, args, isStatic);
        }

        private static bool AreTypesTheSame(Type[] source, Type[] target)
        {
            for (var i = 0; i < source.Length; i++)
                if (source[i] != target[i])
                    return false;
            return true;
        }

        private static bool AreArgExpressionsAndParamsOfTheSameType(IReadOnlyList<Expression> args, ParameterInfo[] pars)
        {
            for (var i = 0; i < pars.Length; i++)
                if (pars[i].ParameterType != args[i].Type)
                    return false;
            return true;
        }

        public static IReadOnlyList<T> AsReadOnlyList<T>(this IEnumerable<T> xs)
        {
            if (xs is IReadOnlyList<T> list)
                return list;
            return xs == null ? null : new List<T>(xs);
        }

        internal static bool IsImplicitlyNumericConvertibleTo(this Type source, Type target)
        {
            if (source == typeof(Char))
                return
                    target == typeof(UInt16) ||
                    target == typeof(Int32) ||
                    target == typeof(UInt32) ||
                    target == typeof(Int64) ||
                    target == typeof(UInt64) ||
                    target == typeof(Single) ||
                    target == typeof(Double) ||
                    target == typeof(Decimal);

            if (source == typeof(SByte))
                return
                    target == typeof(Int16) ||
                    target == typeof(Int32) ||
                    target == typeof(Int64) ||
                    target == typeof(Single) ||
                    target == typeof(Double) ||
                    target == typeof(Decimal);

            if (source == typeof(Byte))
                return
                    target == typeof(Int16) ||
                    target == typeof(UInt16) ||
                    target == typeof(Int32) ||
                    target == typeof(UInt32) ||
                    target == typeof(Int64) ||
                    target == typeof(UInt64) ||
                    target == typeof(Single) ||
                    target == typeof(Double) ||
                    target == typeof(Decimal);

            if (source == typeof(Int16))
                return
                    target == typeof(Int32) ||
                    target == typeof(Int64) ||
                    target == typeof(Single) ||
                    target == typeof(Double) ||
                    target == typeof(Decimal);

            if (source == typeof(UInt16))
                return
                    target == typeof(Int32) ||
                    target == typeof(UInt32) ||
                    target == typeof(Int64) ||
                    target == typeof(UInt64) ||
                    target == typeof(Single) ||
                    target == typeof(Double) ||
                    target == typeof(Decimal);

            if (source == typeof(Int32))
                return
                    target == typeof(Int64) ||
                    target == typeof(Single) ||
                    target == typeof(Double) ||
                    target == typeof(Decimal);

            if (source == typeof(UInt32))
                return
                    target == typeof(UInt32) ||
                    target == typeof(UInt64) ||
                    target == typeof(Single) ||
                    target == typeof(Double) ||
                    target == typeof(Decimal);

            if (source == typeof(Int64) ||
                source == typeof(UInt64))
                return
                    target == typeof(Single) ||
                    target == typeof(Double) ||
                    target == typeof(Decimal);

            if (source == typeof(Single))
                return target == typeof(Double);

            return false;
        }
    }

    /// <summary>Converts the object of known type into the valid C# code representation</summary>
    public static class ExpressionCodePrinter
    {
        internal static StringBuilder NewLineIdent(this StringBuilder sb, int lineIdent) =>
            sb.AppendLine().Append(' ', lineIdent);

        internal static StringBuilder NewLine(this StringBuilder sb, int lineIdent, int identSpaces) =>
            sb.AppendLine().Append(' ', Math.Max(lineIdent - identSpaces, 0));

        internal static StringBuilder NewLineIdentExpr(this StringBuilder sb, Expression expr, List<Expression> uniqueExprs,
            int lineIdent, bool stripNamespace = false, Func<Type, string, string> printType = null, int identSpaces = 2)
        {
            sb.NewLineIdent(lineIdent);
            if (expr == null)
                sb.Append("null");
            else
                expr.ToExpressionString(sb, uniqueExprs, lineIdent + identSpaces, stripNamespace, printType, identSpaces);
            return sb;
        }

        internal static StringBuilder NewLineIdentCs(this StringBuilder sb, Expression expr,
            int lineIdent, bool stripNamespace = false, Func<Type, string, string> printType = null, int identSpaces = 4)
        {
            sb.NewLineIdent(lineIdent);
            if (expr == null)
                sb.Append("null");
            else
                expr.ToCSharpString(sb, lineIdent + identSpaces, stripNamespace, printType, identSpaces);
            return sb;
        }

        internal static StringBuilder NewLineIdentExprs<T>(this StringBuilder sb, IReadOnlyList<T> exprs, List<Expression> uniqueExprs,
            int lineIdent, bool stripNamespace = false, Func<Type, string, string> printType = null, int identSpaces = 2)
            where T : Expression
        {
            if (exprs.Count == 0)
                return sb.Append(" new ").Append(typeof(T).Name).Append("[0]");

            for (var i = 0; i < exprs.Count; i++)
            {
                if (i > 0)
                    sb.Append(',');
                sb.NewLineIdentExpr(exprs[i], uniqueExprs, lineIdent, stripNamespace, printType, identSpaces);
            }

            return sb;
        }

        internal static StringBuilder NewLineIdentCss<T>(this StringBuilder sb, IReadOnlyList<T> exprs,
            int lineIdent, bool stripNamespace = false, Func<Type, string, string> printType = null, int identSpaces = 4)
            where T : Expression
        {
            if (exprs.Count != 0)
                for (var i = 0; i < exprs.Count; i++)
                {
                    if (i > 0)
                        sb.Append(',');
                    sb.NewLineIdentCs(exprs[i], lineIdent, stripNamespace, printType, identSpaces);
                }
            return sb;
        }
    }

    /// <summary>Converts the object of known type into the valid C# code representation</summary>
    public static class CodePrinter
    {
        /// <summary>Converts the `typeof(<paramref name="type"/>)` into the proper C# representation.</summary>
        public static StringBuilder AppendTypeof(this StringBuilder sb, Type type, 
            bool stripNamespace = false, Func<Type, string, string> printType = null) =>
            type == null
                ? sb.Append("null")
                : sb.Append("typeof(").Append(type.ToCode(stripNamespace, printType)).Append(')');

        internal static StringBuilder AppendFieldOrProperty(this StringBuilder sb, MemberInfo member, 
            bool stripNamespace = false, Func<Type, string, string> printType = null) =>
            member is FieldInfo f 
                ? sb.AppendField(f, stripNamespace, printType)
                : sb.AppendProperty((PropertyInfo)member, stripNamespace, printType);

        internal static StringBuilder AppendField(this StringBuilder sb, FieldInfo field, 
            bool stripNamespace = false, Func<Type, string, string> printType = null) =>
            sb.AppendTypeof(field.DeclaringType, stripNamespace, printType)
              .Append(".GetTypeInfo().GetDeclaredField(\"").Append(field.Name).Append("\"),");

        internal static StringBuilder AppendProperty(this StringBuilder sb, PropertyInfo property, 
            bool stripNamespace = false, Func<Type, string, string> printType = null) =>
            sb.AppendTypeof(property.DeclaringType, stripNamespace, printType)
              .Append(".GetTypeInfo().GetDeclaredProperty(\"").Append(property.Name).Append("\"),");
        
        internal static StringBuilder AppendMethod(this StringBuilder sb, MethodInfo method, 
            bool stripNamespace = false, Func<Type, string, string> printType = null)
        {
            var type = method.DeclaringType;
            var methodIndex = type.GetTypeInfo().GetDeclaredMethods(method.Name).AsArray().GetFirstIndex(method);
            return sb.AppendTypeof(type, stripNamespace, printType)
                .Append(".GetTypeInfo().GetDeclaredMethods(\"").Append(method.Name)
                .Append("\").ToArray()[").Append(methodIndex).Append("]");
        }

        /// <summary>Converts the <paramref name="type"/> into the proper C# representation.</summary>
        public static string ToCode(this Type type, bool stripNamespace = false, Func<Type, string, string> printType = null)
        {
            var isArray = type.IsArray;
            if (isArray)
                type = type.GetElementType();

            var typeString = stripNamespace ? type.Name : type.FullName ?? type.Name;

            typeString = typeString.Replace('+', '.');

            var typeInfo = type.GetTypeInfo();
            if (!typeInfo.IsGenericType)
            {
                if (printType != null)
                    typeString = printType.Invoke(type, typeString);
                return isArray ? typeString + "[]" : typeString;
            }

            var s = new StringBuilder(typeString.Substring(0, typeString.IndexOf('`')));
            s.Append('<');

            var genericArgs = typeInfo.GetGenericTypeParametersOrArguments();
            if (typeInfo.IsGenericTypeDefinition)
                s.Append(',', genericArgs.Length - 1);
            else
            {
                for (var i = 0; i < genericArgs.Length; i++)
                {
                    if (i > 0)
                        s.Append(", ");
                    s.Append(genericArgs[i].ToCode(stripNamespace, printType));
                }
            }

            s.Append('>');

            if (isArray)
                s.Append("[]");

            typeString = s.ToString();
            return printType?.Invoke(type, typeString) ?? typeString;
        }

        /// Prints valid C# Boolean
        public static string ToCode(this bool x) => x ? "true" : "false";

        /// Prints valid C# String escaping the things
        public static string ToCode(this string x) =>
            x == null
                ? "null"
                : $"\"{x.Replace("\"", "\\\"").Replace("\r", "\\r").Replace("\n", "\\n")}\"";

        /// Prints valid c# Enum literal
        public static string ToEnumValueCode(this Type enumType, object x)
        {
            var enumTypeInfo = enumType.GetTypeInfo();
            if (enumTypeInfo.IsGenericType && enumTypeInfo.GetGenericTypeDefinition() == typeof(Nullable<>))
            {
                if (x == null)
                    return "null";
                enumType = GetGenericTypeParametersOrArguments(enumTypeInfo)[0];
            }

            return $"{enumType.ToCode()}.{Enum.GetName(enumType, x)}";
        }

        private static Type[] GetGenericTypeParametersOrArguments(this TypeInfo typeInfo) =>
            typeInfo.IsGenericTypeDefinition ? typeInfo.GenericTypeParameters : typeInfo.GenericTypeArguments;

        public interface IObjectToCode
        {
            string ToCode(object x, bool stripNamespace = false, Func<Type, string, string> printType = null);
        }

        /// Prints many code items as array initializer.
        public static string ToCommaSeparatedCode(this IEnumerable items, IObjectToCode notRecognizedToCode,
            bool stripNamespace = false, Func<Type, string, string> printType = null)
        {
            var s = new StringBuilder();
            var count = 0;
            foreach (var item in items)
            {
                if (count++ != 0)
                    s.Append(", ");
                s.Append(item.ToCode(notRecognizedToCode, stripNamespace, printType));
            }
            return s.ToString();
        }

        /// <summary>Prints many code items as array initializer.</summary>
        public static string ToArrayInitializerCode(this IEnumerable items, Type itemType, IObjectToCode notRecognizedToCode,
            bool stripNamespace = false, Func<Type, string, string> printType = null) =>
            $"new {itemType.ToCode(stripNamespace, printType)}[]{{{items.ToCommaSeparatedCode(notRecognizedToCode, stripNamespace, printType)}}}";

        /// <summary>
        /// Prints a valid C# for known <paramref name="x"/>,
        /// otherwise uses passed <paramref name="notRecognizedToCode"/> or falls back to `ToString()`.
        /// </summary>
        public static string ToCode(this object x, IObjectToCode notRecognizedToCode,
            bool stripNamespace = false, Func<Type, string, string> printType = null)
        {
            if (x == null)
                return "null";

            if (x is bool b)
                return b.ToCode();

            if (x is string s)
                return s.ToCode();

            if (x is Type t)
                return t.ToCode(stripNamespace, printType);

            var xTypeInfo = x.GetType().GetTypeInfo();
            if (xTypeInfo.IsEnum)
                return x.GetType().ToEnumValueCode(x);

            if (x is IEnumerable e)
            {
                var elemType = xTypeInfo.IsArray
                    ? xTypeInfo.GetElementType()
                    : xTypeInfo.GetGenericTypeParametersOrArguments().GetFirst();
                if (elemType != null)
                    return e.ToArrayInitializerCode(elemType, notRecognizedToCode);
            }

            if (xTypeInfo.IsPrimitive)
                return x.ToString();

            return notRecognizedToCode?.ToCode(x, stripNamespace, printType) ?? x.ToString();
        }
    }

    public class UnaryExpression : Expression
    {
        public override ExpressionType NodeType { get; }

        public override Type Type => Operand.Type;
        public readonly Expression Operand;

        public virtual MethodInfo Method => null;

        public UnaryExpression(ExpressionType nodeType, Expression operand)
        {
            NodeType = nodeType;
            Operand = operand;
        }

        protected internal override Expression Accept(ExpressionVisitor visitor) => visitor.VisitUnary(this);

        internal override SysExpr CreateSysExpression(ref LiveCountArray<LightAndSysExpr> exprsConverted)
        {
            switch (NodeType)
            {
                case ExpressionType.ArrayLength:    return SysExpr.ArrayLength(Operand.ToExpression(ref exprsConverted));
                case ExpressionType.Convert:        return SysExpr.Convert(Operand.ToExpression(ref exprsConverted), Type, Method);
                case ExpressionType.ConvertChecked: return SysExpr.ConvertChecked(Operand.ToExpression(ref exprsConverted), Type, Method);
                case ExpressionType.Decrement:      return SysExpr.Decrement(Operand.ToExpression(ref exprsConverted));
                case ExpressionType.Increment:      return SysExpr.Increment(Operand.ToExpression(ref exprsConverted));
                case ExpressionType.IsFalse:        return SysExpr.IsFalse(Operand.ToExpression(ref exprsConverted));
                case ExpressionType.IsTrue:         return SysExpr.IsTrue(Operand.ToExpression(ref exprsConverted));
                case ExpressionType.Negate:         return SysExpr.Negate(Operand.ToExpression(ref exprsConverted));
                case ExpressionType.NegateChecked:  return SysExpr.NegateChecked(Operand.ToExpression(ref exprsConverted));
                case ExpressionType.OnesComplement: return SysExpr.OnesComplement(Operand.ToExpression(ref exprsConverted));
                case ExpressionType.PostDecrementAssign: return SysExpr.PostDecrementAssign(Operand.ToExpression(ref exprsConverted));
                case ExpressionType.PostIncrementAssign: return SysExpr.PostIncrementAssign(Operand.ToExpression(ref exprsConverted));
                case ExpressionType.PreDecrementAssign:  return SysExpr.PreDecrementAssign(Operand.ToExpression(ref exprsConverted));
                case ExpressionType.PreIncrementAssign:  return SysExpr.PreIncrementAssign(Operand.ToExpression(ref exprsConverted));
                case ExpressionType.Quote:          return SysExpr.Quote(Operand.ToExpression(ref exprsConverted));
                case ExpressionType.UnaryPlus:      return SysExpr.UnaryPlus(Operand.ToExpression(ref exprsConverted));
                case ExpressionType.Unbox:          return SysExpr.Unbox(Operand.ToExpression(ref exprsConverted), Type);
                case ExpressionType.Throw:          return SysExpr.Throw(Operand.ToExpression(ref exprsConverted), Type);
                case ExpressionType.TypeAs:         return SysExpr.TypeAs(Operand.ToExpression(ref exprsConverted), Type);
                default:
                    throw new NotSupportedException("Cannot convert Expression to Expression of type " + NodeType);
            }
        }

        public override StringBuilder CreateExpressionString(StringBuilder sb, List<Expression> uniqueExprs,
            int lineIdent = 0, bool stripNamespace = false, Func<Type, string, string> printType = null, int identSpaces = 2)
        {
            var name = Enum.GetName(typeof(ExpressionType), NodeType);
            sb.Append(name).Append('(');
            sb.NewLineIdentExpr(Operand, uniqueExprs, lineIdent, stripNamespace, printType, identSpaces);

            if (NodeType == ExpressionType.Convert ||
                NodeType == ExpressionType.ConvertChecked ||
                NodeType == ExpressionType.Unbox ||
                NodeType == ExpressionType.Throw ||
                NodeType == ExpressionType.TypeAs)
            {
                sb.Append(',').NewLineIdent(lineIdent).AppendTypeof(Type, stripNamespace, printType);
            }

            if ((NodeType == ExpressionType.Convert || NodeType == ExpressionType.ConvertChecked)
                && Method != null)
            {
                sb.Append(',').NewLineIdent(lineIdent).AppendMethod(Method, stripNamespace, printType);
            }

            return sb.Append(')');
        }

        public override StringBuilder ToCSharpString(StringBuilder sb,
            int lineIdent = 0, bool stripNamespace = false, Func<Type, string, string> printType = null, int identSpaces = 4)
        {
            switch (NodeType)
            {
                case ExpressionType.Not:
                    sb.Append("!(");
                    Operand.ToCSharpString(sb, lineIdent, stripNamespace, printType, identSpaces);
                    return sb.Append(')');
                case ExpressionType.Convert:
                case ExpressionType.ConvertChecked:
                    sb.Append('(').Append(Type.ToCode(stripNamespace, printType)).Append(')');
                    Operand.ToCSharpString(sb, lineIdent, stripNamespace, printType, identSpaces);
                    return sb;
                case ExpressionType.TypeAs:
                    sb.Append('(');
                    Operand.ToCSharpString(sb, lineIdent, stripNamespace, printType, identSpaces);
                    sb.Append(" as ").Append(Type.ToCode(stripNamespace, printType));
                    return sb.Append(')');
                case ExpressionType.Throw:
                    sb.Append("trow ");
                    return Operand.ToCSharpString(sb, lineIdent, stripNamespace, printType, identSpaces).Append(';');
                default:
                    return sb.Append(ToString()); // falling back ro ToString as a closest to C# code output 
            }
        }
    }

    public sealed class VoidUnaryExpression : UnaryExpression
    {
        public override Type Type => typeof(void);

        public VoidUnaryExpression(ExpressionType nodeType, Expression operand) : base(nodeType, operand) { }
    }

    public class TypedUnaryExpression : UnaryExpression
    {
        public override Type Type { get; }

        public TypedUnaryExpression(ExpressionType nodeType, Expression operand, Type type) : base(nodeType, operand) =>
            Type = type;
    }

    public sealed class TypedUnaryExpression<T> : UnaryExpression
    {
        public override Type Type => typeof(T);

        public TypedUnaryExpression(ExpressionType nodeType, Expression operand) : base(nodeType, operand) { }
    }

    // todo: @perf memory by fixing the nodeType
    public sealed class ConvertWithMethodUnaryExpression : TypedUnaryExpression
    {
        public override MethodInfo Method { get; }

        public ConvertWithMethodUnaryExpression(ExpressionType nodeType, Expression operand, Type type, MethodInfo method)
            : base(nodeType, operand, type) =>
            Method = method;
    }

    public abstract class BinaryExpression : Expression
    {
        //todo: @feature - not supported yet
        public virtual MethodInfo Method => null;

        public virtual LambdaExpression Conversion => null;

        // todo: @feature - not supported yet
        // internal bool IsLifted => NodeType != ExpressionType.Coalesce && NodeType != ExpressionType.Assign 
        //     && Left.Type.IsNullable()
        //     && (Method == null || !Method.GetParameters()[0].ParameterType.GetNonRefType().IsEquivalentTo(Left.Type));

        // todo: @feature - not supported yet
        /// <summary>Gets a value that indicates whether the expression tree node represents a lifted call to an operator whose return type is lifted to a nullable type.</summary>
        public bool IsLiftedToNull => false;//IsLifted && Type.IsNullable();

        public readonly Expression Left, Right;

        protected BinaryExpression(Expression left, Expression right)
        {
            Left = left;
            Right = right;
        }

        protected internal override Expression Accept(ExpressionVisitor visitor) =>
            visitor.VisitBinary(this);

        internal override SysExpr CreateSysExpression(ref LiveCountArray<LightAndSysExpr> exprsConverted) =>
            SysExpr.MakeBinary(NodeType, Left.ToExpression(ref exprsConverted), Right.ToExpression(ref exprsConverted));

        public override StringBuilder CreateExpressionString(StringBuilder sb, List<Expression> uniqueExprs, int lineIdent = 0,
            bool stripNamespace = false, Func<Type, string, string> printType = null, int identSpaces = 2)
        {
            var name = Enum.GetName(typeof(ExpressionType), NodeType);
            sb.Append("MakeBinary(").Append(typeof(ExpressionType).Name).Append('.').Append(name).Append(',');
            sb.NewLineIdentExpr(Left, uniqueExprs, lineIdent, stripNamespace, printType, identSpaces).Append(',');
            sb.NewLineIdentExpr(Right, uniqueExprs, lineIdent, stripNamespace, printType, identSpaces);
            return sb.Append(')');
        }
    }

    /*
        ExpressionType.Equal
        ExpressionType.NotEqual
        ExpressionType.GreaterThan
        ExpressionType.GreaterThanOrEqual
        ExpressionType.LessThan
        ExpressionType.LessThanOrEqual
        ExpressionType.And
        ExpressionType.AndAlso
        ExpressionType.OrElse

        ExpressionType.Or is excluded because it should return the Left.Type for the bitwise operations
    */
    internal class LogicalBinaryExpression : BinaryExpression
    {
        public override ExpressionType NodeType { get; }
        public override Type Type => typeof(bool);
        internal LogicalBinaryExpression(ExpressionType nodeType, Expression left, Expression right) : base(left, right) =>
            NodeType = nodeType;

        public override StringBuilder ToCSharpString(StringBuilder sb,
            int lineIdent = 0, bool stripNamespace = false, Func<Type, string, string> printType = null, int identSpaces = 4)
        {
            if (NodeType == ExpressionType.Equal)
            {
                Left.ToCSharpString(sb, lineIdent, stripNamespace, printType, identSpaces);
                if (Right is ConstantExpression r && r.Value is bool rb && rb)
                    return sb;
                sb.Append(" == ");
                Right.ToCSharpString(sb, lineIdent, stripNamespace, printType, identSpaces);
                return sb;
            }

            if (NodeType == ExpressionType.NotEqual)
            {
                Left.ToCSharpString(sb, lineIdent, stripNamespace, printType, identSpaces);
                if (Right is ConstantExpression r && r.Value is bool rb)
                    return rb ? sb.Append(" == false") : sb;
                sb.Append(" != ");
                Right.ToCSharpString(sb, lineIdent, stripNamespace, printType, identSpaces);
                return sb;
            }

            // todo: @incomplete
            return sb.Append(ToString());
        }
    }

    internal sealed class LeftTypedBinaryExpression : BinaryExpression
    {
        public override ExpressionType NodeType { get; }
        public override Type Type => Left.Type;

        internal LeftTypedBinaryExpression(ExpressionType nodeType, Expression left, Expression right) : base(left, right) =>
            NodeType = nodeType;
    }

    internal class CoalesceBinaryExpression : BinaryExpression
    {
        public override ExpressionType NodeType => ExpressionType.Coalesce;
        public override Type Type { get; }
        internal CoalesceBinaryExpression(Expression left, Expression right, Type type) : base(left, right) =>
            Type = type;

        public override StringBuilder ToCSharpString(StringBuilder sb,
            int lineIdent = 0, bool stripNamespace = false, Func<Type, string, string> printType = null, int identSpaces = 4)
        {
            Left.ToCSharpString(sb, lineIdent, stripNamespace, printType, identSpaces);
            sb.Append(" ?? ").NewLineIdent(lineIdent);
            Right.ToCSharpString(sb, lineIdent, stripNamespace, printType, identSpaces);
            return sb;
        }
    }

    internal sealed class CoalesceConversionBinaryExpression : CoalesceBinaryExpression
    {
        public override Type Type => Right.Type;
        public override LambdaExpression Conversion { get; }

        internal CoalesceConversionBinaryExpression(Expression left, Expression right, LambdaExpression conversion)
            : base(left, right, right.Type) =>
            Conversion = conversion;

        internal override SysExpr CreateSysExpression(ref LiveCountArray<LightAndSysExpr> exprsConverted) =>
            SysExpr.Coalesce(Left.ToExpression(ref exprsConverted), Right.ToExpression(ref exprsConverted), Conversion.ToLambdaExpression());

        public override StringBuilder CreateExpressionString(StringBuilder sb, List<Expression> uniqueExprs,
            int lineIdent = 0, bool stripNamespace = false, Func<Type, string, string> printType = null, int identSpaces = 2)
        {
            sb.Append("Coalesce(");
            sb.NewLineIdentExpr(Left, uniqueExprs, lineIdent, stripNamespace, printType, identSpaces).Append(',');
            sb.NewLineIdentExpr(Right, uniqueExprs, lineIdent, stripNamespace, printType, identSpaces).Append(',');
            sb.NewLineIdentExpr(Conversion, uniqueExprs, lineIdent, stripNamespace, printType, identSpaces);
            return sb.Append(')');
        }
    }

    public sealed class ArrayIndexExpression : BinaryExpression
    {
        public override ExpressionType NodeType => ExpressionType.ArrayIndex;
        public override Type Type { get; }

        internal ArrayIndexExpression(Expression left, Expression right, Type type) : base(left, right) =>
            Type = type;
    }

    public sealed class AssignBinaryExpression : BinaryExpression
    {
        public override ExpressionType NodeType { get; }
        public override Type Type => Left.Type;

        internal AssignBinaryExpression(ExpressionType nodeType, Expression left, Expression right) : base(left, right) =>
            NodeType = nodeType;

        public override StringBuilder ToCSharpString(StringBuilder sb,
            int lineIdent = 0, bool stripNamespace = false, Func<Type, string, string> printType = null, int identSpaces = 4)
        {
            switch (NodeType)
            {
                case ExpressionType.Assign:
                    Left.ToCSharpString(sb, lineIdent, stripNamespace, printType, identSpaces);
                    sb.Append(" = ");
                    Right.ToCSharpString(sb, lineIdent, stripNamespace, printType, identSpaces);
                    return sb;
                default:
                    // todo: @incomplete
                    return sb.Append(ToString());
            }
        }
    }

    // todo: @perf is not used yet
    public interface IArgumentProvider
    {
        int ArgumentCount { get; }
        Expression GetArgument(int index);
    }

    // todo: @perf is not used yet - apply to LambdaExpression, e.g. LambdaExpression of a single argument
    internal interface IParameterProvider
    {
        int ParameterCount { get; }
        ParameterExpression GetParameter(int index);
    }

    public sealed class ElementInit : IArgumentProvider
    {
        public readonly MethodInfo AddMethod;
        public readonly IReadOnlyList<Expression> Arguments;

        public int ArgumentCount => Arguments.Count;
        public Expression GetArgument(int index) => Arguments[index];

        internal ElementInit(MethodInfo addMethod, IReadOnlyList<Expression> arguments)
        {
            AddMethod = addMethod;
            Arguments = arguments;
        }

        internal StringBuilder CreateExpressionString(StringBuilder sb, List<Expression> uniqueExprs, 
            int lineIdent = 0, bool stripNamespace = false, Func<Type, string, string> printType = null, int identSpaces = 2)
        {
            sb.Append("ElementInit(");
            for (int j = 0; j < Arguments.Count; j++)
            {
                var a = Arguments[j];
                if (j > 0) sb.Append(",");
                sb.NewLineIdent(lineIdent).AppendMethod(AddMethod, stripNamespace, printType);
                sb.NewLineIdentExprs(Arguments, uniqueExprs, lineIdent, stripNamespace, printType, identSpaces);
            }
            return sb.Append(")");
        }
    }

    // todo: @feature not supported yet
    public sealed class ListInitExpression : Expression
    {
        public override ExpressionType NodeType => ExpressionType.ListInit;

        public override Type Type => NewExpression.Type;

        public readonly NewExpression NewExpression;
        public readonly IReadOnlyList<ElementInit> Initializers;

        internal ListInitExpression(NewExpression newExpression, IReadOnlyList<ElementInit> initializers)
        {
            NewExpression = newExpression;
            Initializers = initializers;
        }

        protected internal override Expression Accept(ExpressionVisitor visitor) =>
            visitor.VisitListInit(this);

        internal override SysExpr CreateSysExpression(ref LiveCountArray<LightAndSysExpr> convertedExpressions) =>
            SysExpr.ListInit(
                (System.Linq.Expressions.NewExpression)NewExpression.ToExpression(ref convertedExpressions),
                ToElementInits(Initializers, ref convertedExpressions));

        internal static System.Linq.Expressions.ElementInit[] ToElementInits(IReadOnlyList<ElementInit> elemInits, 
            ref LiveCountArray<LightAndSysExpr> exprsConverted)
        {
            if (elemInits.Count == 0)
                return Tools.Empty<System.Linq.Expressions.ElementInit>();

            var result = new System.Linq.Expressions.ElementInit[elemInits.Count];
            for (var i = 0; i < result.Length; ++i)
                result[i] = SysExpr.ElementInit(elemInits[i].AddMethod,
                    ToExpressions(elemInits[i].Arguments, ref exprsConverted));
            return result;
        }

        public override StringBuilder CreateExpressionString(StringBuilder sb, List<Expression> uniqueExprs, 
            int lineIdent = 0, bool stripNamespace = false, Func<Type, string, string> printType = null, int identSpaces = 2)
        {
            sb.Append("ListInit(");
            sb.NewLineIdentExpr(NewExpression, uniqueExprs, lineIdent, stripNamespace, printType, identSpaces).Append(',');
            for (int i = 0; i < Initializers.Count; i++)
            {
                var init = Initializers[i];
                if (i > 0) sb.Append(",");
                sb.NewLineIdent(lineIdent);
                init.CreateExpressionString(sb, uniqueExprs, lineIdent, stripNamespace, printType, identSpaces);
            }

            return sb.Append(")");
        }
    }

    public sealed class TypeBinaryExpression : Expression
    {
        public override ExpressionType NodeType { get; }
        public override Type Type => typeof(bool);
        public Type TypeOperand { get; }
        public readonly Expression Expression;

        internal TypeBinaryExpression(ExpressionType nodeType, Expression expression, Type typeOperand)
        {
            NodeType = nodeType;
            Expression = expression;
            TypeOperand = typeOperand;
        }

        protected internal override Expression Accept(ExpressionVisitor visitor) => visitor.VisitTypeBinary(this);

        internal override SysExpr CreateSysExpression(ref LiveCountArray<LightAndSysExpr> exprsConverted) =>
            SysExpr.TypeIs(Expression.ToExpression(ref exprsConverted), TypeOperand);

        public override StringBuilder CreateExpressionString(StringBuilder sb, List<Expression> uniqueExprs,
            int lineIdent = 0, bool stripNamespace = false, Func<Type, string, string> printType = null, int identSpaces = 2)
        {
            sb.Append(NodeType == ExpressionType.TypeIs ? "TypeIs(" : "TypeEqual(");
            sb.NewLineIdentExpr(Expression, uniqueExprs, lineIdent, stripNamespace, printType, identSpaces).Append(',');
            sb.NewLineIdent(lineIdent).AppendTypeof(TypeOperand, stripNamespace, printType);
            return sb.Append(')');
        }

        public override StringBuilder ToCSharpString(StringBuilder sb,
            int lineIdent = 0, bool stripNamespace = false, Func<Type, string, string> printType = null, int identSpaces = 4)
        {
            sb.Append('(');
            Expression.ToCSharpString(sb, lineIdent, stripNamespace, printType, identSpaces);
            sb.Append(" is ").Append(TypeOperand.ToCode(stripNamespace, printType));
            sb.Append(')');
            return sb;
        }
    }

    public sealed class MemberInitExpression : Expression
    {
        public override ExpressionType NodeType => ExpressionType.MemberInit;
        public override Type Type => Expression.Type;

        public NewExpression NewExpression => Expression as NewExpression;

        public readonly Expression Expression;
        public readonly IReadOnlyList<MemberBinding> Bindings;

        internal MemberInitExpression(NewExpression newExpression, MemberBinding[] bindings)
            : this((Expression)newExpression, bindings) { }

        internal MemberInitExpression(Expression expression, MemberBinding[] bindings)
        {
            Expression = expression;
            Bindings = bindings ?? Tools.Empty<MemberBinding>();
        }

        protected internal override Expression Accept(ExpressionVisitor visitor) => visitor.VisitMemberInit(this);

        internal override SysExpr CreateSysExpression(ref LiveCountArray<LightAndSysExpr> exprsConverted) =>
            SysExpr.MemberInit((System.Linq.Expressions.NewExpression)NewExpression.ToExpression(ref exprsConverted),
                BindingsToExpressions(Bindings, ref exprsConverted));

        internal static System.Linq.Expressions.MemberBinding[] BindingsToExpressions(
            IReadOnlyList<MemberBinding> ms, ref LiveCountArray<LightAndSysExpr> exprsConverted)
        {
            if (ms.Count == 0)
                return Tools.Empty<System.Linq.Expressions.MemberBinding>();

            if (ms.Count == 1)
                return new[] { ms[0].ToMemberBinding(ref exprsConverted) };

            var result = new System.Linq.Expressions.MemberBinding[ms.Count];
            for (var i = 0; i < result.Length; ++i)
                result[i] = ms[i].ToMemberBinding(ref exprsConverted);
            return result;
        }

        public override StringBuilder CreateExpressionString(StringBuilder sb, List<Expression> uniqueExprs, int lineIdent = 0,
            bool stripNamespace = false, Func<Type, string, string> printType = null, int identSpaces = 2)
        {
            sb.Append("MemberInit(");
            sb.NewLineIdentExpr(Expression, uniqueExprs, lineIdent, stripNamespace, printType, identSpaces).Append(',');
            sb.NewLineIdent(lineIdent);

            for (var i = 0; i < Bindings.Count; i++)
            {
                if (i > 0)
                    sb.Append(','); // insert the comma before the 2nd binding
                sb.NewLineIdent(lineIdent);
                Bindings[i].CreateExpressionString(sb, uniqueExprs, lineIdent + identSpaces, stripNamespace, printType, identSpaces);
            }

            return sb.Append(')');
        }
    }

    internal sealed class ByRefParameterExpression : ParameterExpression
    {
        public override bool IsByRef => true;
        internal ByRefParameterExpression(Type type, string name) : base(type, name) { }
    }

    public class ParameterExpression : Expression
    {
        public override ExpressionType NodeType => ExpressionType.Parameter;
        public override Type Type { get; }
        public string Name { get; internal set; } // todo: @hack - made it settable to set from the `BlockExpresssion.ToCSharpString`
        public virtual bool IsByRef => false;
        internal ParameterExpression(Type type, string name)
        {
            Type = type;
            Name = name;
        }

        protected internal override Expression Accept(ExpressionVisitor visitor) => visitor.VisitParameter(this);

        internal override SysExpr CreateSysExpression(ref LiveCountArray<LightAndSysExpr> exprsConverted) =>
            SysExpr.Parameter(IsByRef ? Type.MakeByRefType() : Type, Name);

        public override StringBuilder CreateExpressionString(StringBuilder sb, List<Expression> uniqueExprs,
            int lineIdent = 0, bool stripNamespace = false, Func<Type, string, string> printType = null, int identSpaces = 2)
        {
            sb.Append("Parameter(").AppendTypeof(Type, stripNamespace, printType);

            if (IsByRef)
                sb.Append(".MakeByRefType()");

            if (Name != null)
                sb.Append(",\"").Append(Name).Append('"');

            return sb.Append(')');
        }

        public override StringBuilder ToCSharpString(StringBuilder sb,
            int lineIdent = 0, bool stripNamespace = false, Func<Type, string, string> printType = null, int identSpaces = 4) =>
            sb.Append(Name); // todo: @fix where Name is null

        internal static System.Linq.Expressions.ParameterExpression[] ToParameterExpressions(
            IReadOnlyList<ParameterExpression> ps, ref LiveCountArray<LightAndSysExpr> exprsConverted)
        {
            if (ps.Count == 0)
                return Tools.Empty<System.Linq.Expressions.ParameterExpression>();

            if (ps.Count == 1)
                return new[] { (System.Linq.Expressions.ParameterExpression)ps[0].ToExpression(ref exprsConverted) };

            var result = new System.Linq.Expressions.ParameterExpression[ps.Count];
            for (var i = 0; i < result.Length; ++i)
                result[i] = (System.Linq.Expressions.ParameterExpression)ps[i].ToExpression(ref exprsConverted);
            return result;
        }
    }

    public class ConstantExpression : Expression
    {
        public override ExpressionType NodeType => ExpressionType.Constant;
        public override Type Type => Value.GetType();

        public readonly object Value;

        internal ConstantExpression(object value) => Value = value;

        protected internal override Expression Accept(ExpressionVisitor visitor) => visitor.VisitConstant(this);

        internal override SysExpr CreateSysExpression(ref LiveCountArray<LightAndSysExpr> _) => SysExpr.Constant(Value, Type);

        /// <summary>
        /// Change the method to convert the <see cref="Value"/> to code as you want it globally.
        /// You may try to use `ObjectToCode` from `https://www.nuget.org/packages/ExpressionToCodeLib`
        /// </summary>
        public static CodePrinter.IObjectToCode ValueToCode = new ValueToDefault();

        private class ValueToDefault : CodePrinter.IObjectToCode
        {
            public string ToCode(object x, bool stripNamespace = false, Func<Type, string, string> printType = null) =>
                $"default({x.GetType().ToCode(stripNamespace, printType)})";
        }

        public override StringBuilder CreateExpressionString(StringBuilder sb, List<Expression> uniqueExprs,
            int lineIdent = 0, bool stripNamespace = false, Func<Type, string, string> printType = null, int identSpaces = 2)
        {
            sb.Append("Constant(");

            if (Value == null)
            {
                sb.Append("null");
                if (Type != typeof(object))
                    sb.Append(',').AppendTypeof(Type, stripNamespace, printType);
            }
            else if (Value is Type t) // todo: move this to ValueToCode, we should output `typeof(T)` anyway
            {
                sb.AppendTypeof(t, stripNamespace, printType);
            }
            else
            {
                sb.Append(Value.ToCode(ValueToCode, stripNamespace, printType));

                if (Value.GetType() != Type)
                    sb.Append(',').AppendTypeof(Type, stripNamespace, printType);
            }

            return sb.Append(')');
        }

        public override StringBuilder ToCSharpString(StringBuilder sb,
            int lineIdent = 0, bool stripNamespace = false, Func<Type, string, string> printType = null, int identSpaces = 4)
        {
            if (Value == null)
                return sb.Append("null");

            if (Value is Type t) // todo: move this to ValueToCode, we should output `typeof(T)` anyway
                return sb.AppendTypeof(t, stripNamespace, printType);

            // value with the cast
            if (Value.GetType() != Type)
            {
                sb.Append('(').Append(Type.ToCode(stripNamespace, printType)).Append(')');
                return sb.Append(Value.ToCode(ValueToCode, stripNamespace, printType));
            }

            sb.Append(Value.ToCode(ValueToCode, stripNamespace, printType));

            // suffixes for literals
            if (Type == typeof(float))
                sb.Append('f');
            else if (Type == typeof(uint))
                sb.Append('u');
            else if (Type == typeof(long))
                sb.Append('l');
            else if (Type == typeof(ulong))
                sb.Append("ul");
            else if (Type == typeof(decimal))
                sb.Append('m');

            return sb;
        }
    }

    public sealed class TypedConstantExpression : ConstantExpression
    {
        public override Type Type { get; }

        internal TypedConstantExpression(object value, Type type) : base(value) => Type = type;
    }

    public sealed class TypedConstantExpression<T> : ConstantExpression
    {
        public override Type Type => typeof(T);

        internal TypedConstantExpression(T value) : base(value) { }
    }

    public abstract class ArgumentsExpression : Expression
    {
        public readonly IReadOnlyList<Expression> Arguments;

        protected ArgumentsExpression(IReadOnlyList<Expression> arguments) => Arguments = arguments ?? Tools.Empty<Expression>();
    }

    public class NewExpression : Expression
    {
        public override ExpressionType NodeType => ExpressionType.New;
        public override Type Type => Constructor.DeclaringType;

        public readonly ConstructorInfo Constructor;

        public virtual int FewArgumentCount => 0;
        public virtual IReadOnlyList<Expression> Arguments => Tools.Empty<Expression>();

        internal NewExpression(ConstructorInfo constructor) => Constructor = constructor;

        protected internal override Expression Accept(ExpressionVisitor visitor) => visitor.VisitNew(this);

        internal override SysExpr CreateSysExpression(ref LiveCountArray<LightAndSysExpr> exprsConverted) =>
            SysExpr.New(Constructor, ToExpressions(Arguments, ref exprsConverted));

        public override StringBuilder CreateExpressionString(StringBuilder sb, List<Expression> uniqueExprs,
            int lineIdent = 0, bool stripNamespace = false, Func<Type, string, string> printType = null, int identSpaces = 2)
        {
            var args = Arguments;
            sb.Append("New(/*").Append(args.Count).Append(" args*/");
            var ctorIndex = Constructor.DeclaringType.GetTypeInfo().DeclaredConstructors.ToArray().GetFirstIndex(Constructor);
            sb.NewLineIdent(lineIdent).AppendTypeof(Type, stripNamespace, printType)
                .Append(".GetTypeInfo().DeclaredConstructors.ToArray()[").Append(ctorIndex).Append("],");
            sb.NewLineIdentExprs(args, uniqueExprs, lineIdent, stripNamespace, printType, identSpaces);
            return sb.Append(')');
        }

        public override StringBuilder ToCSharpString(StringBuilder sb,
            int lineIdent = 0, bool stripNamespace = false, Func<Type, string, string> printType = null, int identSpaces = 4)
        {
            sb.Append("new ").Append(Type.ToCode(stripNamespace, printType)).Append('(');
            var args = Arguments;
            if (args.Count == 1)
            {
                args[0].ToCSharpString(sb, lineIdent, stripNamespace, printType, identSpaces);
            }
            else if (args.Count > 1)
            {
                for (var i = 0; i < args.Count; i++)
                {
                    if (i > 0)
                        sb.Append(',');
                    sb.NewLineIdent(lineIdent);
                    args[i].ToCSharpString(sb, lineIdent + identSpaces, stripNamespace, printType, identSpaces);
                }
            }

            return sb.Append(')');
        }
    }

    public sealed class NewValueTypeExpression : NewExpression
    {
        public override Type Type { get; }

        internal NewValueTypeExpression(Type type) : base(null) => Type = type;

        internal override SysExpr CreateSysExpression(ref LiveCountArray<LightAndSysExpr> exprsConverted) => SysExpr.New(Type);

        public override StringBuilder CreateExpressionString(StringBuilder sb, List<Expression> uniqueExprs,
            int lineIdent = 0, bool stripNamespace = false, Func<Type, string, string> printType = null, int identSpaces = 2) =>
            sb.Append("New(").AppendTypeof(Type, stripNamespace, printType).Append(')');
    }

    public sealed class OneArgumentNewExpression : NewExpression
    {
        public readonly Expression Argument;
        public override IReadOnlyList<Expression> Arguments => new[] { Argument };
        public override int FewArgumentCount => 1;

        internal OneArgumentNewExpression(ConstructorInfo constructor, Expression argument) : base(constructor) =>
            Argument = argument;
    }

    public sealed class TwoArgumentsNewExpression : NewExpression
    {
        public readonly Expression Argument0;
        public readonly Expression Argument1;

        public override IReadOnlyList<Expression> Arguments => new[] { Argument0, Argument1 };
        public override int FewArgumentCount => 2;

        internal TwoArgumentsNewExpression(ConstructorInfo constructor,
            Expression argument0, Expression argument1) : base(constructor)
        {
            Argument0 = argument0;
            Argument1 = argument1;
        }
    }

    public sealed class ThreeArgumentsNewExpression : NewExpression
    {
        public readonly Expression Argument0;
        public readonly Expression Argument1;
        public readonly Expression Argument2;

        public override IReadOnlyList<Expression> Arguments => new[] { Argument0, Argument1, Argument2 };
        public override int FewArgumentCount => 3;

        internal ThreeArgumentsNewExpression(ConstructorInfo constructor,
            Expression argument0, Expression argument1, Expression argument2) : base(constructor)
        {
            Argument0 = argument0;
            Argument1 = argument1;
            Argument2 = argument2;
        }
    }

    public sealed class FourArgumentsNewExpression : NewExpression
    {
        public readonly Expression Argument0;
        public readonly Expression Argument1;
        public readonly Expression Argument2;
        public readonly Expression Argument3;

        public override IReadOnlyList<Expression> Arguments => new[] { Argument0, Argument1, Argument2, Argument3 };
        public override int FewArgumentCount => 4;

        internal FourArgumentsNewExpression(ConstructorInfo constructor,
            Expression argument0, Expression argument1, Expression argument2, Expression argument3) : base(constructor)
        {
            Argument0 = argument0;
            Argument1 = argument1;
            Argument2 = argument2;
            Argument3 = argument3;
        }
    }

    public sealed class FiveArgumentsNewExpression : NewExpression
    {
        public readonly Expression Argument0;
        public readonly Expression Argument1;
        public readonly Expression Argument2;
        public readonly Expression Argument3;
        public readonly Expression Argument4;

        public override IReadOnlyList<Expression> Arguments => new[] { Argument0, Argument1, Argument2, Argument3, Argument4 };
        public override int FewArgumentCount => 5;

        internal FiveArgumentsNewExpression(ConstructorInfo constructor,
            Expression argument0, Expression argument1, Expression argument2, Expression argument3, Expression argument4) : base(constructor)
        {
            Argument0 = argument0;
            Argument1 = argument1;
            Argument2 = argument2;
            Argument3 = argument3;
            Argument4 = argument4;
        }
    }

    public sealed class ManyArgumentsNewExpression : NewExpression
    {
        public override IReadOnlyList<Expression> Arguments { get; }
        public override int FewArgumentCount => -1;

        internal ManyArgumentsNewExpression(ConstructorInfo constructor, IReadOnlyList<Expression> arguments) : base(constructor) =>
            Arguments = arguments;
    }

    public sealed class NewArrayExpression : ArgumentsExpression
    {
        public override ExpressionType NodeType { get; }
        public override Type Type { get; }

        // I made it a ICollection for now to use Arguments as input, without changing Arguments type
        public IReadOnlyList<Expression> Expressions => Arguments;

        protected internal override Expression Accept(ExpressionVisitor visitor) => visitor.VisitNewArray(this);

        internal override SysExpr CreateSysExpression(ref LiveCountArray<LightAndSysExpr> exprsConverted) =>
            NodeType == ExpressionType.NewArrayInit
                // ReSharper disable once AssignNullToNotNullAttribute
                ? SysExpr.NewArrayInit(Type.GetElementType(), ToExpressions(Arguments, ref exprsConverted))
                // ReSharper disable once AssignNullToNotNullAttribute
                : SysExpr.NewArrayBounds(Type.GetElementType(), ToExpressions(Arguments, ref exprsConverted));

        public override StringBuilder CreateExpressionString(StringBuilder sb, List<Expression> uniqueExprs,
            int lineIdent = 0, bool stripNamespace = false, Func<Type, string, string> printType = null, int identSpaces = 2)
        {
            sb.Append(NodeType == ExpressionType.NewArrayInit ? "NewArrayInit(" : "NewArrayBounds(");
            sb.NewLineIdent(lineIdent).AppendTypeof(Type.GetElementType(), stripNamespace, printType);
            sb.NewLineIdentExprs(Arguments, uniqueExprs, lineIdent, stripNamespace, printType, identSpaces);
            return sb.Append(')');
        }

        internal NewArrayExpression(ExpressionType expressionType, Type arrayType, IReadOnlyList<Expression> elements) : base(elements)
        {
            NodeType = expressionType;
            Type = arrayType;
        }
    }

    public class MethodCallExpression : Expression
    {
        public override ExpressionType NodeType => ExpressionType.Call;
        public override Type Type => Method.ReturnType;

        public virtual Expression Object => null;
        public virtual IReadOnlyList<Expression> Arguments => Tools.Empty<Expression>();
        public virtual int FewArgumentCount => 0;

        public readonly MethodInfo Method;

        internal MethodCallExpression(MethodInfo method) => Method = method;

        protected internal override Expression Accept(ExpressionVisitor visitor) => visitor.VisitMethodCall(this);

        internal override SysExpr CreateSysExpression(ref LiveCountArray<LightAndSysExpr> exprsConverted) =>
            SysExpr.Call(Object?.ToExpression(ref exprsConverted), Method,
                ToExpressions(Arguments, ref exprsConverted));

        public override StringBuilder CreateExpressionString(StringBuilder sb, List<Expression> uniqueExprs,
            int lineIdent = 0, bool stripNamespace = false, Func<Type, string, string> printType = null, int identSpaces = 2)
        {
            sb.Append("Call(");
            sb.NewLineIdentExpr(Object, uniqueExprs, lineIdent, stripNamespace, printType, identSpaces).Append(',');
            sb.NewLineIdent(lineIdent).AppendMethod(Method, stripNamespace, printType);
            sb.NewLineIdentExprs(Arguments, uniqueExprs, lineIdent, stripNamespace, printType, identSpaces);
            return sb.Append(')');
        }

        public override StringBuilder ToCSharpString(StringBuilder sb,
            int lineIdent = 0, bool stripNamespace = false, Func<Type, string, string> printType = null, int identSpaces = 4)
        {
            if (Object != null)
                Object.ToCSharpString(sb, lineIdent, stripNamespace, printType, identSpaces);
            else // for static method or static extension method we need to qualify with the class
                sb.Append(Method.DeclaringType.ToCode(stripNamespace, printType));

            sb.Append('.').Append(Method.Name);

            if (Method.IsGenericMethod)
            {
                sb.Append('<');
                var typeArgs = Method.GetGenericArguments();
                for (var i = 0; i < typeArgs.Length; i++)
                    (i == 0 ? sb : sb.Append(", ")).Append(typeArgs[i].ToCode(stripNamespace, printType));
                sb.Append('>');
            }

            sb.Append('(');
            var pars = Method.GetParameters();
            var args = Arguments;
            if (args.Count == 1)
            {
                var p = pars[0];
                if (p.ParameterType.IsByRef)
                    sb.Append(p.IsOut ? "out " : p.IsIn ? "in" : "ref ");

                args[0].ToCSharpString(sb, lineIdent, stripNamespace, printType, identSpaces);
            }
            else if (args.Count > 1)
            {
                for (var i = 0; i < args.Count; i++)
                {
                    (i == 0 ? sb : sb.Append(',')).NewLineIdent(lineIdent);
                    var p = pars[i];
                    if (p.ParameterType.IsByRef)
                        sb.Append(p.IsOut ? "out " : p.IsIn ? "in " : "ref ");

                    args[i].ToCSharpString(sb, lineIdent + identSpaces, stripNamespace, printType, identSpaces);
                }
            }

            return sb.Append(')');
        }
    }

    public sealed class InstanceMethodCallExpression : MethodCallExpression
    {
        public override Expression Object { get; }

        internal InstanceMethodCallExpression(Expression instance, MethodInfo method) : base(method) =>
            Object = instance;
    }

    public class ManyArgumentsMethodCallExpression : MethodCallExpression
    {
        public override IReadOnlyList<Expression> Arguments { get; }
        public override int FewArgumentCount => -1;

        internal ManyArgumentsMethodCallExpression(MethodInfo method, IReadOnlyList<Expression> arguments) : base(method) =>
            Arguments = arguments;
    }

    public sealed class InstanceManyArgumentsMethodCallExpression : ManyArgumentsMethodCallExpression
    {
        public override Expression Object { get; }

        internal InstanceManyArgumentsMethodCallExpression(Expression instance, MethodInfo method, IReadOnlyList<Expression> arguments)
            : base(method, arguments) => Object = instance;
    }

    public class OneArgumentMethodCallExpression : MethodCallExpression
    {
        public override IReadOnlyList<Expression> Arguments => new[] { Argument };
        public override int FewArgumentCount => 1;

        public readonly Expression Argument;

        internal OneArgumentMethodCallExpression(MethodInfo method, Expression argument) : base(method) =>
            Argument = argument;
    }

    public sealed class InstanceOneArgumentMethodCallExpression : OneArgumentMethodCallExpression
    {
        public override Expression Object { get; }

        internal InstanceOneArgumentMethodCallExpression(Expression instance, MethodInfo method, Expression argument)
            : base(method, argument) => Object = instance;
    }

    public class TwoArgumentsMethodCallExpression : MethodCallExpression
    {
        public override IReadOnlyList<Expression> Arguments => new[] { Argument0, Argument1 };
        public override int FewArgumentCount => 2;

        public readonly Expression Argument0;
        public readonly Expression Argument1;

        internal TwoArgumentsMethodCallExpression(MethodInfo method, Expression argument0, Expression argument1) : base(method)
        {
            Argument0 = argument0;
            Argument1 = argument1;
        }
    }

    public sealed class InstanceTwoArgumentsMethodCallExpression : TwoArgumentsMethodCallExpression
    {
        public override Expression Object { get; }

        internal InstanceTwoArgumentsMethodCallExpression(Expression instance, MethodInfo method,
            Expression argument0, Expression argument1) : base(method, argument0, argument1) => Object = instance;
    }

    public class ThreeArgumentsMethodCallExpression : MethodCallExpression
    {
        public override IReadOnlyList<Expression> Arguments => new[] { Argument0, Argument1, Argument2 };
        public override int FewArgumentCount => 3;

        public readonly Expression Argument0;
        public readonly Expression Argument1;
        public readonly Expression Argument2;

        internal ThreeArgumentsMethodCallExpression(MethodInfo method,
            Expression argument0, Expression argument1, Expression argument2) : base(method)
        {
            Argument0 = argument0;
            Argument1 = argument1;
            Argument2 = argument2;
        }
    }

    public sealed class InstanceThreeArgumentsMethodCallExpression : ThreeArgumentsMethodCallExpression
    {
        public override Expression Object { get; }

        internal InstanceThreeArgumentsMethodCallExpression(Expression instance, MethodInfo method,
            Expression argument0, Expression argument1, Expression argument2)
            : base(method, argument0, argument1, argument2) => Object = instance;
    }

    public class FourArgumentsMethodCallExpression : MethodCallExpression
    {
        public override IReadOnlyList<Expression> Arguments => new[] { Argument0, Argument1, Argument2, Argument3 };
        public override int FewArgumentCount => 4;

        public readonly Expression Argument0;
        public readonly Expression Argument1;
        public readonly Expression Argument2;
        public readonly Expression Argument3;

        internal FourArgumentsMethodCallExpression(MethodInfo method,
            Expression argument0, Expression argument1, Expression argument2, Expression argument3) : base(method)
        {
            Argument0 = argument0;
            Argument1 = argument1;
            Argument2 = argument2;
            Argument3 = argument3;
        }
    }

    public sealed class InstanceFourArgumentsMethodCallExpression : FourArgumentsMethodCallExpression
    {
        public override Expression Object { get; }

        internal InstanceFourArgumentsMethodCallExpression(Expression instance, MethodInfo method,
            Expression argument0, Expression argument1, Expression argument2, Expression argument3)
            : base(method, argument0, argument1, argument2, argument3) => Object = instance;
    }

    public class FiveArgumentsMethodCallExpression : MethodCallExpression
    {
        public override IReadOnlyList<Expression> Arguments => new[] { Argument0, Argument1, Argument2, Argument3, Argument4 };
        public override int FewArgumentCount => 5;

        public readonly Expression Argument0;
        public readonly Expression Argument1;
        public readonly Expression Argument2;
        public readonly Expression Argument3;
        public readonly Expression Argument4;

        internal FiveArgumentsMethodCallExpression(MethodInfo method,
            Expression argument0, Expression argument1, Expression argument2, Expression argument3, Expression argument4)
            : base(method)
        {
            Argument0 = argument0;
            Argument1 = argument1;
            Argument2 = argument2;
            Argument3 = argument3;
            Argument4 = argument4;
        }
    }

    public sealed class InstanceFiveArgumentsMethodCallExpression : FiveArgumentsMethodCallExpression
    {
        public override Expression Object { get; }

        internal InstanceFiveArgumentsMethodCallExpression(Expression instance, MethodInfo method,
            Expression argument0, Expression argument1, Expression argument2, Expression argument3, Expression argument4)
            : base(method, argument0, argument1, argument2, argument3, argument4) => Object = instance;
    }

    public abstract class MemberExpression : Expression
    {
        public override ExpressionType NodeType => ExpressionType.MemberAccess;
        public readonly MemberInfo Member;

        public virtual Expression Expression => null;

        protected MemberExpression(MemberInfo member) => Member = member;

        protected internal override Expression Accept(ExpressionVisitor visitor) => visitor.VisitMember(this);

        public override StringBuilder ToCSharpString(StringBuilder sb,
            int lineIdent = 0, bool stripNamespace = false, Func<Type, string, string> printType = null, int identSpaces = 4)
        {
            if (Expression != null)
                Expression.ToCSharpString(sb, lineIdent, stripNamespace, printType, identSpaces);
            else
                sb.NewLineIdent(lineIdent).Append(Member.DeclaringType.ToCode(stripNamespace, printType));

            return sb.Append('.').Append(Member.Name);
        }
    }

    public class PropertyExpression : MemberExpression
    {
        public override Type Type => PropertyInfo.PropertyType;
        public PropertyInfo PropertyInfo => (PropertyInfo)Member;

        internal PropertyExpression(PropertyInfo property) : base(property) { }

        internal override SysExpr CreateSysExpression(ref LiveCountArray<LightAndSysExpr> exprsConverted) =>
            SysExpr.Property(Expression?.ToExpression(ref exprsConverted), PropertyInfo);

        public override StringBuilder CreateExpressionString(StringBuilder sb, List<Expression> uniqueExprs,
            int lineIdent = 0, bool stripNamespace = false, Func<Type, string, string> printType = null, int identSpaces = 2)
        {
            sb.Append("Property(");
            sb.NewLineIdentExpr(Expression, uniqueExprs, lineIdent, stripNamespace, printType, identSpaces).Append(',');
            sb.NewLineIdent(lineIdent).AppendProperty(PropertyInfo, stripNamespace, printType);
            return sb.Append(')');
        }
    }

    public sealed class InstancePropertyExpression : PropertyExpression
    {
        public override Expression Expression { get; }

        internal InstancePropertyExpression(Expression instance, PropertyInfo property) : base(property) =>
            Expression = instance;
    }

    public class FieldExpression : MemberExpression
    {
        public override Type Type => FieldInfo.FieldType;
        public FieldInfo FieldInfo => (FieldInfo)Member;

        internal FieldExpression(FieldInfo field) : base(field) { }

        internal override SysExpr CreateSysExpression(ref LiveCountArray<LightAndSysExpr> exprsConverted) =>
            SysExpr.Field(Expression?.ToExpression(ref exprsConverted), FieldInfo);

        public override StringBuilder CreateExpressionString(StringBuilder sb, List<Expression> uniqueExprs,
            int lineIdent = 0, bool stripNamespace = false, Func<Type, string, string> printType = null, int identSpaces = 2)
        {
            sb.Append("Field(");
            sb.NewLineIdentExpr(Expression, uniqueExprs, lineIdent, stripNamespace, printType, identSpaces).Append(',');
            sb.NewLineIdent(lineIdent).AppendField(FieldInfo, stripNamespace, printType);
            return sb.Append(')');
        }
    }

    public sealed class InstanceFieldExpression : FieldExpression
    {
        public override Expression Expression { get; }

        internal InstanceFieldExpression(Expression instance, FieldInfo field) : base(field) =>
            Expression = instance;
    }

    public abstract class MemberBinding
    {
        public readonly MemberInfo Member;
        public abstract MemberBindingType BindingType { get; }

        internal MemberBinding(MemberInfo member) => Member = member;

        public string ToExpressionString() => CreateExpressionString(new StringBuilder(128), new List<Expression>(), 2).ToString();

        public abstract StringBuilder CreateExpressionString(StringBuilder sb, List<Expression> uniqueExprs,
            int lineIdent = 0, bool stripNamespace = false, Func<Type, string, string> printType = null, int identSpaces = 2);

        internal abstract System.Linq.Expressions.MemberBinding ToMemberBinding(ref LiveCountArray<LightAndSysExpr> exprsConverted);
    }

    public sealed class MemberAssignment : MemberBinding
    {
        public readonly Expression Expression;
        public override MemberBindingType BindingType => MemberBindingType.Assignment;

        internal MemberAssignment(MemberInfo member, Expression expression) : base(member) => Expression = expression;

        internal override System.Linq.Expressions.MemberBinding ToMemberBinding(ref LiveCountArray<LightAndSysExpr> exprsConverted) =>
            SysExpr.Bind(Member, Expression.ToExpression(ref exprsConverted));

        public override StringBuilder CreateExpressionString(StringBuilder sb, List<Expression> uniqueExprs,
            int lineIdent = 0, bool stripNamespace = false, Func<Type, string, string> printType = null, int identSpaces = 2)
        {
            sb.Append("Bind(");
            sb.NewLineIdent(lineIdent).AppendFieldOrProperty(Member, stripNamespace, printType);
            sb.NewLineIdentExpr(Expression, uniqueExprs, lineIdent, stripNamespace, printType, identSpaces);
            return sb.Append(")");
        }

        // todo: @incomplete implement ToCSharpCode
    }

    public sealed class MemberMemberBinding : MemberBinding
    {
        public override MemberBindingType BindingType => MemberBindingType.MemberBinding;
        public readonly IReadOnlyList<MemberBinding> Bindings;

        internal MemberMemberBinding(MemberInfo member, IReadOnlyList<MemberBinding> bindings) : base(member) =>
            Bindings = bindings;

        private static System.Linq.Expressions.MemberBinding[] ToMemberBindings(IReadOnlyList<MemberBinding> items, 
            ref LiveCountArray<LightAndSysExpr> exprsConverted)
        {
            if (items.Count == 0)
                return Tools.Empty<System.Linq.Expressions.MemberBinding>();

            var result = new System.Linq.Expressions.MemberBinding[items.Count];
            for (var i = 0; i < result.Length; ++i)
                result[i] = items[i].ToMemberBinding(ref exprsConverted);
            return result;
        }

        internal override System.Linq.Expressions.MemberBinding ToMemberBinding(ref LiveCountArray<LightAndSysExpr> exprsConverted) =>
            SysExpr.MemberBind(Member, ToMemberBindings(Bindings, ref exprsConverted));

        public override StringBuilder CreateExpressionString(StringBuilder sb, List<Expression> uniqueExprs,
            int lineIdent = 0, bool stripNamespace = false, Func<Type, string, string> printType = null, int identSpaces = 2)
        {
            sb.Append("MemberBind(");
            sb.NewLineIdent(lineIdent).AppendFieldOrProperty(Member, stripNamespace, printType);

            for (int i = 0; i < Bindings.Count; i++)
            {
                var b = Bindings[i];
                if (i > 0) sb.Append(",");
                sb.NewLineIdent(lineIdent);
                b.CreateExpressionString(sb, uniqueExprs, lineIdent, stripNamespace, printType, identSpaces);
            }
            
            return sb.Append(")");
        }
    }

    public sealed class MemberListBinding : MemberBinding
    {
        public override MemberBindingType BindingType => MemberBindingType.ListBinding;
        public readonly IReadOnlyList<ElementInit> Initializers;

        internal MemberListBinding(MemberInfo member, IReadOnlyList<ElementInit> initializers) : base(member) =>
            Initializers = initializers;

        internal override System.Linq.Expressions.MemberBinding ToMemberBinding(ref LiveCountArray<LightAndSysExpr> exprsConverted) =>
            SysExpr.ListBind(Member, ListInitExpression.ToElementInits(Initializers, ref exprsConverted));

        public override StringBuilder CreateExpressionString(StringBuilder sb, List<Expression> uniqueExprs,
            int lineIdent = 0, bool stripNamespace = false, Func<Type, string, string> printType = null, int identSpaces = 2)
        {
            sb.Append("ListBind(");
            sb.NewLineIdent(lineIdent).AppendFieldOrProperty(Member, stripNamespace, printType);

            for (int i = 0; i < Initializers.Count; i++)
            {
                var x = Initializers[i];
                if (i > 0) sb.Append(",");
                sb.NewLineIdent(lineIdent);
                x.CreateExpressionString(sb, uniqueExprs, lineIdent, stripNamespace, printType, identSpaces);
            }
            
            return sb.Append(")");
        }
    }

    public class InvocationExpression : Expression
    {
        public override ExpressionType NodeType => ExpressionType.Invoke;

        public override Type Type => ((LambdaExpression)Expression).ReturnType;

        public virtual IReadOnlyList<Expression> Arguments => Tools.Empty<Expression>();

        public readonly Expression Expression;

        internal InvocationExpression(Expression expression) =>
            Expression = expression;

        protected internal override Expression Accept(ExpressionVisitor visitor) => visitor.VisitInvocation(this);

        internal override SysExpr CreateSysExpression(ref LiveCountArray<LightAndSysExpr> exprsConverted) =>
            SysExpr.Invoke(Expression.ToExpression(ref exprsConverted), ToExpressions(Arguments, ref exprsConverted));

        public override StringBuilder CreateExpressionString(StringBuilder sb, List<Expression> uniqueExprs,
            int lineIdent = 0, bool stripNamespace = false, Func<Type, string, string> printType = null, int identSpaces = 2)
        {
            sb.Append("Invoke(");
            sb.NewLineIdentExpr(Expression, uniqueExprs, lineIdent, stripNamespace, printType, identSpaces).Append(',');
            sb.NewLineIdentExprs(Arguments, uniqueExprs, lineIdent, stripNamespace, printType, identSpaces);
            return sb.Append(")");
        }

        public override StringBuilder ToCSharpString(StringBuilder sb,
            int lineIdent = 0, bool stripNamespace = false, Func<Type, string, string> printType = null, int identSpaces = 4)
        {
            sb.Append("new ").Append(Expression.Type.ToCode(stripNamespace, printType)).Append("(");
            sb.NewLineIdentCs(Expression, lineIdent, stripNamespace, printType, identSpaces);
            sb.Append(").Invoke(");
            sb.NewLineIdentCss(Arguments, lineIdent, stripNamespace, printType, identSpaces);
            sb.Append(")");
            return sb;
        }
    }

    public sealed class TypedInvocationExpression : InvocationExpression
    {
        public override Type Type { get; }

        internal TypedInvocationExpression(Expression expression, Type type)
            : base(expression) =>
            Type = type;
    }

    public class ManyArgumentsInvocationExpression : InvocationExpression
    {
        public override IReadOnlyList<Expression> Arguments { get; }

        internal ManyArgumentsInvocationExpression(Expression expression, IReadOnlyList<Expression> arguments)
            : base(expression) =>
            Arguments = arguments;
    }


    public sealed class TypedManyArgumentsInvocationExpression : ManyArgumentsInvocationExpression
    {
        public override Type Type { get; }

        internal TypedManyArgumentsInvocationExpression(Expression expression, IReadOnlyList<Expression> arguments, Type type)
            : base(expression, arguments) =>
            Type = type;
    }

    public sealed class DefaultExpression : Expression
    {
        public override ExpressionType NodeType => ExpressionType.Default;
        public override Type Type { get; }

        internal DefaultExpression(Type type) => Type = type;

        protected internal override Expression Accept(ExpressionVisitor visitor) => visitor.VisitDefault(this);

        internal override SysExpr CreateSysExpression(ref LiveCountArray<LightAndSysExpr> exprsConverted) =>
            Type == typeof(void) ? SysExpr.Empty() : SysExpr.Default(Type);

        public override StringBuilder CreateExpressionString(StringBuilder sb, List<Expression> uniqueExprs,
            int lineIdent = 0, bool stripNamespace = false, Func<Type, string, string> printType = null, int identSpaces = 2) =>
            Type == typeof(void) ? sb.Append("Empty()") : sb.Append("Default(").AppendTypeof(Type, stripNamespace, printType).Append(')');

        public override StringBuilder ToCSharpString(StringBuilder sb,
            int lineIdent = 0, bool stripNamespace = false, Func<Type, string, string> printType = null, int identSpaces = 4) =>
            sb.Append("default(").Append(Type.ToCode(stripNamespace, printType)).Append(')');
    }

    // todo: @test Test all conditional + try for the exact op-codes produced, should help with AutoMapper case
    public class ConditionalExpression : Expression
    {
        public override ExpressionType NodeType => ExpressionType.Conditional;
        public override Type Type => typeof(void);

        public readonly Expression Test;
        public readonly Expression IfTrue;
        public virtual Expression IfFalse => VoidDefault;

        internal ConditionalExpression(Expression test, Expression ifTrue)
        {
            Test = test;
            IfTrue = ifTrue;
        }

        protected internal override Expression Accept(ExpressionVisitor visitor) => visitor.VisitConditional(this);

        internal override SysExpr CreateSysExpression(ref LiveCountArray<LightAndSysExpr> exprsConverted) =>
            SysExpr.Condition(Test.ToExpression(ref exprsConverted), IfTrue.ToExpression(ref exprsConverted), IfFalse.ToExpression(ref exprsConverted), Type);

        public override StringBuilder CreateExpressionString(StringBuilder sb, List<Expression> uniqueExprs,
            int lineIdent = 0, bool stripNamespace = false, Func<Type, string, string> printType = null, int identSpaces = 2)
        {
            sb.Append("Condition(");
            sb.NewLineIdentExpr(Test, uniqueExprs, lineIdent, stripNamespace, printType, identSpaces).Append(',');
            sb.NewLineIdentExpr(IfTrue, uniqueExprs, lineIdent, stripNamespace, printType, identSpaces).Append(',');
            sb.NewLineIdentExpr(IfFalse, uniqueExprs, lineIdent, stripNamespace, printType, identSpaces);
            sb.Append(',').NewLineIdent(lineIdent).AppendTypeof(Type, stripNamespace, printType);

            return sb.Append(')');
        }

        public override StringBuilder ToCSharpString(StringBuilder sb,
            int lineIdent = 0, bool stripNamespace = false, Func<Type, string, string> printType = null, int identSpaces = 4)
        {
            if (Type == typeof(void))
            {
                sb.Append("if (");
                Test.ToCSharpString(sb, lineIdent, stripNamespace, printType, identSpaces);
                sb.Append(')');
                sb.NewLine(lineIdent, identSpaces).Append('{');

                if (IfTrue is BlockExpression)
                    IfTrue.ToCSharpString(sb, lineIdent, stripNamespace, printType, identSpaces);
                else
                    sb.NewLineIdentCs(IfTrue, lineIdent, stripNamespace, printType, identSpaces).Append(';');

                sb.NewLine(lineIdent, identSpaces).Append('}');
                if (IfFalse != VoidDefault)
                {
                    sb.NewLine(lineIdent, identSpaces).Append("else");
                    sb.NewLine(lineIdent, identSpaces).Append('{');

                    if (IfFalse is BlockExpression)
                        IfFalse.ToCSharpString(sb, lineIdent, stripNamespace, printType, identSpaces);
                    else
                        sb.NewLineIdentCs(IfFalse, lineIdent, stripNamespace, printType, identSpaces).Append(';');
                    sb.NewLine(lineIdent, identSpaces).Append('}');
                }
            }
            else
            {
                Test.ToCSharpString(sb, lineIdent, stripNamespace, printType, identSpaces).Append(" ?");
                sb.NewLineIdentCs(IfTrue, lineIdent, stripNamespace, printType, identSpaces).Append(" :");
                sb.NewLineIdentCs(IfFalse, lineIdent, stripNamespace, printType, identSpaces);
            }

            return sb;
        }
    }

    public class VoidWithFalseBranchConditionalExpression : ConditionalExpression
    {
        public override Expression IfFalse { get; }

        internal VoidWithFalseBranchConditionalExpression(Expression test, Expression ifTrue, Expression ifFalse)
            : base(test, ifTrue) =>
            IfFalse = ifFalse;
    }

    public sealed class WithFalseBranchConditionalExpression : VoidWithFalseBranchConditionalExpression
    {
        public override Type Type => IfTrue.Type;

        internal WithFalseBranchConditionalExpression(Expression test, Expression ifTrue, Expression ifFalse)
            : base(test, ifTrue, ifFalse) { }
    }

    public sealed class TypedWithFalseBranchConditionalExpression : VoidWithFalseBranchConditionalExpression
    {
        public override Type Type { get; }

        internal TypedWithFalseBranchConditionalExpression(Expression test, Expression ifTrue, Expression ifFalse, Type type)
            : base(test, ifTrue, ifFalse) =>
            Type = type;
    }

    /// <summary>For indexer property or array access.</summary>
    public sealed class IndexExpression : ArgumentsExpression
    {
        public override ExpressionType NodeType => ExpressionType.Index;
        public override Type Type => Indexer != null ? Indexer.PropertyType : Object.Type.GetElementType();

        public readonly Expression Object;
        public readonly PropertyInfo Indexer;

        protected internal override Expression Accept(ExpressionVisitor visitor) => visitor.VisitIndex(this);

        internal override SysExpr CreateSysExpression(ref LiveCountArray<LightAndSysExpr> exprsConverted) =>
            SysExpr.MakeIndex(Object.ToExpression(ref exprsConverted), Indexer, ToExpressions(Arguments, ref exprsConverted));

        public override StringBuilder CreateExpressionString(StringBuilder sb, List<Expression> uniqueExprs,
            int lineIdent = 0, bool stripNamespace = false, Func<Type, string, string> printType = null, int identSpaces = 2)
        {
            sb.Append("MakeIndex(");
            sb.NewLineIdentExpr(Object, uniqueExprs, lineIdent, stripNamespace, printType, identSpaces);

            var propIndex = Indexer.DeclaringType.GetTypeInfo().DeclaredProperties.AsArray().GetFirstIndex(Indexer);
            sb.NewLineIdent(lineIdent).AppendTypeof(Indexer.DeclaringType)
                .Append(".GetTypeInfo().DeclaredProperties.ToArray()[").Append(propIndex).Append("],");

            sb.NewLineIdentExprs(Arguments, uniqueExprs, lineIdent, stripNamespace, printType, identSpaces);
            return sb.Append(')');
        }

        internal IndexExpression(Expression @object, PropertyInfo indexer, IReadOnlyList<Expression> arguments)
            : base(arguments)
        {
            Object = @object;
            Indexer = indexer;
        }
    }

    /// <summary>Base Block expression with no variables and with Type of its last (Result) exporession</summary>
    public class BlockExpression : Expression
    {
        public override ExpressionType NodeType => ExpressionType.Block;
        public override Type Type => Result.Type;

        public virtual IReadOnlyList<ParameterExpression> Variables => Tools.Empty<ParameterExpression>();
        public readonly IReadOnlyList<Expression> Expressions;
        public Expression Result => Expressions[Expressions.Count - 1];

        internal BlockExpression(IReadOnlyList<Expression> expressions) => Expressions = expressions;

        protected internal override Expression Accept(ExpressionVisitor visitor) => visitor.VisitBlock(this);

        internal override SysExpr CreateSysExpression(ref LiveCountArray<LightAndSysExpr> exprsConverted) =>
            SysExpr.Block(Type,
                ParameterExpression.ToParameterExpressions(Variables, ref exprsConverted),
                ToExpressions(Expressions, ref exprsConverted));

        public override StringBuilder CreateExpressionString(StringBuilder sb, List<Expression> uniqueExprs,
            int lineIdent = 0, bool stripNamespace = false, Func<Type, string, string> printType = null, int identSpaces = 2)
        {
            sb.Append("Block(");
            sb.NewLineIdent(lineIdent).AppendTypeof(Type, stripNamespace, printType).Append(',');

            if (Variables.Count == 0)
                sb.NewLineIdent(lineIdent).Append("new ParameterExpression[0],");
            else
            {
                sb.NewLineIdent(lineIdent).Append("new ParameterExpression[]{");
                sb.NewLineIdentExprs(Variables, uniqueExprs, lineIdent, stripNamespace, printType, identSpaces);
                sb.NewLineIdent(lineIdent).Append("},");
            }

            sb.NewLineIdentExprs(Expressions, uniqueExprs, lineIdent, stripNamespace, printType, identSpaces);
            return sb.Append(')');
        }

        public override StringBuilder ToCSharpString(StringBuilder sb,
            int lineIdent = 0, bool stripNamespace = false, Func<Type, string, string> printType = null, int identSpaces = 4)
        {
            var vars = Variables;
            if (vars.Count != 0)
            {
                for (var i = 0; i < vars.Count; i++)
                {
                    var v = vars[i];
                    sb.NewLineIdent(lineIdent);
                    sb.Append(v.Type.ToCode(stripNamespace, printType)).Append(' ');
                    if (string.IsNullOrEmpty(v.Name))
                        v.Name = "__" + v.Type.Name + "_" + i;
                    sb.Append(v.Name).Append(';');
                }
                sb.AppendLine(); // visually separate the variables from expressions
            }

            var exprs = Expressions;
            for (var i = 0; i < exprs.Count - 1; i++)
            {
                sb.NewLineIdent(lineIdent);

                var expr = exprs[i];

                // this is basically the return pattern (see #237), so we don't care for the rest of expressions if any
                if (expr is GotoExpression gt && gt.Kind == GotoExpressionKind.Return &&
                    exprs[i + 1] is LabelExpression label && label.Target == gt.Target)
                {
                    if (gt.Value == null)
                        return sb.Append("return;");
                    sb.Append("return ");
                    return gt.Value.ToCSharpString(sb, lineIdent, stripNamespace, printType, identSpaces).Append(";");
                }

                // otherwise proceed normally with the next (and not the last) expression
                expr.ToCSharpString(sb, lineIdent + identSpaces, stripNamespace, printType, identSpaces);

                // preventing the `};` kind of situation and emphasing the conditional block with empty line
                if (expr is ConditionalExpression && expr.Type == typeof(void) ||
                    expr is TryExpression ||
                    expr is LoopExpression ||
                    expr is SwitchExpression)
                    sb.AppendLine();
                else
                    sb.Append(';');
            }

            var lastExpr = exprs[exprs.Count - 1];
            if (Type == typeof(void))
                lastExpr.ToCSharpString(sb, lineIdent + identSpaces, stripNamespace, printType, identSpaces);
            else
            {
                // inline the last nested block - it will care about the `return` and ending `;` by itself
                if (lastExpr is BlockExpression ||
                    lastExpr is LabelExpression)
                    return lastExpr.ToCSharpString(sb, lineIdent, stripNamespace, printType, identSpaces);

                sb.NewLineIdent(lineIdent).Append("return ");
                lastExpr.ToCSharpString(sb, lineIdent, stripNamespace, printType, identSpaces);
            }

            return sb.Append(';');
        }
    }

    /// <summary>Block with no variable but user-specified type.</summary>
    public sealed class TypedBlockExpression : BlockExpression
    {
        public override Type Type { get; }

        internal TypedBlockExpression(Type type, IReadOnlyList<Expression> expressions) : base(expressions) =>
            Type = type;
    }


    public class ManyVariablesBlockExpression : BlockExpression
    {
        public override IReadOnlyList<ParameterExpression> Variables { get; }

        internal ManyVariablesBlockExpression(IReadOnlyList<ParameterExpression> variables, IReadOnlyList<Expression> expressions) : base(expressions) =>
            Variables = variables;
    }

    public sealed class TypedManyVariablesBlockExpression : ManyVariablesBlockExpression
    {
        public override Type Type { get; }

        internal TypedManyVariablesBlockExpression(Type type, IReadOnlyList<ParameterExpression> variables, IReadOnlyList<Expression> expressions)
            : base(variables, expressions) =>
            Type = type;
    }

    public sealed class LoopExpression : Expression
    {
        public override ExpressionType NodeType => ExpressionType.Loop;

        public override Type Type => typeof(void);

        public readonly Expression Body;
        public readonly LabelTarget BreakLabel;
        public readonly LabelTarget ContinueLabel;

        internal LoopExpression(Expression body, LabelTarget breakLabel, LabelTarget continueLabel)
        {
            Body = body;
            BreakLabel = breakLabel;
            ContinueLabel = continueLabel;
        }

        protected internal override Expression Accept(ExpressionVisitor visitor) => visitor.VisitLoop(this);

        internal override SysExpr CreateSysExpression(ref LiveCountArray<LightAndSysExpr> exprsConverted) =>
            BreakLabel == null
            ? SysExpr.Loop(Body.ToExpression(ref exprsConverted)) :
            ContinueLabel == null
            ? SysExpr.Loop(Body.ToExpression(ref exprsConverted), BreakLabel.ToSystemLabelTarget(ref exprsConverted)) :
            SysExpr.Loop(Body.ToExpression(ref exprsConverted),
                BreakLabel.ToSystemLabelTarget(ref exprsConverted),
                ContinueLabel.ToSystemLabelTarget(ref exprsConverted));

        public override StringBuilder CreateExpressionString(StringBuilder sb, List<Expression> uniqueExprs,
            int lineIdent = 0, bool stripNamespace = false, Func<Type, string, string> printType = null, int identSpaces = 2)
        {
            sb.Append("Loop(");
            sb.NewLineIdentExpr(Body, uniqueExprs, lineIdent, stripNamespace, printType, identSpaces);

            if (BreakLabel != null)
            {
                sb.Append(',');
                sb.NewLineIdent(lineIdent).Append("Label(\"break\")");
            }

            if (ContinueLabel != null)
            {
                sb.Append(',');
                sb.NewLineIdent(lineIdent).Append("Label(\"continue\")");
            }

            return sb.Append(')');
        }

        // todo: @incomplete to implement
        // public override StringBuilder ToCSharpString(StringBuilder sb,
        //     int lineIdent = 0, bool stripNamespace = false, Func<Type, string, string> printType = null, int identSpaces = 4) {}
    }

    public class TryExpression : Expression
    {
        public override ExpressionType NodeType => ExpressionType.Try;
        public override Type Type => Body.Type;

        public readonly Expression Body;
        public IReadOnlyList<CatchBlock> Handlers => _handlers;
        private readonly CatchBlock[] _handlers;
        public virtual Expression Finally => null;

        internal TryExpression(Expression body, CatchBlock[] handlers)
        {
            Body = body;
            _handlers = handlers;
        }

        protected internal override Expression Accept(ExpressionVisitor visitor) => visitor.VisitTry(this);

        internal override SysExpr CreateSysExpression(ref LiveCountArray<LightAndSysExpr> exprsConverted) =>
            Finally == null ?
                SysExpr.TryCatch(Body.ToExpression(ref exprsConverted),
                    ToCatchBlocks(_handlers, ref exprsConverted)) :
            Handlers == null ?
                SysExpr.TryFinally(Body.ToExpression(ref exprsConverted),
                    Finally.ToExpression(ref exprsConverted)) :
                SysExpr.TryCatchFinally(Body.ToExpression(ref exprsConverted),
                    Finally.ToExpression(ref exprsConverted), ToCatchBlocks(_handlers, ref exprsConverted));

        private static System.Linq.Expressions.CatchBlock ToCatchBlock(
            ref CatchBlock cb, ref LiveCountArray<LightAndSysExpr> exprsConverted) =>
            SysExpr.MakeCatchBlock(cb.Test,
                (System.Linq.Expressions.ParameterExpression)cb.Variable?.ToExpression(ref exprsConverted),
                cb.Body.ToExpression(ref exprsConverted),
                cb.Filter?.ToExpression(ref exprsConverted));

        private static System.Linq.Expressions.CatchBlock[] ToCatchBlocks(
            CatchBlock[] hs, ref LiveCountArray<LightAndSysExpr> exprsConverted)
        {
            if (hs == null)
                return Tools.Empty<System.Linq.Expressions.CatchBlock>();
            var catchBlocks = new System.Linq.Expressions.CatchBlock[hs.Length];
            for (var i = 0; i < hs.Length; ++i)
                catchBlocks[i] = ToCatchBlock(ref hs[i], ref exprsConverted);
            return catchBlocks;
        }

        public override StringBuilder CreateExpressionString(StringBuilder sb, List<Expression> uniqueExprs,
            int lineIdent = 0, bool stripNamespace = false, Func<Type, string, string> printType = null, int identSpaces = 2)
        {
            if (Finally == null)
            {
                sb.Append("TryCatch(");
                sb.NewLineIdentExpr(Body, uniqueExprs, lineIdent, stripNamespace, printType, identSpaces).Append(',');
                ToCatchBlocksCode(Handlers, sb, uniqueExprs, lineIdent, stripNamespace, printType, identSpaces);
            }
            else if (Handlers == null)
            {
                sb.Append("TryFinally(");
                sb.NewLineIdentExpr(Body, uniqueExprs, lineIdent, stripNamespace, printType, identSpaces).Append(',');
                sb.NewLineIdentExpr(Finally, uniqueExprs, lineIdent, stripNamespace, printType, identSpaces);
            }
            else
            {
                sb.Append("TryCatchFinally(");
                sb.NewLineIdentExpr(Body, uniqueExprs, lineIdent, stripNamespace, printType, identSpaces).Append(',');
                ToCatchBlocksCode(Handlers, sb, uniqueExprs, lineIdent, stripNamespace, printType, identSpaces).Append(',');
                sb.NewLineIdentExpr(Finally, uniqueExprs, lineIdent, stripNamespace, printType, identSpaces);
            }

            return sb.Append(')');
        }

        private static StringBuilder ToCatchBlocksCode(IReadOnlyList<CatchBlock> hs, StringBuilder sb, List<Expression> uniqueExprs,
            int lineIdent, bool stripNamespace, Func<Type, string, string> printType, int identSpaces)
        {
            if (hs.Count == 0)
                return sb.Append("new CatchBlock[0]");

            for (var i = 0; i < hs.Count; i++)
            {
                if (i > 0)
                    sb.Append(',');
                sb.NewLineIdent(lineIdent);
                hs[i].CreateExpressionCodeString(sb, uniqueExprs, lineIdent + identSpaces, stripNamespace, printType, identSpaces);
            }

            return sb;
        }

        public override StringBuilder ToCSharpString(StringBuilder sb,
            int lineIdent = 0, bool stripNamespace = false, Func<Type, string, string> printType = null, int identSpaces = 4)
        {
            sb.Append("try");
            sb.NewLine(lineIdent, identSpaces).Append('{');
            sb.NewLineIdentCs(Body, lineIdent, stripNamespace, printType, identSpaces);
            sb.NewLine(lineIdent, identSpaces).Append('}');

            if (_handlers != null && _handlers.Length > 0)
            {
                for (var i = 0; i < _handlers.Length; i++)
                {
                    var h = _handlers[i];
                    sb.NewLine(lineIdent, identSpaces).Append("catch (");
                    var exTypeName = h.Test.ToCode(stripNamespace, printType);
                    sb.Append(exTypeName);
                    if (h.Variable != null)
                    {
                        if (string.IsNullOrEmpty(h.Variable.Name))
                            h.Variable.Name = "ex" + exTypeName; // todo: @hack
                        sb.Append(' ').Append(h.Variable.Name);
                    }
                    sb.Append(')');
                    if (h.Filter != null)
                    {
                        sb.Append("when (");
                        sb.NewLineIdentCs(h.Filter, lineIdent, stripNamespace, printType, identSpaces);
                        sb.NewLine(lineIdent, identSpaces).Append(')');
                    }
                    sb.NewLine(lineIdent, identSpaces).Append('{');
                    sb.NewLineIdentCs(h.Body, lineIdent, stripNamespace, printType, identSpaces);
                    sb.NewLine(lineIdent, identSpaces).Append('}');
                }
            }

            if (Finally != null)
            {
                sb.Append("finally");
                sb.NewLine(lineIdent, identSpaces).Append('{');
                sb.NewLineIdentCs(Finally, lineIdent, stripNamespace, printType, identSpaces);
                sb.NewLine(lineIdent, identSpaces).Append('}');
            }

            return sb;
        }
    }

    public sealed class WithFinallyTryExpression : TryExpression
    {
        public override Expression Finally { get; }

        internal WithFinallyTryExpression(Expression body, CatchBlock[] handlers, Expression @finally)
            : base(body, handlers) =>
            Finally = @finally;
    }

    // todo: @perf convert to class and minimize the memory for the general cases
    public struct CatchBlock
    {
        public readonly ParameterExpression Variable;
        public readonly Expression Body;
        public readonly Expression Filter;
        public readonly Type Test;

        internal CatchBlock(ParameterExpression variable, Expression body, Expression filter, Type test)
        {
            Variable = variable;
            Body = body;
            Filter = filter;
            Test = test;
        }

        internal StringBuilder CreateExpressionCodeString(StringBuilder sb, List<Expression> uniqueExprs,
            int lineIdent, bool stripNamespace, Func<Type, string, string> printType, int identSpaces)
        {
            sb.Append("MakeCatchBlock(");
            sb.NewLineIdent(lineIdent).AppendTypeof(Test, stripNamespace, printType).Append(',');
            sb.NewLineIdentExpr(Variable, uniqueExprs, lineIdent, stripNamespace, printType, identSpaces).Append(',');
            sb.NewLineIdentExpr(Body, uniqueExprs, lineIdent, stripNamespace, printType, identSpaces).Append(',');
            sb.NewLineIdentExpr(Filter, uniqueExprs, lineIdent, stripNamespace, printType, identSpaces);
            return sb.Append(')');
        }
    }

    public class LabelExpression : Expression
    {
        public override ExpressionType NodeType => ExpressionType.Label;
        public override Type Type => Target.Type;

        public readonly LabelTarget Target;
        public virtual Expression DefaultValue => null;

        internal LabelExpression(LabelTarget target) => Target = target;

        protected internal override Expression Accept(ExpressionVisitor visitor) => visitor.VisitLabel(this);

        internal override SysExpr CreateSysExpression(ref LiveCountArray<LightAndSysExpr> exprsConverted) =>
            DefaultValue == null
                ? SysExpr.Label(Target.ToSystemLabelTarget(ref exprsConverted))
                : SysExpr.Label(Target.ToSystemLabelTarget(ref exprsConverted), DefaultValue.ToExpression(ref exprsConverted));

        public override StringBuilder CreateExpressionString(StringBuilder sb, List<Expression> uniqueExprs,
            int lineIdent = 0, bool stripNamespace = false, Func<Type, string, string> printType = null, int identSpaces = 2)
        {
            sb.Append("Label(\"").Append(Target).Append('"');

            if (DefaultValue != null)
            {
                sb.Append(',');
                sb.NewLineIdentExpr(DefaultValue, uniqueExprs, lineIdent, stripNamespace, printType, identSpaces);
            }

            return sb.Append(')');
        }

        public override StringBuilder ToCSharpString(StringBuilder sb,
            int lineIdent = 0, bool stripNamespace = false, Func<Type, string, string> printType = null, int identSpaces = 4)
        {
            sb.NewLineIdent(lineIdent);
            Target.ToCSharpString(sb).Append(':');

            sb.NewLineIdent(lineIdent);
            if (Type == typeof(void))
                return sb.Append("return;");

            if (DefaultValue == null)
                sb.Append("return default(").Append(Type.ToCode(stripNamespace, printType)).Append(");");

            sb.Append("return ");
            DefaultValue.ToCSharpString(sb, lineIdent, stripNamespace, printType, identSpaces);
            return sb.Append(';');
        }
    }

    public sealed class WithDefaultValueLabelExpression : LabelExpression
    {
        public override Expression DefaultValue { get; }
        internal WithDefaultValueLabelExpression(LabelTarget target, Expression defaultValue) : base(target) =>
            DefaultValue = defaultValue;
    }

    public class LabelTarget
    {
        public virtual Type Type => typeof(void);
        public virtual string Name => null;

        internal System.Linq.Expressions.LabelTarget ToSystemLabelTarget(ref LiveCountArray<LightAndSysExpr> converted)
        {
            var i = converted.Count - 1;
            while (i != -1 && !ReferenceEquals(converted.Items[i].LightExpr, this)) --i;
            if (i != -1)
                return (System.Linq.Expressions.LabelTarget)converted.Items[i].SysExpr;

            var sysItem = Name == null
                ? SysExpr.Label(Type)
                : SysExpr.Label(Type, Name);

            ref var item = ref converted.PushSlot();
            item.LightExpr = this;
            item.SysExpr = sysItem;
            return sysItem;
        }

        public StringBuilder CreateExpressionString(StringBuilder sb,
            bool stripNamespace = false, Func<Type, string, string> printType = null)
        {
            sb.Append("Label(");
            sb.Append(Type.ToCode(stripNamespace, printType));
            if (Name != null)
                sb.Append(", ").Append(Name);
            sb.Append(")");
            return sb;
        }

        public StringBuilder ToCSharpString(StringBuilder sb)
        {
            if (Name == null)
            {
                if (Type == typeof(void))
                    return sb.Append("void_").Append(GetHashCode());
                return sb.Append(Type.ToCode(true, null)).Append('_').Append(GetHashCode());
            }

            return sb.Append(Name);
        }

        public override string ToString() => Type.ToCode(true, null) + Name?.ToString();
    }

    public sealed class TypedLabelTarget : LabelTarget
    {
        public override Type Type { get; }

        public TypedLabelTarget(Type type) => Type = type;
    }

    public class NamedLabelTarget : LabelTarget
    {
        public override string Name { get; }

        public NamedLabelTarget(string name) => Name = name;
    }

    public sealed class TypedNamedLabelTarget : NamedLabelTarget
    {
        public override Type Type { get; }

        public TypedNamedLabelTarget(Type type, string name) : base(name) => Type = type;
    }

    public class GotoExpression : Expression
    {
        public override ExpressionType NodeType => ExpressionType.Goto;
        public override Type Type => typeof(void);

        public virtual GotoExpressionKind Kind => GotoExpressionKind.Goto;

        public virtual Expression Value => null;
        public readonly LabelTarget Target;

        internal GotoExpression(LabelTarget target) => Target = target;

        protected internal override Expression Accept(ExpressionVisitor visitor) => visitor.VisitGoto(this);

        internal override SysExpr CreateSysExpression(ref LiveCountArray<LightAndSysExpr> exprsConverted) =>
            SysExpr.MakeGoto(Kind, Target.ToSystemLabelTarget(ref exprsConverted), Value?.ToExpression(ref exprsConverted), Type);

        public override StringBuilder CreateExpressionString(StringBuilder sb, List<Expression> uniqueExprs,
            int lineIdent = 0, bool stripNamespace = false, Func<Type, string, string> printType = null, int identSpaces = 2)
        {
            sb.Append("MakeGoto(");

            sb.Append(nameof(GotoExpressionKind)).Append('.').Append(Enum.GetName(typeof(GotoExpressionKind), Kind)).Append(',');

            sb.NewLineIdent(lineIdent).Append('"');
            Target.CreateExpressionString(sb, stripNamespace, printType).Append("\",");

            sb.NewLineIdentExpr(Value, uniqueExprs, lineIdent, stripNamespace, printType, identSpaces).Append(',');

            sb.NewLineIdent(lineIdent).AppendTypeof(Type, stripNamespace, printType);

            return sb.Append(')');
        }

        public override StringBuilder ToCSharpString(StringBuilder sb,
            int lineIdent = 0, bool stripNamespace = false, Func<Type, string, string> printType = null, int identSpaces = 4)
        {
            sb.Append("goto ");
            return Target.ToCSharpString(sb).Append(';');
        }
    }

    public class ValueGotoExpression : GotoExpression
    {
        public override Expression Value { get; }
        internal ValueGotoExpression(LabelTarget target, Expression value) : base(target) =>
            Value = value;
    }

    public class TypedGotoExpression : GotoExpression
    {
        public override Type Type { get; }
        internal TypedGotoExpression(LabelTarget target, Type type) : base(target) =>
            Type = type;
    }

    public class TypedValueGotoExpression : ValueGotoExpression
    {
        public override Type Type { get; }
        internal TypedValueGotoExpression(LabelTarget target, Expression value, Type type) : base(target, value) =>
            Type = type;
    }

    public sealed class ReturnGotoExpression : GotoExpression
    {
        public override GotoExpressionKind Kind => GotoExpressionKind.Return;
        internal ReturnGotoExpression(LabelTarget target) : base(target) { }
    }

    public sealed class ReturnTypedGotoExpression : TypedGotoExpression
    {
        public override GotoExpressionKind Kind => GotoExpressionKind.Return;
        internal ReturnTypedGotoExpression(LabelTarget target, Type type) : base(target, type) { }
    }

    public sealed class ReturnValueGotoExpression : ValueGotoExpression
    {
        public override GotoExpressionKind Kind => GotoExpressionKind.Return;
        internal ReturnValueGotoExpression(LabelTarget target, Expression value) : base(target, value) { }
    }

    public sealed class ReturnTypedValueGotoExpression : TypedValueGotoExpression
    {
        public override GotoExpressionKind Kind => GotoExpressionKind.Return;
        internal ReturnTypedValueGotoExpression(LabelTarget target, Expression value, Type type) : base(target, value, type) { }
    }

    public sealed class BreakGotoExpression : GotoExpression
    {
        public override GotoExpressionKind Kind => GotoExpressionKind.Break;
        internal BreakGotoExpression(LabelTarget target) : base(target) { }
    }

    public sealed class BreakValueGotoExpression : ValueGotoExpression
    {
        public override GotoExpressionKind Kind => GotoExpressionKind.Break;
        internal BreakValueGotoExpression(LabelTarget target, Expression value) : base(target, value) { }
    }

    public sealed class BreakTypedGotoExpression : TypedGotoExpression
    {
        public override GotoExpressionKind Kind => GotoExpressionKind.Break;
        internal BreakTypedGotoExpression(LabelTarget target, Type type) : base(target, type) { }
    }

    public sealed class BreakTypedValueGotoExpression : TypedValueGotoExpression
    {
        public override GotoExpressionKind Kind => GotoExpressionKind.Break;
        internal BreakTypedValueGotoExpression(LabelTarget target, Expression value, Type type) : base(target, value, type) { }
    }

    public sealed class ContinueGotoExpression : GotoExpression
    {
        public override GotoExpressionKind Kind => GotoExpressionKind.Continue;
        internal ContinueGotoExpression(LabelTarget target) : base(target) { }
    }

    public sealed class ContinueTypedGotoExpression : TypedGotoExpression
    {
        public override GotoExpressionKind Kind => GotoExpressionKind.Continue;
        internal ContinueTypedGotoExpression(LabelTarget target, Type type) : base(target, type) { }
    }

    public struct SwitchCase
    {
        public readonly IReadOnlyList<Expression> TestValues;
        public readonly Expression Body;

        public SwitchCase(Expression body, IEnumerable<Expression> testValues)
        {
            Body = body;
            TestValues = testValues.AsReadOnlyList();
        }

        internal StringBuilder CreateExpressionCodeString(StringBuilder sb, List<Expression> uniqueExprs,
            int lineIdent, bool stripNamespace, Func<Type, string, string> printType, int identSpaces)
        {
            sb.Append("SwitchCase(");
            sb.NewLineIdentExpr(Body, uniqueExprs, lineIdent, stripNamespace, printType, identSpaces).Append(',');
            sb.NewLineIdentExprs(TestValues, uniqueExprs, lineIdent, stripNamespace, printType, identSpaces);
            return sb.Append(')');
        }

        public override bool Equals(object obj) =>
            obj is SwitchCase other && other.Body == Body && ReferenceEquals(other.TestValues, TestValues);

        public override int GetHashCode() => HashCombiner.Combine(Body, TestValues).GetHashCode();
    }

    internal static class HashCombiner
    {
        public static int Combine<T1, T2>(T1 a, T2 b) =>
            Combine(a?.GetHashCode() ?? 0, b?.GetHashCode() ?? 0);

        public static int Combine(int h1, int h2)
        {
            if (h1 == 0) return h2;
            unchecked
            {
                return (h1 << 5) + h1 ^ h2;
            }
        }
    }

    public class SwitchExpression : Expression
    {
        public override ExpressionType NodeType { get; }
        public override Type Type { get; }

        public readonly Expression SwitchValue;
        public IReadOnlyList<SwitchCase> Cases => _cases;
        private readonly SwitchCase[] _cases;
        public readonly Expression DefaultBody;
        public readonly MethodInfo Comparison;

        public SwitchExpression(Type type, Expression switchValue, Expression defaultBody, MethodInfo comparison, SwitchCase[] cases)
        {
            NodeType = ExpressionType.Switch;
            Type = type;
            SwitchValue = switchValue;
            DefaultBody = defaultBody;
            Comparison = comparison;
            _cases = cases;
        }

        protected internal override Expression Accept(ExpressionVisitor visitor) => visitor.VisitSwitch(this);

        internal override SysExpr CreateSysExpression(ref LiveCountArray<LightAndSysExpr> exprsConverted) =>
            SysExpr.Switch(SwitchValue.ToExpression(ref exprsConverted),
                DefaultBody.ToExpression(ref exprsConverted), Comparison,
                ToSwitchCaseExpressions(_cases, ref exprsConverted));

        public override StringBuilder CreateExpressionString(StringBuilder sb, List<Expression> uniqueExprs,
            int lineIdent = 0, bool stripNamespace = false, Func<Type, string, string> printType = null, int identSpaces = 2)
        {
            sb.Append("Switch(");
            sb.NewLineIdentExpr(SwitchValue, uniqueExprs, lineIdent, stripNamespace, printType, identSpaces).Append(',');
            sb.NewLineIdentExpr(DefaultBody, uniqueExprs, lineIdent, stripNamespace, printType, identSpaces).Append(',');
            sb.NewLineIdent(lineIdent).AppendMethod(Comparison, stripNamespace, printType);
            CreateExpressionCodeString(_cases, sb, uniqueExprs, lineIdent, stripNamespace, printType, identSpaces);
            return sb.Append(')');
        }

        internal static StringBuilder CreateExpressionCodeString(IReadOnlyList<SwitchCase> items, StringBuilder sb, List<Expression> uniqueExprs,
            int lineIdent, bool stripNamespace, Func<Type, string, string> printType, int identSpaces)
        {
            if (items.Count == 0)
                return sb.Append("new SwitchCase[0]");

            for (var i = 0; i < items.Count; i++)
            {
                if (i > 0)
                    sb.Append(',');
                sb.NewLineIdent(lineIdent);
                items[i].CreateExpressionCodeString(sb, uniqueExprs, lineIdent, stripNamespace, printType, identSpaces);
            }

            return sb;
        }

        internal static System.Linq.Expressions.SwitchCase ToSwitchCase(ref SwitchCase sw, ref LiveCountArray<LightAndSysExpr> exprsConverted) =>
            SysExpr.SwitchCase(sw.Body.ToExpression(ref exprsConverted), ToExpressions(sw.TestValues, ref exprsConverted));

        internal static System.Linq.Expressions.SwitchCase[] ToSwitchCaseExpressions(
            SwitchCase[] switchCases, ref LiveCountArray<LightAndSysExpr> exprsConverted)
        {
            if (switchCases.Length == 0)
                return Tools.Empty<System.Linq.Expressions.SwitchCase>();

            var result = new System.Linq.Expressions.SwitchCase[switchCases.Length];
            for (var i = 0; i < result.Length; ++i)
                result[i] = ToSwitchCase(ref switchCases[i], ref exprsConverted);
            return result;
        }

        // todo: @incomplete impelement
        // public override StringBuilder ToCSharpString(StringBuilder sb,
        //     int lineIdent = 0, bool stripNamespace = false, Func<Type, string, string> printType = null, int identSpaces = 4)
    }

    public class LambdaExpression : Expression
    {
        public override ExpressionType NodeType => ExpressionType.Lambda;
        public override Type Type { get; }
        public readonly Expression Body;
        public virtual Type ReturnType => Body.Type;
        public virtual IReadOnlyList<ParameterExpression> Parameters => Tools.Empty<ParameterExpression>();

        internal LambdaExpression(Type delegateType, Expression body)
        {
            Type = delegateType;
            Body = body;
        }

        protected internal override Expression Accept(ExpressionVisitor visitor) => visitor.VisitLambda(this);

        public System.Linq.Expressions.LambdaExpression ToLambdaExpression() =>
            (System.Linq.Expressions.LambdaExpression)ToExpression();

        internal override SysExpr CreateSysExpression(ref LiveCountArray<LightAndSysExpr> exprsConverted) =>
            SysExpr.Lambda(Type, Body.ToExpression(ref exprsConverted), ParameterExpression.ToParameterExpressions(Parameters, ref exprsConverted));

        public override StringBuilder CreateExpressionString(StringBuilder sb, List<Expression> uniqueExprs,
            int lineIdent = 0, bool stripNamespace = false, Func<Type, string, string> printType = null, int identSpaces = 2)
        {
            sb.Append("Lambda(/*$*/"); // bookmark the lambdas - $ means it casts something
            sb.NewLineIdent(lineIdent).AppendTypeof(Type, stripNamespace, printType).Append(',');
            sb.NewLineIdentExpr(Body, uniqueExprs, lineIdent, stripNamespace, printType, identSpaces).Append(',');
            sb.NewLineIdentExprs(Parameters, uniqueExprs, lineIdent, stripNamespace, printType, identSpaces);
            return sb.Append(')');
        }

        public override StringBuilder ToCSharpString(StringBuilder sb,
            int lineIdent = 0, bool stripNamespace = false, Func<Type, string, string> printType = null, int identSpaces = 4)
        {
            // The Type of delegate is put into comment because sometime doing `new` or cast to delegate type
            // is not valid like in issue #237: 
            // `new DeserializerDlg<Word>(ref ReadOnlySequence<Byte> input, Word value, out Int64 bytesRead) => {...};`
            // and the cast is invalid too:
            // `(DeserializerDlg<Word>)(ref ReadOnlySequence<Byte> input, Word value, out Int64 bytesRead) => {...};`
            // 
            // The valid thing is:
            // DeserializerDlg<Word> d = (ref ReadOnlySequence<Byte> input, Word value, out Int64 bytesRead) => {...};
            // 
            sb.Append("/*").Append(Type.ToCode(stripNamespace, printType)).Append("*/(");
            if (Parameters.Count > 0)
            {
                var pars = Type.FindDelegateInvokeMethod().GetParameters();

                for (var i = 0; i < Parameters.Count; i++)
                {
                    if (i > 0)
                        sb.Append(", ");
                    var pe = Parameters[i];
                    var p = pars[i];
                    if (pe.IsByRef)
                        sb.Append(p.IsOut ? "out " : p.IsIn ? "in " : "ref ");
                    sb.Append(pe.Type.ToCode(stripNamespace, printType)).Append(' ');
                    sb.Append(pe.Name == null ? "@p" + i : pe.Name);
                }
            }

            sb.Append(") => ");
            if (ReturnType != typeof(void) &&
                Body is BlockExpression == false)
                sb.NewLineIdentCs(Body, lineIdent, stripNamespace, printType);
            else
            {
                sb.NewLine(lineIdent, identSpaces).Append('{');

                // Body handles ident and `;` itself
                if (Body is BlockExpression)
                    Body.ToCSharpString(sb, lineIdent, stripNamespace, printType, identSpaces);
                else
                    sb.NewLineIdentCs(Body, lineIdent, stripNamespace, printType).Append(';');

                sb.NewLine(lineIdent, identSpaces).Append('}');
            }

            return sb;
        }
    }

    public class TypedReturnLambdaExpression : LambdaExpression
    {
        public override Type ReturnType { get; }

        internal TypedReturnLambdaExpression(Type delegateType, Expression body, Type returnType) : base(delegateType, body) =>
            ReturnType = returnType;
    }

    public sealed class ManyParametersLambdaExpression : LambdaExpression
    {
        public override IReadOnlyList<ParameterExpression> Parameters { get; }

        internal ManyParametersLambdaExpression(Type delegateType, Expression body, IReadOnlyList<ParameterExpression> parameters)
            : base(delegateType, body) =>
            Parameters = parameters;
    }

    public sealed class ManyParametersTypedReturnLambdaExpression : TypedReturnLambdaExpression
    {
        public override IReadOnlyList<ParameterExpression> Parameters { get; }

        internal ManyParametersTypedReturnLambdaExpression(Type delegateType, Expression body, IReadOnlyList<ParameterExpression> parameters, Type returnType)
            : base(delegateType, body, returnType) =>
            Parameters = parameters;
    }

    public class Expression<TDelegate> : LambdaExpression where TDelegate : System.Delegate
    {
        internal Expression(Expression body) : base(typeof(TDelegate), body) { }

        protected internal override Expression Accept(ExpressionVisitor visitor) => visitor.VisitLambda(this);

        public new System.Linq.Expressions.Expression<TDelegate> ToLambdaExpression()
        {
            var exprsConverted = new LiveCountArray<LightAndSysExpr>(Tools.Empty<LightAndSysExpr>());
            return SysExpr.Lambda<TDelegate>(Body.ToExpression(ref exprsConverted),
                ParameterExpression.ToParameterExpressions(Parameters, ref exprsConverted));
        }
    }

    public class TypedReturnExpression<TDelegate> : Expression<TDelegate> where TDelegate : System.Delegate
    {
        public override Type ReturnType { get; }
        internal TypedReturnExpression(Expression body, Type returnType) : base(body) =>
            ReturnType = returnType;

        protected internal override Expression Accept(ExpressionVisitor visitor) => visitor.VisitLambda(this);

        public new System.Linq.Expressions.Expression<TDelegate> ToLambdaExpression()
        {
            var exprsConverted = new LiveCountArray<LightAndSysExpr>(Tools.Empty<LightAndSysExpr>());
            return SysExpr.Lambda<TDelegate>(Body.ToExpression(ref exprsConverted),
                ParameterExpression.ToParameterExpressions(Parameters, ref exprsConverted));
        }
    }

    public sealed class ManyParametersExpression<TDelegate> : Expression<TDelegate> where TDelegate : System.Delegate
    {
        public override IReadOnlyList<ParameterExpression> Parameters { get; }

        internal ManyParametersExpression(Expression body, IReadOnlyList<ParameterExpression> parameters) : base(body) =>
            Parameters = parameters;
    }

    public sealed class ManyParametersTypedReturnExpression<TDelegate> : TypedReturnExpression<TDelegate> where TDelegate : System.Delegate
    {
        public override IReadOnlyList<ParameterExpression> Parameters { get; }

        internal ManyParametersTypedReturnExpression(Expression body, IReadOnlyList<ParameterExpression> parameters, Type returnType)
            : base(body, returnType) =>
            Parameters = parameters;
    }

    // todo: @feature is not supported
    public sealed class DynamicExpression : Expression
    {
        public override ExpressionType NodeType => ExpressionType.Dynamic;
        public override Type Type => typeof(object);

        public Type DelegateType { get; }
        public CallSiteBinder Binder { get; }
        public IReadOnlyList<Expression> Arguments { get; }

        public DynamicExpression(Type delegateType, CallSiteBinder binder, IReadOnlyList<Expression> arguments)
        {
            DelegateType = delegateType;
            Binder = binder;
            Arguments = arguments;
        }

        internal override SysExpr CreateSysExpression(ref LiveCountArray<LightAndSysExpr> exprsConverted) =>
            SysExpr.MakeDynamic(DelegateType, Binder, ToExpressions(Arguments, ref exprsConverted));

        protected internal override Expression Accept(ExpressionVisitor visitor) => visitor.VisitDynamic(this);

        // todo: @incomplete implement the bare minimum
        public override StringBuilder CreateExpressionString(StringBuilder sb, List<Expression> uniqueExprs,
            int lineIdent = 0, bool stripNamespace = false, Func<Type, string, string> printType = null, int identSpaces = 2)
        {
            return null;
        }
    }

    // todo: @feature is not supported
    public sealed class RuntimeVariablesExpression : Expression
    {
        public sealed override ExpressionType NodeType => ExpressionType.RuntimeVariables;
        public sealed override Type Type => typeof(IRuntimeVariables);
        public readonly IReadOnlyList<ParameterExpression> Variables;
        internal RuntimeVariablesExpression(IReadOnlyList<ParameterExpression> variables) =>
            Variables = variables;
 
        protected internal override Expression Accept(ExpressionVisitor visitor) => visitor.VisitRuntimeVariables(this);

        internal override SysExpr CreateSysExpression(ref LiveCountArray<LightAndSysExpr> convertedExpressions) =>
            SysExpr.RuntimeVariables(ParameterExpression.ToParameterExpressions(Variables, ref convertedExpressions));

        // todo: @incomplete implement the bare minimum
        public override StringBuilder CreateExpressionString(StringBuilder sb, List<Expression> uniqueExprs,
            int lineIdent = 0, bool stripNamespace = false, Func<Type, string, string> printType = null, int identSpaces = 2)
        {
            return null;
        }
    }

    public class SymbolDocumentInfo
    {
        internal SymbolDocumentInfo(string fileName) => FileName = fileName;

        public string FileName { get; }
        public virtual Guid Language => Guid.Empty;
        public virtual Guid LanguageVendor => Guid.Empty;
        internal static readonly Guid DocumentType_Text = new Guid(0x5a869d0b, 0x6611, 0x11d3, 0xbd, 0x2a, 0, 0, 0xf8, 8, 0x49, 0xbd);

        public virtual Guid DocumentType => DocumentType_Text;
    }

    // todo: @feature is not supported
    /// <summary>
    /// Emits or clears a sequence point for debug information.
    ///
    /// This allows the debugger to highlight the correct source code when
    /// debugging.
    /// </summary>
    public class DebugInfoExpression : Expression
    {
        public sealed override ExpressionType NodeType => ExpressionType.DebugInfo;
        public sealed override Type Type => typeof(void);
        public readonly SymbolDocumentInfo Document;
        public virtual int StartLine { get; }
        public virtual int StartColumn { get; }
        public virtual int EndLine { get; }
        public virtual int EndColumn { get; }
        public virtual bool IsClear => false;
        
        internal DebugInfoExpression(SymbolDocumentInfo document,
            int startLine, int startColumn, int endLine, int endColumn) 
        {
             Document = document;
             StartLine = startLine;
             StartColumn = startColumn;
             EndLine = endLine;
             EndColumn = endColumn;
        }

        protected internal override Expression Accept(ExpressionVisitor visitor) => visitor.VisitDebugInfo(this);

        internal override SysExpr CreateSysExpression(ref LiveCountArray<LightAndSysExpr> convertedExpressions) =>
            SysExpr.DebugInfo(SysExpr.SymbolDocument(Document.FileName), 
                StartLine, StartColumn, EndLine, EndColumn);

        // todo: @incomplete
        public override StringBuilder CreateExpressionString(StringBuilder sb, List<Expression> uniqueExprs, 
            int lineIdent = 0, bool stripNamespace = false, Func<Type, string, string> printType = null, int identSpaces = 2)
        {
            throw new NotImplementedException();
        }
    }
}

//#endif