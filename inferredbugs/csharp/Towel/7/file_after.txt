//------------------------------------------------------------------------------
// <auto-generated>
//	  This code was generated from the "Omnitree.tt" T4 Text Template.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using Towel.Mathematics;
using System.Numerics;

namespace Towel.DataStructures
{
    #region Notes

    // Visualizations--------------------------------------------------
    //
    // 1 Dimensional:
    //
    //  -1D |-----------|-----------| +1D
    //
    //       <--- 0 ---> <--- 1 --->
    //
    // 2 Dimensional:
    //       _____________________
    //      |          |          |  +2D
    //      |          |          |   ^
    //      |     2    |     3    |   |
    //      |          |          |   |
    //      |----------|----------|   |
    //      |          |          |   |
    //      |          |          |   |
    //      |     0    |     1    |   |
    //      |          |          |   v
    //      |__________|__________|  -2D
    //
    //       -1D <-----------> +1D 
    //
    // 3 Dimensional:
    //
    //            +3D     _____________________
    //           7       /         /          /|
    //          /       /    6    /     7    / |
    //         /       /---------/----------/  |
    //        /       /    2    /     3    /|  |
    //       L       /_________/__________/ |  |
    //    -3D       |          |          | | /|          +2D
    //              |          |          | |/ |           ^
    //              |     2    |     3    | /  |           |
    //              |          |          |/|  | <-- 5     |
    //              |----------|----------| |  |           |
    //              |          |          | |  /           |
    //              |          |          | | /            |
    //              |     0    |     1    | |/             |
    //              |          |          | /              v
    //              |__________|__________|/              -2D
    //	         
    //                   ^
    //                   |
    //                   4 (behind 0)
    //
    //               -1D <-----------> +1D
    //
    // Functionality------------------------------------------------------
    //
    // Load Variables:
    //
    // There are 2 load variables: 1) items-per-leaf and 2) tree-depth. These are
    // recomputed after additions and removals.
    //
    //   1) items-per-leaf
    //
    //      DESCRIPTION: indicates how many items can be placed in a leaf before a
    //      tree expansion should occur
    //
    //      EXAMPLE: if the current items-per-leaf value is 7 but we just added 8 
    //      items to a leaf, that leaf must become a branch and its contents must
    //      be divided up into new leaves of the new branch
    //
    //   2) tree-depth
    //
    //      DESCRIPTION: indicates the currently allowed tree depth preventing
    //      tree expansion when it would actually harm the structures algorithms
    //
    //      EXAMPLE: a leaf's count went over the items-per-leaf, but the tree is
    //      already incredibly imbalanced because we are at the currently allowed
    //      tree-depth, thus expansion does not occur; this often happens when the
    //      tree contains multiples of the same value

    #endregion

	/// <summary>Contains the necessary type definitions for the various omnitree types.</summary>
    public static partial class Omnitree
    {
        #region Spacial Types (Bound, Vector, Bounds), Location/Bounding Delegates, And Dimensional Helper Methods


        #region 1 Dimensional

        public struct Vector<A1>
        {
            internal A1 _axis1;

            /// <summary>The value along axis 1.</summary>
            public A1 Axis1 { get { return this._axis1; } }

            /// <summary>Returns a vector with defaulted values.</summary>
            public static Vector<A1> Default
            {
                get { return new Vector<A1>(default(A1)); }
            }

            /// <summary>A location along each axis.</summary>
            /// <param name="axis1">The location along axis 1.</param>
            public Vector(A1 axis1)
            {
                this._axis1 = axis1;
            }
        }

        public struct Bounds<A1>
        {
            Bound<A1> _min1, _max1;

            public Bound<A1> Min1 { get { return this._min1; } }
            public Bound<A1> Max1 { get { return this._max1; } }

            /// <summary>Extends infinitely along each axis.</summary>
            public static Bounds<A1> None
            {
                get
                {
                    return new Bounds<A1>(
                        Bound<A1>.None, Bound<A1>.None);
                }
            }
            
            /// <summary>A set of values denoting a range (or lack of range) along each axis.</summary>
            public Bounds(
                Bound<A1> min1, Bound<A1> max1)
            {
                this._min1 = min1;
                this._max1 = max1;
            }
        }

        public delegate void Location<T, A1>(T element, out A1 axis1);

        public delegate void GetBounds<T, A1>(T element, out Bound<A1> min1, out Bound<A1> max1);

		public delegate void GetBoundings<T, A1>(T element, out A1 min1, out A1 max1);

		internal static GetBounds<T, A1> ConvertToGetBounds<T, A1>(GetBoundings<T, A1> getBoundings)
		{
			return (T item,
				out Bound<A1> minBound1, out Bound<A1> maxBound1) =>
				{
					A1 min1; A1 max1;
					getBoundings(item,
						out min1, out max1);
					
					minBound1 = min1; maxBound1 = max1;
				};
		}

		
        /// <summary>Checks a node for inclusion (overlap) between two bounds.</summary>
        /// <returns>True if the spaces overlap; False if not.</returns>
        internal static bool InclusionCheck<Axis1>(Omnitree.Bounds<Axis1> a, Omnitree.Bounds<Axis1> b, Compare<Axis1> compare1)
        {
            if (a.Max1.Exists && b.Min1.Exists && compare1(a.Max1.Value, b.Min1.Value) == Comparison.Less)
                return false;
            else if (a.Min1.Exists && b.Max1.Exists && compare1(a.Min1.Value, b.Max1.Value) == Comparison.Greater)
                return false;

            return true;
        }

        /// <summary>Checks if a space encapsulates a point.</summary>
        /// <returns>True if the space encapsulates the point; False if not.</returns>
        internal static bool EncapsulationCheck<Axis1>(Omnitree.Bounds<Axis1> bounds, Omnitree.Vector<Axis1> vector, Compare<Axis1> compare1)
        {
            // if the location is not outside the bounds, it must be inside

            if (bounds.Min1.Exists && compare1(vector.Axis1, bounds.Min1.Value) == Comparison.Less)
                return false;
            else if (bounds.Max1.Exists && compare1(vector.Axis1, bounds.Max1.Value) == Comparison.Greater)
                return false;

            return true;
        }

        /// <summary>Checks if a space (left) encapsulates another space (right).</summary>
        /// <returns>True if the left space encapsulates the right; False if not.</returns>
        internal static bool EncapsulationCheck<Axis1>(Omnitree.Bounds<Axis1> a, Omnitree.Bounds<Axis1> b, Compare<Axis1> compare1)
        {
            if ((a.Min1.Exists && !b.Min1.Exists))
                return false;
			if ((a.Max1.Exists && !b.Max1.Exists))
                return false;

            if (b.Min1.Exists && a.Min1.Exists && compare1(a.Min1.Value, b.Min1.Value) != Comparison.Less)
                return false;
            if (b.Max1.Exists && a.Max1.Exists && compare1(a.Max1.Value, b.Max1.Value) != Comparison.Greater)
                return false;

            return true;
        }

        /// <summary>Checks for equality between two locations.</summary>
        /// <returns>True if equal; False if not;</returns>
        internal static bool EqualsCheck<Axis1>(Omnitree.Vector<Axis1> a, Omnitree.Vector<Axis1> b, Equate<Axis1> equate1)
        {
            if (!equate1(a.Axis1, b.Axis1))
                return false;

            return true;
        }

        #endregion


        #region 2 Dimensional

        public struct Vector<A1, A2>
        {
            internal A1 _axis1;
            internal A2 _axis2;

            /// <summary>The value along axis 1.</summary>
            public A1 Axis1 { get { return this._axis1; } }
            /// <summary>The value along axis 2.</summary>
            public A2 Axis2 { get { return this._axis2; } }

            /// <summary>Returns a vector with defaulted values.</summary>
            public static Vector<A1, A2> Default
            {
                get { return new Vector<A1, A2>(default(A1), default(A2)); }
            }

            /// <summary>A location along each axis.</summary>
            /// <param name="axis1">The location along axis 1.</param>
            /// <param name="axis2">The location along axis 2.</param>
            public Vector(A1 axis1, A2 axis2)
            {
                this._axis1 = axis1;
                this._axis2 = axis2;
            }
        }

        public struct Bounds<A1, A2>
        {
            Bound<A1> _min1, _max1;
            Bound<A2> _min2, _max2;

            public Bound<A1> Min1 { get { return this._min1; } }
            public Bound<A1> Max1 { get { return this._max1; } }
            public Bound<A2> Min2 { get { return this._min2; } }
            public Bound<A2> Max2 { get { return this._max2; } }

            /// <summary>Extends infinitely along each axis.</summary>
            public static Bounds<A1, A2> None
            {
                get
                {
                    return new Bounds<A1, A2>(
                        Bound<A1>.None, Bound<A1>.None,
                        Bound<A2>.None, Bound<A2>.None);
                }
            }
            
            /// <summary>A set of values denoting a range (or lack of range) along each axis.</summary>
            public Bounds(
                Bound<A1> min1, Bound<A1> max1,
                Bound<A2> min2, Bound<A2> max2)
            {
                this._min1 = min1;
                this._max1 = max1;
                this._min2 = min2;
                this._max2 = max2;
            }
        }

        public delegate void Location<T, A1, A2>(T element, out A1 axis1, out A2 axis2);

        public delegate void GetBounds<T, A1, A2>(T element, out Bound<A1> min1, out Bound<A1> max1, out Bound<A2> min2, out Bound<A2> max2);

		public delegate void GetBoundings<T, A1, A2>(T element, out A1 min1, out A1 max1, out A2 min2, out A2 max2);

		internal static GetBounds<T, A1, A2> ConvertToGetBounds<T, A1, A2>(GetBoundings<T, A1, A2> getBoundings)
		{
			return (T item,
				out Bound<A1> minBound1, out Bound<A1> maxBound1,
				out Bound<A2> minBound2, out Bound<A2> maxBound2) =>
				{
					A1 min1; A1 max1;
					A2 min2; A2 max2;
					getBoundings(item,
						out min1, out max1,
						out min2, out max2);
					
					minBound1 = min1; maxBound1 = max1;
					minBound2 = min2; maxBound2 = max2;
				};
		}

		
        /// <summary>Checks a node for inclusion (overlap) between two bounds.</summary>
        /// <returns>True if the spaces overlap; False if not.</returns>
        internal static bool InclusionCheck<Axis1, Axis2>(Omnitree.Bounds<Axis1, Axis2> a, Omnitree.Bounds<Axis1, Axis2> b, Compare<Axis1> compare1, Compare<Axis2> compare2)
        {
            if (a.Max1.Exists && b.Min1.Exists && compare1(a.Max1.Value, b.Min1.Value) == Comparison.Less)
                return false;
            else if (a.Min1.Exists && b.Max1.Exists && compare1(a.Min1.Value, b.Max1.Value) == Comparison.Greater)
                return false;

            if (a.Max2.Exists && b.Min2.Exists && compare2(a.Max2.Value, b.Min2.Value) == Comparison.Less)
                return false;
            else if (a.Min2.Exists && b.Max2.Exists && compare2(a.Min2.Value, b.Max2.Value) == Comparison.Greater)
                return false;

            return true;
        }

        /// <summary>Checks if a space encapsulates a point.</summary>
        /// <returns>True if the space encapsulates the point; False if not.</returns>
        internal static bool EncapsulationCheck<Axis1, Axis2>(Omnitree.Bounds<Axis1, Axis2> bounds, Omnitree.Vector<Axis1, Axis2> vector, Compare<Axis1> compare1, Compare<Axis2> compare2)
        {
            // if the location is not outside the bounds, it must be inside

            if (bounds.Min1.Exists && compare1(vector.Axis1, bounds.Min1.Value) == Comparison.Less)
                return false;
            else if (bounds.Max1.Exists && compare1(vector.Axis1, bounds.Max1.Value) == Comparison.Greater)
                return false;

            if (bounds.Min2.Exists && compare2(vector.Axis2, bounds.Min2.Value) == Comparison.Less)
                return false;
            else if (bounds.Max2.Exists && compare2(vector.Axis2, bounds.Max2.Value) == Comparison.Greater)
                return false;

            return true;
        }

        /// <summary>Checks if a space (left) encapsulates another space (right).</summary>
        /// <returns>True if the left space encapsulates the right; False if not.</returns>
        internal static bool EncapsulationCheck<Axis1, Axis2>(Omnitree.Bounds<Axis1, Axis2> a, Omnitree.Bounds<Axis1, Axis2> b, Compare<Axis1> compare1, Compare<Axis2> compare2)
        {
            if ((a.Min1.Exists && !b.Min1.Exists) || (a.Min2.Exists && !b.Min2.Exists))
                return false;
			if ((a.Max1.Exists && !b.Max1.Exists) || (a.Max2.Exists && !b.Max2.Exists))
                return false;

            if (b.Min1.Exists && a.Min1.Exists && compare1(a.Min1.Value, b.Min1.Value) != Comparison.Less)
                return false;
            if (b.Max1.Exists && a.Max1.Exists && compare1(a.Max1.Value, b.Max1.Value) != Comparison.Greater)
                return false;

            if (b.Min2.Exists && a.Min2.Exists && compare2(a.Min2.Value, b.Min2.Value) != Comparison.Less)
                return false;
            if (b.Max2.Exists && a.Max2.Exists && compare2(a.Max2.Value, b.Max2.Value) != Comparison.Greater)
                return false;

            return true;
        }

        /// <summary>Checks for equality between two locations.</summary>
        /// <returns>True if equal; False if not;</returns>
        internal static bool EqualsCheck<Axis1, Axis2>(Omnitree.Vector<Axis1, Axis2> a, Omnitree.Vector<Axis1, Axis2> b, Equate<Axis1> equate1, Equate<Axis2> equate2)
        {
            if (!equate1(a.Axis1, b.Axis1))
                return false;

            if (!equate2(a.Axis2, b.Axis2))
                return false;

            return true;
        }

        #endregion


        #region 3 Dimensional

        public struct Vector<A1, A2, A3>
        {
            internal A1 _axis1;
            internal A2 _axis2;
            internal A3 _axis3;

            /// <summary>The value along axis 1.</summary>
            public A1 Axis1 { get { return this._axis1; } }
            /// <summary>The value along axis 2.</summary>
            public A2 Axis2 { get { return this._axis2; } }
            /// <summary>The value along axis 3.</summary>
            public A3 Axis3 { get { return this._axis3; } }

            /// <summary>Returns a vector with defaulted values.</summary>
            public static Vector<A1, A2, A3> Default
            {
                get { return new Vector<A1, A2, A3>(default(A1), default(A2), default(A3)); }
            }

            /// <summary>A location along each axis.</summary>
            /// <param name="axis1">The location along axis 1.</param>
            /// <param name="axis2">The location along axis 2.</param>
            /// <param name="axis3">The location along axis 3.</param>
            public Vector(A1 axis1, A2 axis2, A3 axis3)
            {
                this._axis1 = axis1;
                this._axis2 = axis2;
                this._axis3 = axis3;
            }
        }

        public struct Bounds<A1, A2, A3>
        {
            Bound<A1> _min1, _max1;
            Bound<A2> _min2, _max2;
            Bound<A3> _min3, _max3;

            public Bound<A1> Min1 { get { return this._min1; } }
            public Bound<A1> Max1 { get { return this._max1; } }
            public Bound<A2> Min2 { get { return this._min2; } }
            public Bound<A2> Max2 { get { return this._max2; } }
            public Bound<A3> Min3 { get { return this._min3; } }
            public Bound<A3> Max3 { get { return this._max3; } }

            /// <summary>Extends infinitely along each axis.</summary>
            public static Bounds<A1, A2, A3> None
            {
                get
                {
                    return new Bounds<A1, A2, A3>(
                        Bound<A1>.None, Bound<A1>.None,
                        Bound<A2>.None, Bound<A2>.None,
                        Bound<A3>.None, Bound<A3>.None);
                }
            }
            
            /// <summary>A set of values denoting a range (or lack of range) along each axis.</summary>
            public Bounds(
                Bound<A1> min1, Bound<A1> max1,
                Bound<A2> min2, Bound<A2> max2,
                Bound<A3> min3, Bound<A3> max3)
            {
                this._min1 = min1;
                this._max1 = max1;
                this._min2 = min2;
                this._max2 = max2;
                this._min3 = min3;
                this._max3 = max3;
            }
        }

        public delegate void Location<T, A1, A2, A3>(T element, out A1 axis1, out A2 axis2, out A3 axis3);

        public delegate void GetBounds<T, A1, A2, A3>(T element, out Bound<A1> min1, out Bound<A1> max1, out Bound<A2> min2, out Bound<A2> max2, out Bound<A3> min3, out Bound<A3> max3);

		public delegate void GetBoundings<T, A1, A2, A3>(T element, out A1 min1, out A1 max1, out A2 min2, out A2 max2, out A3 min3, out A3 max3);

		internal static GetBounds<T, A1, A2, A3> ConvertToGetBounds<T, A1, A2, A3>(GetBoundings<T, A1, A2, A3> getBoundings)
		{
			return (T item,
				out Bound<A1> minBound1, out Bound<A1> maxBound1,
				out Bound<A2> minBound2, out Bound<A2> maxBound2,
				out Bound<A3> minBound3, out Bound<A3> maxBound3) =>
				{
					A1 min1; A1 max1;
					A2 min2; A2 max2;
					A3 min3; A3 max3;
					getBoundings(item,
						out min1, out max1,
						out min2, out max2,
						out min3, out max3);
					
					minBound1 = min1; maxBound1 = max1;
					minBound2 = min2; maxBound2 = max2;
					minBound3 = min3; maxBound3 = max3;
				};
		}

		
        /// <summary>Checks a node for inclusion (overlap) between two bounds.</summary>
        /// <returns>True if the spaces overlap; False if not.</returns>
        internal static bool InclusionCheck<Axis1, Axis2, Axis3>(Omnitree.Bounds<Axis1, Axis2, Axis3> a, Omnitree.Bounds<Axis1, Axis2, Axis3> b, Compare<Axis1> compare1, Compare<Axis2> compare2, Compare<Axis3> compare3)
        {
            if (a.Max1.Exists && b.Min1.Exists && compare1(a.Max1.Value, b.Min1.Value) == Comparison.Less)
                return false;
            else if (a.Min1.Exists && b.Max1.Exists && compare1(a.Min1.Value, b.Max1.Value) == Comparison.Greater)
                return false;

            if (a.Max2.Exists && b.Min2.Exists && compare2(a.Max2.Value, b.Min2.Value) == Comparison.Less)
                return false;
            else if (a.Min2.Exists && b.Max2.Exists && compare2(a.Min2.Value, b.Max2.Value) == Comparison.Greater)
                return false;

            if (a.Max3.Exists && b.Min3.Exists && compare3(a.Max3.Value, b.Min3.Value) == Comparison.Less)
                return false;
            else if (a.Min3.Exists && b.Max3.Exists && compare3(a.Min3.Value, b.Max3.Value) == Comparison.Greater)
                return false;

            return true;
        }

        /// <summary>Checks if a space encapsulates a point.</summary>
        /// <returns>True if the space encapsulates the point; False if not.</returns>
        internal static bool EncapsulationCheck<Axis1, Axis2, Axis3>(Omnitree.Bounds<Axis1, Axis2, Axis3> bounds, Omnitree.Vector<Axis1, Axis2, Axis3> vector, Compare<Axis1> compare1, Compare<Axis2> compare2, Compare<Axis3> compare3)
        {
            // if the location is not outside the bounds, it must be inside

            if (bounds.Min1.Exists && compare1(vector.Axis1, bounds.Min1.Value) == Comparison.Less)
                return false;
            else if (bounds.Max1.Exists && compare1(vector.Axis1, bounds.Max1.Value) == Comparison.Greater)
                return false;

            if (bounds.Min2.Exists && compare2(vector.Axis2, bounds.Min2.Value) == Comparison.Less)
                return false;
            else if (bounds.Max2.Exists && compare2(vector.Axis2, bounds.Max2.Value) == Comparison.Greater)
                return false;

            if (bounds.Min3.Exists && compare3(vector.Axis3, bounds.Min3.Value) == Comparison.Less)
                return false;
            else if (bounds.Max3.Exists && compare3(vector.Axis3, bounds.Max3.Value) == Comparison.Greater)
                return false;

            return true;
        }

        /// <summary>Checks if a space (left) encapsulates another space (right).</summary>
        /// <returns>True if the left space encapsulates the right; False if not.</returns>
        internal static bool EncapsulationCheck<Axis1, Axis2, Axis3>(Omnitree.Bounds<Axis1, Axis2, Axis3> a, Omnitree.Bounds<Axis1, Axis2, Axis3> b, Compare<Axis1> compare1, Compare<Axis2> compare2, Compare<Axis3> compare3)
        {
            if ((a.Min1.Exists && !b.Min1.Exists) || (a.Min2.Exists && !b.Min2.Exists) || (a.Min3.Exists && !b.Min3.Exists))
                return false;
			if ((a.Max1.Exists && !b.Max1.Exists) || (a.Max2.Exists && !b.Max2.Exists) || (a.Max3.Exists && !b.Max3.Exists))
                return false;

            if (b.Min1.Exists && a.Min1.Exists && compare1(a.Min1.Value, b.Min1.Value) != Comparison.Less)
                return false;
            if (b.Max1.Exists && a.Max1.Exists && compare1(a.Max1.Value, b.Max1.Value) != Comparison.Greater)
                return false;

            if (b.Min2.Exists && a.Min2.Exists && compare2(a.Min2.Value, b.Min2.Value) != Comparison.Less)
                return false;
            if (b.Max2.Exists && a.Max2.Exists && compare2(a.Max2.Value, b.Max2.Value) != Comparison.Greater)
                return false;

            if (b.Min3.Exists && a.Min3.Exists && compare3(a.Min3.Value, b.Min3.Value) != Comparison.Less)
                return false;
            if (b.Max3.Exists && a.Max3.Exists && compare3(a.Max3.Value, b.Max3.Value) != Comparison.Greater)
                return false;

            return true;
        }

        /// <summary>Checks for equality between two locations.</summary>
        /// <returns>True if equal; False if not;</returns>
        internal static bool EqualsCheck<Axis1, Axis2, Axis3>(Omnitree.Vector<Axis1, Axis2, Axis3> a, Omnitree.Vector<Axis1, Axis2, Axis3> b, Equate<Axis1> equate1, Equate<Axis2> equate2, Equate<Axis3> equate3)
        {
            if (!equate1(a.Axis1, b.Axis1))
                return false;

            if (!equate2(a.Axis2, b.Axis2))
                return false;

            if (!equate3(a.Axis3, b.Axis3))
                return false;

            return true;
        }

        #endregion


        #region 4 Dimensional

        public struct Vector<A1, A2, A3, A4>
        {
            internal A1 _axis1;
            internal A2 _axis2;
            internal A3 _axis3;
            internal A4 _axis4;

            /// <summary>The value along axis 1.</summary>
            public A1 Axis1 { get { return this._axis1; } }
            /// <summary>The value along axis 2.</summary>
            public A2 Axis2 { get { return this._axis2; } }
            /// <summary>The value along axis 3.</summary>
            public A3 Axis3 { get { return this._axis3; } }
            /// <summary>The value along axis 4.</summary>
            public A4 Axis4 { get { return this._axis4; } }

            /// <summary>Returns a vector with defaulted values.</summary>
            public static Vector<A1, A2, A3, A4> Default
            {
                get { return new Vector<A1, A2, A3, A4>(default(A1), default(A2), default(A3), default(A4)); }
            }

            /// <summary>A location along each axis.</summary>
            /// <param name="axis1">The location along axis 1.</param>
            /// <param name="axis2">The location along axis 2.</param>
            /// <param name="axis3">The location along axis 3.</param>
            /// <param name="axis4">The location along axis 4.</param>
            public Vector(A1 axis1, A2 axis2, A3 axis3, A4 axis4)
            {
                this._axis1 = axis1;
                this._axis2 = axis2;
                this._axis3 = axis3;
                this._axis4 = axis4;
            }
        }

        public struct Bounds<A1, A2, A3, A4>
        {
            Bound<A1> _min1, _max1;
            Bound<A2> _min2, _max2;
            Bound<A3> _min3, _max3;
            Bound<A4> _min4, _max4;

            public Bound<A1> Min1 { get { return this._min1; } }
            public Bound<A1> Max1 { get { return this._max1; } }
            public Bound<A2> Min2 { get { return this._min2; } }
            public Bound<A2> Max2 { get { return this._max2; } }
            public Bound<A3> Min3 { get { return this._min3; } }
            public Bound<A3> Max3 { get { return this._max3; } }
            public Bound<A4> Min4 { get { return this._min4; } }
            public Bound<A4> Max4 { get { return this._max4; } }

            /// <summary>Extends infinitely along each axis.</summary>
            public static Bounds<A1, A2, A3, A4> None
            {
                get
                {
                    return new Bounds<A1, A2, A3, A4>(
                        Bound<A1>.None, Bound<A1>.None,
                        Bound<A2>.None, Bound<A2>.None,
                        Bound<A3>.None, Bound<A3>.None,
                        Bound<A4>.None, Bound<A4>.None);
                }
            }
            
            /// <summary>A set of values denoting a range (or lack of range) along each axis.</summary>
            public Bounds(
                Bound<A1> min1, Bound<A1> max1,
                Bound<A2> min2, Bound<A2> max2,
                Bound<A3> min3, Bound<A3> max3,
                Bound<A4> min4, Bound<A4> max4)
            {
                this._min1 = min1;
                this._max1 = max1;
                this._min2 = min2;
                this._max2 = max2;
                this._min3 = min3;
                this._max3 = max3;
                this._min4 = min4;
                this._max4 = max4;
            }
        }

        public delegate void Location<T, A1, A2, A3, A4>(T element, out A1 axis1, out A2 axis2, out A3 axis3, out A4 axis4);

        public delegate void GetBounds<T, A1, A2, A3, A4>(T element, out Bound<A1> min1, out Bound<A1> max1, out Bound<A2> min2, out Bound<A2> max2, out Bound<A3> min3, out Bound<A3> max3, out Bound<A4> min4, out Bound<A4> max4);

		public delegate void GetBoundings<T, A1, A2, A3, A4>(T element, out A1 min1, out A1 max1, out A2 min2, out A2 max2, out A3 min3, out A3 max3, out A4 min4, out A4 max4);

		internal static GetBounds<T, A1, A2, A3, A4> ConvertToGetBounds<T, A1, A2, A3, A4>(GetBoundings<T, A1, A2, A3, A4> getBoundings)
		{
			return (T item,
				out Bound<A1> minBound1, out Bound<A1> maxBound1,
				out Bound<A2> minBound2, out Bound<A2> maxBound2,
				out Bound<A3> minBound3, out Bound<A3> maxBound3,
				out Bound<A4> minBound4, out Bound<A4> maxBound4) =>
				{
					A1 min1; A1 max1;
					A2 min2; A2 max2;
					A3 min3; A3 max3;
					A4 min4; A4 max4;
					getBoundings(item,
						out min1, out max1,
						out min2, out max2,
						out min3, out max3,
						out min4, out max4);
					
					minBound1 = min1; maxBound1 = max1;
					minBound2 = min2; maxBound2 = max2;
					minBound3 = min3; maxBound3 = max3;
					minBound4 = min4; maxBound4 = max4;
				};
		}

		
        /// <summary>Checks a node for inclusion (overlap) between two bounds.</summary>
        /// <returns>True if the spaces overlap; False if not.</returns>
        internal static bool InclusionCheck<Axis1, Axis2, Axis3, Axis4>(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4> a, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4> b, Compare<Axis1> compare1, Compare<Axis2> compare2, Compare<Axis3> compare3, Compare<Axis4> compare4)
        {
            if (a.Max1.Exists && b.Min1.Exists && compare1(a.Max1.Value, b.Min1.Value) == Comparison.Less)
                return false;
            else if (a.Min1.Exists && b.Max1.Exists && compare1(a.Min1.Value, b.Max1.Value) == Comparison.Greater)
                return false;

            if (a.Max2.Exists && b.Min2.Exists && compare2(a.Max2.Value, b.Min2.Value) == Comparison.Less)
                return false;
            else if (a.Min2.Exists && b.Max2.Exists && compare2(a.Min2.Value, b.Max2.Value) == Comparison.Greater)
                return false;

            if (a.Max3.Exists && b.Min3.Exists && compare3(a.Max3.Value, b.Min3.Value) == Comparison.Less)
                return false;
            else if (a.Min3.Exists && b.Max3.Exists && compare3(a.Min3.Value, b.Max3.Value) == Comparison.Greater)
                return false;

            if (a.Max4.Exists && b.Min4.Exists && compare4(a.Max4.Value, b.Min4.Value) == Comparison.Less)
                return false;
            else if (a.Min4.Exists && b.Max4.Exists && compare4(a.Min4.Value, b.Max4.Value) == Comparison.Greater)
                return false;

            return true;
        }

        /// <summary>Checks if a space encapsulates a point.</summary>
        /// <returns>True if the space encapsulates the point; False if not.</returns>
        internal static bool EncapsulationCheck<Axis1, Axis2, Axis3, Axis4>(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4> bounds, Omnitree.Vector<Axis1, Axis2, Axis3, Axis4> vector, Compare<Axis1> compare1, Compare<Axis2> compare2, Compare<Axis3> compare3, Compare<Axis4> compare4)
        {
            // if the location is not outside the bounds, it must be inside

            if (bounds.Min1.Exists && compare1(vector.Axis1, bounds.Min1.Value) == Comparison.Less)
                return false;
            else if (bounds.Max1.Exists && compare1(vector.Axis1, bounds.Max1.Value) == Comparison.Greater)
                return false;

            if (bounds.Min2.Exists && compare2(vector.Axis2, bounds.Min2.Value) == Comparison.Less)
                return false;
            else if (bounds.Max2.Exists && compare2(vector.Axis2, bounds.Max2.Value) == Comparison.Greater)
                return false;

            if (bounds.Min3.Exists && compare3(vector.Axis3, bounds.Min3.Value) == Comparison.Less)
                return false;
            else if (bounds.Max3.Exists && compare3(vector.Axis3, bounds.Max3.Value) == Comparison.Greater)
                return false;

            if (bounds.Min4.Exists && compare4(vector.Axis4, bounds.Min4.Value) == Comparison.Less)
                return false;
            else if (bounds.Max4.Exists && compare4(vector.Axis4, bounds.Max4.Value) == Comparison.Greater)
                return false;

            return true;
        }

        /// <summary>Checks if a space (left) encapsulates another space (right).</summary>
        /// <returns>True if the left space encapsulates the right; False if not.</returns>
        internal static bool EncapsulationCheck<Axis1, Axis2, Axis3, Axis4>(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4> a, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4> b, Compare<Axis1> compare1, Compare<Axis2> compare2, Compare<Axis3> compare3, Compare<Axis4> compare4)
        {
            if ((a.Min1.Exists && !b.Min1.Exists) || (a.Min2.Exists && !b.Min2.Exists) || (a.Min3.Exists && !b.Min3.Exists) || (a.Min4.Exists && !b.Min4.Exists))
                return false;
			if ((a.Max1.Exists && !b.Max1.Exists) || (a.Max2.Exists && !b.Max2.Exists) || (a.Max3.Exists && !b.Max3.Exists) || (a.Max4.Exists && !b.Max4.Exists))
                return false;

            if (b.Min1.Exists && a.Min1.Exists && compare1(a.Min1.Value, b.Min1.Value) != Comparison.Less)
                return false;
            if (b.Max1.Exists && a.Max1.Exists && compare1(a.Max1.Value, b.Max1.Value) != Comparison.Greater)
                return false;

            if (b.Min2.Exists && a.Min2.Exists && compare2(a.Min2.Value, b.Min2.Value) != Comparison.Less)
                return false;
            if (b.Max2.Exists && a.Max2.Exists && compare2(a.Max2.Value, b.Max2.Value) != Comparison.Greater)
                return false;

            if (b.Min3.Exists && a.Min3.Exists && compare3(a.Min3.Value, b.Min3.Value) != Comparison.Less)
                return false;
            if (b.Max3.Exists && a.Max3.Exists && compare3(a.Max3.Value, b.Max3.Value) != Comparison.Greater)
                return false;

            if (b.Min4.Exists && a.Min4.Exists && compare4(a.Min4.Value, b.Min4.Value) != Comparison.Less)
                return false;
            if (b.Max4.Exists && a.Max4.Exists && compare4(a.Max4.Value, b.Max4.Value) != Comparison.Greater)
                return false;

            return true;
        }

        /// <summary>Checks for equality between two locations.</summary>
        /// <returns>True if equal; False if not;</returns>
        internal static bool EqualsCheck<Axis1, Axis2, Axis3, Axis4>(Omnitree.Vector<Axis1, Axis2, Axis3, Axis4> a, Omnitree.Vector<Axis1, Axis2, Axis3, Axis4> b, Equate<Axis1> equate1, Equate<Axis2> equate2, Equate<Axis3> equate3, Equate<Axis4> equate4)
        {
            if (!equate1(a.Axis1, b.Axis1))
                return false;

            if (!equate2(a.Axis2, b.Axis2))
                return false;

            if (!equate3(a.Axis3, b.Axis3))
                return false;

            if (!equate4(a.Axis4, b.Axis4))
                return false;

            return true;
        }

        #endregion


        #region 5 Dimensional

        public struct Vector<A1, A2, A3, A4, A5>
        {
            internal A1 _axis1;
            internal A2 _axis2;
            internal A3 _axis3;
            internal A4 _axis4;
            internal A5 _axis5;

            /// <summary>The value along axis 1.</summary>
            public A1 Axis1 { get { return this._axis1; } }
            /// <summary>The value along axis 2.</summary>
            public A2 Axis2 { get { return this._axis2; } }
            /// <summary>The value along axis 3.</summary>
            public A3 Axis3 { get { return this._axis3; } }
            /// <summary>The value along axis 4.</summary>
            public A4 Axis4 { get { return this._axis4; } }
            /// <summary>The value along axis 5.</summary>
            public A5 Axis5 { get { return this._axis5; } }

            /// <summary>Returns a vector with defaulted values.</summary>
            public static Vector<A1, A2, A3, A4, A5> Default
            {
                get { return new Vector<A1, A2, A3, A4, A5>(default(A1), default(A2), default(A3), default(A4), default(A5)); }
            }

            /// <summary>A location along each axis.</summary>
            /// <param name="axis1">The location along axis 1.</param>
            /// <param name="axis2">The location along axis 2.</param>
            /// <param name="axis3">The location along axis 3.</param>
            /// <param name="axis4">The location along axis 4.</param>
            /// <param name="axis5">The location along axis 5.</param>
            public Vector(A1 axis1, A2 axis2, A3 axis3, A4 axis4, A5 axis5)
            {
                this._axis1 = axis1;
                this._axis2 = axis2;
                this._axis3 = axis3;
                this._axis4 = axis4;
                this._axis5 = axis5;
            }
        }

        public struct Bounds<A1, A2, A3, A4, A5>
        {
            Bound<A1> _min1, _max1;
            Bound<A2> _min2, _max2;
            Bound<A3> _min3, _max3;
            Bound<A4> _min4, _max4;
            Bound<A5> _min5, _max5;

            public Bound<A1> Min1 { get { return this._min1; } }
            public Bound<A1> Max1 { get { return this._max1; } }
            public Bound<A2> Min2 { get { return this._min2; } }
            public Bound<A2> Max2 { get { return this._max2; } }
            public Bound<A3> Min3 { get { return this._min3; } }
            public Bound<A3> Max3 { get { return this._max3; } }
            public Bound<A4> Min4 { get { return this._min4; } }
            public Bound<A4> Max4 { get { return this._max4; } }
            public Bound<A5> Min5 { get { return this._min5; } }
            public Bound<A5> Max5 { get { return this._max5; } }

            /// <summary>Extends infinitely along each axis.</summary>
            public static Bounds<A1, A2, A3, A4, A5> None
            {
                get
                {
                    return new Bounds<A1, A2, A3, A4, A5>(
                        Bound<A1>.None, Bound<A1>.None,
                        Bound<A2>.None, Bound<A2>.None,
                        Bound<A3>.None, Bound<A3>.None,
                        Bound<A4>.None, Bound<A4>.None,
                        Bound<A5>.None, Bound<A5>.None);
                }
            }
            
            /// <summary>A set of values denoting a range (or lack of range) along each axis.</summary>
            public Bounds(
                Bound<A1> min1, Bound<A1> max1,
                Bound<A2> min2, Bound<A2> max2,
                Bound<A3> min3, Bound<A3> max3,
                Bound<A4> min4, Bound<A4> max4,
                Bound<A5> min5, Bound<A5> max5)
            {
                this._min1 = min1;
                this._max1 = max1;
                this._min2 = min2;
                this._max2 = max2;
                this._min3 = min3;
                this._max3 = max3;
                this._min4 = min4;
                this._max4 = max4;
                this._min5 = min5;
                this._max5 = max5;
            }
        }

        public delegate void Location<T, A1, A2, A3, A4, A5>(T element, out A1 axis1, out A2 axis2, out A3 axis3, out A4 axis4, out A5 axis5);

        public delegate void GetBounds<T, A1, A2, A3, A4, A5>(T element, out Bound<A1> min1, out Bound<A1> max1, out Bound<A2> min2, out Bound<A2> max2, out Bound<A3> min3, out Bound<A3> max3, out Bound<A4> min4, out Bound<A4> max4, out Bound<A5> min5, out Bound<A5> max5);

		public delegate void GetBoundings<T, A1, A2, A3, A4, A5>(T element, out A1 min1, out A1 max1, out A2 min2, out A2 max2, out A3 min3, out A3 max3, out A4 min4, out A4 max4, out A5 min5, out A5 max5);

		internal static GetBounds<T, A1, A2, A3, A4, A5> ConvertToGetBounds<T, A1, A2, A3, A4, A5>(GetBoundings<T, A1, A2, A3, A4, A5> getBoundings)
		{
			return (T item,
				out Bound<A1> minBound1, out Bound<A1> maxBound1,
				out Bound<A2> minBound2, out Bound<A2> maxBound2,
				out Bound<A3> minBound3, out Bound<A3> maxBound3,
				out Bound<A4> minBound4, out Bound<A4> maxBound4,
				out Bound<A5> minBound5, out Bound<A5> maxBound5) =>
				{
					A1 min1; A1 max1;
					A2 min2; A2 max2;
					A3 min3; A3 max3;
					A4 min4; A4 max4;
					A5 min5; A5 max5;
					getBoundings(item,
						out min1, out max1,
						out min2, out max2,
						out min3, out max3,
						out min4, out max4,
						out min5, out max5);
					
					minBound1 = min1; maxBound1 = max1;
					minBound2 = min2; maxBound2 = max2;
					minBound3 = min3; maxBound3 = max3;
					minBound4 = min4; maxBound4 = max4;
					minBound5 = min5; maxBound5 = max5;
				};
		}

		
        /// <summary>Checks a node for inclusion (overlap) between two bounds.</summary>
        /// <returns>True if the spaces overlap; False if not.</returns>
        internal static bool InclusionCheck<Axis1, Axis2, Axis3, Axis4, Axis5>(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5> a, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5> b, Compare<Axis1> compare1, Compare<Axis2> compare2, Compare<Axis3> compare3, Compare<Axis4> compare4, Compare<Axis5> compare5)
        {
            if (a.Max1.Exists && b.Min1.Exists && compare1(a.Max1.Value, b.Min1.Value) == Comparison.Less)
                return false;
            else if (a.Min1.Exists && b.Max1.Exists && compare1(a.Min1.Value, b.Max1.Value) == Comparison.Greater)
                return false;

            if (a.Max2.Exists && b.Min2.Exists && compare2(a.Max2.Value, b.Min2.Value) == Comparison.Less)
                return false;
            else if (a.Min2.Exists && b.Max2.Exists && compare2(a.Min2.Value, b.Max2.Value) == Comparison.Greater)
                return false;

            if (a.Max3.Exists && b.Min3.Exists && compare3(a.Max3.Value, b.Min3.Value) == Comparison.Less)
                return false;
            else if (a.Min3.Exists && b.Max3.Exists && compare3(a.Min3.Value, b.Max3.Value) == Comparison.Greater)
                return false;

            if (a.Max4.Exists && b.Min4.Exists && compare4(a.Max4.Value, b.Min4.Value) == Comparison.Less)
                return false;
            else if (a.Min4.Exists && b.Max4.Exists && compare4(a.Min4.Value, b.Max4.Value) == Comparison.Greater)
                return false;

            if (a.Max5.Exists && b.Min5.Exists && compare5(a.Max5.Value, b.Min5.Value) == Comparison.Less)
                return false;
            else if (a.Min5.Exists && b.Max5.Exists && compare5(a.Min5.Value, b.Max5.Value) == Comparison.Greater)
                return false;

            return true;
        }

        /// <summary>Checks if a space encapsulates a point.</summary>
        /// <returns>True if the space encapsulates the point; False if not.</returns>
        internal static bool EncapsulationCheck<Axis1, Axis2, Axis3, Axis4, Axis5>(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5> bounds, Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5> vector, Compare<Axis1> compare1, Compare<Axis2> compare2, Compare<Axis3> compare3, Compare<Axis4> compare4, Compare<Axis5> compare5)
        {
            // if the location is not outside the bounds, it must be inside

            if (bounds.Min1.Exists && compare1(vector.Axis1, bounds.Min1.Value) == Comparison.Less)
                return false;
            else if (bounds.Max1.Exists && compare1(vector.Axis1, bounds.Max1.Value) == Comparison.Greater)
                return false;

            if (bounds.Min2.Exists && compare2(vector.Axis2, bounds.Min2.Value) == Comparison.Less)
                return false;
            else if (bounds.Max2.Exists && compare2(vector.Axis2, bounds.Max2.Value) == Comparison.Greater)
                return false;

            if (bounds.Min3.Exists && compare3(vector.Axis3, bounds.Min3.Value) == Comparison.Less)
                return false;
            else if (bounds.Max3.Exists && compare3(vector.Axis3, bounds.Max3.Value) == Comparison.Greater)
                return false;

            if (bounds.Min4.Exists && compare4(vector.Axis4, bounds.Min4.Value) == Comparison.Less)
                return false;
            else if (bounds.Max4.Exists && compare4(vector.Axis4, bounds.Max4.Value) == Comparison.Greater)
                return false;

            if (bounds.Min5.Exists && compare5(vector.Axis5, bounds.Min5.Value) == Comparison.Less)
                return false;
            else if (bounds.Max5.Exists && compare5(vector.Axis5, bounds.Max5.Value) == Comparison.Greater)
                return false;

            return true;
        }

        /// <summary>Checks if a space (left) encapsulates another space (right).</summary>
        /// <returns>True if the left space encapsulates the right; False if not.</returns>
        internal static bool EncapsulationCheck<Axis1, Axis2, Axis3, Axis4, Axis5>(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5> a, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5> b, Compare<Axis1> compare1, Compare<Axis2> compare2, Compare<Axis3> compare3, Compare<Axis4> compare4, Compare<Axis5> compare5)
        {
            if ((a.Min1.Exists && !b.Min1.Exists) || (a.Min2.Exists && !b.Min2.Exists) || (a.Min3.Exists && !b.Min3.Exists) || (a.Min4.Exists && !b.Min4.Exists) || (a.Min5.Exists && !b.Min5.Exists))
                return false;
			if ((a.Max1.Exists && !b.Max1.Exists) || (a.Max2.Exists && !b.Max2.Exists) || (a.Max3.Exists && !b.Max3.Exists) || (a.Max4.Exists && !b.Max4.Exists) || (a.Max5.Exists && !b.Max5.Exists))
                return false;

            if (b.Min1.Exists && a.Min1.Exists && compare1(a.Min1.Value, b.Min1.Value) != Comparison.Less)
                return false;
            if (b.Max1.Exists && a.Max1.Exists && compare1(a.Max1.Value, b.Max1.Value) != Comparison.Greater)
                return false;

            if (b.Min2.Exists && a.Min2.Exists && compare2(a.Min2.Value, b.Min2.Value) != Comparison.Less)
                return false;
            if (b.Max2.Exists && a.Max2.Exists && compare2(a.Max2.Value, b.Max2.Value) != Comparison.Greater)
                return false;

            if (b.Min3.Exists && a.Min3.Exists && compare3(a.Min3.Value, b.Min3.Value) != Comparison.Less)
                return false;
            if (b.Max3.Exists && a.Max3.Exists && compare3(a.Max3.Value, b.Max3.Value) != Comparison.Greater)
                return false;

            if (b.Min4.Exists && a.Min4.Exists && compare4(a.Min4.Value, b.Min4.Value) != Comparison.Less)
                return false;
            if (b.Max4.Exists && a.Max4.Exists && compare4(a.Max4.Value, b.Max4.Value) != Comparison.Greater)
                return false;

            if (b.Min5.Exists && a.Min5.Exists && compare5(a.Min5.Value, b.Min5.Value) != Comparison.Less)
                return false;
            if (b.Max5.Exists && a.Max5.Exists && compare5(a.Max5.Value, b.Max5.Value) != Comparison.Greater)
                return false;

            return true;
        }

        /// <summary>Checks for equality between two locations.</summary>
        /// <returns>True if equal; False if not;</returns>
        internal static bool EqualsCheck<Axis1, Axis2, Axis3, Axis4, Axis5>(Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5> a, Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5> b, Equate<Axis1> equate1, Equate<Axis2> equate2, Equate<Axis3> equate3, Equate<Axis4> equate4, Equate<Axis5> equate5)
        {
            if (!equate1(a.Axis1, b.Axis1))
                return false;

            if (!equate2(a.Axis2, b.Axis2))
                return false;

            if (!equate3(a.Axis3, b.Axis3))
                return false;

            if (!equate4(a.Axis4, b.Axis4))
                return false;

            if (!equate5(a.Axis5, b.Axis5))
                return false;

            return true;
        }

        #endregion


        #region 6 Dimensional

        public struct Vector<A1, A2, A3, A4, A5, A6>
        {
            internal A1 _axis1;
            internal A2 _axis2;
            internal A3 _axis3;
            internal A4 _axis4;
            internal A5 _axis5;
            internal A6 _axis6;

            /// <summary>The value along axis 1.</summary>
            public A1 Axis1 { get { return this._axis1; } }
            /// <summary>The value along axis 2.</summary>
            public A2 Axis2 { get { return this._axis2; } }
            /// <summary>The value along axis 3.</summary>
            public A3 Axis3 { get { return this._axis3; } }
            /// <summary>The value along axis 4.</summary>
            public A4 Axis4 { get { return this._axis4; } }
            /// <summary>The value along axis 5.</summary>
            public A5 Axis5 { get { return this._axis5; } }
            /// <summary>The value along axis 6.</summary>
            public A6 Axis6 { get { return this._axis6; } }

            /// <summary>Returns a vector with defaulted values.</summary>
            public static Vector<A1, A2, A3, A4, A5, A6> Default
            {
                get { return new Vector<A1, A2, A3, A4, A5, A6>(default(A1), default(A2), default(A3), default(A4), default(A5), default(A6)); }
            }

            /// <summary>A location along each axis.</summary>
            /// <param name="axis1">The location along axis 1.</param>
            /// <param name="axis2">The location along axis 2.</param>
            /// <param name="axis3">The location along axis 3.</param>
            /// <param name="axis4">The location along axis 4.</param>
            /// <param name="axis5">The location along axis 5.</param>
            /// <param name="axis6">The location along axis 6.</param>
            public Vector(A1 axis1, A2 axis2, A3 axis3, A4 axis4, A5 axis5, A6 axis6)
            {
                this._axis1 = axis1;
                this._axis2 = axis2;
                this._axis3 = axis3;
                this._axis4 = axis4;
                this._axis5 = axis5;
                this._axis6 = axis6;
            }
        }

        public struct Bounds<A1, A2, A3, A4, A5, A6>
        {
            Bound<A1> _min1, _max1;
            Bound<A2> _min2, _max2;
            Bound<A3> _min3, _max3;
            Bound<A4> _min4, _max4;
            Bound<A5> _min5, _max5;
            Bound<A6> _min6, _max6;

            public Bound<A1> Min1 { get { return this._min1; } }
            public Bound<A1> Max1 { get { return this._max1; } }
            public Bound<A2> Min2 { get { return this._min2; } }
            public Bound<A2> Max2 { get { return this._max2; } }
            public Bound<A3> Min3 { get { return this._min3; } }
            public Bound<A3> Max3 { get { return this._max3; } }
            public Bound<A4> Min4 { get { return this._min4; } }
            public Bound<A4> Max4 { get { return this._max4; } }
            public Bound<A5> Min5 { get { return this._min5; } }
            public Bound<A5> Max5 { get { return this._max5; } }
            public Bound<A6> Min6 { get { return this._min6; } }
            public Bound<A6> Max6 { get { return this._max6; } }

            /// <summary>Extends infinitely along each axis.</summary>
            public static Bounds<A1, A2, A3, A4, A5, A6> None
            {
                get
                {
                    return new Bounds<A1, A2, A3, A4, A5, A6>(
                        Bound<A1>.None, Bound<A1>.None,
                        Bound<A2>.None, Bound<A2>.None,
                        Bound<A3>.None, Bound<A3>.None,
                        Bound<A4>.None, Bound<A4>.None,
                        Bound<A5>.None, Bound<A5>.None,
                        Bound<A6>.None, Bound<A6>.None);
                }
            }
            
            /// <summary>A set of values denoting a range (or lack of range) along each axis.</summary>
            public Bounds(
                Bound<A1> min1, Bound<A1> max1,
                Bound<A2> min2, Bound<A2> max2,
                Bound<A3> min3, Bound<A3> max3,
                Bound<A4> min4, Bound<A4> max4,
                Bound<A5> min5, Bound<A5> max5,
                Bound<A6> min6, Bound<A6> max6)
            {
                this._min1 = min1;
                this._max1 = max1;
                this._min2 = min2;
                this._max2 = max2;
                this._min3 = min3;
                this._max3 = max3;
                this._min4 = min4;
                this._max4 = max4;
                this._min5 = min5;
                this._max5 = max5;
                this._min6 = min6;
                this._max6 = max6;
            }
        }

        public delegate void Location<T, A1, A2, A3, A4, A5, A6>(T element, out A1 axis1, out A2 axis2, out A3 axis3, out A4 axis4, out A5 axis5, out A6 axis6);

        public delegate void GetBounds<T, A1, A2, A3, A4, A5, A6>(T element, out Bound<A1> min1, out Bound<A1> max1, out Bound<A2> min2, out Bound<A2> max2, out Bound<A3> min3, out Bound<A3> max3, out Bound<A4> min4, out Bound<A4> max4, out Bound<A5> min5, out Bound<A5> max5, out Bound<A6> min6, out Bound<A6> max6);

		public delegate void GetBoundings<T, A1, A2, A3, A4, A5, A6>(T element, out A1 min1, out A1 max1, out A2 min2, out A2 max2, out A3 min3, out A3 max3, out A4 min4, out A4 max4, out A5 min5, out A5 max5, out A6 min6, out A6 max6);

		internal static GetBounds<T, A1, A2, A3, A4, A5, A6> ConvertToGetBounds<T, A1, A2, A3, A4, A5, A6>(GetBoundings<T, A1, A2, A3, A4, A5, A6> getBoundings)
		{
			return (T item,
				out Bound<A1> minBound1, out Bound<A1> maxBound1,
				out Bound<A2> minBound2, out Bound<A2> maxBound2,
				out Bound<A3> minBound3, out Bound<A3> maxBound3,
				out Bound<A4> minBound4, out Bound<A4> maxBound4,
				out Bound<A5> minBound5, out Bound<A5> maxBound5,
				out Bound<A6> minBound6, out Bound<A6> maxBound6) =>
				{
					A1 min1; A1 max1;
					A2 min2; A2 max2;
					A3 min3; A3 max3;
					A4 min4; A4 max4;
					A5 min5; A5 max5;
					A6 min6; A6 max6;
					getBoundings(item,
						out min1, out max1,
						out min2, out max2,
						out min3, out max3,
						out min4, out max4,
						out min5, out max5,
						out min6, out max6);
					
					minBound1 = min1; maxBound1 = max1;
					minBound2 = min2; maxBound2 = max2;
					minBound3 = min3; maxBound3 = max3;
					minBound4 = min4; maxBound4 = max4;
					minBound5 = min5; maxBound5 = max5;
					minBound6 = min6; maxBound6 = max6;
				};
		}

		
        /// <summary>Checks a node for inclusion (overlap) between two bounds.</summary>
        /// <returns>True if the spaces overlap; False if not.</returns>
        internal static bool InclusionCheck<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> a, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> b, Compare<Axis1> compare1, Compare<Axis2> compare2, Compare<Axis3> compare3, Compare<Axis4> compare4, Compare<Axis5> compare5, Compare<Axis6> compare6)
        {
            if (a.Max1.Exists && b.Min1.Exists && compare1(a.Max1.Value, b.Min1.Value) == Comparison.Less)
                return false;
            else if (a.Min1.Exists && b.Max1.Exists && compare1(a.Min1.Value, b.Max1.Value) == Comparison.Greater)
                return false;

            if (a.Max2.Exists && b.Min2.Exists && compare2(a.Max2.Value, b.Min2.Value) == Comparison.Less)
                return false;
            else if (a.Min2.Exists && b.Max2.Exists && compare2(a.Min2.Value, b.Max2.Value) == Comparison.Greater)
                return false;

            if (a.Max3.Exists && b.Min3.Exists && compare3(a.Max3.Value, b.Min3.Value) == Comparison.Less)
                return false;
            else if (a.Min3.Exists && b.Max3.Exists && compare3(a.Min3.Value, b.Max3.Value) == Comparison.Greater)
                return false;

            if (a.Max4.Exists && b.Min4.Exists && compare4(a.Max4.Value, b.Min4.Value) == Comparison.Less)
                return false;
            else if (a.Min4.Exists && b.Max4.Exists && compare4(a.Min4.Value, b.Max4.Value) == Comparison.Greater)
                return false;

            if (a.Max5.Exists && b.Min5.Exists && compare5(a.Max5.Value, b.Min5.Value) == Comparison.Less)
                return false;
            else if (a.Min5.Exists && b.Max5.Exists && compare5(a.Min5.Value, b.Max5.Value) == Comparison.Greater)
                return false;

            if (a.Max6.Exists && b.Min6.Exists && compare6(a.Max6.Value, b.Min6.Value) == Comparison.Less)
                return false;
            else if (a.Min6.Exists && b.Max6.Exists && compare6(a.Min6.Value, b.Max6.Value) == Comparison.Greater)
                return false;

            return true;
        }

        /// <summary>Checks if a space encapsulates a point.</summary>
        /// <returns>True if the space encapsulates the point; False if not.</returns>
        internal static bool EncapsulationCheck<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> bounds, Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> vector, Compare<Axis1> compare1, Compare<Axis2> compare2, Compare<Axis3> compare3, Compare<Axis4> compare4, Compare<Axis5> compare5, Compare<Axis6> compare6)
        {
            // if the location is not outside the bounds, it must be inside

            if (bounds.Min1.Exists && compare1(vector.Axis1, bounds.Min1.Value) == Comparison.Less)
                return false;
            else if (bounds.Max1.Exists && compare1(vector.Axis1, bounds.Max1.Value) == Comparison.Greater)
                return false;

            if (bounds.Min2.Exists && compare2(vector.Axis2, bounds.Min2.Value) == Comparison.Less)
                return false;
            else if (bounds.Max2.Exists && compare2(vector.Axis2, bounds.Max2.Value) == Comparison.Greater)
                return false;

            if (bounds.Min3.Exists && compare3(vector.Axis3, bounds.Min3.Value) == Comparison.Less)
                return false;
            else if (bounds.Max3.Exists && compare3(vector.Axis3, bounds.Max3.Value) == Comparison.Greater)
                return false;

            if (bounds.Min4.Exists && compare4(vector.Axis4, bounds.Min4.Value) == Comparison.Less)
                return false;
            else if (bounds.Max4.Exists && compare4(vector.Axis4, bounds.Max4.Value) == Comparison.Greater)
                return false;

            if (bounds.Min5.Exists && compare5(vector.Axis5, bounds.Min5.Value) == Comparison.Less)
                return false;
            else if (bounds.Max5.Exists && compare5(vector.Axis5, bounds.Max5.Value) == Comparison.Greater)
                return false;

            if (bounds.Min6.Exists && compare6(vector.Axis6, bounds.Min6.Value) == Comparison.Less)
                return false;
            else if (bounds.Max6.Exists && compare6(vector.Axis6, bounds.Max6.Value) == Comparison.Greater)
                return false;

            return true;
        }

        /// <summary>Checks if a space (left) encapsulates another space (right).</summary>
        /// <returns>True if the left space encapsulates the right; False if not.</returns>
        internal static bool EncapsulationCheck<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> a, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> b, Compare<Axis1> compare1, Compare<Axis2> compare2, Compare<Axis3> compare3, Compare<Axis4> compare4, Compare<Axis5> compare5, Compare<Axis6> compare6)
        {
            if ((a.Min1.Exists && !b.Min1.Exists) || (a.Min2.Exists && !b.Min2.Exists) || (a.Min3.Exists && !b.Min3.Exists) || (a.Min4.Exists && !b.Min4.Exists) || (a.Min5.Exists && !b.Min5.Exists) || (a.Min6.Exists && !b.Min6.Exists))
                return false;
			if ((a.Max1.Exists && !b.Max1.Exists) || (a.Max2.Exists && !b.Max2.Exists) || (a.Max3.Exists && !b.Max3.Exists) || (a.Max4.Exists && !b.Max4.Exists) || (a.Max5.Exists && !b.Max5.Exists) || (a.Max6.Exists && !b.Max6.Exists))
                return false;

            if (b.Min1.Exists && a.Min1.Exists && compare1(a.Min1.Value, b.Min1.Value) != Comparison.Less)
                return false;
            if (b.Max1.Exists && a.Max1.Exists && compare1(a.Max1.Value, b.Max1.Value) != Comparison.Greater)
                return false;

            if (b.Min2.Exists && a.Min2.Exists && compare2(a.Min2.Value, b.Min2.Value) != Comparison.Less)
                return false;
            if (b.Max2.Exists && a.Max2.Exists && compare2(a.Max2.Value, b.Max2.Value) != Comparison.Greater)
                return false;

            if (b.Min3.Exists && a.Min3.Exists && compare3(a.Min3.Value, b.Min3.Value) != Comparison.Less)
                return false;
            if (b.Max3.Exists && a.Max3.Exists && compare3(a.Max3.Value, b.Max3.Value) != Comparison.Greater)
                return false;

            if (b.Min4.Exists && a.Min4.Exists && compare4(a.Min4.Value, b.Min4.Value) != Comparison.Less)
                return false;
            if (b.Max4.Exists && a.Max4.Exists && compare4(a.Max4.Value, b.Max4.Value) != Comparison.Greater)
                return false;

            if (b.Min5.Exists && a.Min5.Exists && compare5(a.Min5.Value, b.Min5.Value) != Comparison.Less)
                return false;
            if (b.Max5.Exists && a.Max5.Exists && compare5(a.Max5.Value, b.Max5.Value) != Comparison.Greater)
                return false;

            if (b.Min6.Exists && a.Min6.Exists && compare6(a.Min6.Value, b.Min6.Value) != Comparison.Less)
                return false;
            if (b.Max6.Exists && a.Max6.Exists && compare6(a.Max6.Value, b.Max6.Value) != Comparison.Greater)
                return false;

            return true;
        }

        /// <summary>Checks for equality between two locations.</summary>
        /// <returns>True if equal; False if not;</returns>
        internal static bool EqualsCheck<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>(Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> a, Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> b, Equate<Axis1> equate1, Equate<Axis2> equate2, Equate<Axis3> equate3, Equate<Axis4> equate4, Equate<Axis5> equate5, Equate<Axis6> equate6)
        {
            if (!equate1(a.Axis1, b.Axis1))
                return false;

            if (!equate2(a.Axis2, b.Axis2))
                return false;

            if (!equate3(a.Axis3, b.Axis3))
                return false;

            if (!equate4(a.Axis4, b.Axis4))
                return false;

            if (!equate5(a.Axis5, b.Axis5))
                return false;

            if (!equate6(a.Axis6, b.Axis6))
                return false;

            return true;
        }

        #endregion


        #region 7 Dimensional

        public struct Vector<A1, A2, A3, A4, A5, A6, A7>
        {
            internal A1 _axis1;
            internal A2 _axis2;
            internal A3 _axis3;
            internal A4 _axis4;
            internal A5 _axis5;
            internal A6 _axis6;
            internal A7 _axis7;

            /// <summary>The value along axis 1.</summary>
            public A1 Axis1 { get { return this._axis1; } }
            /// <summary>The value along axis 2.</summary>
            public A2 Axis2 { get { return this._axis2; } }
            /// <summary>The value along axis 3.</summary>
            public A3 Axis3 { get { return this._axis3; } }
            /// <summary>The value along axis 4.</summary>
            public A4 Axis4 { get { return this._axis4; } }
            /// <summary>The value along axis 5.</summary>
            public A5 Axis5 { get { return this._axis5; } }
            /// <summary>The value along axis 6.</summary>
            public A6 Axis6 { get { return this._axis6; } }
            /// <summary>The value along axis 7.</summary>
            public A7 Axis7 { get { return this._axis7; } }

            /// <summary>Returns a vector with defaulted values.</summary>
            public static Vector<A1, A2, A3, A4, A5, A6, A7> Default
            {
                get { return new Vector<A1, A2, A3, A4, A5, A6, A7>(default(A1), default(A2), default(A3), default(A4), default(A5), default(A6), default(A7)); }
            }

            /// <summary>A location along each axis.</summary>
            /// <param name="axis1">The location along axis 1.</param>
            /// <param name="axis2">The location along axis 2.</param>
            /// <param name="axis3">The location along axis 3.</param>
            /// <param name="axis4">The location along axis 4.</param>
            /// <param name="axis5">The location along axis 5.</param>
            /// <param name="axis6">The location along axis 6.</param>
            /// <param name="axis7">The location along axis 7.</param>
            public Vector(A1 axis1, A2 axis2, A3 axis3, A4 axis4, A5 axis5, A6 axis6, A7 axis7)
            {
                this._axis1 = axis1;
                this._axis2 = axis2;
                this._axis3 = axis3;
                this._axis4 = axis4;
                this._axis5 = axis5;
                this._axis6 = axis6;
                this._axis7 = axis7;
            }
        }

        public struct Bounds<A1, A2, A3, A4, A5, A6, A7>
        {
            Bound<A1> _min1, _max1;
            Bound<A2> _min2, _max2;
            Bound<A3> _min3, _max3;
            Bound<A4> _min4, _max4;
            Bound<A5> _min5, _max5;
            Bound<A6> _min6, _max6;
            Bound<A7> _min7, _max7;

            public Bound<A1> Min1 { get { return this._min1; } }
            public Bound<A1> Max1 { get { return this._max1; } }
            public Bound<A2> Min2 { get { return this._min2; } }
            public Bound<A2> Max2 { get { return this._max2; } }
            public Bound<A3> Min3 { get { return this._min3; } }
            public Bound<A3> Max3 { get { return this._max3; } }
            public Bound<A4> Min4 { get { return this._min4; } }
            public Bound<A4> Max4 { get { return this._max4; } }
            public Bound<A5> Min5 { get { return this._min5; } }
            public Bound<A5> Max5 { get { return this._max5; } }
            public Bound<A6> Min6 { get { return this._min6; } }
            public Bound<A6> Max6 { get { return this._max6; } }
            public Bound<A7> Min7 { get { return this._min7; } }
            public Bound<A7> Max7 { get { return this._max7; } }

            /// <summary>Extends infinitely along each axis.</summary>
            public static Bounds<A1, A2, A3, A4, A5, A6, A7> None
            {
                get
                {
                    return new Bounds<A1, A2, A3, A4, A5, A6, A7>(
                        Bound<A1>.None, Bound<A1>.None,
                        Bound<A2>.None, Bound<A2>.None,
                        Bound<A3>.None, Bound<A3>.None,
                        Bound<A4>.None, Bound<A4>.None,
                        Bound<A5>.None, Bound<A5>.None,
                        Bound<A6>.None, Bound<A6>.None,
                        Bound<A7>.None, Bound<A7>.None);
                }
            }
            
            /// <summary>A set of values denoting a range (or lack of range) along each axis.</summary>
            public Bounds(
                Bound<A1> min1, Bound<A1> max1,
                Bound<A2> min2, Bound<A2> max2,
                Bound<A3> min3, Bound<A3> max3,
                Bound<A4> min4, Bound<A4> max4,
                Bound<A5> min5, Bound<A5> max5,
                Bound<A6> min6, Bound<A6> max6,
                Bound<A7> min7, Bound<A7> max7)
            {
                this._min1 = min1;
                this._max1 = max1;
                this._min2 = min2;
                this._max2 = max2;
                this._min3 = min3;
                this._max3 = max3;
                this._min4 = min4;
                this._max4 = max4;
                this._min5 = min5;
                this._max5 = max5;
                this._min6 = min6;
                this._max6 = max6;
                this._min7 = min7;
                this._max7 = max7;
            }
        }

        public delegate void Location<T, A1, A2, A3, A4, A5, A6, A7>(T element, out A1 axis1, out A2 axis2, out A3 axis3, out A4 axis4, out A5 axis5, out A6 axis6, out A7 axis7);

        public delegate void GetBounds<T, A1, A2, A3, A4, A5, A6, A7>(T element, out Bound<A1> min1, out Bound<A1> max1, out Bound<A2> min2, out Bound<A2> max2, out Bound<A3> min3, out Bound<A3> max3, out Bound<A4> min4, out Bound<A4> max4, out Bound<A5> min5, out Bound<A5> max5, out Bound<A6> min6, out Bound<A6> max6, out Bound<A7> min7, out Bound<A7> max7);

		public delegate void GetBoundings<T, A1, A2, A3, A4, A5, A6, A7>(T element, out A1 min1, out A1 max1, out A2 min2, out A2 max2, out A3 min3, out A3 max3, out A4 min4, out A4 max4, out A5 min5, out A5 max5, out A6 min6, out A6 max6, out A7 min7, out A7 max7);

		internal static GetBounds<T, A1, A2, A3, A4, A5, A6, A7> ConvertToGetBounds<T, A1, A2, A3, A4, A5, A6, A7>(GetBoundings<T, A1, A2, A3, A4, A5, A6, A7> getBoundings)
		{
			return (T item,
				out Bound<A1> minBound1, out Bound<A1> maxBound1,
				out Bound<A2> minBound2, out Bound<A2> maxBound2,
				out Bound<A3> minBound3, out Bound<A3> maxBound3,
				out Bound<A4> minBound4, out Bound<A4> maxBound4,
				out Bound<A5> minBound5, out Bound<A5> maxBound5,
				out Bound<A6> minBound6, out Bound<A6> maxBound6,
				out Bound<A7> minBound7, out Bound<A7> maxBound7) =>
				{
					A1 min1; A1 max1;
					A2 min2; A2 max2;
					A3 min3; A3 max3;
					A4 min4; A4 max4;
					A5 min5; A5 max5;
					A6 min6; A6 max6;
					A7 min7; A7 max7;
					getBoundings(item,
						out min1, out max1,
						out min2, out max2,
						out min3, out max3,
						out min4, out max4,
						out min5, out max5,
						out min6, out max6,
						out min7, out max7);
					
					minBound1 = min1; maxBound1 = max1;
					minBound2 = min2; maxBound2 = max2;
					minBound3 = min3; maxBound3 = max3;
					minBound4 = min4; maxBound4 = max4;
					minBound5 = min5; maxBound5 = max5;
					minBound6 = min6; maxBound6 = max6;
					minBound7 = min7; maxBound7 = max7;
				};
		}

		
        /// <summary>Checks a node for inclusion (overlap) between two bounds.</summary>
        /// <returns>True if the spaces overlap; False if not.</returns>
        internal static bool InclusionCheck<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> a, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> b, Compare<Axis1> compare1, Compare<Axis2> compare2, Compare<Axis3> compare3, Compare<Axis4> compare4, Compare<Axis5> compare5, Compare<Axis6> compare6, Compare<Axis7> compare7)
        {
            if (a.Max1.Exists && b.Min1.Exists && compare1(a.Max1.Value, b.Min1.Value) == Comparison.Less)
                return false;
            else if (a.Min1.Exists && b.Max1.Exists && compare1(a.Min1.Value, b.Max1.Value) == Comparison.Greater)
                return false;

            if (a.Max2.Exists && b.Min2.Exists && compare2(a.Max2.Value, b.Min2.Value) == Comparison.Less)
                return false;
            else if (a.Min2.Exists && b.Max2.Exists && compare2(a.Min2.Value, b.Max2.Value) == Comparison.Greater)
                return false;

            if (a.Max3.Exists && b.Min3.Exists && compare3(a.Max3.Value, b.Min3.Value) == Comparison.Less)
                return false;
            else if (a.Min3.Exists && b.Max3.Exists && compare3(a.Min3.Value, b.Max3.Value) == Comparison.Greater)
                return false;

            if (a.Max4.Exists && b.Min4.Exists && compare4(a.Max4.Value, b.Min4.Value) == Comparison.Less)
                return false;
            else if (a.Min4.Exists && b.Max4.Exists && compare4(a.Min4.Value, b.Max4.Value) == Comparison.Greater)
                return false;

            if (a.Max5.Exists && b.Min5.Exists && compare5(a.Max5.Value, b.Min5.Value) == Comparison.Less)
                return false;
            else if (a.Min5.Exists && b.Max5.Exists && compare5(a.Min5.Value, b.Max5.Value) == Comparison.Greater)
                return false;

            if (a.Max6.Exists && b.Min6.Exists && compare6(a.Max6.Value, b.Min6.Value) == Comparison.Less)
                return false;
            else if (a.Min6.Exists && b.Max6.Exists && compare6(a.Min6.Value, b.Max6.Value) == Comparison.Greater)
                return false;

            if (a.Max7.Exists && b.Min7.Exists && compare7(a.Max7.Value, b.Min7.Value) == Comparison.Less)
                return false;
            else if (a.Min7.Exists && b.Max7.Exists && compare7(a.Min7.Value, b.Max7.Value) == Comparison.Greater)
                return false;

            return true;
        }

        /// <summary>Checks if a space encapsulates a point.</summary>
        /// <returns>True if the space encapsulates the point; False if not.</returns>
        internal static bool EncapsulationCheck<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> bounds, Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> vector, Compare<Axis1> compare1, Compare<Axis2> compare2, Compare<Axis3> compare3, Compare<Axis4> compare4, Compare<Axis5> compare5, Compare<Axis6> compare6, Compare<Axis7> compare7)
        {
            // if the location is not outside the bounds, it must be inside

            if (bounds.Min1.Exists && compare1(vector.Axis1, bounds.Min1.Value) == Comparison.Less)
                return false;
            else if (bounds.Max1.Exists && compare1(vector.Axis1, bounds.Max1.Value) == Comparison.Greater)
                return false;

            if (bounds.Min2.Exists && compare2(vector.Axis2, bounds.Min2.Value) == Comparison.Less)
                return false;
            else if (bounds.Max2.Exists && compare2(vector.Axis2, bounds.Max2.Value) == Comparison.Greater)
                return false;

            if (bounds.Min3.Exists && compare3(vector.Axis3, bounds.Min3.Value) == Comparison.Less)
                return false;
            else if (bounds.Max3.Exists && compare3(vector.Axis3, bounds.Max3.Value) == Comparison.Greater)
                return false;

            if (bounds.Min4.Exists && compare4(vector.Axis4, bounds.Min4.Value) == Comparison.Less)
                return false;
            else if (bounds.Max4.Exists && compare4(vector.Axis4, bounds.Max4.Value) == Comparison.Greater)
                return false;

            if (bounds.Min5.Exists && compare5(vector.Axis5, bounds.Min5.Value) == Comparison.Less)
                return false;
            else if (bounds.Max5.Exists && compare5(vector.Axis5, bounds.Max5.Value) == Comparison.Greater)
                return false;

            if (bounds.Min6.Exists && compare6(vector.Axis6, bounds.Min6.Value) == Comparison.Less)
                return false;
            else if (bounds.Max6.Exists && compare6(vector.Axis6, bounds.Max6.Value) == Comparison.Greater)
                return false;

            if (bounds.Min7.Exists && compare7(vector.Axis7, bounds.Min7.Value) == Comparison.Less)
                return false;
            else if (bounds.Max7.Exists && compare7(vector.Axis7, bounds.Max7.Value) == Comparison.Greater)
                return false;

            return true;
        }

        /// <summary>Checks if a space (left) encapsulates another space (right).</summary>
        /// <returns>True if the left space encapsulates the right; False if not.</returns>
        internal static bool EncapsulationCheck<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> a, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> b, Compare<Axis1> compare1, Compare<Axis2> compare2, Compare<Axis3> compare3, Compare<Axis4> compare4, Compare<Axis5> compare5, Compare<Axis6> compare6, Compare<Axis7> compare7)
        {
            if ((a.Min1.Exists && !b.Min1.Exists) || (a.Min2.Exists && !b.Min2.Exists) || (a.Min3.Exists && !b.Min3.Exists) || (a.Min4.Exists && !b.Min4.Exists) || (a.Min5.Exists && !b.Min5.Exists) || (a.Min6.Exists && !b.Min6.Exists) || (a.Min7.Exists && !b.Min7.Exists))
                return false;
			if ((a.Max1.Exists && !b.Max1.Exists) || (a.Max2.Exists && !b.Max2.Exists) || (a.Max3.Exists && !b.Max3.Exists) || (a.Max4.Exists && !b.Max4.Exists) || (a.Max5.Exists && !b.Max5.Exists) || (a.Max6.Exists && !b.Max6.Exists) || (a.Max7.Exists && !b.Max7.Exists))
                return false;

            if (b.Min1.Exists && a.Min1.Exists && compare1(a.Min1.Value, b.Min1.Value) != Comparison.Less)
                return false;
            if (b.Max1.Exists && a.Max1.Exists && compare1(a.Max1.Value, b.Max1.Value) != Comparison.Greater)
                return false;

            if (b.Min2.Exists && a.Min2.Exists && compare2(a.Min2.Value, b.Min2.Value) != Comparison.Less)
                return false;
            if (b.Max2.Exists && a.Max2.Exists && compare2(a.Max2.Value, b.Max2.Value) != Comparison.Greater)
                return false;

            if (b.Min3.Exists && a.Min3.Exists && compare3(a.Min3.Value, b.Min3.Value) != Comparison.Less)
                return false;
            if (b.Max3.Exists && a.Max3.Exists && compare3(a.Max3.Value, b.Max3.Value) != Comparison.Greater)
                return false;

            if (b.Min4.Exists && a.Min4.Exists && compare4(a.Min4.Value, b.Min4.Value) != Comparison.Less)
                return false;
            if (b.Max4.Exists && a.Max4.Exists && compare4(a.Max4.Value, b.Max4.Value) != Comparison.Greater)
                return false;

            if (b.Min5.Exists && a.Min5.Exists && compare5(a.Min5.Value, b.Min5.Value) != Comparison.Less)
                return false;
            if (b.Max5.Exists && a.Max5.Exists && compare5(a.Max5.Value, b.Max5.Value) != Comparison.Greater)
                return false;

            if (b.Min6.Exists && a.Min6.Exists && compare6(a.Min6.Value, b.Min6.Value) != Comparison.Less)
                return false;
            if (b.Max6.Exists && a.Max6.Exists && compare6(a.Max6.Value, b.Max6.Value) != Comparison.Greater)
                return false;

            if (b.Min7.Exists && a.Min7.Exists && compare7(a.Min7.Value, b.Min7.Value) != Comparison.Less)
                return false;
            if (b.Max7.Exists && a.Max7.Exists && compare7(a.Max7.Value, b.Max7.Value) != Comparison.Greater)
                return false;

            return true;
        }

        /// <summary>Checks for equality between two locations.</summary>
        /// <returns>True if equal; False if not;</returns>
        internal static bool EqualsCheck<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>(Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> a, Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> b, Equate<Axis1> equate1, Equate<Axis2> equate2, Equate<Axis3> equate3, Equate<Axis4> equate4, Equate<Axis5> equate5, Equate<Axis6> equate6, Equate<Axis7> equate7)
        {
            if (!equate1(a.Axis1, b.Axis1))
                return false;

            if (!equate2(a.Axis2, b.Axis2))
                return false;

            if (!equate3(a.Axis3, b.Axis3))
                return false;

            if (!equate4(a.Axis4, b.Axis4))
                return false;

            if (!equate5(a.Axis5, b.Axis5))
                return false;

            if (!equate6(a.Axis6, b.Axis6))
                return false;

            if (!equate7(a.Axis7, b.Axis7))
                return false;

            return true;
        }

        #endregion

        #endregion
    }
    
    #region OmnitreePoints
    
    // NOTE: the ND version can be found int "Omnitree_ND.cs"

    #region 1 Dimensional

    public interface IOmnitreePoints<T, Axis1> : IDataStructure<T>,
            DataStructure.ICountable,
            DataStructure.IAddable<T>,
            DataStructure.IClearable,
            DataStructure.IRemovable<T>,
            DataStructure.IEquating<T>
    {
        #region Properties

        /// <summary>Steps through the values at a given location.</summary>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
        /// <returns>A Stepper of the items at the given coordinates.</returns>
        Stepper<T> this[Axis1 axis1] { get; }
        /// <summary>The number of dimensions in this tree.</summary>
        int Dimensions { get; }

        #endregion

        #region Methods

        /// <summary>Counts the number of items in a sub space.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
        /// <returns>The number of items in the provided sub space.</returns>
        int CountSubSpace(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1);

        /// <summary>Iterates through the entire tree and ensures each item is in the proper leaf.</summary>
        void Update();
        /// <summary>Iterates through the provided dimensions and ensures each item is in the proper leaf.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
        void Update(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1);

        /// <summary>Removes all the items in a given space.</summary>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
        void Remove(Axis1 axis1);
        /// <summary>Removes all the items in a given space.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
        void Remove(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1);
        /// <summary>Removes all the items in a given space where equality is met.</summary>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
        /// <param name="where">The equality constraint of the removal.</param>
        void Remove(Axis1 axis1, Predicate<T> where);
        /// <summary>Removes all the items in a given space where predicate is met.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
        /// <param name="where">The predicate constraint of the removal.</param>
        void Remove(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Predicate<T> where);

        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="step">The step function to perform on all items in the tree within the given bounds.</param>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
        void Stepper(Step<T> step, Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1);
        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="step">The step function to perform on all items in the tree within the given bounds.</param>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
        StepStatus Stepper(StepBreak<T> step, Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1);
        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="step">The step function to perform on all items in the tree within the given bounds.</param>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
        void Stepper(Step<T> step, Axis1 axis1);
        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="step">The step function to perform on all items in the tree within the given bounds.</param>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
        StepStatus Stepper(StepBreak<T> function, Axis1 axis1);

        #endregion
    }

    public class OmnitreePointsLinked<T, Axis1> : IOmnitreePoints<T, Axis1>
    {
        private const int _dimensions = 1;
        internal static int _children_per_node = (int)BigInteger.Pow(2, 1);

        private Node _top;

		private int _naturalLogLower = 1; // caching the next time to calculate loads (lower count)
		private int _naturalLogUpper = -1; // caching the next time to calculate loads (upper count)
		private int _load; // ln(count); min = _defaultLoad
        private Omnitree.Location<T, Axis1> _locate;

        private bool _defaultEquate;
        private Equate<T> _equate;


        private bool _defaultEquate1;
        private Equate<Axis1> _equate1;



        private bool _defaultCompare1;
        private Compare<Axis1> _compare1;


        // allows median overriding for custom optimizations (USE AT YOUR OWN RISK)
        private Omnitree.SubdivisionOverride<T, Axis1, Omnitree.Bounds<Axis1>> _subdivisionOverride1;

        #region Nested Types

        /// <summary>Can be a leaf or a branch.</summary>
        public abstract class Node
        {
            internal Omnitree.Bounds<Axis1> _bounds;
            internal Branch _parent;
            internal int _index;
            internal int _count;

            /// <summary>The parent of this node.</summary>
            public Omnitree.Bounds<Axis1> Bounds { get { return this._bounds; } }
            /// <summary>The parent of this node.</summary>
            public Branch Parent { get { return this._parent; } }
            /// <summary>The computed child index of this node (see the "Notes" region in "Omnitree.cs" for the algorithm.</summary>
            public int Index { get { return this._index; } }
            /// <summary>The number of elements stored in this node and its children.</summary>
            public int Count { get { return this._count; } set { this._count = value; } }

            /// <summary>The depth this node is located in the Omnitree.</summary>
            public int Depth
            {
                get
                {
                    int depth = -1;
                    for (Node looper = this; looper != null; looper = looper.Parent)
                        depth++;
                    return depth;
                }
            }

            /// <summary>Constructs a node.</summary>
            /// <param name="bounds">The bounds of this node.</param>
            /// <param name="parent">The parent of this node.</param>
            /// <param name="index">The number of elements stored in this node and its children.</param>
            public Node(Omnitree.Bounds<Axis1> bounds, Branch parent, int index)
            {
                this._bounds = bounds;
                this._parent = parent;
                this._index = index;
            }

            internal Node(Node nodeToClone)
            {
                this._bounds = nodeToClone._bounds;
                this._parent = nodeToClone._parent;
                this._index = nodeToClone._index;
                this._count = nodeToClone._count;
            }

            internal abstract Node Clone();
        }

        /// <summary>A branch in the tree. Only contains nodes.</summary>
        public class Branch : Node
        {
            private Node[] _children;
            private Omnitree.Vector<Axis1> _pointOfDivision;

            public Node[] Children { get { return this._children; } set { this._children = value; } }
            public Omnitree.Vector<Axis1> PointOfDivision { get { return this._pointOfDivision; } internal set { this._pointOfDivision = value; } }
            
            /// <summary>Gets child by index.</summary>
            /// <param name="child_index">The index of the child to get.</param>
            /// <returns>The child of the given index or null if non-existent.</returns>
            public Node this[int child_index]
            {
                get
                {
                    if (this._children == null)
                        return null;
                    if (this._children.Length == OmnitreePointsLinked<T, Axis1>._children_per_node)
                        return this._children[(int)child_index];
                    foreach (Node node in this._children)
                        if (node.Index == child_index)
                            return node;
                    return null;
                }
                set
                {
                    // This error check should be unnecessary... but fuck it... might as well
                    if (value.Index != child_index)
                        throw new System.Exception("Bug in Omnitree (index/property mis-match when setting a child on a branch)");

                    // no children yet
                    if (this._children == null)
                    {
                        this._children = new Node[] { value };
                        return;
                    }
                    // max children overwrite
                    else if (this._children.Length == OmnitreePointsLinked<T, Axis1>._children_per_node)
                    {
                        this._children[(int)child_index] = value;
                        return;
                    }
                    // non-max child overwrite
                    for (int i = 0; i < this._children.Length; i++)
                        if (this._children[i].Index == child_index)
                        {
                            this._children[i] = value;
                            return;
                        }
                    // new child
                    Node[] newArray = new Node[this._children.Length + 1];
                    if (newArray.Length == OmnitreePointsLinked<T, Axis1>._children_per_node)
                    {
                        // new child resulting in a max children branch (sorting required)
                        for (int i = 0; i < this._children.Length; i++)
                        {
                            newArray[(int)this._children[i]._index] = this._children[i];
                        }
                        newArray[(int)value._index] = value;
                    }
                    else
                    {
                        // new child resulting in a non-max children branch
                        Array.Copy(this._children, newArray, this._children.Length);
                        newArray[newArray.Length - 1] = value;
                    }
                    this._children = newArray;
                }
            }

            public Branch(Omnitree.Vector<Axis1> pointOfDivision, Omnitree.Bounds<Axis1> bounds, Branch parent, int index)
                : base(bounds, parent, index)
            {
                this._pointOfDivision = pointOfDivision;
            }

            public Branch(Branch branchToClone)
                : base(branchToClone)
            {
                this._children = branchToClone._children.Clone() as Node[];
                this._pointOfDivision = branchToClone._pointOfDivision;
            }

            internal override Node Clone()
            {
                return new Branch(this);
            }
        }

        /// <summary>A branch in the tree. Only contains items.</summary>
        public class Leaf : Node
        {
            public class Node
            {
                internal T _value;
                internal Leaf.Node _next;

                public T Value { get { return _value; } set { _value = value; } }
                public Leaf.Node Next { get { return _next; } set { _next = value; } }

                public Node(T value, Leaf.Node next)
                {
                    _value = value;
                    _next = next;
                }
            }

            private Leaf.Node _head;

            public Leaf.Node Head { get { return this._head; } set { this._head = value; } }

            internal Leaf(Omnitree.Bounds<Axis1> bounds, Branch parent, int index)
                : base(bounds, parent, index)
            { }

            internal Leaf(Leaf leafToClone)
                : base(leafToClone)
            {
                this._head = new Node(leafToClone._head.Value, null);

                Node this_looper = this._head;
                Node other_looper = leafToClone._head;

                while (other_looper != null)
                {
                    this_looper.Next = new Node(other_looper.Next.Value, null);
                    this_looper = this_looper.Next;
                    other_looper = other_looper.Next;
                }
            }

            public void Add(T addition)
            {
                this._head = new Leaf.Node(addition, this._head);
                this.Count++;
            }

            internal override OmnitreePointsLinked<T, Axis1>.Node Clone()
            {
                return new Leaf(this);
            }
        }

        #endregion

        #region Constructors

        /// <summary>This constructor is for cloning purposes</summary>
        private OmnitreePointsLinked(OmnitreePointsLinked<T, Axis1> omnitree)
        {
            this._top = omnitree._top.Clone();
            this._load = omnitree._load;
            this._locate = omnitree._locate;
            this._defaultEquate = omnitree._defaultEquate;
            this._equate = omnitree._equate;

            this._defaultEquate1 = omnitree._defaultEquate1;
            this._equate1 = omnitree._equate1;

            this._defaultCompare1 = omnitree._defaultCompare1;
            this._compare1 = omnitree._compare1;

            this._subdivisionOverride1 = omnitree._subdivisionOverride1;
        }

        private OmnitreePointsLinked(
            Omnitree.Location<T, Axis1> locate,

            bool defaultEquate,
            Equate<T> equate,

            bool defaultEquate1,
            Equate<Axis1> equateAxis1,

            bool defaultCompare1,
            Compare<Axis1> compare1,

            Omnitree.SubdivisionOverride<T, Axis1, Omnitree.Bounds<Axis1>> subdivisionOverride1)
        {
			if (locate == null)
			{
				throw new ArgumentNullException(nameof(locate));
			}
			if (equate == null)
			{
				throw new ArgumentNullException(nameof(equate));
			}

			if (equateAxis1 == null)
			{
				throw new ArgumentNullException(nameof(equateAxis1));
			}

			if (compare1 == null)
			{
				throw new ArgumentNullException(nameof(compare1));
			}

            this._locate = locate;
            this._defaultEquate = defaultEquate;
            this._equate = equate;

            this._defaultEquate1 = defaultEquate1;
            this._equate1 = equateAxis1;

            this._defaultCompare1 = defaultCompare1;
            this._compare1 = compare1;

            this._subdivisionOverride1 = subdivisionOverride1;

            this._top = new Leaf(Omnitree.Bounds<Axis1>.None, null, -1);
            Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
        }

        private OmnitreePointsLinked(
            Omnitree.Location<T, Axis1> locate,
            Equate<T> equate,

            Equate<Axis1> equateAxis1,

            Compare<Axis1> compare1,

            Omnitree.SubdivisionOverride<T, Axis1, Omnitree.Bounds<Axis1>> subdivisionOverride1)
            : this(
            locate,

            false,
            equate,

            false,
            equateAxis1,

            false,
            compare1,

            subdivisionOverride1)
        { }

        public OmnitreePointsLinked(
            Omnitree.Location<T, Axis1> locate,

            Equate<T> equate,

            Equate<Axis1> equateAxis1,

            Compare<Axis1> compare1)
            : this(
                locate,

                false,
                equate,

                false,
                equateAxis1,

                false,
                compare1,

                null)
        { }



        public OmnitreePointsLinked(
            Omnitree.Location<T, Axis1> locate,

            Equate<T> equate,

            Compare<Axis1> compare1)
            : this(
                locate,
                false,
                equate,

                true,
                Towel.Equate.Default,

                false,
                compare1,

                null)
        { }

        public OmnitreePointsLinked(
            Omnitree.Location<T, Axis1> locate,
            Equate<T> equate,

            Compare<Axis1> compare1,

            Omnitree.SubdivisionOverride<T, Axis1, Omnitree.Bounds<Axis1>> subdivisionOverride1)
            : this(
                locate,

                false,
                equate,

                true,
                Towel.Equate.Default,

                false,
                compare1,

                subdivisionOverride1)
        { }

        public OmnitreePointsLinked(
            Omnitree.Location<T, Axis1> locate,

            Compare<Axis1> compare1)
            : this(
                locate,
                true,
                Towel.Equate.Default,

                true,
                Towel.Equate.Default,

                false,
                compare1,

                null)
        { }

        public OmnitreePointsLinked(
            Omnitree.Location<T, Axis1> locate,

            Compare<Axis1> compare1,

            Omnitree.SubdivisionOverride<T, Axis1, Omnitree.Bounds<Axis1>> subdivisionOverride1)
            : this(
                locate,

                true,
                Towel.Equate.Default,

                true,
                Towel.Equate.Default,

                false,
                compare1,

                subdivisionOverride1)
        { }

        public OmnitreePointsLinked(
            Omnitree.Location<T, Axis1> locate,
            Equate<T> equate)
            : this(
                locate,

                false,
                equate,

                true,
                Towel.Equate.Default,

                true,
                Compare.Default,

                null)
        { }

        public OmnitreePointsLinked(
            Omnitree.Location<T, Axis1> locate,
            Equate<T> equate,
            Omnitree.SubdivisionOverride<T, Axis1, Omnitree.Bounds<Axis1>> subdivisionOverride1)
            : this(
                locate,

                false,
                equate,

                true,
                Towel.Equate.Default,

                true,
                Compare.Default,

                subdivisionOverride1)
        { }

        public OmnitreePointsLinked(
            Omnitree.Location<T, Axis1> locate)
            : this(
                locate,

                true,
                Towel.Equate.Default,

                true,
                Towel.Equate.Default,

                true,
                Compare.Default,

                null)
        { }

        public OmnitreePointsLinked(
            Omnitree.Location<T, Axis1> locate,
            Omnitree.SubdivisionOverride<T, Axis1, Omnitree.Bounds<Axis1>> subdivisionOverride1)
            : this(
                locate,

                true,
                Towel.Equate.Default,

                true,
                Towel.Equate.Default,

                true,
                Compare.Default,

                subdivisionOverride1)
        { }

        #endregion

        #region Properties

        /// <summary>Steps through all the items at a given coordinate.</summary>
        /// <param name="axis1">The coordinate along axis 1.</param>
        /// <returns>The stepper for the items at the given coordinate.</returns>
        public Stepper<T> this[Axis1 axis1]
        {
            get
            {
                return (Step<T> step) => { this.Stepper(step, axis1); };
            }
        }

        /// <summary>The number of dimensions in this tree.</summary>
        public int Dimensions { get { return _dimensions; } }

        /// <summary>The function for equating keys in this table.</summary>
        public Equate<T> Equate { get { return this._equate; } }

        /// <summary>The location function the Omnitree is using.</summary>
        public Omnitree.Location<T, Axis1> Locate { get { return this._locate; } }


        /// <summary>The comparison function the Omnitree is using along the 1D axis.</summary>
        public Compare<Axis1> Compare1 { get { return this._compare1; } }

        /// <summary>The function for equating values along the 1D axis.</summary>
        public Equate<Axis1> EquateAxis1 { get { return this._equate1; } }

        /// <summary>The current number of items in the tree.</summary>
        public int Count { get { return this._top.Count; } }

        private delegate void MaxDepthFinder(Node node, int current_depth, ref int max_depth);
        /// <summary>Finds the current maximum depth of the tree. NOT AN O(1) OPERATION. Intended for educational purposes only.</summary>
        public int MaxDepth
        {
            get
            {
                MaxDepthFinder maxDepthFinder = null;
                maxDepthFinder =
                        (Node node, int current_depth, ref int max_depth) =>
                        {
                            if (current_depth > max_depth)
                                max_depth = current_depth;
                            if (node is Branch)
                                foreach (Node child in (node as Branch).Children)
                                    maxDepthFinder(child, current_depth + 1, ref max_depth);
                        };
                int _max_depth = -1;
                maxDepthFinder(this._top, 0, ref _max_depth);
                return _max_depth;
            }
        }

        private delegate void NodeCountFinder(Node node, ref int current_count);
        /// <summary>Counts the current number of nodes in the tree. NOT AN O(1) OPERATION. Intended for educational purposes only.</summary>
        public int NodeCount
        {
            get
            {
                NodeCountFinder nodeCountFinder = null;
                nodeCountFinder =
                        (Node node, ref int current_count) =>
                        {
                            current_count++;
                            if (node is Branch)
                                foreach (Node child in (node as Branch).Children)
                                    nodeCountFinder(child, ref current_count);
                        };

                int _current_count = 0;
                nodeCountFinder(this._top, ref _current_count);
                return _current_count;
            }
        }

        private delegate void BranchCountFinder(Node node, ref int current_count);
        /// <summary>Counts the current number of branches in the tree. NOT AN O(1) OPERATION. Intended for educational purposes only.</summary>
        public int BranchCount
        {
            get
            {
                BranchCountFinder branchCountFinder = null;
                branchCountFinder =
                        (Node node, ref int current_count) =>
                        {
                            if (node is Branch)
                            {
                                current_count++;
                                foreach (Node child in (node as Branch).Children)
                                    branchCountFinder(child, ref current_count);
                            }
                        };

                int _current_count = 0;
                branchCountFinder(this._top, ref _current_count);
                return _current_count;
            }
        }

        private delegate void LeafCountFinder(Node node, ref int current_count);
        /// <summary>Counts the current number of leaves in the tree. NOT AN O(1) OPERATION. Intended for educational purposes only.</summary>
        public int LeafCount
        {
            get
            {
                LeafCountFinder leafCountFinder = null;
                leafCountFinder =
                        (Node node, ref int current_count) =>
                        {
                            if (node is Leaf)
                                current_count++;
                            else
                                foreach (Node child in (node as Branch).Children)
                                    leafCountFinder(child, ref current_count);
                        };

                int _current_count = 0;
                leafCountFinder(this._top, ref _current_count);
                return _current_count;
            }
        }

        #endregion

        #region Methods

        #region Add

        #region Bulk

        public void Add(IndexedBigArray<T> additions, bool allowMultithreading)
        {
            if (additions.Length > int.MaxValue)
                throw new System.Exception("The maximum size of the Omnitree was exceeded during bulk addition.");

            if (this._top.Count != 0 || (int)additions.Length <= _load)
            {
                for (ulong i = 0; i < additions.Length; i++)
                    this.Add(additions[i]);
            }
            else
            {
                // adjust the loads prior to additions
				Omnitree.ComputeLoads((int)additions.Length, ref _naturalLogLower, ref _naturalLogUpper, ref _load);

                Branch new_top = new Branch(Omnitree.Vector<Axis1>.Default, Omnitree.Bounds<Axis1>.None, null, -1);
                new_top.Count = (int)additions.Length;


                // prepare data for median computations
                IndexedBigArray<Axis1> values1;
                IAsyncResult result1 = null;
                if (this._subdivisionOverride1 != null)
                    values1 = null;
                else
                {
                    values1 = null;
                    Towel.Parallels.Parallel.Operation operation = () =>
                    {
                        values1 = new IndexedBigArray<Axis1>(additions.Length);
                        for (ulong i = 0; i < additions.Length; i++)
                            values1[i] = LocateVector(additions[i]).Axis1;
                        Towel.Algorithms.Sort.Merge(this._compare1, (int i) => { return values1[(ulong)i]; }, (int i, Axis1 value) => { values1[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
                    };

                    if (allowMultithreading)
                        result1 = Towel.Parallels.Parallel.Thread(operation);
                    else
                        operation();
                }



                if (this._subdivisionOverride1 == null && allowMultithreading)
                    result1.AsyncWaitHandle.WaitOne();


                // build the tree
                Add(new_top, 1, -1, additions.Stepper(), (int)additions.Length, int.MinValue, (int)additions.Length, (int index) => { return values1[index]; }, allowMultithreading);
                
                this._top = new_top;
            }
        }

        public void Add(bool allowMultithreading, params T[] additions)
        {
            if (additions.Length > int.MaxValue)
                throw new System.Exception("The maximum size of the Omnitree was exceeded during bulk addition.");

            if (this._top.Count != 0 || (int)additions.Length <= _load)
            {
                for (int i = 0; i < additions.Length; i++)
                    this.Add(additions[i]);
            }
            else
            {
                // adjust the loads prior to additions
				Omnitree.ComputeLoads((int)additions.Length, ref _naturalLogLower, ref _naturalLogUpper, ref _load);

                Branch new_top = new Branch(Omnitree.Vector<Axis1>.Default, Omnitree.Bounds<Axis1>.None, null, -1);
                new_top.Count = (int)additions.Length;


                // prepare data for median computations
                IndexedBigArray<Axis1> values1;
                IAsyncResult result1 = null;
                if (this._subdivisionOverride1 != null)
                    values1 = null;
                else
                {
                    values1 = null;
                    Towel.Parallels.Parallel.Operation operation = () =>
                    {
                        values1 = new IndexedBigArray<Axis1>(additions.Length);
                        for (int i = 0; i < additions.Length; i++)
                            values1[i] = LocateVector(additions[i]).Axis1;
                        Towel.Algorithms.Sort.Merge(this._compare1, (int i) => { return values1[(ulong)i]; }, (int i, Axis1 value) => { values1[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
                    };

                    if (allowMultithreading)
                        result1 = Towel.Parallels.Parallel.Thread(operation);
                    else
                        operation();
                }



                if (this._subdivisionOverride1 == null && allowMultithreading)
                    result1.AsyncWaitHandle.WaitOne();


                // build the tree
                Add(new_top, 1, -1, additions.Stepper(), additions.Length, int.MinValue, (int)additions.Length, (int index) => { return values1[index]; }, allowMultithreading);
                
                this._top = new_top;
            }
        }

        
        private int Add(Branch parent, int depth, int child, Stepper<T> additions, int parent_count, int prevmed1, int initial_count, Get<Axis1> values1, bool allowMultithreading)
        {
            Axis1 pointOfDivision1;

            int median_axis1 = -1;
            if (this._subdivisionOverride1 == null)
                GetMedianIndexes(initial_count, child, depth, prevmed1, out median_axis1);

            if (this._subdivisionOverride1 != null)
                pointOfDivision1 = this._subdivisionOverride1(parent.Bounds, additions);
            else
                pointOfDivision1 = values1(median_axis1);

            parent.PointOfDivision = new Omnitree.Vector<Axis1>(pointOfDivision1);

            // divide the values along the medians
            IMap<IAddable<T>, int> collection_map = new MapHashLinked<IAddable<T>, int>();
            additions((T value) => 
            {
                int index = DetermineChildIndex(parent.PointOfDivision, LocateVector(value));
                IAddable<T> list = null;
                if (collection_map.TryGet(index, out list))
                {
                    list.Add(value);
                }
                else
                {
                    if (parent_count < 100000)
                        list = new AddableArray<T>();
                    else
                        list = new AddableLinked<T>();
                    collection_map.Add(index, list);
                    list.Add(value);
                }
            });

            if (depth == 1 && allowMultithreading)
            {
                // NOTE: Must assign placeholders before multithreading so that the threads do not overwrite each other
                collection_map.Keys((int key) => { parent[key] = new Leaf(Omnitree.Bounds<Axis1>.None, parent, key); });
                IAsyncResult[] handles = new IAsyncResult[Environment.ProcessorCount];
                for (int i = 0; i < handles.Length; i++)
                {
                    int multiTheadSafe_i = i; // used as catpure variable below making it multithread-safe
                    handles[i] = Towel.Parallels.Parallel.Thread(() =>
                    {
                        Step.EveryNth<Link<IAddable<T>, int>>(collection_map.Pairs, multiTheadSafe_i + 1)(
                        (Link<IAddable<T>, int> link) =>
                            {
                                ReversedChildBuilding(parent, link._2, depth, link._1.Stepper, link._1.Count, median_axis1, initial_count, values1, allowMultithreading);
                            });
                    });
                }
                
                foreach (IAsyncResult handle in handles)
                {
                    handle.AsyncWaitHandle.WaitOne();
                }
            }
            else
            {
                collection_map.Pairs((Link<IAddable<T>, int> link) =>
                { 
                    ReversedChildBuilding(parent, link._2, depth, link._1.Stepper, link._1.Count, median_axis1, initial_count, values1, allowMultithreading);
                });
            }

            int count = 0;
            foreach (Node node in parent.Children)
                count += node.Count;
            return count;
        }

        int ReversedChildBuilding(Branch parent, int child_index, int depth, Stepper<T> additions, int count, int prevmed1, int initial_count, Get<Axis1> values1, bool allowMultithreading)
        {
            Omnitree.Bounds<Axis1> child_bounds = DetermineChildBounds(parent, child_index);
            if (depth >= _load || count <= _load)
            {
                Leaf new_leaf = new Leaf(child_bounds, parent, child_index);
                additions((T value) => { new_leaf.Add(value); });
                parent[new_leaf.Index] = new_leaf;
                return new_leaf.Count;
            }
            else
            {
                Branch new_branch = new Branch(Omnitree.Vector<Axis1>.Default, child_bounds, parent, child_index);
                parent[new_branch.Index] = new_branch;
                new_branch.Count = Add(new_branch, depth + 1, child_index, additions, count, prevmed1, count, values1, allowMultithreading);
                return new_branch.Count;
            }
        }

        /// <summary>Gets the indeces of the median values at the given position during bulk additions.</summary>
        private void GetMedianIndexes(int count, int child_index, int depth, int previous1, out int index1)
        {
            if (depth == 1)
            {
                index1 = (count - 1) / 2;
                return;
            }

            int splits = Compute.Power(2, depth);
            int mid_child_range = count / splits;

            if (child_index >= 1)
            {
                index1 = previous1 + mid_child_range;
                child_index -= 1;
            }
            else
            {
                index1 = previous1 - mid_child_range;
            }

        }

        #endregion

        #region single

        /// <summary>Adds an item to the tree.</summary>
        /// <param name="addition">The item to be added.</param>
        public void Add(T addition)
        {
            if (this._top.Count == int.MaxValue)
                throw new System.InvalidOperationException("(Count == int.MaxValue) max Omnitree size reached (change ints to longs if you need to).");

            // dynamic tree sizes
			Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);

            Omnitree.Vector<Axis1> location = LocateVector(addition);

            // grow the first branch of the tree
            if (this._top is Leaf && (this._top as Leaf).Count >= _load)
            {
                Leaf top = this._top as Leaf;

                // create the new branch from the median values
                this._top = new Branch(DetermineMedians(top), Omnitree.Bounds<Axis1>.None, null, -1);

                // iterate through the elements and add them to the appropriate children
                for (Leaf.Node list = top.Head; list != null; list = list.Next)
                    Add(list.Value, this._top, LocateVector(list.Value), 0);
            }

            this.Add(addition, this._top, location, 0);
        }
        
        /// <summary>Recursive version of the add function.</summary>
        /// <param name="addition">The item to be added.</param>
        /// <param name="node">The current node for tree trversal.</param>
        /// <param name="ms">The location of the addition.</param>
        /// <param name="depth">The current depth of iteration.</param>
        private void Add(T addition, Node node, Omnitree.Vector<Axis1> location, int depth)
        {
            if (node is Leaf)
            {
                Leaf leaf = node as Leaf;
                if (depth >= _load || !(leaf.Count >= _load))
                {
                    leaf.Add(addition);
                    return;
                }
                else
                {
                    Branch parent = node.Parent;
                    int child_index = this.DetermineChildIndex(parent.PointOfDivision, location);
                    Branch growth = new Branch(DetermineMedians(leaf), leaf.Bounds, parent, child_index);
                    parent[child_index] = growth;
                    for (Leaf.Node list = leaf.Head; list != null; list = list.Next)
                    {
                        Omnitree.Vector<Axis1> temp_location = LocateVector(list.Value);
                        if (EncapsulationCheck(growth.Bounds, temp_location))
                            Add(list.Value, growth, temp_location, depth);
                        else
                        {
                            ReduceParentCounts(parent, 1);
                            Add(list.Value, this._top, temp_location, depth);
                        }
                    }

                    Add(addition, growth, location, depth);
                    return;
                }
            }
            else
            {
                Branch branch = node as Branch;
                int child_index = this.DetermineChildIndex(branch.PointOfDivision, location); // determine the child "index" (0 through 2^Dimensions) the addition belongs in
                Node child_node = branch[child_index];

                // null children in branches are just empty leaves
                if (child_node == null)
                {
                    Leaf new_leaf = new Leaf(DetermineChildBounds(branch, child_index), branch, child_index);
                    branch[child_index] = new_leaf;
                    new_leaf.Add(addition);
                }
                else
                    // child exists already, continue adding
                    Add(addition, child_node, location, depth + 1);

                branch.Count++;
                return;
            }
        }

        /// <summary>Determins the dimensions of the child at the given index.</summary>
        /// <param name="leaf">The parent of the node to compute dimensions for.</param>
        /// <param name="child">The index of the child to compute dimensions for.</param>
        /// <param name="median1">The computed minimum dimensions of the child node along the 1D axis.</param>
        /// <param name="median2">The computed minimum dimensions of the child node along the 2D axis.</param>
        /// <param name="median3">The computed minimum dimensions of the child node along the 3D axis.</param>
        private Omnitree.Vector<Axis1> DetermineMedians(Leaf leaf)
        {
            try
            {
                // extract the values
                Axis1[] values1 = new Axis1[leaf.Count];
                Leaf.Node for_current = leaf.Head; // used in for loop
                for (int i = 0; i < leaf.Count; i++, for_current = for_current.Next)
                    this._locate(for_current.Value, out values1[i]);
                // sort the values
                if (_defaultCompare1) Array.Sort(values1);
                else Array.Sort(values1, Compare.ToSystemComparison(this._compare1));
                // pull out the lazy medians (if even # of items... just take the left)
                int index = (leaf.Count - 1) / 2;
                return new Omnitree.Vector<Axis1>(values1[index]);
            }
            catch (Exception exception)
            {
				System.Diagnostics.Debugger.Break();
                // extract the values
                IndexedBigArray<Axis1> values1 = new IndexedBigArray<Axis1>(leaf.Count);
                Leaf.Node for_current = leaf.Head; // used in for loop
                for (int i = 0; i < leaf.Count; i++, for_current = for_current.Next)
                {
                    Axis1 value1;
                    this._locate(for_current.Value, out value1);
                    values1[i] = value1;
                }
                // sort the values
                if (_defaultCompare1) Towel.Algorithms.Sort.Merge(Compare.Default, (int sorting_index) => { return values1[sorting_index]; }, (int sorting_index, Axis1 axis1) => { values1[sorting_index] = axis1; }, 0, (int)values1.Length);
                else Towel.Algorithms.Sort.Merge(_compare1, (int sorting_index) => { return values1[sorting_index]; }, (int sorting_index, Axis1 axis1) => { values1[sorting_index] = axis1; }, 0, (int)values1.Length);
                // pull out the lazy medians (if even # of items... just take the left)
                int index = (leaf.Count - 1) / 2;
                return new Omnitree.Vector<Axis1>(values1[index]);
            }
        }

        #endregion

        #region Add Helpers

        private Omnitree.Bounds<Axis1> DetermineChildBounds(Branch branch, int child_index)
        {

            Omnitree.Bound<Axis1> min1, max1;
            if (child_index >= 1)
            {
                min1 = branch.PointOfDivision.Axis1;
                max1 = branch.Bounds.Max1;
                child_index -= 1;
            }
            else
            {
                min1 = branch.Bounds.Min1;
                max1 = branch.PointOfDivision.Axis1;
            }

            return new Omnitree.Bounds<Axis1>(min1, max1);
        }

        #endregion

        #endregion

        #region Clear

        /// <summary>Returns the tree to an empty state.</summary>
        public void Clear()
        {
            this._top = new Leaf(Omnitree.Bounds<Axis1>.None, null, -1);
			Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
        }

        #endregion

        #region Clone

        /// <summary>Creates a shallow clone of this data structure.</summary>
        /// <returns>A shallow clone of this data structure.</returns>
        public OmnitreePointsLinked<T, Axis1> Clone()
        {
            return new OmnitreePointsLinked<T, Axis1>(this);
        }

        #endregion

        #region Count

        /// <summary>Counts the number of items in a sub space.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
        /// <returns>The number of items in the provided sub space.</returns>
        public int CountSubSpace(Axis1 min1, Axis1 max1)
        {
            return CountSubSpace(_top, new Omnitree.Bounds<Axis1>(min1, max1));
        }
        /// <summary>Counts the number of items in a sub space.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
        /// <returns>The number of items in the provided sub space.</returns>
        public int CountSubSpace(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1)
        {
            return CountSubSpace(_top, new Omnitree.Bounds<Axis1>(min1, max1));
        }
        /// <summary>Counts the number of items in a sub space.</summary>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
        /// <returns>The number of items in the provided sub space.</returns>
        public int CountSubSpace(Axis1 axis1)
        {
            return CountSubSpace(_top, new Omnitree.Bounds<Axis1>(axis1, axis1));
        }
        /// <summary>Counts the number of items in a sub space.</summary>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
        /// <returns>The number of items in the provided sub space.</returns>
        public int CountSubSpace(Omnitree.Bound<Axis1> axis1)
        {
            return CountSubSpace(_top, new Omnitree.Bounds<Axis1>(axis1, axis1));
        }
        /// <summary>Counts the number of items in a sub space.</summary>
        /// <param name="node">The current traversal node.</param>
        /// <returns>The number of items in the provided sub space.</returns>
        private int CountSubSpace(Node node, Omnitree.Bounds<Axis1> bounds)
        {
            // adjust min/max values
            int count = 0;
            if (EncapsulationCheck(bounds, node.Bounds))
                count += node.Count;
            else if (node is Leaf)
            {
                for (Leaf.Node list = (node as Leaf).Head; list != null; list = list.Next)
                    if (EncapsulationCheck(bounds, LocateVector(list.Value)))
                        count++;
            }
            else
            {
                Branch branch = node as Branch;
                if (!StraddlesLines(branch.Bounds, branch.PointOfDivision))
                {
                    int child_index = DetermineChildIndex(branch.PointOfDivision, new Omnitree.Vector<Axis1>(bounds.Min1.Value));
                    Node child = branch[child_index];
                    if (child != null)
                      count += this.CountSubSpace(child, bounds);
                }
                else
                {
                    foreach (Node child in (node as Branch).Children)
                        count += this.CountSubSpace(child, bounds);
                }
            }
            return count;
        }

        #endregion

        #region Update

        /// <summary>Iterates through the entire tree and ensures each item is in the proper leaf.</summary>
        public void Update()
        {
            this.Update(this._top, 0);
        }

        /// <summary>Recursive version of the Update method.</summary>
        /// <param name="node">The current node of iteration.</param>
        /// <param name="depth">The current depth of iteration.</param>
        private int Update(Node node, int depth)
        {
            int removals = 0;

            if (node is Leaf)
            {
                Leaf leaf = node as Leaf;
                Leaf.Node current = leaf.Head;
                Leaf.Node previous = null;
                while (current != null)
                {
                    Omnitree.Vector<Axis1> location = LocateVector(current.Value);
                    if (!this.EncapsulationCheck(node.Bounds, location))
                    {
                        removals++;
                        T updated = current.Value;
                        if (previous == null)
                        {
                            leaf.Head = current.Next;
                            goto HeadRemoved;
                        }
                        else
                            previous.Next = current.Next;

                        Node whereToAdd = GetEncapsulationParent(node.Parent, location);

                        if (whereToAdd == null)
                            throw new System.Exception("an item was updated outside the range of the omnitree");

                        this.Add(updated, whereToAdd, location, whereToAdd.Depth);
                    }
                    previous = current;
                HeadRemoved:
                    current = current.Next;
                }
                leaf.Count -= removals;
                return removals;
            }
            else
            {
                Branch branch = node as Branch;
                int skipped = 0;
                for (int i = 0; i + skipped < branch.Children.Length; )
                {
                    removals += this.Update(branch.Children[i], depth + 1);
                    if (branch.Children[i].Count == 0)
                        branch.Children[i] = branch.Children[branch.Children.Length - skipped++ - 1];
                    else
                        i++;
                }
                Node[] newArray = new Node[branch.Children.Length - skipped];
                Array.Copy(branch.Children, newArray, newArray.Length);
                branch.Children = newArray;

                branch.Count -= removals;

                if (branch.Count < _load && branch.Count != 0)
                    ShrinkChild(branch.Parent, branch.Index);
            }

            return removals;
        }

        /// <summary>Iterates through the provided dimensions and ensures each item is in the proper leaf.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
        public void Update(Axis1 min1, Axis1 max1)
        {
            this.Update(new Omnitree.Bounds<Axis1>(min1, max1), this._top, 0);
        }
        /// <summary>Iterates through the provided dimensions and ensures each item is in the proper leaf.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
        public void Update(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1)
        {
            this.Update(new Omnitree.Bounds<Axis1>(min1, max1), this._top, 0);
        }
        /// <summary>Iterates through the provided dimensions and ensures each item is in the proper leaf.</summary>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
        public void Update(Axis1 axis1)
        {
            this.Update(new Omnitree.Bounds<Axis1>(axis1, axis1), this._top, 0);
        }
        /// <summary>Iterates through the provided dimensions and ensures each item is in the proper leaf.</summary>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
        public void Update(Omnitree.Bound<Axis1> axis1)
        {
            this.Update(new Omnitree.Bounds<Axis1>(axis1, axis1), this._top, 0);
        }
        private int Update(Omnitree.Bounds<Axis1> bounds, Node node, int depth)
        {
            if (!InclusionCheck(bounds, node.Bounds))
                return 0;

            int removals = 0;

            if (node is Leaf)
            {
                Leaf leaf = node as Leaf;
                Leaf.Node current = leaf.Head;
                Leaf.Node previous = null;
                while (current != null)
                {
                    Omnitree.Vector<Axis1> location = LocateVector(current.Value);
                    if (!this.EncapsulationCheck(node.Bounds, location))
                    {
                        removals++;
                        T updated = current.Value;
                        if (previous == null)
                        {
                            leaf.Head = current.Next;
                            goto HeadRemoved;
                        }
                        else
                            previous.Next = current.Next;
                        Node whereToAdd = GetEncapsulationParent(node.Parent, location);
                        if (whereToAdd == null)
                            throw new System.Exception("an item was updates outside the range of the omnitree");
                        this.Add(updated, whereToAdd, location, whereToAdd.Depth);
                    }
                    previous = current;
                HeadRemoved:
                    current = current.Next;
                }
                leaf.Count -= removals;
                return removals;
            }
            else
            {
                Branch branch = node as Branch;
                int skipped = 0;
                for (int i = 0; i + skipped < branch.Children.Length; )
                {
                    removals += this.Update(branch.Children[i], depth + 1);
                    if (branch.Children[i].Count == 0)
                        branch.Children[i] = branch.Children[branch.Children.Length - skipped++ - 1];
                    else
                        i++;
                }
                Node[] newArray = new Node[branch.Children.Length - skipped];
                Array.Copy(branch.Children, newArray, newArray.Length);
                branch.Children = newArray;

                branch.Count -= removals;

                if (branch.Count < _load && branch.Count != 0)
                    ShrinkChild(branch.Parent, branch.Index);
            }

            return removals;
        }

        #endregion

        #region Remove

        /// <summary>Removes all the items qualified by the delegate.</summary>
        /// <param name="where">The predicate to qualify removals.</param>
        public void Remove(Predicate<T> where)
        {
            this.Remove(this._top, where);
			Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
        }

        /// <summary>Recursive version of the remove method.</summary>
        /// <param name="node">The current node of traversal.</param>
        /// <param name="where">The predicate to qualify removals.</param>
        private int Remove(Node node, Predicate<T> where)
        {
            int removals = 0;
            if (node is Leaf)
            {
                Leaf leaf = node as Leaf;
                while (leaf.Head != null && where(leaf.Head.Value))
                {
                    leaf.Head = leaf.Head.Next;
                    removals++;
                }
                if (leaf.Head != null)
                {
                    Leaf.Node list = leaf.Head;
                    while (list.Next != null)
                    {
                        if (where(list.Next.Value))
                        {
                            list.Next = list.Next.Next;
                            removals++;
                        }
                    }
                }

                leaf.Count -= removals;
                return removals;
            }
            else
            {
                Branch branch = node as Branch;
                int skipped = 0;
                for (int i = 0; i + skipped < branch.Children.Length; )
                {
                    removals += this.Remove(branch.Children[i], where);
                    if (branch.Children[i].Count == 0)
                        branch.Children[i] = branch.Children[branch.Children.Length - skipped++ - 1];
                    else
                        i++;
                }
                Node[] newArray = new Node[branch.Children.Length - skipped];
                Array.Copy(branch.Children, newArray, newArray.Length);
                branch.Children = newArray;

                branch.Count -= removals;

                if (branch.Count < _load && branch.Count != 0)
                    ShrinkChild(branch.Parent, branch.Index);

                return removals;
            }
        }

        /// <summary>Removes all the items in a given space.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
        /// <returns>The number of items that were removed.</returns>
        public void Remove(Axis1 min1, Axis1 max1)
        {
            this.Remove(this._top, new Omnitree.Bounds<Axis1>(min1, max1));
            Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
        }
        /// <summary>Removes all the items in a given space.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
        /// <returns>The number of items that were removed.</returns>
        public void Remove(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1)
        {
            this.Remove(this._top, new Omnitree.Bounds<Axis1>(min1, max1));
            Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
        }
        private int Remove(Node node, Omnitree.Bounds<Axis1> bounds)
        {
            int removals = 0;
            if (InclusionCheck(bounds, node.Bounds))
            {
                if (node is Leaf)
                {
                    Leaf leaf = node as Leaf;
                    Leaf.Node current_node = leaf.Head;
                    Leaf.Node previous_node = null;
                    while (current_node != null)
                    {
                        Leaf.Node temp_previous = current_node;
                        if (EncapsulationCheck(bounds, LocateVector(current_node.Value)))
                        {
                            removals++;
                            if (current_node == leaf.Head)
                                leaf.Head = leaf.Head.Next;
                            else
                            {
                                previous_node.Next = current_node.Next;
                                temp_previous = previous_node;
                            }
                        }
                        previous_node = temp_previous;
                        current_node = current_node.Next;
                    }
                    leaf.Count -= removals;
                }
                else
                {
                    Branch branch = node as Branch;
                    int skipped = 0;
                    for (int i = 0; i + skipped < branch.Children.Length; )
                    {
                        removals += this.Remove(branch.Children[i], bounds);
                        if (branch.Children[i].Count == 0)
                            branch.Children[i] = branch.Children[branch.Children.Length - skipped++ - 1];
                        else
                            i++;
                    }
                    Node[] newArray = new Node[branch.Children.Length - skipped];
                    Array.Copy(branch.Children, newArray, newArray.Length);
                    branch.Children = newArray;

                    branch.Count -= removals;
                    // convert this branch back into a leaf
                    // Note: if count is zero, it will be chopped off
                    if (branch.Count < _load && branch.Count > 0)
                        ShrinkChild(branch.Parent, branch.Index);
                }
            }

            return removals;
        }

        /// <summary>Removes all the items in a given space validated by a predicate.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
        /// <param name="where">The equality constraint of the removal.</param>
        public void Remove(Axis1 min1, Axis1 max1, Predicate<T> where)
        {
            this.Remove(this._top, new Omnitree.Bounds<Axis1>(min1, max1), where);
            Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
        }
        /// <summary>Removes all the items in a given space validated by a predicate.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
        /// <param name="where">The equality constraint of the removal.</param>
        public void Remove(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Predicate<T> where)
        {
            this.Remove(this._top, new Omnitree.Bounds<Axis1>(min1, max1), where);
			Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
        }
        private int Remove(Node node, Omnitree.Bounds<Axis1> bounds, Predicate<T> where)
        {
            if (!InclusionCheck(node.Bounds, bounds))
                return 0;
            int removals = 0;
            if (node is Leaf)
            {
                Leaf leaf = node as Leaf;
                Leaf.Node current = leaf.Head;
                Leaf.Node previous = null;
                while (current != null)
                {
                    if (this.EncapsulationCheck(bounds, LocateVector(current.Value)) && where(current.Value))
                    {
                        removals++;
                        if (previous == null)
                        {
                            leaf.Head = current.Next;
                            goto HeadRemoved;
                        }
                        else
                            previous.Next = current.Next;
                    }
                    previous = current;
                HeadRemoved:
                    current = current.Next;
                }

                leaf.Count -= removals;
                return removals;
            }
            else
            {
                Branch branch = node as Branch;
                int skipped = 0;
                for (int i = 0; i + skipped < branch.Children.Length; )
                {
                    removals += this.Remove(branch.Children[i], bounds, where);
                    if (branch.Children[i].Count == 0)
                        branch.Children[i] = branch.Children[branch.Children.Length - skipped++ - 1];
                    else
                        i++;
                }
                Node[] newArray = new Node[branch.Children.Length - skipped];
                Array.Copy(branch.Children, newArray, newArray.Length);
                branch.Children = newArray;

                node.Count -= removals;

                if (node.Count < _load && node.Count != 0)
                    ShrinkChild(node.Parent, node.Index);

                return removals;
            }
        }

        /// <summary>Removes all instances of a given value.</summary>
        public void Remove(T removal)
        {
            Axis1 axis1;
            this._locate(removal, out axis1);
            this.Remove(axis1, (T item) => { return this._equate(item, removal); });
        }
        /// <summary>Removes all the items in a given space.</summary>
        /// <param name="axis1">The axis of the removal along the  1D axis.</param>
        /// <returns>The number of items that were removed.</returns>
        public void Remove(Axis1 axis1)
        {
            this.Remove(this._top, new Omnitree.Vector<Axis1>(axis1));
            Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
        }
        private int Remove(Node node, Omnitree.Vector<Axis1> vector)
        {
            int removals = 0;
            if (node is Leaf)
            {
                Leaf leaf = node as Leaf;
                Leaf.Node current_node = leaf.Head;
                Leaf.Node previous_node = null;
                while (current_node != null)
                {
                    Leaf.Node temp_previous = current_node;
                    if (EqualsCheck(vector, LocateVector(current_node.Value)))
                    {
                        removals++;
                        if (current_node == leaf.Head)
                            leaf.Head = leaf.Head.Next;
                        else
                        {
                            previous_node.Next = current_node.Next;
                            temp_previous = previous_node;
                        }
                    }
                    previous_node = temp_previous;
                    current_node = current_node.Next;
                }
                leaf.Count -= removals;
            }
            else
            {
                Branch branch = node as Branch;
                int child_index = DetermineChildIndex(branch.PointOfDivision, vector);
                removals += Remove(branch[child_index], vector);
                branch.Count -= removals;
                // convert this branch back into a leaf
                // Note: if count is zero, it will be chopped off
                if (branch.Count < _load && branch.Count > 0)
                    ShrinkChild(branch.Parent, branch.Index);
            }

            return removals;
        }

        /// <summary>Removes all the items in a given space validated by a predicate.</summary>
        /// <param name="axis1">The axis of the removal along the  1D axis.</param>
        /// <param name="where">The equality constraint of the removal.</param>
        public void Remove(Axis1 axis1, Predicate<T> where)
        {
            this.Remove(this._top, new Omnitree.Vector<Axis1>(axis1), where);
            Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
        }
        private int Remove(Node node, Omnitree.Vector<Axis1> vector, Predicate<T> where)
        {
            int removals = 0;
            if (node is Leaf)
            {
                Leaf leaf = node as Leaf;
                Leaf.Node current_node = leaf.Head;
                Leaf.Node previous_node = null;
                while (current_node != null)
                {
                    Leaf.Node temp_previous = current_node;
                    if (EqualsCheck(vector, LocateVector(current_node.Value)) && where(current_node.Value))
                    {
                        removals++;
                        if (current_node == leaf.Head)
                            leaf.Head = leaf.Head.Next;
                        else
                        {
                            previous_node.Next = current_node.Next;
                            temp_previous = previous_node;
                        }
                    }
                    previous_node = temp_previous;
                    current_node = current_node.Next;
                }
                leaf.Count -= removals;
            }
            else
            {
                Branch branch = node as Branch;
                int child_index = DetermineChildIndex(branch.PointOfDivision, vector);
                removals += Remove(branch[child_index], vector, where);
                branch.Count -= removals;
                // convert this branch back into a leaf
                // Note: if count is zero, it will be chopped off
                if (branch.Count < _load && branch.Count > 0)
                    ShrinkChild(branch.Parent, branch.Index);
            }
            return removals;
        }

        #endregion

        #region Stepper And IEnumerable

        /// <summary>Traverses every item in the tree and performs the delegate in them.</summary>
        /// <param name="function">The delegate to perform on every item in the tree.</param>
        public void Stepper(Step<T> function)
        {
            this.Stepper(function, this._top);
        }
        private void Stepper(Step<T> function, Node node)
        {
            if (node is Leaf)
            {
                Leaf.Node list = (node as Leaf).Head;
                while (list != null)
                {
                    function(list.Value);
                    list = list.Next;
                }
            }
            else
            {
                foreach (Node child in (node as Branch).Children)
                    this.Stepper(function, child);
            }
        }

        /// <summary>Traverses every item in the tree and performs the delegate in them.</summary>
        /// <param name="function">The delegate to perform on every item in the tree.</param>
        public StepStatus Stepper(StepBreak<T> function)
        {
            return Stepper(function, _top);
        }
        private StepStatus Stepper(StepBreak<T> function, Node node)
        {
            StepStatus status = StepStatus.Continue;
            if (node is Leaf)
            {
                for (Leaf.Node list = (node as Leaf).Head; list != null; list = list.Next)
                    if ((status = function(list._value)) != StepStatus.Continue)
                        break;
            }
            else
            {
                foreach (Node child in (node as Branch).Children)
                    if ((status = Stepper(function, child)) != StepStatus.Continue)
                        break;
            }
            return status;
        }

        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="function">The delegate to perform on all items in the tree within the given bounds.</param>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
        public void Stepper(Step<T> function, Axis1 min1, Axis1 max1)
        {
            Stepper(function, _top, new Omnitree.Bounds<Axis1>(min1, max1));
        }
        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="function">The delegate to perform on all items in the tree within the given bounds.</param>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
        public void Stepper(Step<T> function, Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1)
        {
            Stepper(function, _top, new Omnitree.Bounds<Axis1>(min1, max1));
        }
        private void Stepper(Step<T> function, Node node, Omnitree.Bounds<Axis1> bounds)
        {
            if (node is Leaf)
            {
                for (Leaf.Node list = (node as Leaf).Head; list != null; list = list.Next)
                    if (EncapsulationCheck(bounds, LocateVector(list.Value)))
                        function(list.Value);
            }
            else
            {
                foreach (Node child in (node as Branch).Children)
                    // optimization: stop bounds checking if space encapsulates node
                    if (EncapsulationCheck(bounds, child.Bounds))
                        this.Stepper(function, child);
                    else if (InclusionCheck(child.Bounds, bounds))
                        this.Stepper(function, child, bounds);
            }
        }

        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
        public StepStatus Stepper(StepBreak<T> function, Axis1 min1, Axis1 max1)
        {
            return Stepper(function, _top, new Omnitree.Bounds<Axis1>(min1, max1));
        }
        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
        public StepStatus Stepper(StepBreak<T> function, Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1)
        {
            return Stepper(function, _top, new Omnitree.Bounds<Axis1>(min1, max1));
        }
        private StepStatus Stepper(StepBreak<T> function, Node node, Omnitree.Bounds<Axis1> bounds)
        {
            StepStatus status = StepStatus.Continue;
            if (node is Leaf)
            {
                for (Leaf.Node list = (node as Leaf).Head; list != null; list = list.Next)
                    if (EncapsulationCheck(bounds, LocateVector(list.Value)) &&
                        (status = function(list.Value)) != StepStatus.Continue)
                        break;
            }
            else
            {
                foreach (Node child in (node as Branch).Children)
                    // optimization: stop bounds checking if space encapsulates node
                    if (EncapsulationCheck(bounds, child.Bounds) &&
                        (status = this.Stepper(function, child)) != StepStatus.Continue)
                        break;
                    else if (!InclusionCheck(child.Bounds, bounds) &&
                        (status = this.Stepper(function, child, bounds)) != StepStatus.Continue)
                        break;
            }
            return status;
        }

        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="axis1">The axis of the removal along the  1D axis.</param>
        public void Stepper(Step<T> function, Axis1 axis1)
        {
            Stepper(function, _top, new Omnitree.Vector<Axis1>(axis1));
        }
        private void Stepper(Step<T> function, Node node, Omnitree.Vector<Axis1> vector)
        {
            Node current = node;
            while (current != null)
            {
                if (current is Leaf)
                {
                    for (Leaf.Node leaf_node = (current as Leaf).Head; leaf_node != null; leaf_node = leaf_node.Next)
                        if (EqualsCheck(vector, LocateVector(leaf_node.Value)))
                            function(leaf_node.Value);
                    break;
                }
                else
                {
                    Branch branch = current as Branch;
                    int child_index = DetermineChildIndex(branch.PointOfDivision, vector);
                    current = branch[child_index];
                }
            }
        }

        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="function">The delegate to perform on all items in the tree within the given bounds.</param>
        /// <param name="axis1">The axis of the removal along the  1D axis.</param>
        public StepStatus Stepper(StepBreak<T> function, Axis1 axis1)
        {
            return Stepper(function, _top, new Omnitree.Vector<Axis1>(axis1));
        }
        private StepStatus Stepper(StepBreak<T> function, Node node, Omnitree.Vector<Axis1> vector)
        {
            Node current = node;
            while (current != null)
            {
                if (current is Leaf)
                {
                    for (Leaf.Node list = (current as Leaf).Head; list != null; list = list.Next)
                    {
                        StepStatus status = StepStatus.Continue;
                        if (EqualsCheck(vector, LocateVector(list.Value)) &&
                            (status = function(list.Value)) != StepStatus.Continue)
                            return status;
                    }
                }
                else
                {
                    Branch branch = current as Branch;
                    int child_index = DetermineChildIndex(branch.PointOfDivision, vector);
                    current = branch[child_index];
                }
            }
            return StepStatus.Continue;
        }

        /// <summary>FOR COMPATIBILITY ONLY. AVOID IF POSSIBLE.</summary>
        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
        {
            throw new System.NotImplementedException();
            //return (this.ToArray() as System.Collections.Generic.IEnumerable<T>).GetEnumerator();
        }

        /// <summary>FOR COMPATIBILITY ONLY. AVOID IF POSSIBLE.</summary>
        System.Collections.Generic.IEnumerator<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator()
        {
            throw new System.NotImplementedException();
            //return (this.ToArray() as System.Collections.Generic.IEnumerable<T>).GetEnumerator();
        }

        #endregion

        #region Helpers

        private bool StraddlesLines(Omnitree.Bounds<Axis1> bounds, Omnitree.Vector<Axis1> vector)
        {
			if ((!bounds.Min1.Exists || (bounds.Min1.Exists && this._compare1(bounds.Min1.Value, vector.Axis1) != Comparison.Greater)) &&
				(!bounds.Max1.Exists || (bounds.Max1.Exists && this._compare1(bounds.Max1.Value, vector.Axis1) != Comparison.Less)))
				return true;
            return false;
        }

        /// <summary>Computes the child index that contains the desired dimensions.</summary>
        /// <param name="node">The branch .</param>
        /// <param name="vector">The dimensions to determine the child index.</param>
        /// <returns>The computed child index based on the coordinates relative to the center of the node.</returns>
        private int DetermineChildIndex(Omnitree.Vector<Axis1> pointOfDivision, Omnitree.Vector<Axis1> vector)
        {
            int child = 0;
            if (!(this._compare1(vector.Axis1, pointOfDivision.Axis1) == Comparison.Less))
                child += 1 << 0;
            return child;
        }

        /// <summary>Converts a branch back into a leaf when the count is reduced.</summary>
        /// <param name="parent">The parent to shrink a child of.</param>
        /// <param name="child">The index of the child to shrink.</param>
        private void ShrinkChild(Branch parent, int child_index)
        {
            Leaf leaf;
            Node removal = null;
            if (parent == null) // top of tree
            {
                removal = this._top;
                leaf = new Leaf(Omnitree.Bounds<Axis1>.None, null, -1);
                this._top = leaf;
            }
            else // non-top branch
            {
                removal = parent[child_index];
                leaf = new Leaf(removal.Bounds, removal.Parent, removal.Index);
                parent[child_index] = leaf;
            }

            this.Stepper((T step) => { leaf.Add(step); }, removal);
        }

        /// <summary>Reduces the counts of all the parents of a given node by a given amount.</summary>
        /// <param name="parent">The starting parent of the reduction.</param>
        /// <param name="reduction">The amount to reduce the parent counts by.</param>
        private void ReduceParentCounts(Node parent, int reduction)
        {
            IncreaseParentCounts(parent, -reduction);
        }

        /// <summary>Increases the counts of all the parents of a given node by a given amount.</summary>
        /// <param name="parent">The starting parent of the increase.</param>
        /// <param name="increase">The amount to increase the parent counts by.</param>
        private void IncreaseParentCounts(Node parent, int increase)
        {
            Node looper = parent;
            while (looper != null)
            {
                looper.Count += increase;
                looper = looper.Parent;
            }
        }

        /// <summary>Checks a node for inclusion (overlap) between two bounds.</summary>
        /// <returns>True if the spaces overlap; False if not.</returns>
        private bool InclusionCheck(Omnitree.Bounds<Axis1> a, Omnitree.Bounds<Axis1> b)
        {

            if (a.Max1.Exists && b.Min1.Exists && this._compare1(a.Max1.Value, b.Min1.Value) == Comparison.Less)
                return false;
            else if (a.Min1.Exists && b.Max1.Exists && this._compare1(a.Min1.Value, b.Max1.Value) == Comparison.Greater)
                return false;

            return true;
        }

        /// <summary>Checks if a space encapsulates a point.</summary>
        /// <returns>True if the space encapsulates the point; False if not.</returns>
        private bool EncapsulationCheck(Omnitree.Bounds<Axis1> bounds, Omnitree.Vector<Axis1> vector)
        {
            // if the location is not outside the bounds, it must be inside

            if (bounds.Min1.Exists && this._compare1(vector.Axis1, bounds.Min1.Value) == Comparison.Less)
                return false;
            else if (bounds.Max1.Exists && this._compare1(vector.Axis1, bounds.Max1.Value) == Comparison.Greater)
                return false;

            return true;
        }

        /// <summary>Checks if a space (left) encapsulates another space (right).</summary>
        /// <returns>True if the left space encapsulates the right; False if not.</returns>
        private bool EncapsulationCheck(Omnitree.Bounds<Axis1> a, Omnitree.Bounds<Axis1> b)
        {
            if ((a.Min1.Exists && !b.Min1.Exists))
                return false;
			if ((a.Max1.Exists && !b.Max1.Exists))
                return false;

            if (b.Min1.Exists && a.Min1.Exists && this._compare1(a.Min1.Value, b.Min1.Value) != Comparison.Less)
                return false;
            if (b.Max1.Exists && a.Max1.Exists && this._compare1(a.Max1.Value, b.Max1.Value) != Comparison.Greater)
                return false;

            return true;
        }

        /// <summary>Checks for equality between two locations.</summary>
        /// <returns>True if equal; False if not;</returns>
        private bool EqualsCheck(Omnitree.Vector<Axis1> a, Omnitree.Vector<Axis1> b)
        {

            if (!this._equate1(a.Axis1, b.Axis1))
                return false;

            return true;
        }

        /// <summary>Gets the nearest parent that encapsulates a location.</summary>
        /// <param name="node">The starting node to find the encapsulating parent of the location.</param>
        /// <param name="coordinate1">The coordinate along the 1D axis.</param>
        /// <param name="coordinate2">The coordinate along the 2D axis.</param>
        /// <param name="coordinate3">The coordinate along the 3D axis.</param>
        /// <returns>The nearest node that encapsulates the given location.</returns>
        private Node GetEncapsulationParent(Node node, Omnitree.Vector<Axis1> vector)
        {
            while (node != null && !EncapsulationCheck(node.Bounds, vector))
                node = node.Parent;
            return node;
        }

        private Omnitree.Vector<Axis1> LocateVector(T value)
        {
            Axis1 axis1;
            this._locate(value, out axis1);
            return new Omnitree.Vector<Axis1>(axis1);
        }

        #endregion

        #endregion
    }

    #endregion

    #region 2 Dimensional

    public interface IOmnitreePoints<T, Axis1, Axis2> : IDataStructure<T>,
            DataStructure.ICountable,
            DataStructure.IAddable<T>,
            DataStructure.IClearable,
            DataStructure.IRemovable<T>,
            DataStructure.IEquating<T>
    {
        #region Properties

        /// <summary>Steps through the values at a given location.</summary>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
        /// <returns>A Stepper of the items at the given coordinates.</returns>
        Stepper<T> this[Axis1 axis1, Axis2 axis2] { get; }
        /// <summary>The number of dimensions in this tree.</summary>
        int Dimensions { get; }

        #endregion

        #region Methods

        /// <summary>Counts the number of items in a sub space.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
        /// <returns>The number of items in the provided sub space.</returns>
        int CountSubSpace(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2);

        /// <summary>Iterates through the entire tree and ensures each item is in the proper leaf.</summary>
        void Update();
        /// <summary>Iterates through the provided dimensions and ensures each item is in the proper leaf.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
        void Update(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2);

        /// <summary>Removes all the items in a given space.</summary>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
        void Remove(Axis1 axis1, Axis2 axis2);
        /// <summary>Removes all the items in a given space.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
        void Remove(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2);
        /// <summary>Removes all the items in a given space where equality is met.</summary>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
        /// <param name="where">The equality constraint of the removal.</param>
        void Remove(Axis1 axis1, Axis2 axis2, Predicate<T> where);
        /// <summary>Removes all the items in a given space where predicate is met.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
        /// <param name="where">The predicate constraint of the removal.</param>
        void Remove(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Predicate<T> where);

        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="step">The step function to perform on all items in the tree within the given bounds.</param>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
        void Stepper(Step<T> step, Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2);
        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="step">The step function to perform on all items in the tree within the given bounds.</param>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
        StepStatus Stepper(StepBreak<T> step, Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2);
        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="step">The step function to perform on all items in the tree within the given bounds.</param>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
        void Stepper(Step<T> step, Axis1 axis1, Axis2 axis2);
        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="step">The step function to perform on all items in the tree within the given bounds.</param>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
        StepStatus Stepper(StepBreak<T> function, Axis1 axis1, Axis2 axis2);

        #endregion
    }

    public class OmnitreePointsLinked<T, Axis1, Axis2> : IOmnitreePoints<T, Axis1, Axis2>
    {
        private const int _dimensions = 2;
        internal static int _children_per_node = (int)BigInteger.Pow(2, 2);

        private Node _top;

		private int _naturalLogLower = 1; // caching the next time to calculate loads (lower count)
		private int _naturalLogUpper = -1; // caching the next time to calculate loads (upper count)
		private int _load; // ln(count); min = _defaultLoad
        private Omnitree.Location<T, Axis1, Axis2> _locate;

        private bool _defaultEquate;
        private Equate<T> _equate;


        private bool _defaultEquate1;
        private Equate<Axis1> _equate1;

        private bool _defaultEquate2;
        private Equate<Axis2> _equate2;



        private bool _defaultCompare1;
        private Compare<Axis1> _compare1;

        private bool _defaultCompare2;
        private Compare<Axis2> _compare2;


        // allows median overriding for custom optimizations (USE AT YOUR OWN RISK)
        private Omnitree.SubdivisionOverride<T, Axis1, Omnitree.Bounds<Axis1, Axis2>> _subdivisionOverride1;
        private Omnitree.SubdivisionOverride<T, Axis2, Omnitree.Bounds<Axis1, Axis2>> _subdivisionOverride2;

        #region Nested Types

        /// <summary>Can be a leaf or a branch.</summary>
        public abstract class Node
        {
            internal Omnitree.Bounds<Axis1, Axis2> _bounds;
            internal Branch _parent;
            internal int _index;
            internal int _count;

            /// <summary>The parent of this node.</summary>
            public Omnitree.Bounds<Axis1, Axis2> Bounds { get { return this._bounds; } }
            /// <summary>The parent of this node.</summary>
            public Branch Parent { get { return this._parent; } }
            /// <summary>The computed child index of this node (see the "Notes" region in "Omnitree.cs" for the algorithm.</summary>
            public int Index { get { return this._index; } }
            /// <summary>The number of elements stored in this node and its children.</summary>
            public int Count { get { return this._count; } set { this._count = value; } }

            /// <summary>The depth this node is located in the Omnitree.</summary>
            public int Depth
            {
                get
                {
                    int depth = -1;
                    for (Node looper = this; looper != null; looper = looper.Parent)
                        depth++;
                    return depth;
                }
            }

            /// <summary>Constructs a node.</summary>
            /// <param name="bounds">The bounds of this node.</param>
            /// <param name="parent">The parent of this node.</param>
            /// <param name="index">The number of elements stored in this node and its children.</param>
            public Node(Omnitree.Bounds<Axis1, Axis2> bounds, Branch parent, int index)
            {
                this._bounds = bounds;
                this._parent = parent;
                this._index = index;
            }

            internal Node(Node nodeToClone)
            {
                this._bounds = nodeToClone._bounds;
                this._parent = nodeToClone._parent;
                this._index = nodeToClone._index;
                this._count = nodeToClone._count;
            }

            internal abstract Node Clone();
        }

        /// <summary>A branch in the tree. Only contains nodes.</summary>
        public class Branch : Node
        {
            private Node[] _children;
            private Omnitree.Vector<Axis1, Axis2> _pointOfDivision;

            public Node[] Children { get { return this._children; } set { this._children = value; } }
            public Omnitree.Vector<Axis1, Axis2> PointOfDivision { get { return this._pointOfDivision; } internal set { this._pointOfDivision = value; } }
            
            /// <summary>Gets child by index.</summary>
            /// <param name="child_index">The index of the child to get.</param>
            /// <returns>The child of the given index or null if non-existent.</returns>
            public Node this[int child_index]
            {
                get
                {
                    if (this._children == null)
                        return null;
                    if (this._children.Length == OmnitreePointsLinked<T, Axis1, Axis2>._children_per_node)
                        return this._children[(int)child_index];
                    foreach (Node node in this._children)
                        if (node.Index == child_index)
                            return node;
                    return null;
                }
                set
                {
                    // This error check should be unnecessary... but fuck it... might as well
                    if (value.Index != child_index)
                        throw new System.Exception("Bug in Omnitree (index/property mis-match when setting a child on a branch)");

                    // no children yet
                    if (this._children == null)
                    {
                        this._children = new Node[] { value };
                        return;
                    }
                    // max children overwrite
                    else if (this._children.Length == OmnitreePointsLinked<T, Axis1, Axis2>._children_per_node)
                    {
                        this._children[(int)child_index] = value;
                        return;
                    }
                    // non-max child overwrite
                    for (int i = 0; i < this._children.Length; i++)
                        if (this._children[i].Index == child_index)
                        {
                            this._children[i] = value;
                            return;
                        }
                    // new child
                    Node[] newArray = new Node[this._children.Length + 1];
                    if (newArray.Length == OmnitreePointsLinked<T, Axis1, Axis2>._children_per_node)
                    {
                        // new child resulting in a max children branch (sorting required)
                        for (int i = 0; i < this._children.Length; i++)
                        {
                            newArray[(int)this._children[i]._index] = this._children[i];
                        }
                        newArray[(int)value._index] = value;
                    }
                    else
                    {
                        // new child resulting in a non-max children branch
                        Array.Copy(this._children, newArray, this._children.Length);
                        newArray[newArray.Length - 1] = value;
                    }
                    this._children = newArray;
                }
            }

            public Branch(Omnitree.Vector<Axis1, Axis2> pointOfDivision, Omnitree.Bounds<Axis1, Axis2> bounds, Branch parent, int index)
                : base(bounds, parent, index)
            {
                this._pointOfDivision = pointOfDivision;
            }

            public Branch(Branch branchToClone)
                : base(branchToClone)
            {
                this._children = branchToClone._children.Clone() as Node[];
                this._pointOfDivision = branchToClone._pointOfDivision;
            }

            internal override Node Clone()
            {
                return new Branch(this);
            }
        }

        /// <summary>A branch in the tree. Only contains items.</summary>
        public class Leaf : Node
        {
            public class Node
            {
                internal T _value;
                internal Leaf.Node _next;

                public T Value { get { return _value; } set { _value = value; } }
                public Leaf.Node Next { get { return _next; } set { _next = value; } }

                public Node(T value, Leaf.Node next)
                {
                    _value = value;
                    _next = next;
                }
            }

            private Leaf.Node _head;

            public Leaf.Node Head { get { return this._head; } set { this._head = value; } }

            internal Leaf(Omnitree.Bounds<Axis1, Axis2> bounds, Branch parent, int index)
                : base(bounds, parent, index)
            { }

            internal Leaf(Leaf leafToClone)
                : base(leafToClone)
            {
                this._head = new Node(leafToClone._head.Value, null);

                Node this_looper = this._head;
                Node other_looper = leafToClone._head;

                while (other_looper != null)
                {
                    this_looper.Next = new Node(other_looper.Next.Value, null);
                    this_looper = this_looper.Next;
                    other_looper = other_looper.Next;
                }
            }

            public void Add(T addition)
            {
                this._head = new Leaf.Node(addition, this._head);
                this.Count++;
            }

            internal override OmnitreePointsLinked<T, Axis1, Axis2>.Node Clone()
            {
                return new Leaf(this);
            }
        }

        #endregion

        #region Constructors

        /// <summary>This constructor is for cloning purposes</summary>
        private OmnitreePointsLinked(OmnitreePointsLinked<T, Axis1, Axis2> omnitree)
        {
            this._top = omnitree._top.Clone();
            this._load = omnitree._load;
            this._locate = omnitree._locate;
            this._defaultEquate = omnitree._defaultEquate;
            this._equate = omnitree._equate;

            this._defaultEquate1 = omnitree._defaultEquate1;
            this._equate1 = omnitree._equate1;
            this._defaultEquate2 = omnitree._defaultEquate2;
            this._equate2 = omnitree._equate2;

            this._defaultCompare1 = omnitree._defaultCompare1;
            this._compare1 = omnitree._compare1;
            this._defaultCompare2 = omnitree._defaultCompare2;
            this._compare2 = omnitree._compare2;

            this._subdivisionOverride1 = omnitree._subdivisionOverride1;
            this._subdivisionOverride2 = omnitree._subdivisionOverride2;
        }

        private OmnitreePointsLinked(
            Omnitree.Location<T, Axis1, Axis2> locate,

            bool defaultEquate,
            Equate<T> equate,

            bool defaultEquate1,
            Equate<Axis1> equateAxis1,
            bool defaultEquate2,
            Equate<Axis2> equateAxis2,

            bool defaultCompare1,
            Compare<Axis1> compare1,
            bool defaultCompare2,
            Compare<Axis2> compare2,

            Omnitree.SubdivisionOverride<T, Axis1, Omnitree.Bounds<Axis1, Axis2>> subdivisionOverride1,
            Omnitree.SubdivisionOverride<T, Axis2, Omnitree.Bounds<Axis1, Axis2>> subdivisionOverride2)
        {
			if (locate == null)
			{
				throw new ArgumentNullException(nameof(locate));
			}
			if (equate == null)
			{
				throw new ArgumentNullException(nameof(equate));
			}

			if (equateAxis1 == null)
			{
				throw new ArgumentNullException(nameof(equateAxis1));
			}
			if (equateAxis2 == null)
			{
				throw new ArgumentNullException(nameof(equateAxis2));
			}

			if (compare1 == null)
			{
				throw new ArgumentNullException(nameof(compare1));
			}
			if (compare2 == null)
			{
				throw new ArgumentNullException(nameof(compare2));
			}

            this._locate = locate;
            this._defaultEquate = defaultEquate;
            this._equate = equate;

            this._defaultEquate1 = defaultEquate1;
            this._equate1 = equateAxis1;
            this._defaultEquate2 = defaultEquate2;
            this._equate2 = equateAxis2;

            this._defaultCompare1 = defaultCompare1;
            this._compare1 = compare1;
            this._defaultCompare2 = defaultCompare2;
            this._compare2 = compare2;

            this._subdivisionOverride1 = subdivisionOverride1;
            this._subdivisionOverride2 = subdivisionOverride2;

            this._top = new Leaf(Omnitree.Bounds<Axis1, Axis2>.None, null, -1);
            Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
        }

        private OmnitreePointsLinked(
            Omnitree.Location<T, Axis1, Axis2> locate,
            Equate<T> equate,

            Equate<Axis1> equateAxis1,
            Equate<Axis2> equateAxis2,

            Compare<Axis1> compare1,
            Compare<Axis2> compare2,

            Omnitree.SubdivisionOverride<T, Axis1, Omnitree.Bounds<Axis1, Axis2>> subdivisionOverride1,
            Omnitree.SubdivisionOverride<T, Axis2, Omnitree.Bounds<Axis1, Axis2>> subdivisionOverride2)
            : this(
            locate,

            false,
            equate,

            false,
            equateAxis1,
            false,
            equateAxis2,

            false,
            compare1,
            false,
            compare2,

            subdivisionOverride1,
            subdivisionOverride2)
        { }

        public OmnitreePointsLinked(
            Omnitree.Location<T, Axis1, Axis2> locate,

            Equate<T> equate,

            Equate<Axis1> equateAxis1,
            Equate<Axis2> equateAxis2,

            Compare<Axis1> compare1,
            Compare<Axis2> compare2)
            : this(
                locate,

                false,
                equate,

                false,
                equateAxis1,
                false,
                equateAxis2,

                false,
                compare1,
                false,
                compare2,

                null,
                null)
        { }



        public OmnitreePointsLinked(
            Omnitree.Location<T, Axis1, Axis2> locate,

            Equate<T> equate,

            Compare<Axis1> compare1,
            Compare<Axis2> compare2)
            : this(
                locate,
                false,
                equate,

                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,

                false,
                compare1,
                false,
                compare2,

                null,
                null)
        { }

        public OmnitreePointsLinked(
            Omnitree.Location<T, Axis1, Axis2> locate,
            Equate<T> equate,

            Compare<Axis1> compare1,
            Compare<Axis2> compare2,

            Omnitree.SubdivisionOverride<T, Axis1, Omnitree.Bounds<Axis1, Axis2>> subdivisionOverride1,
            Omnitree.SubdivisionOverride<T, Axis2, Omnitree.Bounds<Axis1, Axis2>> subdivisionOverride2)
            : this(
                locate,

                false,
                equate,

                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,

                false,
                compare1,
                false,
                compare2,

                subdivisionOverride1,
                subdivisionOverride2)
        { }

        public OmnitreePointsLinked(
            Omnitree.Location<T, Axis1, Axis2> locate,

            Compare<Axis1> compare1,
            Compare<Axis2> compare2)
            : this(
                locate,
                true,
                Towel.Equate.Default,

                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,

                false,
                compare1,
                false,
                compare2,

                null,
                null)
        { }

        public OmnitreePointsLinked(
            Omnitree.Location<T, Axis1, Axis2> locate,

            Compare<Axis1> compare1,
            Compare<Axis2> compare2,

            Omnitree.SubdivisionOverride<T, Axis1, Omnitree.Bounds<Axis1, Axis2>> subdivisionOverride1,
            Omnitree.SubdivisionOverride<T, Axis2, Omnitree.Bounds<Axis1, Axis2>> subdivisionOverride2)
            : this(
                locate,

                true,
                Towel.Equate.Default,

                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,

                false,
                compare1,
                false,
                compare2,

                subdivisionOverride1,
                subdivisionOverride2)
        { }

        public OmnitreePointsLinked(
            Omnitree.Location<T, Axis1, Axis2> locate,
            Equate<T> equate)
            : this(
                locate,

                false,
                equate,

                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,

                true,
                Compare.Default,
                true,
                Compare.Default,

                null,
                null)
        { }

        public OmnitreePointsLinked(
            Omnitree.Location<T, Axis1, Axis2> locate,
            Equate<T> equate,
            Omnitree.SubdivisionOverride<T, Axis1, Omnitree.Bounds<Axis1, Axis2>> subdivisionOverride1,
            Omnitree.SubdivisionOverride<T, Axis2, Omnitree.Bounds<Axis1, Axis2>> subdivisionOverride2)
            : this(
                locate,

                false,
                equate,

                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,

                true,
                Compare.Default,
                true,
                Compare.Default,

                subdivisionOverride1,
                subdivisionOverride2)
        { }

        public OmnitreePointsLinked(
            Omnitree.Location<T, Axis1, Axis2> locate)
            : this(
                locate,

                true,
                Towel.Equate.Default,

                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,

                true,
                Compare.Default,
                true,
                Compare.Default,

                null,
                null)
        { }

        public OmnitreePointsLinked(
            Omnitree.Location<T, Axis1, Axis2> locate,
            Omnitree.SubdivisionOverride<T, Axis1, Omnitree.Bounds<Axis1, Axis2>> subdivisionOverride1,
            Omnitree.SubdivisionOverride<T, Axis2, Omnitree.Bounds<Axis1, Axis2>> subdivisionOverride2)
            : this(
                locate,

                true,
                Towel.Equate.Default,

                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,

                true,
                Compare.Default,
                true,
                Compare.Default,

                subdivisionOverride1,
                subdivisionOverride2)
        { }

        #endregion

        #region Properties

        /// <summary>Steps through all the items at a given coordinate.</summary>
        /// <param name="axis1">The coordinate along axis 1.</param>
        /// <param name="axis2">The coordinate along axis 2.</param>
        /// <returns>The stepper for the items at the given coordinate.</returns>
        public Stepper<T> this[Axis1 axis1, Axis2 axis2]
        {
            get
            {
                return (Step<T> step) => { this.Stepper(step, axis1, axis2); };
            }
        }

        /// <summary>The number of dimensions in this tree.</summary>
        public int Dimensions { get { return _dimensions; } }

        /// <summary>The function for equating keys in this table.</summary>
        public Equate<T> Equate { get { return this._equate; } }

        /// <summary>The location function the Omnitree is using.</summary>
        public Omnitree.Location<T, Axis1, Axis2> Locate { get { return this._locate; } }


        /// <summary>The comparison function the Omnitree is using along the 1D axis.</summary>
        public Compare<Axis1> Compare1 { get { return this._compare1; } }
        /// <summary>The comparison function the Omnitree is using along the 2D axis.</summary>
        public Compare<Axis2> Compare2 { get { return this._compare2; } }

        /// <summary>The function for equating values along the 1D axis.</summary>
        public Equate<Axis1> EquateAxis1 { get { return this._equate1; } }
        /// <summary>The function for equating values along the 2D axis.</summary>
        public Equate<Axis2> EquateAxis2 { get { return this._equate2; } }

        /// <summary>The current number of items in the tree.</summary>
        public int Count { get { return this._top.Count; } }

        private delegate void MaxDepthFinder(Node node, int current_depth, ref int max_depth);
        /// <summary>Finds the current maximum depth of the tree. NOT AN O(1) OPERATION. Intended for educational purposes only.</summary>
        public int MaxDepth
        {
            get
            {
                MaxDepthFinder maxDepthFinder = null;
                maxDepthFinder =
                        (Node node, int current_depth, ref int max_depth) =>
                        {
                            if (current_depth > max_depth)
                                max_depth = current_depth;
                            if (node is Branch)
                                foreach (Node child in (node as Branch).Children)
                                    maxDepthFinder(child, current_depth + 1, ref max_depth);
                        };
                int _max_depth = -1;
                maxDepthFinder(this._top, 0, ref _max_depth);
                return _max_depth;
            }
        }

        private delegate void NodeCountFinder(Node node, ref int current_count);
        /// <summary>Counts the current number of nodes in the tree. NOT AN O(1) OPERATION. Intended for educational purposes only.</summary>
        public int NodeCount
        {
            get
            {
                NodeCountFinder nodeCountFinder = null;
                nodeCountFinder =
                        (Node node, ref int current_count) =>
                        {
                            current_count++;
                            if (node is Branch)
                                foreach (Node child in (node as Branch).Children)
                                    nodeCountFinder(child, ref current_count);
                        };

                int _current_count = 0;
                nodeCountFinder(this._top, ref _current_count);
                return _current_count;
            }
        }

        private delegate void BranchCountFinder(Node node, ref int current_count);
        /// <summary>Counts the current number of branches in the tree. NOT AN O(1) OPERATION. Intended for educational purposes only.</summary>
        public int BranchCount
        {
            get
            {
                BranchCountFinder branchCountFinder = null;
                branchCountFinder =
                        (Node node, ref int current_count) =>
                        {
                            if (node is Branch)
                            {
                                current_count++;
                                foreach (Node child in (node as Branch).Children)
                                    branchCountFinder(child, ref current_count);
                            }
                        };

                int _current_count = 0;
                branchCountFinder(this._top, ref _current_count);
                return _current_count;
            }
        }

        private delegate void LeafCountFinder(Node node, ref int current_count);
        /// <summary>Counts the current number of leaves in the tree. NOT AN O(1) OPERATION. Intended for educational purposes only.</summary>
        public int LeafCount
        {
            get
            {
                LeafCountFinder leafCountFinder = null;
                leafCountFinder =
                        (Node node, ref int current_count) =>
                        {
                            if (node is Leaf)
                                current_count++;
                            else
                                foreach (Node child in (node as Branch).Children)
                                    leafCountFinder(child, ref current_count);
                        };

                int _current_count = 0;
                leafCountFinder(this._top, ref _current_count);
                return _current_count;
            }
        }

        #endregion

        #region Methods

        #region Add

        #region Bulk

        public void Add(IndexedBigArray<T> additions, bool allowMultithreading)
        {
            if (additions.Length > int.MaxValue)
                throw new System.Exception("The maximum size of the Omnitree was exceeded during bulk addition.");

            if (this._top.Count != 0 || (int)additions.Length <= _load)
            {
                for (ulong i = 0; i < additions.Length; i++)
                    this.Add(additions[i]);
            }
            else
            {
                // adjust the loads prior to additions
				Omnitree.ComputeLoads((int)additions.Length, ref _naturalLogLower, ref _naturalLogUpper, ref _load);

                Branch new_top = new Branch(Omnitree.Vector<Axis1, Axis2>.Default, Omnitree.Bounds<Axis1, Axis2>.None, null, -1);
                new_top.Count = (int)additions.Length;


                // prepare data for median computations
                IndexedBigArray<Axis1> values1;
                IAsyncResult result1 = null;
                if (this._subdivisionOverride1 != null)
                    values1 = null;
                else
                {
                    values1 = null;
                    Towel.Parallels.Parallel.Operation operation = () =>
                    {
                        values1 = new IndexedBigArray<Axis1>(additions.Length);
                        for (ulong i = 0; i < additions.Length; i++)
                            values1[i] = LocateVector(additions[i]).Axis1;
                        Towel.Algorithms.Sort.Merge(this._compare1, (int i) => { return values1[(ulong)i]; }, (int i, Axis1 value) => { values1[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
                    };

                    if (allowMultithreading)
                        result1 = Towel.Parallels.Parallel.Thread(operation);
                    else
                        operation();
                }

                // prepare data for median computations
                IndexedBigArray<Axis2> values2;
                IAsyncResult result2 = null;
                if (this._subdivisionOverride2 != null)
                    values2 = null;
                else
                {
                    values2 = null;
                    Towel.Parallels.Parallel.Operation operation = () =>
                    {
                        values2 = new IndexedBigArray<Axis2>(additions.Length);
                        for (ulong i = 0; i < additions.Length; i++)
                            values2[i] = LocateVector(additions[i]).Axis2;
                        Towel.Algorithms.Sort.Merge(this._compare2, (int i) => { return values2[(ulong)i]; }, (int i, Axis2 value) => { values2[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
                    };

                    if (allowMultithreading)
                        result2 = Towel.Parallels.Parallel.Thread(operation);
                    else
                        operation();
                }



                if (this._subdivisionOverride1 == null && allowMultithreading)
                    result1.AsyncWaitHandle.WaitOne();

                if (this._subdivisionOverride2 == null && allowMultithreading)
                    result2.AsyncWaitHandle.WaitOne();


                // build the tree
                Add(new_top, 1, -1, additions.Stepper(), (int)additions.Length, int.MinValue, int.MinValue, (int)additions.Length, (int index) => { return values1[index]; }, (int index) => { return values2[index]; }, allowMultithreading);
                
                this._top = new_top;
            }
        }

        public void Add(bool allowMultithreading, params T[] additions)
        {
            if (additions.Length > int.MaxValue)
                throw new System.Exception("The maximum size of the Omnitree was exceeded during bulk addition.");

            if (this._top.Count != 0 || (int)additions.Length <= _load)
            {
                for (int i = 0; i < additions.Length; i++)
                    this.Add(additions[i]);
            }
            else
            {
                // adjust the loads prior to additions
				Omnitree.ComputeLoads((int)additions.Length, ref _naturalLogLower, ref _naturalLogUpper, ref _load);

                Branch new_top = new Branch(Omnitree.Vector<Axis1, Axis2>.Default, Omnitree.Bounds<Axis1, Axis2>.None, null, -1);
                new_top.Count = (int)additions.Length;


                // prepare data for median computations
                IndexedBigArray<Axis1> values1;
                IAsyncResult result1 = null;
                if (this._subdivisionOverride1 != null)
                    values1 = null;
                else
                {
                    values1 = null;
                    Towel.Parallels.Parallel.Operation operation = () =>
                    {
                        values1 = new IndexedBigArray<Axis1>(additions.Length);
                        for (int i = 0; i < additions.Length; i++)
                            values1[i] = LocateVector(additions[i]).Axis1;
                        Towel.Algorithms.Sort.Merge(this._compare1, (int i) => { return values1[(ulong)i]; }, (int i, Axis1 value) => { values1[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
                    };

                    if (allowMultithreading)
                        result1 = Towel.Parallels.Parallel.Thread(operation);
                    else
                        operation();
                }

                // prepare data for median computations
                IndexedBigArray<Axis2> values2;
                IAsyncResult result2 = null;
                if (this._subdivisionOverride2 != null)
                    values2 = null;
                else
                {
                    values2 = null;
                    Towel.Parallels.Parallel.Operation operation = () =>
                    {
                        values2 = new IndexedBigArray<Axis2>(additions.Length);
                        for (int i = 0; i < additions.Length; i++)
                            values2[i] = LocateVector(additions[i]).Axis2;
                        Towel.Algorithms.Sort.Merge(this._compare2, (int i) => { return values2[(ulong)i]; }, (int i, Axis2 value) => { values2[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
                    };

                    if (allowMultithreading)
                        result2 = Towel.Parallels.Parallel.Thread(operation);
                    else
                        operation();
                }



                if (this._subdivisionOverride1 == null && allowMultithreading)
                    result1.AsyncWaitHandle.WaitOne();

                if (this._subdivisionOverride2 == null && allowMultithreading)
                    result2.AsyncWaitHandle.WaitOne();


                // build the tree
                Add(new_top, 1, -1, additions.Stepper(), additions.Length, int.MinValue, int.MinValue, (int)additions.Length, (int index) => { return values1[index]; }, (int index) => { return values2[index]; }, allowMultithreading);
                
                this._top = new_top;
            }
        }

        
        private int Add(Branch parent, int depth, int child, Stepper<T> additions, int parent_count, int prevmed1, int prevmed2, int initial_count, Get<Axis1> values1, Get<Axis2> values2, bool allowMultithreading)
        {
            Axis1 pointOfDivision1;
            Axis2 pointOfDivision2;

            int median_axis1 = -1;
            int median_axis2 = -1;
            if (this._subdivisionOverride1 == null || this._subdivisionOverride2 == null)
                GetMedianIndexes(initial_count, child, depth, prevmed1, prevmed2, out median_axis1, out median_axis2);

            if (this._subdivisionOverride1 != null)
                pointOfDivision1 = this._subdivisionOverride1(parent.Bounds, additions);
            else
                pointOfDivision1 = values1(median_axis1);

            if (this._subdivisionOverride2 != null)
                pointOfDivision2 = this._subdivisionOverride2(parent.Bounds, additions);
            else
                pointOfDivision2 = values2(median_axis2);

            parent.PointOfDivision = new Omnitree.Vector<Axis1, Axis2>(pointOfDivision1, pointOfDivision2);

            // divide the values along the medians
            IMap<IAddable<T>, int> collection_map = new MapHashLinked<IAddable<T>, int>();
            additions((T value) => 
            {
                int index = DetermineChildIndex(parent.PointOfDivision, LocateVector(value));
                IAddable<T> list = null;
                if (collection_map.TryGet(index, out list))
                {
                    list.Add(value);
                }
                else
                {
                    if (parent_count < 100000)
                        list = new AddableArray<T>();
                    else
                        list = new AddableLinked<T>();
                    collection_map.Add(index, list);
                    list.Add(value);
                }
            });

            if (depth == 1 && allowMultithreading)
            {
                // NOTE: Must assign placeholders before multithreading so that the threads do not overwrite each other
                collection_map.Keys((int key) => { parent[key] = new Leaf(Omnitree.Bounds<Axis1, Axis2>.None, parent, key); });
                IAsyncResult[] handles = new IAsyncResult[Environment.ProcessorCount];
                for (int i = 0; i < handles.Length; i++)
                {
                    int multiTheadSafe_i = i; // used as catpure variable below making it multithread-safe
                    handles[i] = Towel.Parallels.Parallel.Thread(() =>
                    {
                        Step.EveryNth<Link<IAddable<T>, int>>(collection_map.Pairs, multiTheadSafe_i + 1)(
                        (Link<IAddable<T>, int> link) =>
                            {
                                ReversedChildBuilding(parent, link._2, depth, link._1.Stepper, link._1.Count, median_axis1, median_axis2, initial_count, values1, values2, allowMultithreading);
                            });
                    });
                }
                
                foreach (IAsyncResult handle in handles)
                {
                    handle.AsyncWaitHandle.WaitOne();
                }
            }
            else
            {
                collection_map.Pairs((Link<IAddable<T>, int> link) =>
                { 
                    ReversedChildBuilding(parent, link._2, depth, link._1.Stepper, link._1.Count, median_axis1, median_axis2, initial_count, values1, values2, allowMultithreading);
                });
            }

            int count = 0;
            foreach (Node node in parent.Children)
                count += node.Count;
            return count;
        }

        int ReversedChildBuilding(Branch parent, int child_index, int depth, Stepper<T> additions, int count, int prevmed1, int prevmed2, int initial_count, Get<Axis1> values1, Get<Axis2> values2, bool allowMultithreading)
        {
            Omnitree.Bounds<Axis1, Axis2> child_bounds = DetermineChildBounds(parent, child_index);
            if (depth >= _load || count <= _load)
            {
                Leaf new_leaf = new Leaf(child_bounds, parent, child_index);
                additions((T value) => { new_leaf.Add(value); });
                parent[new_leaf.Index] = new_leaf;
                return new_leaf.Count;
            }
            else
            {
                Branch new_branch = new Branch(Omnitree.Vector<Axis1, Axis2>.Default, child_bounds, parent, child_index);
                parent[new_branch.Index] = new_branch;
                new_branch.Count = Add(new_branch, depth + 1, child_index, additions, count, prevmed1, prevmed2, count, values1, values2, allowMultithreading);
                return new_branch.Count;
            }
        }

        /// <summary>Gets the indeces of the median values at the given position during bulk additions.</summary>
        private void GetMedianIndexes(int count, int child_index, int depth, int previous1, int previous2, out int index1, out int index2)
        {
            if (depth == 1)
            {
                index1 = (count - 1) / 2;
                index2 = (count - 1) / 2;
                return;
            }

            int splits = Compute.Power(2, depth);
            int mid_child_range = count / splits;

            if (child_index >= 2)
            {
                index2 = previous2 + mid_child_range;
                child_index -= 2;
            }
            else
            {
                index2 = previous2 - mid_child_range;
            }

            if (child_index >= 1)
            {
                index1 = previous1 + mid_child_range;
                child_index -= 1;
            }
            else
            {
                index1 = previous1 - mid_child_range;
            }

        }

        #endregion

        #region single

        /// <summary>Adds an item to the tree.</summary>
        /// <param name="addition">The item to be added.</param>
        public void Add(T addition)
        {
            if (this._top.Count == int.MaxValue)
                throw new System.InvalidOperationException("(Count == int.MaxValue) max Omnitree size reached (change ints to longs if you need to).");

            // dynamic tree sizes
			Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);

            Omnitree.Vector<Axis1, Axis2> location = LocateVector(addition);

            // grow the first branch of the tree
            if (this._top is Leaf && (this._top as Leaf).Count >= _load)
            {
                Leaf top = this._top as Leaf;

                // create the new branch from the median values
                this._top = new Branch(DetermineMedians(top), Omnitree.Bounds<Axis1, Axis2>.None, null, -1);

                // iterate through the elements and add them to the appropriate children
                for (Leaf.Node list = top.Head; list != null; list = list.Next)
                    Add(list.Value, this._top, LocateVector(list.Value), 0);
            }

            this.Add(addition, this._top, location, 0);
        }
        
        /// <summary>Recursive version of the add function.</summary>
        /// <param name="addition">The item to be added.</param>
        /// <param name="node">The current node for tree trversal.</param>
        /// <param name="ms">The location of the addition.</param>
        /// <param name="depth">The current depth of iteration.</param>
        private void Add(T addition, Node node, Omnitree.Vector<Axis1, Axis2> location, int depth)
        {
            if (node is Leaf)
            {
                Leaf leaf = node as Leaf;
                if (depth >= _load || !(leaf.Count >= _load))
                {
                    leaf.Add(addition);
                    return;
                }
                else
                {
                    Branch parent = node.Parent;
                    int child_index = this.DetermineChildIndex(parent.PointOfDivision, location);
                    Branch growth = new Branch(DetermineMedians(leaf), leaf.Bounds, parent, child_index);
                    parent[child_index] = growth;
                    for (Leaf.Node list = leaf.Head; list != null; list = list.Next)
                    {
                        Omnitree.Vector<Axis1, Axis2> temp_location = LocateVector(list.Value);
                        if (EncapsulationCheck(growth.Bounds, temp_location))
                            Add(list.Value, growth, temp_location, depth);
                        else
                        {
                            ReduceParentCounts(parent, 1);
                            Add(list.Value, this._top, temp_location, depth);
                        }
                    }

                    Add(addition, growth, location, depth);
                    return;
                }
            }
            else
            {
                Branch branch = node as Branch;
                int child_index = this.DetermineChildIndex(branch.PointOfDivision, location); // determine the child "index" (0 through 2^Dimensions) the addition belongs in
                Node child_node = branch[child_index];

                // null children in branches are just empty leaves
                if (child_node == null)
                {
                    Leaf new_leaf = new Leaf(DetermineChildBounds(branch, child_index), branch, child_index);
                    branch[child_index] = new_leaf;
                    new_leaf.Add(addition);
                }
                else
                    // child exists already, continue adding
                    Add(addition, child_node, location, depth + 1);

                branch.Count++;
                return;
            }
        }

        /// <summary>Determins the dimensions of the child at the given index.</summary>
        /// <param name="leaf">The parent of the node to compute dimensions for.</param>
        /// <param name="child">The index of the child to compute dimensions for.</param>
        /// <param name="median1">The computed minimum dimensions of the child node along the 1D axis.</param>
        /// <param name="median2">The computed minimum dimensions of the child node along the 2D axis.</param>
        /// <param name="median3">The computed minimum dimensions of the child node along the 3D axis.</param>
        private Omnitree.Vector<Axis1, Axis2> DetermineMedians(Leaf leaf)
        {
            try
            {
                // extract the values
                Axis1[] values1 = new Axis1[leaf.Count];
                Axis2[] values2 = new Axis2[leaf.Count];
                Leaf.Node for_current = leaf.Head; // used in for loop
                for (int i = 0; i < leaf.Count; i++, for_current = for_current.Next)
                    this._locate(for_current.Value, out values1[i], out values2[i]);
                // sort the values
                if (_defaultCompare1) Array.Sort(values1);
                else Array.Sort(values1, Compare.ToSystemComparison(this._compare1));
                if (_defaultCompare2) Array.Sort(values2);
                else Array.Sort(values2, Compare.ToSystemComparison(this._compare2));
                // pull out the lazy medians (if even # of items... just take the left)
                int index = (leaf.Count - 1) / 2;
                return new Omnitree.Vector<Axis1, Axis2>(values1[index], values2[index]);
            }
            catch (Exception exception)
            {
				System.Diagnostics.Debugger.Break();
                // extract the values
                IndexedBigArray<Axis1> values1 = new IndexedBigArray<Axis1>(leaf.Count);
                IndexedBigArray<Axis2> values2 = new IndexedBigArray<Axis2>(leaf.Count);
                Leaf.Node for_current = leaf.Head; // used in for loop
                for (int i = 0; i < leaf.Count; i++, for_current = for_current.Next)
                {
                    Axis1 value1;
                    Axis2 value2;
                    this._locate(for_current.Value, out value1, out value2);
                    values1[i] = value1;
                    values2[i] = value2;
                }
                // sort the values
                if (_defaultCompare1) Towel.Algorithms.Sort.Merge(Compare.Default, (int sorting_index) => { return values1[sorting_index]; }, (int sorting_index, Axis1 axis1) => { values1[sorting_index] = axis1; }, 0, (int)values1.Length);
                else Towel.Algorithms.Sort.Merge(_compare1, (int sorting_index) => { return values1[sorting_index]; }, (int sorting_index, Axis1 axis1) => { values1[sorting_index] = axis1; }, 0, (int)values1.Length);
                if (_defaultCompare2) Towel.Algorithms.Sort.Merge(Compare.Default, (int sorting_index) => { return values2[sorting_index]; }, (int sorting_index, Axis2 axis2) => { values2[sorting_index] = axis2; }, 0, (int)values1.Length);
                else Towel.Algorithms.Sort.Merge(_compare2, (int sorting_index) => { return values2[sorting_index]; }, (int sorting_index, Axis2 axis2) => { values2[sorting_index] = axis2; }, 0, (int)values1.Length);
                // pull out the lazy medians (if even # of items... just take the left)
                int index = (leaf.Count - 1) / 2;
                return new Omnitree.Vector<Axis1, Axis2>(values1[index], values2[index]);
            }
        }

        #endregion

        #region Add Helpers

        private Omnitree.Bounds<Axis1, Axis2> DetermineChildBounds(Branch branch, int child_index)
        {

            Omnitree.Bound<Axis2> min2, max2;
            if (child_index >= 2)
            {
                min2 = branch.PointOfDivision.Axis2;
                max2 = branch.Bounds.Max2;
                child_index -= 2;
            }
            else
            {
                min2 = branch.Bounds.Min2;
                max2 = branch.PointOfDivision.Axis2;
            }

            Omnitree.Bound<Axis1> min1, max1;
            if (child_index >= 1)
            {
                min1 = branch.PointOfDivision.Axis1;
                max1 = branch.Bounds.Max1;
                child_index -= 1;
            }
            else
            {
                min1 = branch.Bounds.Min1;
                max1 = branch.PointOfDivision.Axis1;
            }

            return new Omnitree.Bounds<Axis1, Axis2>(min1, max1, min2, max2);
        }

        #endregion

        #endregion

        #region Clear

        /// <summary>Returns the tree to an empty state.</summary>
        public void Clear()
        {
            this._top = new Leaf(Omnitree.Bounds<Axis1, Axis2>.None, null, -1);
			Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
        }

        #endregion

        #region Clone

        /// <summary>Creates a shallow clone of this data structure.</summary>
        /// <returns>A shallow clone of this data structure.</returns>
        public OmnitreePointsLinked<T, Axis1, Axis2> Clone()
        {
            return new OmnitreePointsLinked<T, Axis1, Axis2>(this);
        }

        #endregion

        #region Count

        /// <summary>Counts the number of items in a sub space.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
        /// <returns>The number of items in the provided sub space.</returns>
        public int CountSubSpace(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2)
        {
            return CountSubSpace(_top, new Omnitree.Bounds<Axis1, Axis2>(min1, max1, min2, max2));
        }
        /// <summary>Counts the number of items in a sub space.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
        /// <returns>The number of items in the provided sub space.</returns>
        public int CountSubSpace(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2)
        {
            return CountSubSpace(_top, new Omnitree.Bounds<Axis1, Axis2>(min1, max1, min2, max2));
        }
        /// <summary>Counts the number of items in a sub space.</summary>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
        /// <returns>The number of items in the provided sub space.</returns>
        public int CountSubSpace(Axis1 axis1, Axis2 axis2)
        {
            return CountSubSpace(_top, new Omnitree.Bounds<Axis1, Axis2>(axis1, axis1, axis2, axis2));
        }
        /// <summary>Counts the number of items in a sub space.</summary>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
        /// <returns>The number of items in the provided sub space.</returns>
        public int CountSubSpace(Omnitree.Bound<Axis1> axis1, Omnitree.Bound<Axis2> axis2)
        {
            return CountSubSpace(_top, new Omnitree.Bounds<Axis1, Axis2>(axis1, axis1, axis2, axis2));
        }
        /// <summary>Counts the number of items in a sub space.</summary>
        /// <param name="node">The current traversal node.</param>
        /// <returns>The number of items in the provided sub space.</returns>
        private int CountSubSpace(Node node, Omnitree.Bounds<Axis1, Axis2> bounds)
        {
            // adjust min/max values
            int count = 0;
            if (EncapsulationCheck(bounds, node.Bounds))
                count += node.Count;
            else if (node is Leaf)
            {
                for (Leaf.Node list = (node as Leaf).Head; list != null; list = list.Next)
                    if (EncapsulationCheck(bounds, LocateVector(list.Value)))
                        count++;
            }
            else
            {
                Branch branch = node as Branch;
                if (!StraddlesLines(branch.Bounds, branch.PointOfDivision))
                {
                    int child_index = DetermineChildIndex(branch.PointOfDivision, new Omnitree.Vector<Axis1, Axis2>(bounds.Min1.Value, bounds.Min2.Value));
                    Node child = branch[child_index];
                    if (child != null)
                      count += this.CountSubSpace(child, bounds);
                }
                else
                {
                    foreach (Node child in (node as Branch).Children)
                        count += this.CountSubSpace(child, bounds);
                }
            }
            return count;
        }

        #endregion

        #region Update

        /// <summary>Iterates through the entire tree and ensures each item is in the proper leaf.</summary>
        public void Update()
        {
            this.Update(this._top, 0);
        }

        /// <summary>Recursive version of the Update method.</summary>
        /// <param name="node">The current node of iteration.</param>
        /// <param name="depth">The current depth of iteration.</param>
        private int Update(Node node, int depth)
        {
            int removals = 0;

            if (node is Leaf)
            {
                Leaf leaf = node as Leaf;
                Leaf.Node current = leaf.Head;
                Leaf.Node previous = null;
                while (current != null)
                {
                    Omnitree.Vector<Axis1, Axis2> location = LocateVector(current.Value);
                    if (!this.EncapsulationCheck(node.Bounds, location))
                    {
                        removals++;
                        T updated = current.Value;
                        if (previous == null)
                        {
                            leaf.Head = current.Next;
                            goto HeadRemoved;
                        }
                        else
                            previous.Next = current.Next;

                        Node whereToAdd = GetEncapsulationParent(node.Parent, location);

                        if (whereToAdd == null)
                            throw new System.Exception("an item was updated outside the range of the omnitree");

                        this.Add(updated, whereToAdd, location, whereToAdd.Depth);
                    }
                    previous = current;
                HeadRemoved:
                    current = current.Next;
                }
                leaf.Count -= removals;
                return removals;
            }
            else
            {
                Branch branch = node as Branch;
                int skipped = 0;
                for (int i = 0; i + skipped < branch.Children.Length; )
                {
                    removals += this.Update(branch.Children[i], depth + 1);
                    if (branch.Children[i].Count == 0)
                        branch.Children[i] = branch.Children[branch.Children.Length - skipped++ - 1];
                    else
                        i++;
                }
                Node[] newArray = new Node[branch.Children.Length - skipped];
                Array.Copy(branch.Children, newArray, newArray.Length);
                branch.Children = newArray;

                branch.Count -= removals;

                if (branch.Count < _load && branch.Count != 0)
                    ShrinkChild(branch.Parent, branch.Index);
            }

            return removals;
        }

        /// <summary>Iterates through the provided dimensions and ensures each item is in the proper leaf.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
        public void Update(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2)
        {
            this.Update(new Omnitree.Bounds<Axis1, Axis2>(min1, max1, min2, max2), this._top, 0);
        }
        /// <summary>Iterates through the provided dimensions and ensures each item is in the proper leaf.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
        public void Update(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2)
        {
            this.Update(new Omnitree.Bounds<Axis1, Axis2>(min1, max1, min2, max2), this._top, 0);
        }
        /// <summary>Iterates through the provided dimensions and ensures each item is in the proper leaf.</summary>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
        public void Update(Axis1 axis1, Axis2 axis2)
        {
            this.Update(new Omnitree.Bounds<Axis1, Axis2>(axis1, axis1, axis2, axis2), this._top, 0);
        }
        /// <summary>Iterates through the provided dimensions and ensures each item is in the proper leaf.</summary>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
        public void Update(Omnitree.Bound<Axis1> axis1, Omnitree.Bound<Axis2> axis2)
        {
            this.Update(new Omnitree.Bounds<Axis1, Axis2>(axis1, axis1, axis2, axis2), this._top, 0);
        }
        private int Update(Omnitree.Bounds<Axis1, Axis2> bounds, Node node, int depth)
        {
            if (!InclusionCheck(bounds, node.Bounds))
                return 0;

            int removals = 0;

            if (node is Leaf)
            {
                Leaf leaf = node as Leaf;
                Leaf.Node current = leaf.Head;
                Leaf.Node previous = null;
                while (current != null)
                {
                    Omnitree.Vector<Axis1, Axis2> location = LocateVector(current.Value);
                    if (!this.EncapsulationCheck(node.Bounds, location))
                    {
                        removals++;
                        T updated = current.Value;
                        if (previous == null)
                        {
                            leaf.Head = current.Next;
                            goto HeadRemoved;
                        }
                        else
                            previous.Next = current.Next;
                        Node whereToAdd = GetEncapsulationParent(node.Parent, location);
                        if (whereToAdd == null)
                            throw new System.Exception("an item was updates outside the range of the omnitree");
                        this.Add(updated, whereToAdd, location, whereToAdd.Depth);
                    }
                    previous = current;
                HeadRemoved:
                    current = current.Next;
                }
                leaf.Count -= removals;
                return removals;
            }
            else
            {
                Branch branch = node as Branch;
                int skipped = 0;
                for (int i = 0; i + skipped < branch.Children.Length; )
                {
                    removals += this.Update(branch.Children[i], depth + 1);
                    if (branch.Children[i].Count == 0)
                        branch.Children[i] = branch.Children[branch.Children.Length - skipped++ - 1];
                    else
                        i++;
                }
                Node[] newArray = new Node[branch.Children.Length - skipped];
                Array.Copy(branch.Children, newArray, newArray.Length);
                branch.Children = newArray;

                branch.Count -= removals;

                if (branch.Count < _load && branch.Count != 0)
                    ShrinkChild(branch.Parent, branch.Index);
            }

            return removals;
        }

        #endregion

        #region Remove

        /// <summary>Removes all the items qualified by the delegate.</summary>
        /// <param name="where">The predicate to qualify removals.</param>
        public void Remove(Predicate<T> where)
        {
            this.Remove(this._top, where);
			Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
        }

        /// <summary>Recursive version of the remove method.</summary>
        /// <param name="node">The current node of traversal.</param>
        /// <param name="where">The predicate to qualify removals.</param>
        private int Remove(Node node, Predicate<T> where)
        {
            int removals = 0;
            if (node is Leaf)
            {
                Leaf leaf = node as Leaf;
                while (leaf.Head != null && where(leaf.Head.Value))
                {
                    leaf.Head = leaf.Head.Next;
                    removals++;
                }
                if (leaf.Head != null)
                {
                    Leaf.Node list = leaf.Head;
                    while (list.Next != null)
                    {
                        if (where(list.Next.Value))
                        {
                            list.Next = list.Next.Next;
                            removals++;
                        }
                    }
                }

                leaf.Count -= removals;
                return removals;
            }
            else
            {
                Branch branch = node as Branch;
                int skipped = 0;
                for (int i = 0; i + skipped < branch.Children.Length; )
                {
                    removals += this.Remove(branch.Children[i], where);
                    if (branch.Children[i].Count == 0)
                        branch.Children[i] = branch.Children[branch.Children.Length - skipped++ - 1];
                    else
                        i++;
                }
                Node[] newArray = new Node[branch.Children.Length - skipped];
                Array.Copy(branch.Children, newArray, newArray.Length);
                branch.Children = newArray;

                branch.Count -= removals;

                if (branch.Count < _load && branch.Count != 0)
                    ShrinkChild(branch.Parent, branch.Index);

                return removals;
            }
        }

        /// <summary>Removes all the items in a given space.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
        /// <returns>The number of items that were removed.</returns>
        public void Remove(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2)
        {
            this.Remove(this._top, new Omnitree.Bounds<Axis1, Axis2>(min1, max1, min2, max2));
            Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
        }
        /// <summary>Removes all the items in a given space.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
        /// <returns>The number of items that were removed.</returns>
        public void Remove(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2)
        {
            this.Remove(this._top, new Omnitree.Bounds<Axis1, Axis2>(min1, max1, min2, max2));
            Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
        }
        private int Remove(Node node, Omnitree.Bounds<Axis1, Axis2> bounds)
        {
            int removals = 0;
            if (InclusionCheck(bounds, node.Bounds))
            {
                if (node is Leaf)
                {
                    Leaf leaf = node as Leaf;
                    Leaf.Node current_node = leaf.Head;
                    Leaf.Node previous_node = null;
                    while (current_node != null)
                    {
                        Leaf.Node temp_previous = current_node;
                        if (EncapsulationCheck(bounds, LocateVector(current_node.Value)))
                        {
                            removals++;
                            if (current_node == leaf.Head)
                                leaf.Head = leaf.Head.Next;
                            else
                            {
                                previous_node.Next = current_node.Next;
                                temp_previous = previous_node;
                            }
                        }
                        previous_node = temp_previous;
                        current_node = current_node.Next;
                    }
                    leaf.Count -= removals;
                }
                else
                {
                    Branch branch = node as Branch;
                    int skipped = 0;
                    for (int i = 0; i + skipped < branch.Children.Length; )
                    {
                        removals += this.Remove(branch.Children[i], bounds);
                        if (branch.Children[i].Count == 0)
                            branch.Children[i] = branch.Children[branch.Children.Length - skipped++ - 1];
                        else
                            i++;
                    }
                    Node[] newArray = new Node[branch.Children.Length - skipped];
                    Array.Copy(branch.Children, newArray, newArray.Length);
                    branch.Children = newArray;

                    branch.Count -= removals;
                    // convert this branch back into a leaf
                    // Note: if count is zero, it will be chopped off
                    if (branch.Count < _load && branch.Count > 0)
                        ShrinkChild(branch.Parent, branch.Index);
                }
            }

            return removals;
        }

        /// <summary>Removes all the items in a given space validated by a predicate.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
        /// <param name="where">The equality constraint of the removal.</param>
        public void Remove(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Predicate<T> where)
        {
            this.Remove(this._top, new Omnitree.Bounds<Axis1, Axis2>(min1, max1, min2, max2), where);
            Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
        }
        /// <summary>Removes all the items in a given space validated by a predicate.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
        /// <param name="where">The equality constraint of the removal.</param>
        public void Remove(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Predicate<T> where)
        {
            this.Remove(this._top, new Omnitree.Bounds<Axis1, Axis2>(min1, max1, min2, max2), where);
			Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
        }
        private int Remove(Node node, Omnitree.Bounds<Axis1, Axis2> bounds, Predicate<T> where)
        {
            if (!InclusionCheck(node.Bounds, bounds))
                return 0;
            int removals = 0;
            if (node is Leaf)
            {
                Leaf leaf = node as Leaf;
                Leaf.Node current = leaf.Head;
                Leaf.Node previous = null;
                while (current != null)
                {
                    if (this.EncapsulationCheck(bounds, LocateVector(current.Value)) && where(current.Value))
                    {
                        removals++;
                        if (previous == null)
                        {
                            leaf.Head = current.Next;
                            goto HeadRemoved;
                        }
                        else
                            previous.Next = current.Next;
                    }
                    previous = current;
                HeadRemoved:
                    current = current.Next;
                }

                leaf.Count -= removals;
                return removals;
            }
            else
            {
                Branch branch = node as Branch;
                int skipped = 0;
                for (int i = 0; i + skipped < branch.Children.Length; )
                {
                    removals += this.Remove(branch.Children[i], bounds, where);
                    if (branch.Children[i].Count == 0)
                        branch.Children[i] = branch.Children[branch.Children.Length - skipped++ - 1];
                    else
                        i++;
                }
                Node[] newArray = new Node[branch.Children.Length - skipped];
                Array.Copy(branch.Children, newArray, newArray.Length);
                branch.Children = newArray;

                node.Count -= removals;

                if (node.Count < _load && node.Count != 0)
                    ShrinkChild(node.Parent, node.Index);

                return removals;
            }
        }

        /// <summary>Removes all instances of a given value.</summary>
        public void Remove(T removal)
        {
            Axis1 axis1;
            Axis2 axis2;
            this._locate(removal, out axis1, out axis2);
            this.Remove(axis1, axis2, (T item) => { return this._equate(item, removal); });
        }
        /// <summary>Removes all the items in a given space.</summary>
        /// <param name="axis1">The axis of the removal along the  1D axis.</param>
		/// <param name="axis2">The axis of the removal along the  2D axis.</param>
        /// <returns>The number of items that were removed.</returns>
        public void Remove(Axis1 axis1, Axis2 axis2)
        {
            this.Remove(this._top, new Omnitree.Vector<Axis1, Axis2>(axis1, axis2));
            Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
        }
        private int Remove(Node node, Omnitree.Vector<Axis1, Axis2> vector)
        {
            int removals = 0;
            if (node is Leaf)
            {
                Leaf leaf = node as Leaf;
                Leaf.Node current_node = leaf.Head;
                Leaf.Node previous_node = null;
                while (current_node != null)
                {
                    Leaf.Node temp_previous = current_node;
                    if (EqualsCheck(vector, LocateVector(current_node.Value)))
                    {
                        removals++;
                        if (current_node == leaf.Head)
                            leaf.Head = leaf.Head.Next;
                        else
                        {
                            previous_node.Next = current_node.Next;
                            temp_previous = previous_node;
                        }
                    }
                    previous_node = temp_previous;
                    current_node = current_node.Next;
                }
                leaf.Count -= removals;
            }
            else
            {
                Branch branch = node as Branch;
                int child_index = DetermineChildIndex(branch.PointOfDivision, vector);
                removals += Remove(branch[child_index], vector);
                branch.Count -= removals;
                // convert this branch back into a leaf
                // Note: if count is zero, it will be chopped off
                if (branch.Count < _load && branch.Count > 0)
                    ShrinkChild(branch.Parent, branch.Index);
            }

            return removals;
        }

        /// <summary>Removes all the items in a given space validated by a predicate.</summary>
        /// <param name="axis1">The axis of the removal along the  1D axis.</param>
		/// <param name="axis2">The axis of the removal along the  2D axis.</param>
        /// <param name="where">The equality constraint of the removal.</param>
        public void Remove(Axis1 axis1, Axis2 axis2, Predicate<T> where)
        {
            this.Remove(this._top, new Omnitree.Vector<Axis1, Axis2>(axis1, axis2), where);
            Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
        }
        private int Remove(Node node, Omnitree.Vector<Axis1, Axis2> vector, Predicate<T> where)
        {
            int removals = 0;
            if (node is Leaf)
            {
                Leaf leaf = node as Leaf;
                Leaf.Node current_node = leaf.Head;
                Leaf.Node previous_node = null;
                while (current_node != null)
                {
                    Leaf.Node temp_previous = current_node;
                    if (EqualsCheck(vector, LocateVector(current_node.Value)) && where(current_node.Value))
                    {
                        removals++;
                        if (current_node == leaf.Head)
                            leaf.Head = leaf.Head.Next;
                        else
                        {
                            previous_node.Next = current_node.Next;
                            temp_previous = previous_node;
                        }
                    }
                    previous_node = temp_previous;
                    current_node = current_node.Next;
                }
                leaf.Count -= removals;
            }
            else
            {
                Branch branch = node as Branch;
                int child_index = DetermineChildIndex(branch.PointOfDivision, vector);
                removals += Remove(branch[child_index], vector, where);
                branch.Count -= removals;
                // convert this branch back into a leaf
                // Note: if count is zero, it will be chopped off
                if (branch.Count < _load && branch.Count > 0)
                    ShrinkChild(branch.Parent, branch.Index);
            }
            return removals;
        }

        #endregion

        #region Stepper And IEnumerable

        /// <summary>Traverses every item in the tree and performs the delegate in them.</summary>
        /// <param name="function">The delegate to perform on every item in the tree.</param>
        public void Stepper(Step<T> function)
        {
            this.Stepper(function, this._top);
        }
        private void Stepper(Step<T> function, Node node)
        {
            if (node is Leaf)
            {
                Leaf.Node list = (node as Leaf).Head;
                while (list != null)
                {
                    function(list.Value);
                    list = list.Next;
                }
            }
            else
            {
                foreach (Node child in (node as Branch).Children)
                    this.Stepper(function, child);
            }
        }

        /// <summary>Traverses every item in the tree and performs the delegate in them.</summary>
        /// <param name="function">The delegate to perform on every item in the tree.</param>
        public StepStatus Stepper(StepBreak<T> function)
        {
            return Stepper(function, _top);
        }
        private StepStatus Stepper(StepBreak<T> function, Node node)
        {
            StepStatus status = StepStatus.Continue;
            if (node is Leaf)
            {
                for (Leaf.Node list = (node as Leaf).Head; list != null; list = list.Next)
                    if ((status = function(list._value)) != StepStatus.Continue)
                        break;
            }
            else
            {
                foreach (Node child in (node as Branch).Children)
                    if ((status = Stepper(function, child)) != StepStatus.Continue)
                        break;
            }
            return status;
        }

        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="function">The delegate to perform on all items in the tree within the given bounds.</param>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
        public void Stepper(Step<T> function, Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2)
        {
            Stepper(function, _top, new Omnitree.Bounds<Axis1, Axis2>(min1, max1, min2, max2));
        }
        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="function">The delegate to perform on all items in the tree within the given bounds.</param>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
        public void Stepper(Step<T> function, Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2)
        {
            Stepper(function, _top, new Omnitree.Bounds<Axis1, Axis2>(min1, max1, min2, max2));
        }
        private void Stepper(Step<T> function, Node node, Omnitree.Bounds<Axis1, Axis2> bounds)
        {
            if (node is Leaf)
            {
                for (Leaf.Node list = (node as Leaf).Head; list != null; list = list.Next)
                    if (EncapsulationCheck(bounds, LocateVector(list.Value)))
                        function(list.Value);
            }
            else
            {
                foreach (Node child in (node as Branch).Children)
                    // optimization: stop bounds checking if space encapsulates node
                    if (EncapsulationCheck(bounds, child.Bounds))
                        this.Stepper(function, child);
                    else if (InclusionCheck(child.Bounds, bounds))
                        this.Stepper(function, child, bounds);
            }
        }

        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
        public StepStatus Stepper(StepBreak<T> function, Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2)
        {
            return Stepper(function, _top, new Omnitree.Bounds<Axis1, Axis2>(min1, max1, min2, max2));
        }
        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
        public StepStatus Stepper(StepBreak<T> function, Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2)
        {
            return Stepper(function, _top, new Omnitree.Bounds<Axis1, Axis2>(min1, max1, min2, max2));
        }
        private StepStatus Stepper(StepBreak<T> function, Node node, Omnitree.Bounds<Axis1, Axis2> bounds)
        {
            StepStatus status = StepStatus.Continue;
            if (node is Leaf)
            {
                for (Leaf.Node list = (node as Leaf).Head; list != null; list = list.Next)
                    if (EncapsulationCheck(bounds, LocateVector(list.Value)) &&
                        (status = function(list.Value)) != StepStatus.Continue)
                        break;
            }
            else
            {
                foreach (Node child in (node as Branch).Children)
                    // optimization: stop bounds checking if space encapsulates node
                    if (EncapsulationCheck(bounds, child.Bounds) &&
                        (status = this.Stepper(function, child)) != StepStatus.Continue)
                        break;
                    else if (!InclusionCheck(child.Bounds, bounds) &&
                        (status = this.Stepper(function, child, bounds)) != StepStatus.Continue)
                        break;
            }
            return status;
        }

        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="axis1">The axis of the removal along the  1D axis.</param>
		/// <param name="axis2">The axis of the removal along the  2D axis.</param>
        public void Stepper(Step<T> function, Axis1 axis1, Axis2 axis2)
        {
            Stepper(function, _top, new Omnitree.Vector<Axis1, Axis2>(axis1, axis2));
        }
        private void Stepper(Step<T> function, Node node, Omnitree.Vector<Axis1, Axis2> vector)
        {
            Node current = node;
            while (current != null)
            {
                if (current is Leaf)
                {
                    for (Leaf.Node leaf_node = (current as Leaf).Head; leaf_node != null; leaf_node = leaf_node.Next)
                        if (EqualsCheck(vector, LocateVector(leaf_node.Value)))
                            function(leaf_node.Value);
                    break;
                }
                else
                {
                    Branch branch = current as Branch;
                    int child_index = DetermineChildIndex(branch.PointOfDivision, vector);
                    current = branch[child_index];
                }
            }
        }

        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="function">The delegate to perform on all items in the tree within the given bounds.</param>
        /// <param name="axis1">The axis of the removal along the  1D axis.</param>
		/// <param name="axis2">The axis of the removal along the  2D axis.</param>
        public StepStatus Stepper(StepBreak<T> function, Axis1 axis1, Axis2 axis2)
        {
            return Stepper(function, _top, new Omnitree.Vector<Axis1, Axis2>(axis1, axis2));
        }
        private StepStatus Stepper(StepBreak<T> function, Node node, Omnitree.Vector<Axis1, Axis2> vector)
        {
            Node current = node;
            while (current != null)
            {
                if (current is Leaf)
                {
                    for (Leaf.Node list = (current as Leaf).Head; list != null; list = list.Next)
                    {
                        StepStatus status = StepStatus.Continue;
                        if (EqualsCheck(vector, LocateVector(list.Value)) &&
                            (status = function(list.Value)) != StepStatus.Continue)
                            return status;
                    }
                }
                else
                {
                    Branch branch = current as Branch;
                    int child_index = DetermineChildIndex(branch.PointOfDivision, vector);
                    current = branch[child_index];
                }
            }
            return StepStatus.Continue;
        }

        /// <summary>FOR COMPATIBILITY ONLY. AVOID IF POSSIBLE.</summary>
        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
        {
            throw new System.NotImplementedException();
            //return (this.ToArray() as System.Collections.Generic.IEnumerable<T>).GetEnumerator();
        }

        /// <summary>FOR COMPATIBILITY ONLY. AVOID IF POSSIBLE.</summary>
        System.Collections.Generic.IEnumerator<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator()
        {
            throw new System.NotImplementedException();
            //return (this.ToArray() as System.Collections.Generic.IEnumerable<T>).GetEnumerator();
        }

        #endregion

        #region Helpers

        private bool StraddlesLines(Omnitree.Bounds<Axis1, Axis2> bounds, Omnitree.Vector<Axis1, Axis2> vector)
        {
			if ((!bounds.Min1.Exists || (bounds.Min1.Exists && this._compare1(bounds.Min1.Value, vector.Axis1) != Comparison.Greater)) &&
				(!bounds.Max1.Exists || (bounds.Max1.Exists && this._compare1(bounds.Max1.Value, vector.Axis1) != Comparison.Less)))
				return true;
			if ((!bounds.Min2.Exists || (bounds.Min2.Exists && this._compare2(bounds.Min2.Value, vector.Axis2) != Comparison.Greater)) &&
				(!bounds.Max2.Exists || (bounds.Max2.Exists && this._compare2(bounds.Max2.Value, vector.Axis2) != Comparison.Less)))
				return true;
            return false;
        }

        /// <summary>Computes the child index that contains the desired dimensions.</summary>
        /// <param name="node">The branch .</param>
        /// <param name="vector">The dimensions to determine the child index.</param>
        /// <returns>The computed child index based on the coordinates relative to the center of the node.</returns>
        private int DetermineChildIndex(Omnitree.Vector<Axis1, Axis2> pointOfDivision, Omnitree.Vector<Axis1, Axis2> vector)
        {
            int child = 0;
            if (!(this._compare1(vector.Axis1, pointOfDivision.Axis1) == Comparison.Less))
                child += 1 << 0;
            if (!(this._compare2(vector.Axis2, pointOfDivision.Axis2) == Comparison.Less))
                child += 1 << 1;
            return child;
        }

        /// <summary>Converts a branch back into a leaf when the count is reduced.</summary>
        /// <param name="parent">The parent to shrink a child of.</param>
        /// <param name="child">The index of the child to shrink.</param>
        private void ShrinkChild(Branch parent, int child_index)
        {
            Leaf leaf;
            Node removal = null;
            if (parent == null) // top of tree
            {
                removal = this._top;
                leaf = new Leaf(Omnitree.Bounds<Axis1, Axis2>.None, null, -1);
                this._top = leaf;
            }
            else // non-top branch
            {
                removal = parent[child_index];
                leaf = new Leaf(removal.Bounds, removal.Parent, removal.Index);
                parent[child_index] = leaf;
            }

            this.Stepper((T step) => { leaf.Add(step); }, removal);
        }

        /// <summary>Reduces the counts of all the parents of a given node by a given amount.</summary>
        /// <param name="parent">The starting parent of the reduction.</param>
        /// <param name="reduction">The amount to reduce the parent counts by.</param>
        private void ReduceParentCounts(Node parent, int reduction)
        {
            IncreaseParentCounts(parent, -reduction);
        }

        /// <summary>Increases the counts of all the parents of a given node by a given amount.</summary>
        /// <param name="parent">The starting parent of the increase.</param>
        /// <param name="increase">The amount to increase the parent counts by.</param>
        private void IncreaseParentCounts(Node parent, int increase)
        {
            Node looper = parent;
            while (looper != null)
            {
                looper.Count += increase;
                looper = looper.Parent;
            }
        }

        /// <summary>Checks a node for inclusion (overlap) between two bounds.</summary>
        /// <returns>True if the spaces overlap; False if not.</returns>
        private bool InclusionCheck(Omnitree.Bounds<Axis1, Axis2> a, Omnitree.Bounds<Axis1, Axis2> b)
        {

            if (a.Max1.Exists && b.Min1.Exists && this._compare1(a.Max1.Value, b.Min1.Value) == Comparison.Less)
                return false;
            else if (a.Min1.Exists && b.Max1.Exists && this._compare1(a.Min1.Value, b.Max1.Value) == Comparison.Greater)
                return false;

            if (a.Max2.Exists && b.Min2.Exists && this._compare2(a.Max2.Value, b.Min2.Value) == Comparison.Less)
                return false;
            else if (a.Min2.Exists && b.Max2.Exists && this._compare2(a.Min2.Value, b.Max2.Value) == Comparison.Greater)
                return false;

            return true;
        }

        /// <summary>Checks if a space encapsulates a point.</summary>
        /// <returns>True if the space encapsulates the point; False if not.</returns>
        private bool EncapsulationCheck(Omnitree.Bounds<Axis1, Axis2> bounds, Omnitree.Vector<Axis1, Axis2> vector)
        {
            // if the location is not outside the bounds, it must be inside

            if (bounds.Min1.Exists && this._compare1(vector.Axis1, bounds.Min1.Value) == Comparison.Less)
                return false;
            else if (bounds.Max1.Exists && this._compare1(vector.Axis1, bounds.Max1.Value) == Comparison.Greater)
                return false;

            if (bounds.Min2.Exists && this._compare2(vector.Axis2, bounds.Min2.Value) == Comparison.Less)
                return false;
            else if (bounds.Max2.Exists && this._compare2(vector.Axis2, bounds.Max2.Value) == Comparison.Greater)
                return false;

            return true;
        }

        /// <summary>Checks if a space (left) encapsulates another space (right).</summary>
        /// <returns>True if the left space encapsulates the right; False if not.</returns>
        private bool EncapsulationCheck(Omnitree.Bounds<Axis1, Axis2> a, Omnitree.Bounds<Axis1, Axis2> b)
        {
            if ((a.Min1.Exists && !b.Min1.Exists) || (a.Min2.Exists && !b.Min2.Exists))
                return false;
			if ((a.Max1.Exists && !b.Max1.Exists) || (a.Max2.Exists && !b.Max2.Exists))
                return false;

            if (b.Min1.Exists && a.Min1.Exists && this._compare1(a.Min1.Value, b.Min1.Value) != Comparison.Less)
                return false;
            if (b.Max1.Exists && a.Max1.Exists && this._compare1(a.Max1.Value, b.Max1.Value) != Comparison.Greater)
                return false;

            if (b.Min2.Exists && a.Min2.Exists && this._compare2(a.Min2.Value, b.Min2.Value) != Comparison.Less)
                return false;
            if (b.Max2.Exists && a.Max2.Exists && this._compare2(a.Max2.Value, b.Max2.Value) != Comparison.Greater)
                return false;

            return true;
        }

        /// <summary>Checks for equality between two locations.</summary>
        /// <returns>True if equal; False if not;</returns>
        private bool EqualsCheck(Omnitree.Vector<Axis1, Axis2> a, Omnitree.Vector<Axis1, Axis2> b)
        {

            if (!this._equate1(a.Axis1, b.Axis1))
                return false;

            if (!this._equate2(a.Axis2, b.Axis2))
                return false;

            return true;
        }

        /// <summary>Gets the nearest parent that encapsulates a location.</summary>
        /// <param name="node">The starting node to find the encapsulating parent of the location.</param>
        /// <param name="coordinate1">The coordinate along the 1D axis.</param>
        /// <param name="coordinate2">The coordinate along the 2D axis.</param>
        /// <param name="coordinate3">The coordinate along the 3D axis.</param>
        /// <returns>The nearest node that encapsulates the given location.</returns>
        private Node GetEncapsulationParent(Node node, Omnitree.Vector<Axis1, Axis2> vector)
        {
            while (node != null && !EncapsulationCheck(node.Bounds, vector))
                node = node.Parent;
            return node;
        }

        private Omnitree.Vector<Axis1, Axis2> LocateVector(T value)
        {
            Axis1 axis1;
            Axis2 axis2;
            this._locate(value, out axis1, out axis2);
            return new Omnitree.Vector<Axis1, Axis2>(axis1, axis2);
        }

        #endregion

        #endregion
    }

    #endregion

    #region 3 Dimensional

    public interface IOmnitreePoints<T, Axis1, Axis2, Axis3> : IDataStructure<T>,
            DataStructure.ICountable,
            DataStructure.IAddable<T>,
            DataStructure.IClearable,
            DataStructure.IRemovable<T>,
            DataStructure.IEquating<T>
    {
        #region Properties

        /// <summary>Steps through the values at a given location.</summary>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
        /// <returns>A Stepper of the items at the given coordinates.</returns>
        Stepper<T> this[Axis1 axis1, Axis2 axis2, Axis3 axis3] { get; }
        /// <summary>The number of dimensions in this tree.</summary>
        int Dimensions { get; }

        #endregion

        #region Methods

        /// <summary>Counts the number of items in a sub space.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
        /// <returns>The number of items in the provided sub space.</returns>
        int CountSubSpace(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3);

        /// <summary>Iterates through the entire tree and ensures each item is in the proper leaf.</summary>
        void Update();
        /// <summary>Iterates through the provided dimensions and ensures each item is in the proper leaf.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
        void Update(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3);

        /// <summary>Removes all the items in a given space.</summary>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
        void Remove(Axis1 axis1, Axis2 axis2, Axis3 axis3);
        /// <summary>Removes all the items in a given space.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
        void Remove(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3);
        /// <summary>Removes all the items in a given space where equality is met.</summary>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
        /// <param name="where">The equality constraint of the removal.</param>
        void Remove(Axis1 axis1, Axis2 axis2, Axis3 axis3, Predicate<T> where);
        /// <summary>Removes all the items in a given space where predicate is met.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
        /// <param name="where">The predicate constraint of the removal.</param>
        void Remove(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Predicate<T> where);

        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="step">The step function to perform on all items in the tree within the given bounds.</param>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
        void Stepper(Step<T> step, Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3);
        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="step">The step function to perform on all items in the tree within the given bounds.</param>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
        StepStatus Stepper(StepBreak<T> step, Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3);
        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="step">The step function to perform on all items in the tree within the given bounds.</param>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
        void Stepper(Step<T> step, Axis1 axis1, Axis2 axis2, Axis3 axis3);
        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="step">The step function to perform on all items in the tree within the given bounds.</param>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
        StepStatus Stepper(StepBreak<T> function, Axis1 axis1, Axis2 axis2, Axis3 axis3);

        #endregion
    }

    public class OmnitreePointsLinked<T, Axis1, Axis2, Axis3> : IOmnitreePoints<T, Axis1, Axis2, Axis3>
    {
        private const int _dimensions = 3;
        internal static int _children_per_node = (int)BigInteger.Pow(2, 3);

        private Node _top;

		private int _naturalLogLower = 1; // caching the next time to calculate loads (lower count)
		private int _naturalLogUpper = -1; // caching the next time to calculate loads (upper count)
		private int _load; // ln(count); min = _defaultLoad
        private Omnitree.Location<T, Axis1, Axis2, Axis3> _locate;

        private bool _defaultEquate;
        private Equate<T> _equate;


        private bool _defaultEquate1;
        private Equate<Axis1> _equate1;

        private bool _defaultEquate2;
        private Equate<Axis2> _equate2;

        private bool _defaultEquate3;
        private Equate<Axis3> _equate3;



        private bool _defaultCompare1;
        private Compare<Axis1> _compare1;

        private bool _defaultCompare2;
        private Compare<Axis2> _compare2;

        private bool _defaultCompare3;
        private Compare<Axis3> _compare3;


        // allows median overriding for custom optimizations (USE AT YOUR OWN RISK)
        private Omnitree.SubdivisionOverride<T, Axis1, Omnitree.Bounds<Axis1, Axis2, Axis3>> _subdivisionOverride1;
        private Omnitree.SubdivisionOverride<T, Axis2, Omnitree.Bounds<Axis1, Axis2, Axis3>> _subdivisionOverride2;
        private Omnitree.SubdivisionOverride<T, Axis3, Omnitree.Bounds<Axis1, Axis2, Axis3>> _subdivisionOverride3;

        #region Nested Types

        /// <summary>Can be a leaf or a branch.</summary>
        public abstract class Node
        {
            internal Omnitree.Bounds<Axis1, Axis2, Axis3> _bounds;
            internal Branch _parent;
            internal int _index;
            internal int _count;

            /// <summary>The parent of this node.</summary>
            public Omnitree.Bounds<Axis1, Axis2, Axis3> Bounds { get { return this._bounds; } }
            /// <summary>The parent of this node.</summary>
            public Branch Parent { get { return this._parent; } }
            /// <summary>The computed child index of this node (see the "Notes" region in "Omnitree.cs" for the algorithm.</summary>
            public int Index { get { return this._index; } }
            /// <summary>The number of elements stored in this node and its children.</summary>
            public int Count { get { return this._count; } set { this._count = value; } }

            /// <summary>The depth this node is located in the Omnitree.</summary>
            public int Depth
            {
                get
                {
                    int depth = -1;
                    for (Node looper = this; looper != null; looper = looper.Parent)
                        depth++;
                    return depth;
                }
            }

            /// <summary>Constructs a node.</summary>
            /// <param name="bounds">The bounds of this node.</param>
            /// <param name="parent">The parent of this node.</param>
            /// <param name="index">The number of elements stored in this node and its children.</param>
            public Node(Omnitree.Bounds<Axis1, Axis2, Axis3> bounds, Branch parent, int index)
            {
                this._bounds = bounds;
                this._parent = parent;
                this._index = index;
            }

            internal Node(Node nodeToClone)
            {
                this._bounds = nodeToClone._bounds;
                this._parent = nodeToClone._parent;
                this._index = nodeToClone._index;
                this._count = nodeToClone._count;
            }

            internal abstract Node Clone();
        }

        /// <summary>A branch in the tree. Only contains nodes.</summary>
        public class Branch : Node
        {
            private Node[] _children;
            private Omnitree.Vector<Axis1, Axis2, Axis3> _pointOfDivision;

            public Node[] Children { get { return this._children; } set { this._children = value; } }
            public Omnitree.Vector<Axis1, Axis2, Axis3> PointOfDivision { get { return this._pointOfDivision; } internal set { this._pointOfDivision = value; } }
            
            /// <summary>Gets child by index.</summary>
            /// <param name="child_index">The index of the child to get.</param>
            /// <returns>The child of the given index or null if non-existent.</returns>
            public Node this[int child_index]
            {
                get
                {
                    if (this._children == null)
                        return null;
                    if (this._children.Length == OmnitreePointsLinked<T, Axis1, Axis2, Axis3>._children_per_node)
                        return this._children[(int)child_index];
                    foreach (Node node in this._children)
                        if (node.Index == child_index)
                            return node;
                    return null;
                }
                set
                {
                    // This error check should be unnecessary... but fuck it... might as well
                    if (value.Index != child_index)
                        throw new System.Exception("Bug in Omnitree (index/property mis-match when setting a child on a branch)");

                    // no children yet
                    if (this._children == null)
                    {
                        this._children = new Node[] { value };
                        return;
                    }
                    // max children overwrite
                    else if (this._children.Length == OmnitreePointsLinked<T, Axis1, Axis2, Axis3>._children_per_node)
                    {
                        this._children[(int)child_index] = value;
                        return;
                    }
                    // non-max child overwrite
                    for (int i = 0; i < this._children.Length; i++)
                        if (this._children[i].Index == child_index)
                        {
                            this._children[i] = value;
                            return;
                        }
                    // new child
                    Node[] newArray = new Node[this._children.Length + 1];
                    if (newArray.Length == OmnitreePointsLinked<T, Axis1, Axis2, Axis3>._children_per_node)
                    {
                        // new child resulting in a max children branch (sorting required)
                        for (int i = 0; i < this._children.Length; i++)
                        {
                            newArray[(int)this._children[i]._index] = this._children[i];
                        }
                        newArray[(int)value._index] = value;
                    }
                    else
                    {
                        // new child resulting in a non-max children branch
                        Array.Copy(this._children, newArray, this._children.Length);
                        newArray[newArray.Length - 1] = value;
                    }
                    this._children = newArray;
                }
            }

            public Branch(Omnitree.Vector<Axis1, Axis2, Axis3> pointOfDivision, Omnitree.Bounds<Axis1, Axis2, Axis3> bounds, Branch parent, int index)
                : base(bounds, parent, index)
            {
                this._pointOfDivision = pointOfDivision;
            }

            public Branch(Branch branchToClone)
                : base(branchToClone)
            {
                this._children = branchToClone._children.Clone() as Node[];
                this._pointOfDivision = branchToClone._pointOfDivision;
            }

            internal override Node Clone()
            {
                return new Branch(this);
            }
        }

        /// <summary>A branch in the tree. Only contains items.</summary>
        public class Leaf : Node
        {
            public class Node
            {
                internal T _value;
                internal Leaf.Node _next;

                public T Value { get { return _value; } set { _value = value; } }
                public Leaf.Node Next { get { return _next; } set { _next = value; } }

                public Node(T value, Leaf.Node next)
                {
                    _value = value;
                    _next = next;
                }
            }

            private Leaf.Node _head;

            public Leaf.Node Head { get { return this._head; } set { this._head = value; } }

            internal Leaf(Omnitree.Bounds<Axis1, Axis2, Axis3> bounds, Branch parent, int index)
                : base(bounds, parent, index)
            { }

            internal Leaf(Leaf leafToClone)
                : base(leafToClone)
            {
                this._head = new Node(leafToClone._head.Value, null);

                Node this_looper = this._head;
                Node other_looper = leafToClone._head;

                while (other_looper != null)
                {
                    this_looper.Next = new Node(other_looper.Next.Value, null);
                    this_looper = this_looper.Next;
                    other_looper = other_looper.Next;
                }
            }

            public void Add(T addition)
            {
                this._head = new Leaf.Node(addition, this._head);
                this.Count++;
            }

            internal override OmnitreePointsLinked<T, Axis1, Axis2, Axis3>.Node Clone()
            {
                return new Leaf(this);
            }
        }

        #endregion

        #region Constructors

        /// <summary>This constructor is for cloning purposes</summary>
        private OmnitreePointsLinked(OmnitreePointsLinked<T, Axis1, Axis2, Axis3> omnitree)
        {
            this._top = omnitree._top.Clone();
            this._load = omnitree._load;
            this._locate = omnitree._locate;
            this._defaultEquate = omnitree._defaultEquate;
            this._equate = omnitree._equate;

            this._defaultEquate1 = omnitree._defaultEquate1;
            this._equate1 = omnitree._equate1;
            this._defaultEquate2 = omnitree._defaultEquate2;
            this._equate2 = omnitree._equate2;
            this._defaultEquate3 = omnitree._defaultEquate3;
            this._equate3 = omnitree._equate3;

            this._defaultCompare1 = omnitree._defaultCompare1;
            this._compare1 = omnitree._compare1;
            this._defaultCompare2 = omnitree._defaultCompare2;
            this._compare2 = omnitree._compare2;
            this._defaultCompare3 = omnitree._defaultCompare3;
            this._compare3 = omnitree._compare3;

            this._subdivisionOverride1 = omnitree._subdivisionOverride1;
            this._subdivisionOverride2 = omnitree._subdivisionOverride2;
            this._subdivisionOverride3 = omnitree._subdivisionOverride3;
        }

        private OmnitreePointsLinked(
            Omnitree.Location<T, Axis1, Axis2, Axis3> locate,

            bool defaultEquate,
            Equate<T> equate,

            bool defaultEquate1,
            Equate<Axis1> equateAxis1,
            bool defaultEquate2,
            Equate<Axis2> equateAxis2,
            bool defaultEquate3,
            Equate<Axis3> equateAxis3,

            bool defaultCompare1,
            Compare<Axis1> compare1,
            bool defaultCompare2,
            Compare<Axis2> compare2,
            bool defaultCompare3,
            Compare<Axis3> compare3,

            Omnitree.SubdivisionOverride<T, Axis1, Omnitree.Bounds<Axis1, Axis2, Axis3>> subdivisionOverride1,
            Omnitree.SubdivisionOverride<T, Axis2, Omnitree.Bounds<Axis1, Axis2, Axis3>> subdivisionOverride2,
            Omnitree.SubdivisionOverride<T, Axis3, Omnitree.Bounds<Axis1, Axis2, Axis3>> subdivisionOverride3)
        {
			if (locate == null)
			{
				throw new ArgumentNullException(nameof(locate));
			}
			if (equate == null)
			{
				throw new ArgumentNullException(nameof(equate));
			}

			if (equateAxis1 == null)
			{
				throw new ArgumentNullException(nameof(equateAxis1));
			}
			if (equateAxis2 == null)
			{
				throw new ArgumentNullException(nameof(equateAxis2));
			}
			if (equateAxis3 == null)
			{
				throw new ArgumentNullException(nameof(equateAxis3));
			}

			if (compare1 == null)
			{
				throw new ArgumentNullException(nameof(compare1));
			}
			if (compare2 == null)
			{
				throw new ArgumentNullException(nameof(compare2));
			}
			if (compare3 == null)
			{
				throw new ArgumentNullException(nameof(compare3));
			}

            this._locate = locate;
            this._defaultEquate = defaultEquate;
            this._equate = equate;

            this._defaultEquate1 = defaultEquate1;
            this._equate1 = equateAxis1;
            this._defaultEquate2 = defaultEquate2;
            this._equate2 = equateAxis2;
            this._defaultEquate3 = defaultEquate3;
            this._equate3 = equateAxis3;

            this._defaultCompare1 = defaultCompare1;
            this._compare1 = compare1;
            this._defaultCompare2 = defaultCompare2;
            this._compare2 = compare2;
            this._defaultCompare3 = defaultCompare3;
            this._compare3 = compare3;

            this._subdivisionOverride1 = subdivisionOverride1;
            this._subdivisionOverride2 = subdivisionOverride2;
            this._subdivisionOverride3 = subdivisionOverride3;

            this._top = new Leaf(Omnitree.Bounds<Axis1, Axis2, Axis3>.None, null, -1);
            Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
        }

        private OmnitreePointsLinked(
            Omnitree.Location<T, Axis1, Axis2, Axis3> locate,
            Equate<T> equate,

            Equate<Axis1> equateAxis1,
            Equate<Axis2> equateAxis2,
            Equate<Axis3> equateAxis3,

            Compare<Axis1> compare1,
            Compare<Axis2> compare2,
            Compare<Axis3> compare3,

            Omnitree.SubdivisionOverride<T, Axis1, Omnitree.Bounds<Axis1, Axis2, Axis3>> subdivisionOverride1,
            Omnitree.SubdivisionOverride<T, Axis2, Omnitree.Bounds<Axis1, Axis2, Axis3>> subdivisionOverride2,
            Omnitree.SubdivisionOverride<T, Axis3, Omnitree.Bounds<Axis1, Axis2, Axis3>> subdivisionOverride3)
            : this(
            locate,

            false,
            equate,

            false,
            equateAxis1,
            false,
            equateAxis2,
            false,
            equateAxis3,

            false,
            compare1,
            false,
            compare2,
            false,
            compare3,

            subdivisionOverride1,
            subdivisionOverride2,
            subdivisionOverride3)
        { }

        public OmnitreePointsLinked(
            Omnitree.Location<T, Axis1, Axis2, Axis3> locate,

            Equate<T> equate,

            Equate<Axis1> equateAxis1,
            Equate<Axis2> equateAxis2,
            Equate<Axis3> equateAxis3,

            Compare<Axis1> compare1,
            Compare<Axis2> compare2,
            Compare<Axis3> compare3)
            : this(
                locate,

                false,
                equate,

                false,
                equateAxis1,
                false,
                equateAxis2,
                false,
                equateAxis3,

                false,
                compare1,
                false,
                compare2,
                false,
                compare3,

                null,
                null,
                null)
        { }



        public OmnitreePointsLinked(
            Omnitree.Location<T, Axis1, Axis2, Axis3> locate,

            Equate<T> equate,

            Compare<Axis1> compare1,
            Compare<Axis2> compare2,
            Compare<Axis3> compare3)
            : this(
                locate,
                false,
                equate,

                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,

                false,
                compare1,
                false,
                compare2,
                false,
                compare3,

                null,
                null,
                null)
        { }

        public OmnitreePointsLinked(
            Omnitree.Location<T, Axis1, Axis2, Axis3> locate,
            Equate<T> equate,

            Compare<Axis1> compare1,
            Compare<Axis2> compare2,
            Compare<Axis3> compare3,

            Omnitree.SubdivisionOverride<T, Axis1, Omnitree.Bounds<Axis1, Axis2, Axis3>> subdivisionOverride1,
            Omnitree.SubdivisionOverride<T, Axis2, Omnitree.Bounds<Axis1, Axis2, Axis3>> subdivisionOverride2,
            Omnitree.SubdivisionOverride<T, Axis3, Omnitree.Bounds<Axis1, Axis2, Axis3>> subdivisionOverride3)
            : this(
                locate,

                false,
                equate,

                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,

                false,
                compare1,
                false,
                compare2,
                false,
                compare3,

                subdivisionOverride1,
                subdivisionOverride2,
                subdivisionOverride3)
        { }

        public OmnitreePointsLinked(
            Omnitree.Location<T, Axis1, Axis2, Axis3> locate,

            Compare<Axis1> compare1,
            Compare<Axis2> compare2,
            Compare<Axis3> compare3)
            : this(
                locate,
                true,
                Towel.Equate.Default,

                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,

                false,
                compare1,
                false,
                compare2,
                false,
                compare3,

                null,
                null,
                null)
        { }

        public OmnitreePointsLinked(
            Omnitree.Location<T, Axis1, Axis2, Axis3> locate,

            Compare<Axis1> compare1,
            Compare<Axis2> compare2,
            Compare<Axis3> compare3,

            Omnitree.SubdivisionOverride<T, Axis1, Omnitree.Bounds<Axis1, Axis2, Axis3>> subdivisionOverride1,
            Omnitree.SubdivisionOverride<T, Axis2, Omnitree.Bounds<Axis1, Axis2, Axis3>> subdivisionOverride2,
            Omnitree.SubdivisionOverride<T, Axis3, Omnitree.Bounds<Axis1, Axis2, Axis3>> subdivisionOverride3)
            : this(
                locate,

                true,
                Towel.Equate.Default,

                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,

                false,
                compare1,
                false,
                compare2,
                false,
                compare3,

                subdivisionOverride1,
                subdivisionOverride2,
                subdivisionOverride3)
        { }

        public OmnitreePointsLinked(
            Omnitree.Location<T, Axis1, Axis2, Axis3> locate,
            Equate<T> equate)
            : this(
                locate,

                false,
                equate,

                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,

                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,

                null,
                null,
                null)
        { }

        public OmnitreePointsLinked(
            Omnitree.Location<T, Axis1, Axis2, Axis3> locate,
            Equate<T> equate,
            Omnitree.SubdivisionOverride<T, Axis1, Omnitree.Bounds<Axis1, Axis2, Axis3>> subdivisionOverride1,
            Omnitree.SubdivisionOverride<T, Axis2, Omnitree.Bounds<Axis1, Axis2, Axis3>> subdivisionOverride2,
            Omnitree.SubdivisionOverride<T, Axis3, Omnitree.Bounds<Axis1, Axis2, Axis3>> subdivisionOverride3)
            : this(
                locate,

                false,
                equate,

                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,

                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,

                subdivisionOverride1,
                subdivisionOverride2,
                subdivisionOverride3)
        { }

        public OmnitreePointsLinked(
            Omnitree.Location<T, Axis1, Axis2, Axis3> locate)
            : this(
                locate,

                true,
                Towel.Equate.Default,

                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,

                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,

                null,
                null,
                null)
        { }

        public OmnitreePointsLinked(
            Omnitree.Location<T, Axis1, Axis2, Axis3> locate,
            Omnitree.SubdivisionOverride<T, Axis1, Omnitree.Bounds<Axis1, Axis2, Axis3>> subdivisionOverride1,
            Omnitree.SubdivisionOverride<T, Axis2, Omnitree.Bounds<Axis1, Axis2, Axis3>> subdivisionOverride2,
            Omnitree.SubdivisionOverride<T, Axis3, Omnitree.Bounds<Axis1, Axis2, Axis3>> subdivisionOverride3)
            : this(
                locate,

                true,
                Towel.Equate.Default,

                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,

                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,

                subdivisionOverride1,
                subdivisionOverride2,
                subdivisionOverride3)
        { }

        #endregion

        #region Properties

        /// <summary>Steps through all the items at a given coordinate.</summary>
        /// <param name="axis1">The coordinate along axis 1.</param>
        /// <param name="axis2">The coordinate along axis 2.</param>
        /// <param name="axis3">The coordinate along axis 3.</param>
        /// <returns>The stepper for the items at the given coordinate.</returns>
        public Stepper<T> this[Axis1 axis1, Axis2 axis2, Axis3 axis3]
        {
            get
            {
                return (Step<T> step) => { this.Stepper(step, axis1, axis2, axis3); };
            }
        }

        /// <summary>The number of dimensions in this tree.</summary>
        public int Dimensions { get { return _dimensions; } }

        /// <summary>The function for equating keys in this table.</summary>
        public Equate<T> Equate { get { return this._equate; } }

        /// <summary>The location function the Omnitree is using.</summary>
        public Omnitree.Location<T, Axis1, Axis2, Axis3> Locate { get { return this._locate; } }


        /// <summary>The comparison function the Omnitree is using along the 1D axis.</summary>
        public Compare<Axis1> Compare1 { get { return this._compare1; } }
        /// <summary>The comparison function the Omnitree is using along the 2D axis.</summary>
        public Compare<Axis2> Compare2 { get { return this._compare2; } }
        /// <summary>The comparison function the Omnitree is using along the 3D axis.</summary>
        public Compare<Axis3> Compare3 { get { return this._compare3; } }

        /// <summary>The function for equating values along the 1D axis.</summary>
        public Equate<Axis1> EquateAxis1 { get { return this._equate1; } }
        /// <summary>The function for equating values along the 2D axis.</summary>
        public Equate<Axis2> EquateAxis2 { get { return this._equate2; } }
        /// <summary>The function for equating values along the 3D axis.</summary>
        public Equate<Axis3> EquateAxis3 { get { return this._equate3; } }

        /// <summary>The current number of items in the tree.</summary>
        public int Count { get { return this._top.Count; } }

        private delegate void MaxDepthFinder(Node node, int current_depth, ref int max_depth);
        /// <summary>Finds the current maximum depth of the tree. NOT AN O(1) OPERATION. Intended for educational purposes only.</summary>
        public int MaxDepth
        {
            get
            {
                MaxDepthFinder maxDepthFinder = null;
                maxDepthFinder =
                        (Node node, int current_depth, ref int max_depth) =>
                        {
                            if (current_depth > max_depth)
                                max_depth = current_depth;
                            if (node is Branch)
                                foreach (Node child in (node as Branch).Children)
                                    maxDepthFinder(child, current_depth + 1, ref max_depth);
                        };
                int _max_depth = -1;
                maxDepthFinder(this._top, 0, ref _max_depth);
                return _max_depth;
            }
        }

        private delegate void NodeCountFinder(Node node, ref int current_count);
        /// <summary>Counts the current number of nodes in the tree. NOT AN O(1) OPERATION. Intended for educational purposes only.</summary>
        public int NodeCount
        {
            get
            {
                NodeCountFinder nodeCountFinder = null;
                nodeCountFinder =
                        (Node node, ref int current_count) =>
                        {
                            current_count++;
                            if (node is Branch)
                                foreach (Node child in (node as Branch).Children)
                                    nodeCountFinder(child, ref current_count);
                        };

                int _current_count = 0;
                nodeCountFinder(this._top, ref _current_count);
                return _current_count;
            }
        }

        private delegate void BranchCountFinder(Node node, ref int current_count);
        /// <summary>Counts the current number of branches in the tree. NOT AN O(1) OPERATION. Intended for educational purposes only.</summary>
        public int BranchCount
        {
            get
            {
                BranchCountFinder branchCountFinder = null;
                branchCountFinder =
                        (Node node, ref int current_count) =>
                        {
                            if (node is Branch)
                            {
                                current_count++;
                                foreach (Node child in (node as Branch).Children)
                                    branchCountFinder(child, ref current_count);
                            }
                        };

                int _current_count = 0;
                branchCountFinder(this._top, ref _current_count);
                return _current_count;
            }
        }

        private delegate void LeafCountFinder(Node node, ref int current_count);
        /// <summary>Counts the current number of leaves in the tree. NOT AN O(1) OPERATION. Intended for educational purposes only.</summary>
        public int LeafCount
        {
            get
            {
                LeafCountFinder leafCountFinder = null;
                leafCountFinder =
                        (Node node, ref int current_count) =>
                        {
                            if (node is Leaf)
                                current_count++;
                            else
                                foreach (Node child in (node as Branch).Children)
                                    leafCountFinder(child, ref current_count);
                        };

                int _current_count = 0;
                leafCountFinder(this._top, ref _current_count);
                return _current_count;
            }
        }

        #endregion

        #region Methods

        #region Add

        #region Bulk

        public void Add(IndexedBigArray<T> additions, bool allowMultithreading)
        {
            if (additions.Length > int.MaxValue)
                throw new System.Exception("The maximum size of the Omnitree was exceeded during bulk addition.");

            if (this._top.Count != 0 || (int)additions.Length <= _load)
            {
                for (ulong i = 0; i < additions.Length; i++)
                    this.Add(additions[i]);
            }
            else
            {
                // adjust the loads prior to additions
				Omnitree.ComputeLoads((int)additions.Length, ref _naturalLogLower, ref _naturalLogUpper, ref _load);

                Branch new_top = new Branch(Omnitree.Vector<Axis1, Axis2, Axis3>.Default, Omnitree.Bounds<Axis1, Axis2, Axis3>.None, null, -1);
                new_top.Count = (int)additions.Length;


                // prepare data for median computations
                IndexedBigArray<Axis1> values1;
                IAsyncResult result1 = null;
                if (this._subdivisionOverride1 != null)
                    values1 = null;
                else
                {
                    values1 = null;
                    Towel.Parallels.Parallel.Operation operation = () =>
                    {
                        values1 = new IndexedBigArray<Axis1>(additions.Length);
                        for (ulong i = 0; i < additions.Length; i++)
                            values1[i] = LocateVector(additions[i]).Axis1;
                        Towel.Algorithms.Sort.Merge(this._compare1, (int i) => { return values1[(ulong)i]; }, (int i, Axis1 value) => { values1[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
                    };

                    if (allowMultithreading)
                        result1 = Towel.Parallels.Parallel.Thread(operation);
                    else
                        operation();
                }

                // prepare data for median computations
                IndexedBigArray<Axis2> values2;
                IAsyncResult result2 = null;
                if (this._subdivisionOverride2 != null)
                    values2 = null;
                else
                {
                    values2 = null;
                    Towel.Parallels.Parallel.Operation operation = () =>
                    {
                        values2 = new IndexedBigArray<Axis2>(additions.Length);
                        for (ulong i = 0; i < additions.Length; i++)
                            values2[i] = LocateVector(additions[i]).Axis2;
                        Towel.Algorithms.Sort.Merge(this._compare2, (int i) => { return values2[(ulong)i]; }, (int i, Axis2 value) => { values2[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
                    };

                    if (allowMultithreading)
                        result2 = Towel.Parallels.Parallel.Thread(operation);
                    else
                        operation();
                }

                // prepare data for median computations
                IndexedBigArray<Axis3> values3;
                IAsyncResult result3 = null;
                if (this._subdivisionOverride3 != null)
                    values3 = null;
                else
                {
                    values3 = null;
                    Towel.Parallels.Parallel.Operation operation = () =>
                    {
                        values3 = new IndexedBigArray<Axis3>(additions.Length);
                        for (ulong i = 0; i < additions.Length; i++)
                            values3[i] = LocateVector(additions[i]).Axis3;
                        Towel.Algorithms.Sort.Merge(this._compare3, (int i) => { return values3[(ulong)i]; }, (int i, Axis3 value) => { values3[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
                    };

                    if (allowMultithreading)
                        result3 = Towel.Parallels.Parallel.Thread(operation);
                    else
                        operation();
                }



                if (this._subdivisionOverride1 == null && allowMultithreading)
                    result1.AsyncWaitHandle.WaitOne();

                if (this._subdivisionOverride2 == null && allowMultithreading)
                    result2.AsyncWaitHandle.WaitOne();

                if (this._subdivisionOverride3 == null && allowMultithreading)
                    result3.AsyncWaitHandle.WaitOne();


                // build the tree
                Add(new_top, 1, -1, additions.Stepper(), (int)additions.Length, int.MinValue, int.MinValue, int.MinValue, (int)additions.Length, (int index) => { return values1[index]; }, (int index) => { return values2[index]; }, (int index) => { return values3[index]; }, allowMultithreading);
                
                this._top = new_top;
            }
        }

        public void Add(bool allowMultithreading, params T[] additions)
        {
            if (additions.Length > int.MaxValue)
                throw new System.Exception("The maximum size of the Omnitree was exceeded during bulk addition.");

            if (this._top.Count != 0 || (int)additions.Length <= _load)
            {
                for (int i = 0; i < additions.Length; i++)
                    this.Add(additions[i]);
            }
            else
            {
                // adjust the loads prior to additions
				Omnitree.ComputeLoads((int)additions.Length, ref _naturalLogLower, ref _naturalLogUpper, ref _load);

                Branch new_top = new Branch(Omnitree.Vector<Axis1, Axis2, Axis3>.Default, Omnitree.Bounds<Axis1, Axis2, Axis3>.None, null, -1);
                new_top.Count = (int)additions.Length;


                // prepare data for median computations
                IndexedBigArray<Axis1> values1;
                IAsyncResult result1 = null;
                if (this._subdivisionOverride1 != null)
                    values1 = null;
                else
                {
                    values1 = null;
                    Towel.Parallels.Parallel.Operation operation = () =>
                    {
                        values1 = new IndexedBigArray<Axis1>(additions.Length);
                        for (int i = 0; i < additions.Length; i++)
                            values1[i] = LocateVector(additions[i]).Axis1;
                        Towel.Algorithms.Sort.Merge(this._compare1, (int i) => { return values1[(ulong)i]; }, (int i, Axis1 value) => { values1[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
                    };

                    if (allowMultithreading)
                        result1 = Towel.Parallels.Parallel.Thread(operation);
                    else
                        operation();
                }

                // prepare data for median computations
                IndexedBigArray<Axis2> values2;
                IAsyncResult result2 = null;
                if (this._subdivisionOverride2 != null)
                    values2 = null;
                else
                {
                    values2 = null;
                    Towel.Parallels.Parallel.Operation operation = () =>
                    {
                        values2 = new IndexedBigArray<Axis2>(additions.Length);
                        for (int i = 0; i < additions.Length; i++)
                            values2[i] = LocateVector(additions[i]).Axis2;
                        Towel.Algorithms.Sort.Merge(this._compare2, (int i) => { return values2[(ulong)i]; }, (int i, Axis2 value) => { values2[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
                    };

                    if (allowMultithreading)
                        result2 = Towel.Parallels.Parallel.Thread(operation);
                    else
                        operation();
                }

                // prepare data for median computations
                IndexedBigArray<Axis3> values3;
                IAsyncResult result3 = null;
                if (this._subdivisionOverride3 != null)
                    values3 = null;
                else
                {
                    values3 = null;
                    Towel.Parallels.Parallel.Operation operation = () =>
                    {
                        values3 = new IndexedBigArray<Axis3>(additions.Length);
                        for (int i = 0; i < additions.Length; i++)
                            values3[i] = LocateVector(additions[i]).Axis3;
                        Towel.Algorithms.Sort.Merge(this._compare3, (int i) => { return values3[(ulong)i]; }, (int i, Axis3 value) => { values3[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
                    };

                    if (allowMultithreading)
                        result3 = Towel.Parallels.Parallel.Thread(operation);
                    else
                        operation();
                }



                if (this._subdivisionOverride1 == null && allowMultithreading)
                    result1.AsyncWaitHandle.WaitOne();

                if (this._subdivisionOverride2 == null && allowMultithreading)
                    result2.AsyncWaitHandle.WaitOne();

                if (this._subdivisionOverride3 == null && allowMultithreading)
                    result3.AsyncWaitHandle.WaitOne();


                // build the tree
                Add(new_top, 1, -1, additions.Stepper(), additions.Length, int.MinValue, int.MinValue, int.MinValue, (int)additions.Length, (int index) => { return values1[index]; }, (int index) => { return values2[index]; }, (int index) => { return values3[index]; }, allowMultithreading);
                
                this._top = new_top;
            }
        }

        
        private int Add(Branch parent, int depth, int child, Stepper<T> additions, int parent_count, int prevmed1, int prevmed2, int prevmed3, int initial_count, Get<Axis1> values1, Get<Axis2> values2, Get<Axis3> values3, bool allowMultithreading)
        {
            Axis1 pointOfDivision1;
            Axis2 pointOfDivision2;
            Axis3 pointOfDivision3;

            int median_axis1 = -1;
            int median_axis2 = -1;
            int median_axis3 = -1;
            if (this._subdivisionOverride1 == null || this._subdivisionOverride2 == null || this._subdivisionOverride3 == null)
                GetMedianIndexes(initial_count, child, depth, prevmed1, prevmed2, prevmed3, out median_axis1, out median_axis2, out median_axis3);

            if (this._subdivisionOverride1 != null)
                pointOfDivision1 = this._subdivisionOverride1(parent.Bounds, additions);
            else
                pointOfDivision1 = values1(median_axis1);

            if (this._subdivisionOverride2 != null)
                pointOfDivision2 = this._subdivisionOverride2(parent.Bounds, additions);
            else
                pointOfDivision2 = values2(median_axis2);

            if (this._subdivisionOverride3 != null)
                pointOfDivision3 = this._subdivisionOverride3(parent.Bounds, additions);
            else
                pointOfDivision3 = values3(median_axis3);

            parent.PointOfDivision = new Omnitree.Vector<Axis1, Axis2, Axis3>(pointOfDivision1, pointOfDivision2, pointOfDivision3);

            // divide the values along the medians
            IMap<IAddable<T>, int> collection_map = new MapHashLinked<IAddable<T>, int>();
            additions((T value) => 
            {
                int index = DetermineChildIndex(parent.PointOfDivision, LocateVector(value));
                IAddable<T> list = null;
                if (collection_map.TryGet(index, out list))
                {
                    list.Add(value);
                }
                else
                {
                    if (parent_count < 100000)
                        list = new AddableArray<T>();
                    else
                        list = new AddableLinked<T>();
                    collection_map.Add(index, list);
                    list.Add(value);
                }
            });

            if (depth == 1 && allowMultithreading)
            {
                // NOTE: Must assign placeholders before multithreading so that the threads do not overwrite each other
                collection_map.Keys((int key) => { parent[key] = new Leaf(Omnitree.Bounds<Axis1, Axis2, Axis3>.None, parent, key); });
                IAsyncResult[] handles = new IAsyncResult[Environment.ProcessorCount];
                for (int i = 0; i < handles.Length; i++)
                {
                    int multiTheadSafe_i = i; // used as catpure variable below making it multithread-safe
                    handles[i] = Towel.Parallels.Parallel.Thread(() =>
                    {
                        Step.EveryNth<Link<IAddable<T>, int>>(collection_map.Pairs, multiTheadSafe_i + 1)(
                        (Link<IAddable<T>, int> link) =>
                            {
                                ReversedChildBuilding(parent, link._2, depth, link._1.Stepper, link._1.Count, median_axis1, median_axis2, median_axis3, initial_count, values1, values2, values3, allowMultithreading);
                            });
                    });
                }
                
                foreach (IAsyncResult handle in handles)
                {
                    handle.AsyncWaitHandle.WaitOne();
                }
            }
            else
            {
                collection_map.Pairs((Link<IAddable<T>, int> link) =>
                { 
                    ReversedChildBuilding(parent, link._2, depth, link._1.Stepper, link._1.Count, median_axis1, median_axis2, median_axis3, initial_count, values1, values2, values3, allowMultithreading);
                });
            }

            int count = 0;
            foreach (Node node in parent.Children)
                count += node.Count;
            return count;
        }

        int ReversedChildBuilding(Branch parent, int child_index, int depth, Stepper<T> additions, int count, int prevmed1, int prevmed2, int prevmed3, int initial_count, Get<Axis1> values1, Get<Axis2> values2, Get<Axis3> values3, bool allowMultithreading)
        {
            Omnitree.Bounds<Axis1, Axis2, Axis3> child_bounds = DetermineChildBounds(parent, child_index);
            if (depth >= _load || count <= _load)
            {
                Leaf new_leaf = new Leaf(child_bounds, parent, child_index);
                additions((T value) => { new_leaf.Add(value); });
                parent[new_leaf.Index] = new_leaf;
                return new_leaf.Count;
            }
            else
            {
                Branch new_branch = new Branch(Omnitree.Vector<Axis1, Axis2, Axis3>.Default, child_bounds, parent, child_index);
                parent[new_branch.Index] = new_branch;
                new_branch.Count = Add(new_branch, depth + 1, child_index, additions, count, prevmed1, prevmed2, prevmed3, count, values1, values2, values3, allowMultithreading);
                return new_branch.Count;
            }
        }

        /// <summary>Gets the indeces of the median values at the given position during bulk additions.</summary>
        private void GetMedianIndexes(int count, int child_index, int depth, int previous1, int previous2, int previous3, out int index1, out int index2, out int index3)
        {
            if (depth == 1)
            {
                index1 = (count - 1) / 2;
                index2 = (count - 1) / 2;
                index3 = (count - 1) / 2;
                return;
            }

            int splits = Compute.Power(2, depth);
            int mid_child_range = count / splits;

            if (child_index >= 4)
            {
                index3 = previous3 + mid_child_range;
                child_index -= 4;
            }
            else
            {
                index3 = previous3 - mid_child_range;
            }

            if (child_index >= 2)
            {
                index2 = previous2 + mid_child_range;
                child_index -= 2;
            }
            else
            {
                index2 = previous2 - mid_child_range;
            }

            if (child_index >= 1)
            {
                index1 = previous1 + mid_child_range;
                child_index -= 1;
            }
            else
            {
                index1 = previous1 - mid_child_range;
            }

        }

        #endregion

        #region single

        /// <summary>Adds an item to the tree.</summary>
        /// <param name="addition">The item to be added.</param>
        public void Add(T addition)
        {
            if (this._top.Count == int.MaxValue)
                throw new System.InvalidOperationException("(Count == int.MaxValue) max Omnitree size reached (change ints to longs if you need to).");

            // dynamic tree sizes
			Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);

            Omnitree.Vector<Axis1, Axis2, Axis3> location = LocateVector(addition);

            // grow the first branch of the tree
            if (this._top is Leaf && (this._top as Leaf).Count >= _load)
            {
                Leaf top = this._top as Leaf;

                // create the new branch from the median values
                this._top = new Branch(DetermineMedians(top), Omnitree.Bounds<Axis1, Axis2, Axis3>.None, null, -1);

                // iterate through the elements and add them to the appropriate children
                for (Leaf.Node list = top.Head; list != null; list = list.Next)
                    Add(list.Value, this._top, LocateVector(list.Value), 0);
            }

            this.Add(addition, this._top, location, 0);
        }
        
        /// <summary>Recursive version of the add function.</summary>
        /// <param name="addition">The item to be added.</param>
        /// <param name="node">The current node for tree trversal.</param>
        /// <param name="ms">The location of the addition.</param>
        /// <param name="depth">The current depth of iteration.</param>
        private void Add(T addition, Node node, Omnitree.Vector<Axis1, Axis2, Axis3> location, int depth)
        {
            if (node is Leaf)
            {
                Leaf leaf = node as Leaf;
                if (depth >= _load || !(leaf.Count >= _load))
                {
                    leaf.Add(addition);
                    return;
                }
                else
                {
                    Branch parent = node.Parent;
                    int child_index = this.DetermineChildIndex(parent.PointOfDivision, location);
                    Branch growth = new Branch(DetermineMedians(leaf), leaf.Bounds, parent, child_index);
                    parent[child_index] = growth;
                    for (Leaf.Node list = leaf.Head; list != null; list = list.Next)
                    {
                        Omnitree.Vector<Axis1, Axis2, Axis3> temp_location = LocateVector(list.Value);
                        if (EncapsulationCheck(growth.Bounds, temp_location))
                            Add(list.Value, growth, temp_location, depth);
                        else
                        {
                            ReduceParentCounts(parent, 1);
                            Add(list.Value, this._top, temp_location, depth);
                        }
                    }

                    Add(addition, growth, location, depth);
                    return;
                }
            }
            else
            {
                Branch branch = node as Branch;
                int child_index = this.DetermineChildIndex(branch.PointOfDivision, location); // determine the child "index" (0 through 2^Dimensions) the addition belongs in
                Node child_node = branch[child_index];

                // null children in branches are just empty leaves
                if (child_node == null)
                {
                    Leaf new_leaf = new Leaf(DetermineChildBounds(branch, child_index), branch, child_index);
                    branch[child_index] = new_leaf;
                    new_leaf.Add(addition);
                }
                else
                    // child exists already, continue adding
                    Add(addition, child_node, location, depth + 1);

                branch.Count++;
                return;
            }
        }

        /// <summary>Determins the dimensions of the child at the given index.</summary>
        /// <param name="leaf">The parent of the node to compute dimensions for.</param>
        /// <param name="child">The index of the child to compute dimensions for.</param>
        /// <param name="median1">The computed minimum dimensions of the child node along the 1D axis.</param>
        /// <param name="median2">The computed minimum dimensions of the child node along the 2D axis.</param>
        /// <param name="median3">The computed minimum dimensions of the child node along the 3D axis.</param>
        private Omnitree.Vector<Axis1, Axis2, Axis3> DetermineMedians(Leaf leaf)
        {
            try
            {
                // extract the values
                Axis1[] values1 = new Axis1[leaf.Count];
                Axis2[] values2 = new Axis2[leaf.Count];
                Axis3[] values3 = new Axis3[leaf.Count];
                Leaf.Node for_current = leaf.Head; // used in for loop
                for (int i = 0; i < leaf.Count; i++, for_current = for_current.Next)
                    this._locate(for_current.Value, out values1[i], out values2[i], out values3[i]);
                // sort the values
                if (_defaultCompare1) Array.Sort(values1);
                else Array.Sort(values1, Compare.ToSystemComparison(this._compare1));
                if (_defaultCompare2) Array.Sort(values2);
                else Array.Sort(values2, Compare.ToSystemComparison(this._compare2));
                if (_defaultCompare3) Array.Sort(values3);
                else Array.Sort(values3, Compare.ToSystemComparison(this._compare3));
                // pull out the lazy medians (if even # of items... just take the left)
                int index = (leaf.Count - 1) / 2;
                return new Omnitree.Vector<Axis1, Axis2, Axis3>(values1[index], values2[index], values3[index]);
            }
            catch (Exception exception)
            {
				System.Diagnostics.Debugger.Break();
                // extract the values
                IndexedBigArray<Axis1> values1 = new IndexedBigArray<Axis1>(leaf.Count);
                IndexedBigArray<Axis2> values2 = new IndexedBigArray<Axis2>(leaf.Count);
                IndexedBigArray<Axis3> values3 = new IndexedBigArray<Axis3>(leaf.Count);
                Leaf.Node for_current = leaf.Head; // used in for loop
                for (int i = 0; i < leaf.Count; i++, for_current = for_current.Next)
                {
                    Axis1 value1;
                    Axis2 value2;
                    Axis3 value3;
                    this._locate(for_current.Value, out value1, out value2, out value3);
                    values1[i] = value1;
                    values2[i] = value2;
                    values3[i] = value3;
                }
                // sort the values
                if (_defaultCompare1) Towel.Algorithms.Sort.Merge(Compare.Default, (int sorting_index) => { return values1[sorting_index]; }, (int sorting_index, Axis1 axis1) => { values1[sorting_index] = axis1; }, 0, (int)values1.Length);
                else Towel.Algorithms.Sort.Merge(_compare1, (int sorting_index) => { return values1[sorting_index]; }, (int sorting_index, Axis1 axis1) => { values1[sorting_index] = axis1; }, 0, (int)values1.Length);
                if (_defaultCompare2) Towel.Algorithms.Sort.Merge(Compare.Default, (int sorting_index) => { return values2[sorting_index]; }, (int sorting_index, Axis2 axis2) => { values2[sorting_index] = axis2; }, 0, (int)values1.Length);
                else Towel.Algorithms.Sort.Merge(_compare2, (int sorting_index) => { return values2[sorting_index]; }, (int sorting_index, Axis2 axis2) => { values2[sorting_index] = axis2; }, 0, (int)values1.Length);
                if (_defaultCompare3) Towel.Algorithms.Sort.Merge(Compare.Default, (int sorting_index) => { return values3[sorting_index]; }, (int sorting_index, Axis3 axis3) => { values3[sorting_index] = axis3; }, 0, (int)values1.Length);
                else Towel.Algorithms.Sort.Merge(_compare3, (int sorting_index) => { return values3[sorting_index]; }, (int sorting_index, Axis3 axis3) => { values3[sorting_index] = axis3; }, 0, (int)values1.Length);
                // pull out the lazy medians (if even # of items... just take the left)
                int index = (leaf.Count - 1) / 2;
                return new Omnitree.Vector<Axis1, Axis2, Axis3>(values1[index], values2[index], values3[index]);
            }
        }

        #endregion

        #region Add Helpers

        private Omnitree.Bounds<Axis1, Axis2, Axis3> DetermineChildBounds(Branch branch, int child_index)
        {

            Omnitree.Bound<Axis3> min3, max3;
            if (child_index >= 4)
            {
                min3 = branch.PointOfDivision.Axis3;
                max3 = branch.Bounds.Max3;
                child_index -= 4;
            }
            else
            {
                min3 = branch.Bounds.Min3;
                max3 = branch.PointOfDivision.Axis3;
            }

            Omnitree.Bound<Axis2> min2, max2;
            if (child_index >= 2)
            {
                min2 = branch.PointOfDivision.Axis2;
                max2 = branch.Bounds.Max2;
                child_index -= 2;
            }
            else
            {
                min2 = branch.Bounds.Min2;
                max2 = branch.PointOfDivision.Axis2;
            }

            Omnitree.Bound<Axis1> min1, max1;
            if (child_index >= 1)
            {
                min1 = branch.PointOfDivision.Axis1;
                max1 = branch.Bounds.Max1;
                child_index -= 1;
            }
            else
            {
                min1 = branch.Bounds.Min1;
                max1 = branch.PointOfDivision.Axis1;
            }

            return new Omnitree.Bounds<Axis1, Axis2, Axis3>(min1, max1, min2, max2, min3, max3);
        }

        #endregion

        #endregion

        #region Clear

        /// <summary>Returns the tree to an empty state.</summary>
        public void Clear()
        {
            this._top = new Leaf(Omnitree.Bounds<Axis1, Axis2, Axis3>.None, null, -1);
			Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
        }

        #endregion

        #region Clone

        /// <summary>Creates a shallow clone of this data structure.</summary>
        /// <returns>A shallow clone of this data structure.</returns>
        public OmnitreePointsLinked<T, Axis1, Axis2, Axis3> Clone()
        {
            return new OmnitreePointsLinked<T, Axis1, Axis2, Axis3>(this);
        }

        #endregion

        #region Count

        /// <summary>Counts the number of items in a sub space.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
        /// <returns>The number of items in the provided sub space.</returns>
        public int CountSubSpace(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3)
        {
            return CountSubSpace(_top, new Omnitree.Bounds<Axis1, Axis2, Axis3>(min1, max1, min2, max2, min3, max3));
        }
        /// <summary>Counts the number of items in a sub space.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
        /// <returns>The number of items in the provided sub space.</returns>
        public int CountSubSpace(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3)
        {
            return CountSubSpace(_top, new Omnitree.Bounds<Axis1, Axis2, Axis3>(min1, max1, min2, max2, min3, max3));
        }
        /// <summary>Counts the number of items in a sub space.</summary>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
        /// <returns>The number of items in the provided sub space.</returns>
        public int CountSubSpace(Axis1 axis1, Axis2 axis2, Axis3 axis3)
        {
            return CountSubSpace(_top, new Omnitree.Bounds<Axis1, Axis2, Axis3>(axis1, axis1, axis2, axis2, axis3, axis3));
        }
        /// <summary>Counts the number of items in a sub space.</summary>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
        /// <returns>The number of items in the provided sub space.</returns>
        public int CountSubSpace(Omnitree.Bound<Axis1> axis1, Omnitree.Bound<Axis2> axis2, Omnitree.Bound<Axis3> axis3)
        {
            return CountSubSpace(_top, new Omnitree.Bounds<Axis1, Axis2, Axis3>(axis1, axis1, axis2, axis2, axis3, axis3));
        }
        /// <summary>Counts the number of items in a sub space.</summary>
        /// <param name="node">The current traversal node.</param>
        /// <returns>The number of items in the provided sub space.</returns>
        private int CountSubSpace(Node node, Omnitree.Bounds<Axis1, Axis2, Axis3> bounds)
        {
            // adjust min/max values
            int count = 0;
            if (EncapsulationCheck(bounds, node.Bounds))
                count += node.Count;
            else if (node is Leaf)
            {
                for (Leaf.Node list = (node as Leaf).Head; list != null; list = list.Next)
                    if (EncapsulationCheck(bounds, LocateVector(list.Value)))
                        count++;
            }
            else
            {
                Branch branch = node as Branch;
                if (!StraddlesLines(branch.Bounds, branch.PointOfDivision))
                {
                    int child_index = DetermineChildIndex(branch.PointOfDivision, new Omnitree.Vector<Axis1, Axis2, Axis3>(bounds.Min1.Value, bounds.Min2.Value, bounds.Min3.Value));
                    Node child = branch[child_index];
                    if (child != null)
                      count += this.CountSubSpace(child, bounds);
                }
                else
                {
                    foreach (Node child in (node as Branch).Children)
                        count += this.CountSubSpace(child, bounds);
                }
            }
            return count;
        }

        #endregion

        #region Update

        /// <summary>Iterates through the entire tree and ensures each item is in the proper leaf.</summary>
        public void Update()
        {
            this.Update(this._top, 0);
        }

        /// <summary>Recursive version of the Update method.</summary>
        /// <param name="node">The current node of iteration.</param>
        /// <param name="depth">The current depth of iteration.</param>
        private int Update(Node node, int depth)
        {
            int removals = 0;

            if (node is Leaf)
            {
                Leaf leaf = node as Leaf;
                Leaf.Node current = leaf.Head;
                Leaf.Node previous = null;
                while (current != null)
                {
                    Omnitree.Vector<Axis1, Axis2, Axis3> location = LocateVector(current.Value);
                    if (!this.EncapsulationCheck(node.Bounds, location))
                    {
                        removals++;
                        T updated = current.Value;
                        if (previous == null)
                        {
                            leaf.Head = current.Next;
                            goto HeadRemoved;
                        }
                        else
                            previous.Next = current.Next;

                        Node whereToAdd = GetEncapsulationParent(node.Parent, location);

                        if (whereToAdd == null)
                            throw new System.Exception("an item was updated outside the range of the omnitree");

                        this.Add(updated, whereToAdd, location, whereToAdd.Depth);
                    }
                    previous = current;
                HeadRemoved:
                    current = current.Next;
                }
                leaf.Count -= removals;
                return removals;
            }
            else
            {
                Branch branch = node as Branch;
                int skipped = 0;
                for (int i = 0; i + skipped < branch.Children.Length; )
                {
                    removals += this.Update(branch.Children[i], depth + 1);
                    if (branch.Children[i].Count == 0)
                        branch.Children[i] = branch.Children[branch.Children.Length - skipped++ - 1];
                    else
                        i++;
                }
                Node[] newArray = new Node[branch.Children.Length - skipped];
                Array.Copy(branch.Children, newArray, newArray.Length);
                branch.Children = newArray;

                branch.Count -= removals;

                if (branch.Count < _load && branch.Count != 0)
                    ShrinkChild(branch.Parent, branch.Index);
            }

            return removals;
        }

        /// <summary>Iterates through the provided dimensions and ensures each item is in the proper leaf.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
        public void Update(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3)
        {
            this.Update(new Omnitree.Bounds<Axis1, Axis2, Axis3>(min1, max1, min2, max2, min3, max3), this._top, 0);
        }
        /// <summary>Iterates through the provided dimensions and ensures each item is in the proper leaf.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
        public void Update(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3)
        {
            this.Update(new Omnitree.Bounds<Axis1, Axis2, Axis3>(min1, max1, min2, max2, min3, max3), this._top, 0);
        }
        /// <summary>Iterates through the provided dimensions and ensures each item is in the proper leaf.</summary>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
        public void Update(Axis1 axis1, Axis2 axis2, Axis3 axis3)
        {
            this.Update(new Omnitree.Bounds<Axis1, Axis2, Axis3>(axis1, axis1, axis2, axis2, axis3, axis3), this._top, 0);
        }
        /// <summary>Iterates through the provided dimensions and ensures each item is in the proper leaf.</summary>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
        public void Update(Omnitree.Bound<Axis1> axis1, Omnitree.Bound<Axis2> axis2, Omnitree.Bound<Axis3> axis3)
        {
            this.Update(new Omnitree.Bounds<Axis1, Axis2, Axis3>(axis1, axis1, axis2, axis2, axis3, axis3), this._top, 0);
        }
        private int Update(Omnitree.Bounds<Axis1, Axis2, Axis3> bounds, Node node, int depth)
        {
            if (!InclusionCheck(bounds, node.Bounds))
                return 0;

            int removals = 0;

            if (node is Leaf)
            {
                Leaf leaf = node as Leaf;
                Leaf.Node current = leaf.Head;
                Leaf.Node previous = null;
                while (current != null)
                {
                    Omnitree.Vector<Axis1, Axis2, Axis3> location = LocateVector(current.Value);
                    if (!this.EncapsulationCheck(node.Bounds, location))
                    {
                        removals++;
                        T updated = current.Value;
                        if (previous == null)
                        {
                            leaf.Head = current.Next;
                            goto HeadRemoved;
                        }
                        else
                            previous.Next = current.Next;
                        Node whereToAdd = GetEncapsulationParent(node.Parent, location);
                        if (whereToAdd == null)
                            throw new System.Exception("an item was updates outside the range of the omnitree");
                        this.Add(updated, whereToAdd, location, whereToAdd.Depth);
                    }
                    previous = current;
                HeadRemoved:
                    current = current.Next;
                }
                leaf.Count -= removals;
                return removals;
            }
            else
            {
                Branch branch = node as Branch;
                int skipped = 0;
                for (int i = 0; i + skipped < branch.Children.Length; )
                {
                    removals += this.Update(branch.Children[i], depth + 1);
                    if (branch.Children[i].Count == 0)
                        branch.Children[i] = branch.Children[branch.Children.Length - skipped++ - 1];
                    else
                        i++;
                }
                Node[] newArray = new Node[branch.Children.Length - skipped];
                Array.Copy(branch.Children, newArray, newArray.Length);
                branch.Children = newArray;

                branch.Count -= removals;

                if (branch.Count < _load && branch.Count != 0)
                    ShrinkChild(branch.Parent, branch.Index);
            }

            return removals;
        }

        #endregion

        #region Remove

        /// <summary>Removes all the items qualified by the delegate.</summary>
        /// <param name="where">The predicate to qualify removals.</param>
        public void Remove(Predicate<T> where)
        {
            this.Remove(this._top, where);
			Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
        }

        /// <summary>Recursive version of the remove method.</summary>
        /// <param name="node">The current node of traversal.</param>
        /// <param name="where">The predicate to qualify removals.</param>
        private int Remove(Node node, Predicate<T> where)
        {
            int removals = 0;
            if (node is Leaf)
            {
                Leaf leaf = node as Leaf;
                while (leaf.Head != null && where(leaf.Head.Value))
                {
                    leaf.Head = leaf.Head.Next;
                    removals++;
                }
                if (leaf.Head != null)
                {
                    Leaf.Node list = leaf.Head;
                    while (list.Next != null)
                    {
                        if (where(list.Next.Value))
                        {
                            list.Next = list.Next.Next;
                            removals++;
                        }
                    }
                }

                leaf.Count -= removals;
                return removals;
            }
            else
            {
                Branch branch = node as Branch;
                int skipped = 0;
                for (int i = 0; i + skipped < branch.Children.Length; )
                {
                    removals += this.Remove(branch.Children[i], where);
                    if (branch.Children[i].Count == 0)
                        branch.Children[i] = branch.Children[branch.Children.Length - skipped++ - 1];
                    else
                        i++;
                }
                Node[] newArray = new Node[branch.Children.Length - skipped];
                Array.Copy(branch.Children, newArray, newArray.Length);
                branch.Children = newArray;

                branch.Count -= removals;

                if (branch.Count < _load && branch.Count != 0)
                    ShrinkChild(branch.Parent, branch.Index);

                return removals;
            }
        }

        /// <summary>Removes all the items in a given space.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
        /// <returns>The number of items that were removed.</returns>
        public void Remove(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3)
        {
            this.Remove(this._top, new Omnitree.Bounds<Axis1, Axis2, Axis3>(min1, max1, min2, max2, min3, max3));
            Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
        }
        /// <summary>Removes all the items in a given space.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
        /// <returns>The number of items that were removed.</returns>
        public void Remove(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3)
        {
            this.Remove(this._top, new Omnitree.Bounds<Axis1, Axis2, Axis3>(min1, max1, min2, max2, min3, max3));
            Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
        }
        private int Remove(Node node, Omnitree.Bounds<Axis1, Axis2, Axis3> bounds)
        {
            int removals = 0;
            if (InclusionCheck(bounds, node.Bounds))
            {
                if (node is Leaf)
                {
                    Leaf leaf = node as Leaf;
                    Leaf.Node current_node = leaf.Head;
                    Leaf.Node previous_node = null;
                    while (current_node != null)
                    {
                        Leaf.Node temp_previous = current_node;
                        if (EncapsulationCheck(bounds, LocateVector(current_node.Value)))
                        {
                            removals++;
                            if (current_node == leaf.Head)
                                leaf.Head = leaf.Head.Next;
                            else
                            {
                                previous_node.Next = current_node.Next;
                                temp_previous = previous_node;
                            }
                        }
                        previous_node = temp_previous;
                        current_node = current_node.Next;
                    }
                    leaf.Count -= removals;
                }
                else
                {
                    Branch branch = node as Branch;
                    int skipped = 0;
                    for (int i = 0; i + skipped < branch.Children.Length; )
                    {
                        removals += this.Remove(branch.Children[i], bounds);
                        if (branch.Children[i].Count == 0)
                            branch.Children[i] = branch.Children[branch.Children.Length - skipped++ - 1];
                        else
                            i++;
                    }
                    Node[] newArray = new Node[branch.Children.Length - skipped];
                    Array.Copy(branch.Children, newArray, newArray.Length);
                    branch.Children = newArray;

                    branch.Count -= removals;
                    // convert this branch back into a leaf
                    // Note: if count is zero, it will be chopped off
                    if (branch.Count < _load && branch.Count > 0)
                        ShrinkChild(branch.Parent, branch.Index);
                }
            }

            return removals;
        }

        /// <summary>Removes all the items in a given space validated by a predicate.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
        /// <param name="where">The equality constraint of the removal.</param>
        public void Remove(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Predicate<T> where)
        {
            this.Remove(this._top, new Omnitree.Bounds<Axis1, Axis2, Axis3>(min1, max1, min2, max2, min3, max3), where);
            Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
        }
        /// <summary>Removes all the items in a given space validated by a predicate.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
        /// <param name="where">The equality constraint of the removal.</param>
        public void Remove(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Predicate<T> where)
        {
            this.Remove(this._top, new Omnitree.Bounds<Axis1, Axis2, Axis3>(min1, max1, min2, max2, min3, max3), where);
			Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
        }
        private int Remove(Node node, Omnitree.Bounds<Axis1, Axis2, Axis3> bounds, Predicate<T> where)
        {
            if (!InclusionCheck(node.Bounds, bounds))
                return 0;
            int removals = 0;
            if (node is Leaf)
            {
                Leaf leaf = node as Leaf;
                Leaf.Node current = leaf.Head;
                Leaf.Node previous = null;
                while (current != null)
                {
                    if (this.EncapsulationCheck(bounds, LocateVector(current.Value)) && where(current.Value))
                    {
                        removals++;
                        if (previous == null)
                        {
                            leaf.Head = current.Next;
                            goto HeadRemoved;
                        }
                        else
                            previous.Next = current.Next;
                    }
                    previous = current;
                HeadRemoved:
                    current = current.Next;
                }

                leaf.Count -= removals;
                return removals;
            }
            else
            {
                Branch branch = node as Branch;
                int skipped = 0;
                for (int i = 0; i + skipped < branch.Children.Length; )
                {
                    removals += this.Remove(branch.Children[i], bounds, where);
                    if (branch.Children[i].Count == 0)
                        branch.Children[i] = branch.Children[branch.Children.Length - skipped++ - 1];
                    else
                        i++;
                }
                Node[] newArray = new Node[branch.Children.Length - skipped];
                Array.Copy(branch.Children, newArray, newArray.Length);
                branch.Children = newArray;

                node.Count -= removals;

                if (node.Count < _load && node.Count != 0)
                    ShrinkChild(node.Parent, node.Index);

                return removals;
            }
        }

        /// <summary>Removes all instances of a given value.</summary>
        public void Remove(T removal)
        {
            Axis1 axis1;
            Axis2 axis2;
            Axis3 axis3;
            this._locate(removal, out axis1, out axis2, out axis3);
            this.Remove(axis1, axis2, axis3, (T item) => { return this._equate(item, removal); });
        }
        /// <summary>Removes all the items in a given space.</summary>
        /// <param name="axis1">The axis of the removal along the  1D axis.</param>
		/// <param name="axis2">The axis of the removal along the  2D axis.</param>
		/// <param name="axis3">The axis of the removal along the  3D axis.</param>
        /// <returns>The number of items that were removed.</returns>
        public void Remove(Axis1 axis1, Axis2 axis2, Axis3 axis3)
        {
            this.Remove(this._top, new Omnitree.Vector<Axis1, Axis2, Axis3>(axis1, axis2, axis3));
            Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
        }
        private int Remove(Node node, Omnitree.Vector<Axis1, Axis2, Axis3> vector)
        {
            int removals = 0;
            if (node is Leaf)
            {
                Leaf leaf = node as Leaf;
                Leaf.Node current_node = leaf.Head;
                Leaf.Node previous_node = null;
                while (current_node != null)
                {
                    Leaf.Node temp_previous = current_node;
                    if (EqualsCheck(vector, LocateVector(current_node.Value)))
                    {
                        removals++;
                        if (current_node == leaf.Head)
                            leaf.Head = leaf.Head.Next;
                        else
                        {
                            previous_node.Next = current_node.Next;
                            temp_previous = previous_node;
                        }
                    }
                    previous_node = temp_previous;
                    current_node = current_node.Next;
                }
                leaf.Count -= removals;
            }
            else
            {
                Branch branch = node as Branch;
                int child_index = DetermineChildIndex(branch.PointOfDivision, vector);
                removals += Remove(branch[child_index], vector);
                branch.Count -= removals;
                // convert this branch back into a leaf
                // Note: if count is zero, it will be chopped off
                if (branch.Count < _load && branch.Count > 0)
                    ShrinkChild(branch.Parent, branch.Index);
            }

            return removals;
        }

        /// <summary>Removes all the items in a given space validated by a predicate.</summary>
        /// <param name="axis1">The axis of the removal along the  1D axis.</param>
		/// <param name="axis2">The axis of the removal along the  2D axis.</param>
		/// <param name="axis3">The axis of the removal along the  3D axis.</param>
        /// <param name="where">The equality constraint of the removal.</param>
        public void Remove(Axis1 axis1, Axis2 axis2, Axis3 axis3, Predicate<T> where)
        {
            this.Remove(this._top, new Omnitree.Vector<Axis1, Axis2, Axis3>(axis1, axis2, axis3), where);
            Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
        }
        private int Remove(Node node, Omnitree.Vector<Axis1, Axis2, Axis3> vector, Predicate<T> where)
        {
            int removals = 0;
            if (node is Leaf)
            {
                Leaf leaf = node as Leaf;
                Leaf.Node current_node = leaf.Head;
                Leaf.Node previous_node = null;
                while (current_node != null)
                {
                    Leaf.Node temp_previous = current_node;
                    if (EqualsCheck(vector, LocateVector(current_node.Value)) && where(current_node.Value))
                    {
                        removals++;
                        if (current_node == leaf.Head)
                            leaf.Head = leaf.Head.Next;
                        else
                        {
                            previous_node.Next = current_node.Next;
                            temp_previous = previous_node;
                        }
                    }
                    previous_node = temp_previous;
                    current_node = current_node.Next;
                }
                leaf.Count -= removals;
            }
            else
            {
                Branch branch = node as Branch;
                int child_index = DetermineChildIndex(branch.PointOfDivision, vector);
                removals += Remove(branch[child_index], vector, where);
                branch.Count -= removals;
                // convert this branch back into a leaf
                // Note: if count is zero, it will be chopped off
                if (branch.Count < _load && branch.Count > 0)
                    ShrinkChild(branch.Parent, branch.Index);
            }
            return removals;
        }

        #endregion

        #region Stepper And IEnumerable

        /// <summary>Traverses every item in the tree and performs the delegate in them.</summary>
        /// <param name="function">The delegate to perform on every item in the tree.</param>
        public void Stepper(Step<T> function)
        {
            this.Stepper(function, this._top);
        }
        private void Stepper(Step<T> function, Node node)
        {
            if (node is Leaf)
            {
                Leaf.Node list = (node as Leaf).Head;
                while (list != null)
                {
                    function(list.Value);
                    list = list.Next;
                }
            }
            else
            {
                foreach (Node child in (node as Branch).Children)
                    this.Stepper(function, child);
            }
        }

        /// <summary>Traverses every item in the tree and performs the delegate in them.</summary>
        /// <param name="function">The delegate to perform on every item in the tree.</param>
        public StepStatus Stepper(StepBreak<T> function)
        {
            return Stepper(function, _top);
        }
        private StepStatus Stepper(StepBreak<T> function, Node node)
        {
            StepStatus status = StepStatus.Continue;
            if (node is Leaf)
            {
                for (Leaf.Node list = (node as Leaf).Head; list != null; list = list.Next)
                    if ((status = function(list._value)) != StepStatus.Continue)
                        break;
            }
            else
            {
                foreach (Node child in (node as Branch).Children)
                    if ((status = Stepper(function, child)) != StepStatus.Continue)
                        break;
            }
            return status;
        }

        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="function">The delegate to perform on all items in the tree within the given bounds.</param>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
        public void Stepper(Step<T> function, Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3)
        {
            Stepper(function, _top, new Omnitree.Bounds<Axis1, Axis2, Axis3>(min1, max1, min2, max2, min3, max3));
        }
        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="function">The delegate to perform on all items in the tree within the given bounds.</param>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
        public void Stepper(Step<T> function, Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3)
        {
            Stepper(function, _top, new Omnitree.Bounds<Axis1, Axis2, Axis3>(min1, max1, min2, max2, min3, max3));
        }
        private void Stepper(Step<T> function, Node node, Omnitree.Bounds<Axis1, Axis2, Axis3> bounds)
        {
            if (node is Leaf)
            {
                for (Leaf.Node list = (node as Leaf).Head; list != null; list = list.Next)
                    if (EncapsulationCheck(bounds, LocateVector(list.Value)))
                        function(list.Value);
            }
            else
            {
                foreach (Node child in (node as Branch).Children)
                    // optimization: stop bounds checking if space encapsulates node
                    if (EncapsulationCheck(bounds, child.Bounds))
                        this.Stepper(function, child);
                    else if (InclusionCheck(child.Bounds, bounds))
                        this.Stepper(function, child, bounds);
            }
        }

        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
        public StepStatus Stepper(StepBreak<T> function, Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3)
        {
            return Stepper(function, _top, new Omnitree.Bounds<Axis1, Axis2, Axis3>(min1, max1, min2, max2, min3, max3));
        }
        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
        public StepStatus Stepper(StepBreak<T> function, Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3)
        {
            return Stepper(function, _top, new Omnitree.Bounds<Axis1, Axis2, Axis3>(min1, max1, min2, max2, min3, max3));
        }
        private StepStatus Stepper(StepBreak<T> function, Node node, Omnitree.Bounds<Axis1, Axis2, Axis3> bounds)
        {
            StepStatus status = StepStatus.Continue;
            if (node is Leaf)
            {
                for (Leaf.Node list = (node as Leaf).Head; list != null; list = list.Next)
                    if (EncapsulationCheck(bounds, LocateVector(list.Value)) &&
                        (status = function(list.Value)) != StepStatus.Continue)
                        break;
            }
            else
            {
                foreach (Node child in (node as Branch).Children)
                    // optimization: stop bounds checking if space encapsulates node
                    if (EncapsulationCheck(bounds, child.Bounds) &&
                        (status = this.Stepper(function, child)) != StepStatus.Continue)
                        break;
                    else if (!InclusionCheck(child.Bounds, bounds) &&
                        (status = this.Stepper(function, child, bounds)) != StepStatus.Continue)
                        break;
            }
            return status;
        }

        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="axis1">The axis of the removal along the  1D axis.</param>
		/// <param name="axis2">The axis of the removal along the  2D axis.</param>
		/// <param name="axis3">The axis of the removal along the  3D axis.</param>
        public void Stepper(Step<T> function, Axis1 axis1, Axis2 axis2, Axis3 axis3)
        {
            Stepper(function, _top, new Omnitree.Vector<Axis1, Axis2, Axis3>(axis1, axis2, axis3));
        }
        private void Stepper(Step<T> function, Node node, Omnitree.Vector<Axis1, Axis2, Axis3> vector)
        {
            Node current = node;
            while (current != null)
            {
                if (current is Leaf)
                {
                    for (Leaf.Node leaf_node = (current as Leaf).Head; leaf_node != null; leaf_node = leaf_node.Next)
                        if (EqualsCheck(vector, LocateVector(leaf_node.Value)))
                            function(leaf_node.Value);
                    break;
                }
                else
                {
                    Branch branch = current as Branch;
                    int child_index = DetermineChildIndex(branch.PointOfDivision, vector);
                    current = branch[child_index];
                }
            }
        }

        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="function">The delegate to perform on all items in the tree within the given bounds.</param>
        /// <param name="axis1">The axis of the removal along the  1D axis.</param>
		/// <param name="axis2">The axis of the removal along the  2D axis.</param>
		/// <param name="axis3">The axis of the removal along the  3D axis.</param>
        public StepStatus Stepper(StepBreak<T> function, Axis1 axis1, Axis2 axis2, Axis3 axis3)
        {
            return Stepper(function, _top, new Omnitree.Vector<Axis1, Axis2, Axis3>(axis1, axis2, axis3));
        }
        private StepStatus Stepper(StepBreak<T> function, Node node, Omnitree.Vector<Axis1, Axis2, Axis3> vector)
        {
            Node current = node;
            while (current != null)
            {
                if (current is Leaf)
                {
                    for (Leaf.Node list = (current as Leaf).Head; list != null; list = list.Next)
                    {
                        StepStatus status = StepStatus.Continue;
                        if (EqualsCheck(vector, LocateVector(list.Value)) &&
                            (status = function(list.Value)) != StepStatus.Continue)
                            return status;
                    }
                }
                else
                {
                    Branch branch = current as Branch;
                    int child_index = DetermineChildIndex(branch.PointOfDivision, vector);
                    current = branch[child_index];
                }
            }
            return StepStatus.Continue;
        }

        /// <summary>FOR COMPATIBILITY ONLY. AVOID IF POSSIBLE.</summary>
        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
        {
            throw new System.NotImplementedException();
            //return (this.ToArray() as System.Collections.Generic.IEnumerable<T>).GetEnumerator();
        }

        /// <summary>FOR COMPATIBILITY ONLY. AVOID IF POSSIBLE.</summary>
        System.Collections.Generic.IEnumerator<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator()
        {
            throw new System.NotImplementedException();
            //return (this.ToArray() as System.Collections.Generic.IEnumerable<T>).GetEnumerator();
        }

        #endregion

        #region Helpers

        private bool StraddlesLines(Omnitree.Bounds<Axis1, Axis2, Axis3> bounds, Omnitree.Vector<Axis1, Axis2, Axis3> vector)
        {
			if ((!bounds.Min1.Exists || (bounds.Min1.Exists && this._compare1(bounds.Min1.Value, vector.Axis1) != Comparison.Greater)) &&
				(!bounds.Max1.Exists || (bounds.Max1.Exists && this._compare1(bounds.Max1.Value, vector.Axis1) != Comparison.Less)))
				return true;
			if ((!bounds.Min2.Exists || (bounds.Min2.Exists && this._compare2(bounds.Min2.Value, vector.Axis2) != Comparison.Greater)) &&
				(!bounds.Max2.Exists || (bounds.Max2.Exists && this._compare2(bounds.Max2.Value, vector.Axis2) != Comparison.Less)))
				return true;
			if ((!bounds.Min3.Exists || (bounds.Min3.Exists && this._compare3(bounds.Min3.Value, vector.Axis3) != Comparison.Greater)) &&
				(!bounds.Max3.Exists || (bounds.Max3.Exists && this._compare3(bounds.Max3.Value, vector.Axis3) != Comparison.Less)))
				return true;
            return false;
        }

        /// <summary>Computes the child index that contains the desired dimensions.</summary>
        /// <param name="node">The branch .</param>
        /// <param name="vector">The dimensions to determine the child index.</param>
        /// <returns>The computed child index based on the coordinates relative to the center of the node.</returns>
        private int DetermineChildIndex(Omnitree.Vector<Axis1, Axis2, Axis3> pointOfDivision, Omnitree.Vector<Axis1, Axis2, Axis3> vector)
        {
            int child = 0;
            if (!(this._compare1(vector.Axis1, pointOfDivision.Axis1) == Comparison.Less))
                child += 1 << 0;
            if (!(this._compare2(vector.Axis2, pointOfDivision.Axis2) == Comparison.Less))
                child += 1 << 1;
            if (!(this._compare3(vector.Axis3, pointOfDivision.Axis3) == Comparison.Less))
                child += 1 << 2;
            return child;
        }

        /// <summary>Converts a branch back into a leaf when the count is reduced.</summary>
        /// <param name="parent">The parent to shrink a child of.</param>
        /// <param name="child">The index of the child to shrink.</param>
        private void ShrinkChild(Branch parent, int child_index)
        {
            Leaf leaf;
            Node removal = null;
            if (parent == null) // top of tree
            {
                removal = this._top;
                leaf = new Leaf(Omnitree.Bounds<Axis1, Axis2, Axis3>.None, null, -1);
                this._top = leaf;
            }
            else // non-top branch
            {
                removal = parent[child_index];
                leaf = new Leaf(removal.Bounds, removal.Parent, removal.Index);
                parent[child_index] = leaf;
            }

            this.Stepper((T step) => { leaf.Add(step); }, removal);
        }

        /// <summary>Reduces the counts of all the parents of a given node by a given amount.</summary>
        /// <param name="parent">The starting parent of the reduction.</param>
        /// <param name="reduction">The amount to reduce the parent counts by.</param>
        private void ReduceParentCounts(Node parent, int reduction)
        {
            IncreaseParentCounts(parent, -reduction);
        }

        /// <summary>Increases the counts of all the parents of a given node by a given amount.</summary>
        /// <param name="parent">The starting parent of the increase.</param>
        /// <param name="increase">The amount to increase the parent counts by.</param>
        private void IncreaseParentCounts(Node parent, int increase)
        {
            Node looper = parent;
            while (looper != null)
            {
                looper.Count += increase;
                looper = looper.Parent;
            }
        }

        /// <summary>Checks a node for inclusion (overlap) between two bounds.</summary>
        /// <returns>True if the spaces overlap; False if not.</returns>
        private bool InclusionCheck(Omnitree.Bounds<Axis1, Axis2, Axis3> a, Omnitree.Bounds<Axis1, Axis2, Axis3> b)
        {

            if (a.Max1.Exists && b.Min1.Exists && this._compare1(a.Max1.Value, b.Min1.Value) == Comparison.Less)
                return false;
            else if (a.Min1.Exists && b.Max1.Exists && this._compare1(a.Min1.Value, b.Max1.Value) == Comparison.Greater)
                return false;

            if (a.Max2.Exists && b.Min2.Exists && this._compare2(a.Max2.Value, b.Min2.Value) == Comparison.Less)
                return false;
            else if (a.Min2.Exists && b.Max2.Exists && this._compare2(a.Min2.Value, b.Max2.Value) == Comparison.Greater)
                return false;

            if (a.Max3.Exists && b.Min3.Exists && this._compare3(a.Max3.Value, b.Min3.Value) == Comparison.Less)
                return false;
            else if (a.Min3.Exists && b.Max3.Exists && this._compare3(a.Min3.Value, b.Max3.Value) == Comparison.Greater)
                return false;

            return true;
        }

        /// <summary>Checks if a space encapsulates a point.</summary>
        /// <returns>True if the space encapsulates the point; False if not.</returns>
        private bool EncapsulationCheck(Omnitree.Bounds<Axis1, Axis2, Axis3> bounds, Omnitree.Vector<Axis1, Axis2, Axis3> vector)
        {
            // if the location is not outside the bounds, it must be inside

            if (bounds.Min1.Exists && this._compare1(vector.Axis1, bounds.Min1.Value) == Comparison.Less)
                return false;
            else if (bounds.Max1.Exists && this._compare1(vector.Axis1, bounds.Max1.Value) == Comparison.Greater)
                return false;

            if (bounds.Min2.Exists && this._compare2(vector.Axis2, bounds.Min2.Value) == Comparison.Less)
                return false;
            else if (bounds.Max2.Exists && this._compare2(vector.Axis2, bounds.Max2.Value) == Comparison.Greater)
                return false;

            if (bounds.Min3.Exists && this._compare3(vector.Axis3, bounds.Min3.Value) == Comparison.Less)
                return false;
            else if (bounds.Max3.Exists && this._compare3(vector.Axis3, bounds.Max3.Value) == Comparison.Greater)
                return false;

            return true;
        }

        /// <summary>Checks if a space (left) encapsulates another space (right).</summary>
        /// <returns>True if the left space encapsulates the right; False if not.</returns>
        private bool EncapsulationCheck(Omnitree.Bounds<Axis1, Axis2, Axis3> a, Omnitree.Bounds<Axis1, Axis2, Axis3> b)
        {
            if ((a.Min1.Exists && !b.Min1.Exists) || (a.Min2.Exists && !b.Min2.Exists) || (a.Min3.Exists && !b.Min3.Exists))
                return false;
			if ((a.Max1.Exists && !b.Max1.Exists) || (a.Max2.Exists && !b.Max2.Exists) || (a.Max3.Exists && !b.Max3.Exists))
                return false;

            if (b.Min1.Exists && a.Min1.Exists && this._compare1(a.Min1.Value, b.Min1.Value) != Comparison.Less)
                return false;
            if (b.Max1.Exists && a.Max1.Exists && this._compare1(a.Max1.Value, b.Max1.Value) != Comparison.Greater)
                return false;

            if (b.Min2.Exists && a.Min2.Exists && this._compare2(a.Min2.Value, b.Min2.Value) != Comparison.Less)
                return false;
            if (b.Max2.Exists && a.Max2.Exists && this._compare2(a.Max2.Value, b.Max2.Value) != Comparison.Greater)
                return false;

            if (b.Min3.Exists && a.Min3.Exists && this._compare3(a.Min3.Value, b.Min3.Value) != Comparison.Less)
                return false;
            if (b.Max3.Exists && a.Max3.Exists && this._compare3(a.Max3.Value, b.Max3.Value) != Comparison.Greater)
                return false;

            return true;
        }

        /// <summary>Checks for equality between two locations.</summary>
        /// <returns>True if equal; False if not;</returns>
        private bool EqualsCheck(Omnitree.Vector<Axis1, Axis2, Axis3> a, Omnitree.Vector<Axis1, Axis2, Axis3> b)
        {

            if (!this._equate1(a.Axis1, b.Axis1))
                return false;

            if (!this._equate2(a.Axis2, b.Axis2))
                return false;

            if (!this._equate3(a.Axis3, b.Axis3))
                return false;

            return true;
        }

        /// <summary>Gets the nearest parent that encapsulates a location.</summary>
        /// <param name="node">The starting node to find the encapsulating parent of the location.</param>
        /// <param name="coordinate1">The coordinate along the 1D axis.</param>
        /// <param name="coordinate2">The coordinate along the 2D axis.</param>
        /// <param name="coordinate3">The coordinate along the 3D axis.</param>
        /// <returns>The nearest node that encapsulates the given location.</returns>
        private Node GetEncapsulationParent(Node node, Omnitree.Vector<Axis1, Axis2, Axis3> vector)
        {
            while (node != null && !EncapsulationCheck(node.Bounds, vector))
                node = node.Parent;
            return node;
        }

        private Omnitree.Vector<Axis1, Axis2, Axis3> LocateVector(T value)
        {
            Axis1 axis1;
            Axis2 axis2;
            Axis3 axis3;
            this._locate(value, out axis1, out axis2, out axis3);
            return new Omnitree.Vector<Axis1, Axis2, Axis3>(axis1, axis2, axis3);
        }

        #endregion

        #endregion
    }

    #endregion

    #region 4 Dimensional

    public interface IOmnitreePoints<T, Axis1, Axis2, Axis3, Axis4> : IDataStructure<T>,
            DataStructure.ICountable,
            DataStructure.IAddable<T>,
            DataStructure.IClearable,
            DataStructure.IRemovable<T>,
            DataStructure.IEquating<T>
    {
        #region Properties

        /// <summary>Steps through the values at a given location.</summary>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
        /// <returns>A Stepper of the items at the given coordinates.</returns>
        Stepper<T> this[Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4] { get; }
        /// <summary>The number of dimensions in this tree.</summary>
        int Dimensions { get; }

        #endregion

        #region Methods

        /// <summary>Counts the number of items in a sub space.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
        /// <returns>The number of items in the provided sub space.</returns>
        int CountSubSpace(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4);

        /// <summary>Iterates through the entire tree and ensures each item is in the proper leaf.</summary>
        void Update();
        /// <summary>Iterates through the provided dimensions and ensures each item is in the proper leaf.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
        void Update(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4);

        /// <summary>Removes all the items in a given space.</summary>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
        void Remove(Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4);
        /// <summary>Removes all the items in a given space.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
        void Remove(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4);
        /// <summary>Removes all the items in a given space where equality is met.</summary>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
        /// <param name="where">The equality constraint of the removal.</param>
        void Remove(Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Predicate<T> where);
        /// <summary>Removes all the items in a given space where predicate is met.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
        /// <param name="where">The predicate constraint of the removal.</param>
        void Remove(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Predicate<T> where);

        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="step">The step function to perform on all items in the tree within the given bounds.</param>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
        void Stepper(Step<T> step, Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4);
        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="step">The step function to perform on all items in the tree within the given bounds.</param>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
        StepStatus Stepper(StepBreak<T> step, Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4);
        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="step">The step function to perform on all items in the tree within the given bounds.</param>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
        void Stepper(Step<T> step, Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4);
        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="step">The step function to perform on all items in the tree within the given bounds.</param>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
        StepStatus Stepper(StepBreak<T> function, Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4);

        #endregion
    }

    public class OmnitreePointsLinked<T, Axis1, Axis2, Axis3, Axis4> : IOmnitreePoints<T, Axis1, Axis2, Axis3, Axis4>
    {
        private const int _dimensions = 4;
        internal static int _children_per_node = (int)BigInteger.Pow(2, 4);

        private Node _top;

		private int _naturalLogLower = 1; // caching the next time to calculate loads (lower count)
		private int _naturalLogUpper = -1; // caching the next time to calculate loads (upper count)
		private int _load; // ln(count); min = _defaultLoad
        private Omnitree.Location<T, Axis1, Axis2, Axis3, Axis4> _locate;

        private bool _defaultEquate;
        private Equate<T> _equate;


        private bool _defaultEquate1;
        private Equate<Axis1> _equate1;

        private bool _defaultEquate2;
        private Equate<Axis2> _equate2;

        private bool _defaultEquate3;
        private Equate<Axis3> _equate3;

        private bool _defaultEquate4;
        private Equate<Axis4> _equate4;



        private bool _defaultCompare1;
        private Compare<Axis1> _compare1;

        private bool _defaultCompare2;
        private Compare<Axis2> _compare2;

        private bool _defaultCompare3;
        private Compare<Axis3> _compare3;

        private bool _defaultCompare4;
        private Compare<Axis4> _compare4;


        // allows median overriding for custom optimizations (USE AT YOUR OWN RISK)
        private Omnitree.SubdivisionOverride<T, Axis1, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>> _subdivisionOverride1;
        private Omnitree.SubdivisionOverride<T, Axis2, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>> _subdivisionOverride2;
        private Omnitree.SubdivisionOverride<T, Axis3, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>> _subdivisionOverride3;
        private Omnitree.SubdivisionOverride<T, Axis4, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>> _subdivisionOverride4;

        #region Nested Types

        /// <summary>Can be a leaf or a branch.</summary>
        public abstract class Node
        {
            internal Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4> _bounds;
            internal Branch _parent;
            internal int _index;
            internal int _count;

            /// <summary>The parent of this node.</summary>
            public Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4> Bounds { get { return this._bounds; } }
            /// <summary>The parent of this node.</summary>
            public Branch Parent { get { return this._parent; } }
            /// <summary>The computed child index of this node (see the "Notes" region in "Omnitree.cs" for the algorithm.</summary>
            public int Index { get { return this._index; } }
            /// <summary>The number of elements stored in this node and its children.</summary>
            public int Count { get { return this._count; } set { this._count = value; } }

            /// <summary>The depth this node is located in the Omnitree.</summary>
            public int Depth
            {
                get
                {
                    int depth = -1;
                    for (Node looper = this; looper != null; looper = looper.Parent)
                        depth++;
                    return depth;
                }
            }

            /// <summary>Constructs a node.</summary>
            /// <param name="bounds">The bounds of this node.</param>
            /// <param name="parent">The parent of this node.</param>
            /// <param name="index">The number of elements stored in this node and its children.</param>
            public Node(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4> bounds, Branch parent, int index)
            {
                this._bounds = bounds;
                this._parent = parent;
                this._index = index;
            }

            internal Node(Node nodeToClone)
            {
                this._bounds = nodeToClone._bounds;
                this._parent = nodeToClone._parent;
                this._index = nodeToClone._index;
                this._count = nodeToClone._count;
            }

            internal abstract Node Clone();
        }

        /// <summary>A branch in the tree. Only contains nodes.</summary>
        public class Branch : Node
        {
            private Node[] _children;
            private Omnitree.Vector<Axis1, Axis2, Axis3, Axis4> _pointOfDivision;

            public Node[] Children { get { return this._children; } set { this._children = value; } }
            public Omnitree.Vector<Axis1, Axis2, Axis3, Axis4> PointOfDivision { get { return this._pointOfDivision; } internal set { this._pointOfDivision = value; } }
            
            /// <summary>Gets child by index.</summary>
            /// <param name="child_index">The index of the child to get.</param>
            /// <returns>The child of the given index or null if non-existent.</returns>
            public Node this[int child_index]
            {
                get
                {
                    if (this._children == null)
                        return null;
                    if (this._children.Length == OmnitreePointsLinked<T, Axis1, Axis2, Axis3, Axis4>._children_per_node)
                        return this._children[(int)child_index];
                    foreach (Node node in this._children)
                        if (node.Index == child_index)
                            return node;
                    return null;
                }
                set
                {
                    // This error check should be unnecessary... but fuck it... might as well
                    if (value.Index != child_index)
                        throw new System.Exception("Bug in Omnitree (index/property mis-match when setting a child on a branch)");

                    // no children yet
                    if (this._children == null)
                    {
                        this._children = new Node[] { value };
                        return;
                    }
                    // max children overwrite
                    else if (this._children.Length == OmnitreePointsLinked<T, Axis1, Axis2, Axis3, Axis4>._children_per_node)
                    {
                        this._children[(int)child_index] = value;
                        return;
                    }
                    // non-max child overwrite
                    for (int i = 0; i < this._children.Length; i++)
                        if (this._children[i].Index == child_index)
                        {
                            this._children[i] = value;
                            return;
                        }
                    // new child
                    Node[] newArray = new Node[this._children.Length + 1];
                    if (newArray.Length == OmnitreePointsLinked<T, Axis1, Axis2, Axis3, Axis4>._children_per_node)
                    {
                        // new child resulting in a max children branch (sorting required)
                        for (int i = 0; i < this._children.Length; i++)
                        {
                            newArray[(int)this._children[i]._index] = this._children[i];
                        }
                        newArray[(int)value._index] = value;
                    }
                    else
                    {
                        // new child resulting in a non-max children branch
                        Array.Copy(this._children, newArray, this._children.Length);
                        newArray[newArray.Length - 1] = value;
                    }
                    this._children = newArray;
                }
            }

            public Branch(Omnitree.Vector<Axis1, Axis2, Axis3, Axis4> pointOfDivision, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4> bounds, Branch parent, int index)
                : base(bounds, parent, index)
            {
                this._pointOfDivision = pointOfDivision;
            }

            public Branch(Branch branchToClone)
                : base(branchToClone)
            {
                this._children = branchToClone._children.Clone() as Node[];
                this._pointOfDivision = branchToClone._pointOfDivision;
            }

            internal override Node Clone()
            {
                return new Branch(this);
            }
        }

        /// <summary>A branch in the tree. Only contains items.</summary>
        public class Leaf : Node
        {
            public class Node
            {
                internal T _value;
                internal Leaf.Node _next;

                public T Value { get { return _value; } set { _value = value; } }
                public Leaf.Node Next { get { return _next; } set { _next = value; } }

                public Node(T value, Leaf.Node next)
                {
                    _value = value;
                    _next = next;
                }
            }

            private Leaf.Node _head;

            public Leaf.Node Head { get { return this._head; } set { this._head = value; } }

            internal Leaf(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4> bounds, Branch parent, int index)
                : base(bounds, parent, index)
            { }

            internal Leaf(Leaf leafToClone)
                : base(leafToClone)
            {
                this._head = new Node(leafToClone._head.Value, null);

                Node this_looper = this._head;
                Node other_looper = leafToClone._head;

                while (other_looper != null)
                {
                    this_looper.Next = new Node(other_looper.Next.Value, null);
                    this_looper = this_looper.Next;
                    other_looper = other_looper.Next;
                }
            }

            public void Add(T addition)
            {
                this._head = new Leaf.Node(addition, this._head);
                this.Count++;
            }

            internal override OmnitreePointsLinked<T, Axis1, Axis2, Axis3, Axis4>.Node Clone()
            {
                return new Leaf(this);
            }
        }

        #endregion

        #region Constructors

        /// <summary>This constructor is for cloning purposes</summary>
        private OmnitreePointsLinked(OmnitreePointsLinked<T, Axis1, Axis2, Axis3, Axis4> omnitree)
        {
            this._top = omnitree._top.Clone();
            this._load = omnitree._load;
            this._locate = omnitree._locate;
            this._defaultEquate = omnitree._defaultEquate;
            this._equate = omnitree._equate;

            this._defaultEquate1 = omnitree._defaultEquate1;
            this._equate1 = omnitree._equate1;
            this._defaultEquate2 = omnitree._defaultEquate2;
            this._equate2 = omnitree._equate2;
            this._defaultEquate3 = omnitree._defaultEquate3;
            this._equate3 = omnitree._equate3;
            this._defaultEquate4 = omnitree._defaultEquate4;
            this._equate4 = omnitree._equate4;

            this._defaultCompare1 = omnitree._defaultCompare1;
            this._compare1 = omnitree._compare1;
            this._defaultCompare2 = omnitree._defaultCompare2;
            this._compare2 = omnitree._compare2;
            this._defaultCompare3 = omnitree._defaultCompare3;
            this._compare3 = omnitree._compare3;
            this._defaultCompare4 = omnitree._defaultCompare4;
            this._compare4 = omnitree._compare4;

            this._subdivisionOverride1 = omnitree._subdivisionOverride1;
            this._subdivisionOverride2 = omnitree._subdivisionOverride2;
            this._subdivisionOverride3 = omnitree._subdivisionOverride3;
            this._subdivisionOverride4 = omnitree._subdivisionOverride4;
        }

        private OmnitreePointsLinked(
            Omnitree.Location<T, Axis1, Axis2, Axis3, Axis4> locate,

            bool defaultEquate,
            Equate<T> equate,

            bool defaultEquate1,
            Equate<Axis1> equateAxis1,
            bool defaultEquate2,
            Equate<Axis2> equateAxis2,
            bool defaultEquate3,
            Equate<Axis3> equateAxis3,
            bool defaultEquate4,
            Equate<Axis4> equateAxis4,

            bool defaultCompare1,
            Compare<Axis1> compare1,
            bool defaultCompare2,
            Compare<Axis2> compare2,
            bool defaultCompare3,
            Compare<Axis3> compare3,
            bool defaultCompare4,
            Compare<Axis4> compare4,

            Omnitree.SubdivisionOverride<T, Axis1, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>> subdivisionOverride1,
            Omnitree.SubdivisionOverride<T, Axis2, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>> subdivisionOverride2,
            Omnitree.SubdivisionOverride<T, Axis3, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>> subdivisionOverride3,
            Omnitree.SubdivisionOverride<T, Axis4, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>> subdivisionOverride4)
        {
			if (locate == null)
			{
				throw new ArgumentNullException(nameof(locate));
			}
			if (equate == null)
			{
				throw new ArgumentNullException(nameof(equate));
			}

			if (equateAxis1 == null)
			{
				throw new ArgumentNullException(nameof(equateAxis1));
			}
			if (equateAxis2 == null)
			{
				throw new ArgumentNullException(nameof(equateAxis2));
			}
			if (equateAxis3 == null)
			{
				throw new ArgumentNullException(nameof(equateAxis3));
			}
			if (equateAxis4 == null)
			{
				throw new ArgumentNullException(nameof(equateAxis4));
			}

			if (compare1 == null)
			{
				throw new ArgumentNullException(nameof(compare1));
			}
			if (compare2 == null)
			{
				throw new ArgumentNullException(nameof(compare2));
			}
			if (compare3 == null)
			{
				throw new ArgumentNullException(nameof(compare3));
			}
			if (compare4 == null)
			{
				throw new ArgumentNullException(nameof(compare4));
			}

            this._locate = locate;
            this._defaultEquate = defaultEquate;
            this._equate = equate;

            this._defaultEquate1 = defaultEquate1;
            this._equate1 = equateAxis1;
            this._defaultEquate2 = defaultEquate2;
            this._equate2 = equateAxis2;
            this._defaultEquate3 = defaultEquate3;
            this._equate3 = equateAxis3;
            this._defaultEquate4 = defaultEquate4;
            this._equate4 = equateAxis4;

            this._defaultCompare1 = defaultCompare1;
            this._compare1 = compare1;
            this._defaultCompare2 = defaultCompare2;
            this._compare2 = compare2;
            this._defaultCompare3 = defaultCompare3;
            this._compare3 = compare3;
            this._defaultCompare4 = defaultCompare4;
            this._compare4 = compare4;

            this._subdivisionOverride1 = subdivisionOverride1;
            this._subdivisionOverride2 = subdivisionOverride2;
            this._subdivisionOverride3 = subdivisionOverride3;
            this._subdivisionOverride4 = subdivisionOverride4;

            this._top = new Leaf(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>.None, null, -1);
            Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
        }

        private OmnitreePointsLinked(
            Omnitree.Location<T, Axis1, Axis2, Axis3, Axis4> locate,
            Equate<T> equate,

            Equate<Axis1> equateAxis1,
            Equate<Axis2> equateAxis2,
            Equate<Axis3> equateAxis3,
            Equate<Axis4> equateAxis4,

            Compare<Axis1> compare1,
            Compare<Axis2> compare2,
            Compare<Axis3> compare3,
            Compare<Axis4> compare4,

            Omnitree.SubdivisionOverride<T, Axis1, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>> subdivisionOverride1,
            Omnitree.SubdivisionOverride<T, Axis2, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>> subdivisionOverride2,
            Omnitree.SubdivisionOverride<T, Axis3, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>> subdivisionOverride3,
            Omnitree.SubdivisionOverride<T, Axis4, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>> subdivisionOverride4)
            : this(
            locate,

            false,
            equate,

            false,
            equateAxis1,
            false,
            equateAxis2,
            false,
            equateAxis3,
            false,
            equateAxis4,

            false,
            compare1,
            false,
            compare2,
            false,
            compare3,
            false,
            compare4,

            subdivisionOverride1,
            subdivisionOverride2,
            subdivisionOverride3,
            subdivisionOverride4)
        { }

        public OmnitreePointsLinked(
            Omnitree.Location<T, Axis1, Axis2, Axis3, Axis4> locate,

            Equate<T> equate,

            Equate<Axis1> equateAxis1,
            Equate<Axis2> equateAxis2,
            Equate<Axis3> equateAxis3,
            Equate<Axis4> equateAxis4,

            Compare<Axis1> compare1,
            Compare<Axis2> compare2,
            Compare<Axis3> compare3,
            Compare<Axis4> compare4)
            : this(
                locate,

                false,
                equate,

                false,
                equateAxis1,
                false,
                equateAxis2,
                false,
                equateAxis3,
                false,
                equateAxis4,

                false,
                compare1,
                false,
                compare2,
                false,
                compare3,
                false,
                compare4,

                null,
                null,
                null,
                null)
        { }



        public OmnitreePointsLinked(
            Omnitree.Location<T, Axis1, Axis2, Axis3, Axis4> locate,

            Equate<T> equate,

            Compare<Axis1> compare1,
            Compare<Axis2> compare2,
            Compare<Axis3> compare3,
            Compare<Axis4> compare4)
            : this(
                locate,
                false,
                equate,

                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,

                false,
                compare1,
                false,
                compare2,
                false,
                compare3,
                false,
                compare4,

                null,
                null,
                null,
                null)
        { }

        public OmnitreePointsLinked(
            Omnitree.Location<T, Axis1, Axis2, Axis3, Axis4> locate,
            Equate<T> equate,

            Compare<Axis1> compare1,
            Compare<Axis2> compare2,
            Compare<Axis3> compare3,
            Compare<Axis4> compare4,

            Omnitree.SubdivisionOverride<T, Axis1, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>> subdivisionOverride1,
            Omnitree.SubdivisionOverride<T, Axis2, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>> subdivisionOverride2,
            Omnitree.SubdivisionOverride<T, Axis3, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>> subdivisionOverride3,
            Omnitree.SubdivisionOverride<T, Axis4, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>> subdivisionOverride4)
            : this(
                locate,

                false,
                equate,

                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,

                false,
                compare1,
                false,
                compare2,
                false,
                compare3,
                false,
                compare4,

                subdivisionOverride1,
                subdivisionOverride2,
                subdivisionOverride3,
                subdivisionOverride4)
        { }

        public OmnitreePointsLinked(
            Omnitree.Location<T, Axis1, Axis2, Axis3, Axis4> locate,

            Compare<Axis1> compare1,
            Compare<Axis2> compare2,
            Compare<Axis3> compare3,
            Compare<Axis4> compare4)
            : this(
                locate,
                true,
                Towel.Equate.Default,

                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,

                false,
                compare1,
                false,
                compare2,
                false,
                compare3,
                false,
                compare4,

                null,
                null,
                null,
                null)
        { }

        public OmnitreePointsLinked(
            Omnitree.Location<T, Axis1, Axis2, Axis3, Axis4> locate,

            Compare<Axis1> compare1,
            Compare<Axis2> compare2,
            Compare<Axis3> compare3,
            Compare<Axis4> compare4,

            Omnitree.SubdivisionOverride<T, Axis1, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>> subdivisionOverride1,
            Omnitree.SubdivisionOverride<T, Axis2, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>> subdivisionOverride2,
            Omnitree.SubdivisionOverride<T, Axis3, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>> subdivisionOverride3,
            Omnitree.SubdivisionOverride<T, Axis4, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>> subdivisionOverride4)
            : this(
                locate,

                true,
                Towel.Equate.Default,

                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,

                false,
                compare1,
                false,
                compare2,
                false,
                compare3,
                false,
                compare4,

                subdivisionOverride1,
                subdivisionOverride2,
                subdivisionOverride3,
                subdivisionOverride4)
        { }

        public OmnitreePointsLinked(
            Omnitree.Location<T, Axis1, Axis2, Axis3, Axis4> locate,
            Equate<T> equate)
            : this(
                locate,

                false,
                equate,

                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,

                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,

                null,
                null,
                null,
                null)
        { }

        public OmnitreePointsLinked(
            Omnitree.Location<T, Axis1, Axis2, Axis3, Axis4> locate,
            Equate<T> equate,
            Omnitree.SubdivisionOverride<T, Axis1, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>> subdivisionOverride1,
            Omnitree.SubdivisionOverride<T, Axis2, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>> subdivisionOverride2,
            Omnitree.SubdivisionOverride<T, Axis3, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>> subdivisionOverride3,
            Omnitree.SubdivisionOverride<T, Axis4, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>> subdivisionOverride4)
            : this(
                locate,

                false,
                equate,

                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,

                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,

                subdivisionOverride1,
                subdivisionOverride2,
                subdivisionOverride3,
                subdivisionOverride4)
        { }

        public OmnitreePointsLinked(
            Omnitree.Location<T, Axis1, Axis2, Axis3, Axis4> locate)
            : this(
                locate,

                true,
                Towel.Equate.Default,

                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,

                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,

                null,
                null,
                null,
                null)
        { }

        public OmnitreePointsLinked(
            Omnitree.Location<T, Axis1, Axis2, Axis3, Axis4> locate,
            Omnitree.SubdivisionOverride<T, Axis1, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>> subdivisionOverride1,
            Omnitree.SubdivisionOverride<T, Axis2, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>> subdivisionOverride2,
            Omnitree.SubdivisionOverride<T, Axis3, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>> subdivisionOverride3,
            Omnitree.SubdivisionOverride<T, Axis4, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>> subdivisionOverride4)
            : this(
                locate,

                true,
                Towel.Equate.Default,

                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,

                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,

                subdivisionOverride1,
                subdivisionOverride2,
                subdivisionOverride3,
                subdivisionOverride4)
        { }

        #endregion

        #region Properties

        /// <summary>Steps through all the items at a given coordinate.</summary>
        /// <param name="axis1">The coordinate along axis 1.</param>
        /// <param name="axis2">The coordinate along axis 2.</param>
        /// <param name="axis3">The coordinate along axis 3.</param>
        /// <param name="axis4">The coordinate along axis 4.</param>
        /// <returns>The stepper for the items at the given coordinate.</returns>
        public Stepper<T> this[Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4]
        {
            get
            {
                return (Step<T> step) => { this.Stepper(step, axis1, axis2, axis3, axis4); };
            }
        }

        /// <summary>The number of dimensions in this tree.</summary>
        public int Dimensions { get { return _dimensions; } }

        /// <summary>The function for equating keys in this table.</summary>
        public Equate<T> Equate { get { return this._equate; } }

        /// <summary>The location function the Omnitree is using.</summary>
        public Omnitree.Location<T, Axis1, Axis2, Axis3, Axis4> Locate { get { return this._locate; } }


        /// <summary>The comparison function the Omnitree is using along the 1D axis.</summary>
        public Compare<Axis1> Compare1 { get { return this._compare1; } }
        /// <summary>The comparison function the Omnitree is using along the 2D axis.</summary>
        public Compare<Axis2> Compare2 { get { return this._compare2; } }
        /// <summary>The comparison function the Omnitree is using along the 3D axis.</summary>
        public Compare<Axis3> Compare3 { get { return this._compare3; } }
        /// <summary>The comparison function the Omnitree is using along the 4D axis.</summary>
        public Compare<Axis4> Compare4 { get { return this._compare4; } }

        /// <summary>The function for equating values along the 1D axis.</summary>
        public Equate<Axis1> EquateAxis1 { get { return this._equate1; } }
        /// <summary>The function for equating values along the 2D axis.</summary>
        public Equate<Axis2> EquateAxis2 { get { return this._equate2; } }
        /// <summary>The function for equating values along the 3D axis.</summary>
        public Equate<Axis3> EquateAxis3 { get { return this._equate3; } }
        /// <summary>The function for equating values along the 4D axis.</summary>
        public Equate<Axis4> EquateAxis4 { get { return this._equate4; } }

        /// <summary>The current number of items in the tree.</summary>
        public int Count { get { return this._top.Count; } }

        private delegate void MaxDepthFinder(Node node, int current_depth, ref int max_depth);
        /// <summary>Finds the current maximum depth of the tree. NOT AN O(1) OPERATION. Intended for educational purposes only.</summary>
        public int MaxDepth
        {
            get
            {
                MaxDepthFinder maxDepthFinder = null;
                maxDepthFinder =
                        (Node node, int current_depth, ref int max_depth) =>
                        {
                            if (current_depth > max_depth)
                                max_depth = current_depth;
                            if (node is Branch)
                                foreach (Node child in (node as Branch).Children)
                                    maxDepthFinder(child, current_depth + 1, ref max_depth);
                        };
                int _max_depth = -1;
                maxDepthFinder(this._top, 0, ref _max_depth);
                return _max_depth;
            }
        }

        private delegate void NodeCountFinder(Node node, ref int current_count);
        /// <summary>Counts the current number of nodes in the tree. NOT AN O(1) OPERATION. Intended for educational purposes only.</summary>
        public int NodeCount
        {
            get
            {
                NodeCountFinder nodeCountFinder = null;
                nodeCountFinder =
                        (Node node, ref int current_count) =>
                        {
                            current_count++;
                            if (node is Branch)
                                foreach (Node child in (node as Branch).Children)
                                    nodeCountFinder(child, ref current_count);
                        };

                int _current_count = 0;
                nodeCountFinder(this._top, ref _current_count);
                return _current_count;
            }
        }

        private delegate void BranchCountFinder(Node node, ref int current_count);
        /// <summary>Counts the current number of branches in the tree. NOT AN O(1) OPERATION. Intended for educational purposes only.</summary>
        public int BranchCount
        {
            get
            {
                BranchCountFinder branchCountFinder = null;
                branchCountFinder =
                        (Node node, ref int current_count) =>
                        {
                            if (node is Branch)
                            {
                                current_count++;
                                foreach (Node child in (node as Branch).Children)
                                    branchCountFinder(child, ref current_count);
                            }
                        };

                int _current_count = 0;
                branchCountFinder(this._top, ref _current_count);
                return _current_count;
            }
        }

        private delegate void LeafCountFinder(Node node, ref int current_count);
        /// <summary>Counts the current number of leaves in the tree. NOT AN O(1) OPERATION. Intended for educational purposes only.</summary>
        public int LeafCount
        {
            get
            {
                LeafCountFinder leafCountFinder = null;
                leafCountFinder =
                        (Node node, ref int current_count) =>
                        {
                            if (node is Leaf)
                                current_count++;
                            else
                                foreach (Node child in (node as Branch).Children)
                                    leafCountFinder(child, ref current_count);
                        };

                int _current_count = 0;
                leafCountFinder(this._top, ref _current_count);
                return _current_count;
            }
        }

        #endregion

        #region Methods

        #region Add

        #region Bulk

        public void Add(IndexedBigArray<T> additions, bool allowMultithreading)
        {
            if (additions.Length > int.MaxValue)
                throw new System.Exception("The maximum size of the Omnitree was exceeded during bulk addition.");

            if (this._top.Count != 0 || (int)additions.Length <= _load)
            {
                for (ulong i = 0; i < additions.Length; i++)
                    this.Add(additions[i]);
            }
            else
            {
                // adjust the loads prior to additions
				Omnitree.ComputeLoads((int)additions.Length, ref _naturalLogLower, ref _naturalLogUpper, ref _load);

                Branch new_top = new Branch(Omnitree.Vector<Axis1, Axis2, Axis3, Axis4>.Default, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>.None, null, -1);
                new_top.Count = (int)additions.Length;


                // prepare data for median computations
                IndexedBigArray<Axis1> values1;
                IAsyncResult result1 = null;
                if (this._subdivisionOverride1 != null)
                    values1 = null;
                else
                {
                    values1 = null;
                    Towel.Parallels.Parallel.Operation operation = () =>
                    {
                        values1 = new IndexedBigArray<Axis1>(additions.Length);
                        for (ulong i = 0; i < additions.Length; i++)
                            values1[i] = LocateVector(additions[i]).Axis1;
                        Towel.Algorithms.Sort.Merge(this._compare1, (int i) => { return values1[(ulong)i]; }, (int i, Axis1 value) => { values1[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
                    };

                    if (allowMultithreading)
                        result1 = Towel.Parallels.Parallel.Thread(operation);
                    else
                        operation();
                }

                // prepare data for median computations
                IndexedBigArray<Axis2> values2;
                IAsyncResult result2 = null;
                if (this._subdivisionOverride2 != null)
                    values2 = null;
                else
                {
                    values2 = null;
                    Towel.Parallels.Parallel.Operation operation = () =>
                    {
                        values2 = new IndexedBigArray<Axis2>(additions.Length);
                        for (ulong i = 0; i < additions.Length; i++)
                            values2[i] = LocateVector(additions[i]).Axis2;
                        Towel.Algorithms.Sort.Merge(this._compare2, (int i) => { return values2[(ulong)i]; }, (int i, Axis2 value) => { values2[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
                    };

                    if (allowMultithreading)
                        result2 = Towel.Parallels.Parallel.Thread(operation);
                    else
                        operation();
                }

                // prepare data for median computations
                IndexedBigArray<Axis3> values3;
                IAsyncResult result3 = null;
                if (this._subdivisionOverride3 != null)
                    values3 = null;
                else
                {
                    values3 = null;
                    Towel.Parallels.Parallel.Operation operation = () =>
                    {
                        values3 = new IndexedBigArray<Axis3>(additions.Length);
                        for (ulong i = 0; i < additions.Length; i++)
                            values3[i] = LocateVector(additions[i]).Axis3;
                        Towel.Algorithms.Sort.Merge(this._compare3, (int i) => { return values3[(ulong)i]; }, (int i, Axis3 value) => { values3[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
                    };

                    if (allowMultithreading)
                        result3 = Towel.Parallels.Parallel.Thread(operation);
                    else
                        operation();
                }

                // prepare data for median computations
                IndexedBigArray<Axis4> values4;
                IAsyncResult result4 = null;
                if (this._subdivisionOverride4 != null)
                    values4 = null;
                else
                {
                    values4 = null;
                    Towel.Parallels.Parallel.Operation operation = () =>
                    {
                        values4 = new IndexedBigArray<Axis4>(additions.Length);
                        for (ulong i = 0; i < additions.Length; i++)
                            values4[i] = LocateVector(additions[i]).Axis4;
                        Towel.Algorithms.Sort.Merge(this._compare4, (int i) => { return values4[(ulong)i]; }, (int i, Axis4 value) => { values4[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
                    };

                    if (allowMultithreading)
                        result4 = Towel.Parallels.Parallel.Thread(operation);
                    else
                        operation();
                }



                if (this._subdivisionOverride1 == null && allowMultithreading)
                    result1.AsyncWaitHandle.WaitOne();

                if (this._subdivisionOverride2 == null && allowMultithreading)
                    result2.AsyncWaitHandle.WaitOne();

                if (this._subdivisionOverride3 == null && allowMultithreading)
                    result3.AsyncWaitHandle.WaitOne();

                if (this._subdivisionOverride4 == null && allowMultithreading)
                    result4.AsyncWaitHandle.WaitOne();


                // build the tree
                Add(new_top, 1, -1, additions.Stepper(), (int)additions.Length, int.MinValue, int.MinValue, int.MinValue, int.MinValue, (int)additions.Length, (int index) => { return values1[index]; }, (int index) => { return values2[index]; }, (int index) => { return values3[index]; }, (int index) => { return values4[index]; }, allowMultithreading);
                
                this._top = new_top;
            }
        }

        public void Add(bool allowMultithreading, params T[] additions)
        {
            if (additions.Length > int.MaxValue)
                throw new System.Exception("The maximum size of the Omnitree was exceeded during bulk addition.");

            if (this._top.Count != 0 || (int)additions.Length <= _load)
            {
                for (int i = 0; i < additions.Length; i++)
                    this.Add(additions[i]);
            }
            else
            {
                // adjust the loads prior to additions
				Omnitree.ComputeLoads((int)additions.Length, ref _naturalLogLower, ref _naturalLogUpper, ref _load);

                Branch new_top = new Branch(Omnitree.Vector<Axis1, Axis2, Axis3, Axis4>.Default, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>.None, null, -1);
                new_top.Count = (int)additions.Length;


                // prepare data for median computations
                IndexedBigArray<Axis1> values1;
                IAsyncResult result1 = null;
                if (this._subdivisionOverride1 != null)
                    values1 = null;
                else
                {
                    values1 = null;
                    Towel.Parallels.Parallel.Operation operation = () =>
                    {
                        values1 = new IndexedBigArray<Axis1>(additions.Length);
                        for (int i = 0; i < additions.Length; i++)
                            values1[i] = LocateVector(additions[i]).Axis1;
                        Towel.Algorithms.Sort.Merge(this._compare1, (int i) => { return values1[(ulong)i]; }, (int i, Axis1 value) => { values1[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
                    };

                    if (allowMultithreading)
                        result1 = Towel.Parallels.Parallel.Thread(operation);
                    else
                        operation();
                }

                // prepare data for median computations
                IndexedBigArray<Axis2> values2;
                IAsyncResult result2 = null;
                if (this._subdivisionOverride2 != null)
                    values2 = null;
                else
                {
                    values2 = null;
                    Towel.Parallels.Parallel.Operation operation = () =>
                    {
                        values2 = new IndexedBigArray<Axis2>(additions.Length);
                        for (int i = 0; i < additions.Length; i++)
                            values2[i] = LocateVector(additions[i]).Axis2;
                        Towel.Algorithms.Sort.Merge(this._compare2, (int i) => { return values2[(ulong)i]; }, (int i, Axis2 value) => { values2[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
                    };

                    if (allowMultithreading)
                        result2 = Towel.Parallels.Parallel.Thread(operation);
                    else
                        operation();
                }

                // prepare data for median computations
                IndexedBigArray<Axis3> values3;
                IAsyncResult result3 = null;
                if (this._subdivisionOverride3 != null)
                    values3 = null;
                else
                {
                    values3 = null;
                    Towel.Parallels.Parallel.Operation operation = () =>
                    {
                        values3 = new IndexedBigArray<Axis3>(additions.Length);
                        for (int i = 0; i < additions.Length; i++)
                            values3[i] = LocateVector(additions[i]).Axis3;
                        Towel.Algorithms.Sort.Merge(this._compare3, (int i) => { return values3[(ulong)i]; }, (int i, Axis3 value) => { values3[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
                    };

                    if (allowMultithreading)
                        result3 = Towel.Parallels.Parallel.Thread(operation);
                    else
                        operation();
                }

                // prepare data for median computations
                IndexedBigArray<Axis4> values4;
                IAsyncResult result4 = null;
                if (this._subdivisionOverride4 != null)
                    values4 = null;
                else
                {
                    values4 = null;
                    Towel.Parallels.Parallel.Operation operation = () =>
                    {
                        values4 = new IndexedBigArray<Axis4>(additions.Length);
                        for (int i = 0; i < additions.Length; i++)
                            values4[i] = LocateVector(additions[i]).Axis4;
                        Towel.Algorithms.Sort.Merge(this._compare4, (int i) => { return values4[(ulong)i]; }, (int i, Axis4 value) => { values4[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
                    };

                    if (allowMultithreading)
                        result4 = Towel.Parallels.Parallel.Thread(operation);
                    else
                        operation();
                }



                if (this._subdivisionOverride1 == null && allowMultithreading)
                    result1.AsyncWaitHandle.WaitOne();

                if (this._subdivisionOverride2 == null && allowMultithreading)
                    result2.AsyncWaitHandle.WaitOne();

                if (this._subdivisionOverride3 == null && allowMultithreading)
                    result3.AsyncWaitHandle.WaitOne();

                if (this._subdivisionOverride4 == null && allowMultithreading)
                    result4.AsyncWaitHandle.WaitOne();


                // build the tree
                Add(new_top, 1, -1, additions.Stepper(), additions.Length, int.MinValue, int.MinValue, int.MinValue, int.MinValue, (int)additions.Length, (int index) => { return values1[index]; }, (int index) => { return values2[index]; }, (int index) => { return values3[index]; }, (int index) => { return values4[index]; }, allowMultithreading);
                
                this._top = new_top;
            }
        }

        
        private int Add(Branch parent, int depth, int child, Stepper<T> additions, int parent_count, int prevmed1, int prevmed2, int prevmed3, int prevmed4, int initial_count, Get<Axis1> values1, Get<Axis2> values2, Get<Axis3> values3, Get<Axis4> values4, bool allowMultithreading)
        {
            Axis1 pointOfDivision1;
            Axis2 pointOfDivision2;
            Axis3 pointOfDivision3;
            Axis4 pointOfDivision4;

            int median_axis1 = -1;
            int median_axis2 = -1;
            int median_axis3 = -1;
            int median_axis4 = -1;
            if (this._subdivisionOverride1 == null || this._subdivisionOverride2 == null || this._subdivisionOverride3 == null || this._subdivisionOverride4 == null)
                GetMedianIndexes(initial_count, child, depth, prevmed1, prevmed2, prevmed3, prevmed4, out median_axis1, out median_axis2, out median_axis3, out median_axis4);

            if (this._subdivisionOverride1 != null)
                pointOfDivision1 = this._subdivisionOverride1(parent.Bounds, additions);
            else
                pointOfDivision1 = values1(median_axis1);

            if (this._subdivisionOverride2 != null)
                pointOfDivision2 = this._subdivisionOverride2(parent.Bounds, additions);
            else
                pointOfDivision2 = values2(median_axis2);

            if (this._subdivisionOverride3 != null)
                pointOfDivision3 = this._subdivisionOverride3(parent.Bounds, additions);
            else
                pointOfDivision3 = values3(median_axis3);

            if (this._subdivisionOverride4 != null)
                pointOfDivision4 = this._subdivisionOverride4(parent.Bounds, additions);
            else
                pointOfDivision4 = values4(median_axis4);

            parent.PointOfDivision = new Omnitree.Vector<Axis1, Axis2, Axis3, Axis4>(pointOfDivision1, pointOfDivision2, pointOfDivision3, pointOfDivision4);

            // divide the values along the medians
            IMap<IAddable<T>, int> collection_map = new MapHashLinked<IAddable<T>, int>();
            additions((T value) => 
            {
                int index = DetermineChildIndex(parent.PointOfDivision, LocateVector(value));
                IAddable<T> list = null;
                if (collection_map.TryGet(index, out list))
                {
                    list.Add(value);
                }
                else
                {
                    if (parent_count < 100000)
                        list = new AddableArray<T>();
                    else
                        list = new AddableLinked<T>();
                    collection_map.Add(index, list);
                    list.Add(value);
                }
            });

            if (depth == 1 && allowMultithreading)
            {
                // NOTE: Must assign placeholders before multithreading so that the threads do not overwrite each other
                collection_map.Keys((int key) => { parent[key] = new Leaf(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>.None, parent, key); });
                IAsyncResult[] handles = new IAsyncResult[Environment.ProcessorCount];
                for (int i = 0; i < handles.Length; i++)
                {
                    int multiTheadSafe_i = i; // used as catpure variable below making it multithread-safe
                    handles[i] = Towel.Parallels.Parallel.Thread(() =>
                    {
                        Step.EveryNth<Link<IAddable<T>, int>>(collection_map.Pairs, multiTheadSafe_i + 1)(
                        (Link<IAddable<T>, int> link) =>
                            {
                                ReversedChildBuilding(parent, link._2, depth, link._1.Stepper, link._1.Count, median_axis1, median_axis2, median_axis3, median_axis4, initial_count, values1, values2, values3, values4, allowMultithreading);
                            });
                    });
                }
                
                foreach (IAsyncResult handle in handles)
                {
                    handle.AsyncWaitHandle.WaitOne();
                }
            }
            else
            {
                collection_map.Pairs((Link<IAddable<T>, int> link) =>
                { 
                    ReversedChildBuilding(parent, link._2, depth, link._1.Stepper, link._1.Count, median_axis1, median_axis2, median_axis3, median_axis4, initial_count, values1, values2, values3, values4, allowMultithreading);
                });
            }

            int count = 0;
            foreach (Node node in parent.Children)
                count += node.Count;
            return count;
        }

        int ReversedChildBuilding(Branch parent, int child_index, int depth, Stepper<T> additions, int count, int prevmed1, int prevmed2, int prevmed3, int prevmed4, int initial_count, Get<Axis1> values1, Get<Axis2> values2, Get<Axis3> values3, Get<Axis4> values4, bool allowMultithreading)
        {
            Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4> child_bounds = DetermineChildBounds(parent, child_index);
            if (depth >= _load || count <= _load)
            {
                Leaf new_leaf = new Leaf(child_bounds, parent, child_index);
                additions((T value) => { new_leaf.Add(value); });
                parent[new_leaf.Index] = new_leaf;
                return new_leaf.Count;
            }
            else
            {
                Branch new_branch = new Branch(Omnitree.Vector<Axis1, Axis2, Axis3, Axis4>.Default, child_bounds, parent, child_index);
                parent[new_branch.Index] = new_branch;
                new_branch.Count = Add(new_branch, depth + 1, child_index, additions, count, prevmed1, prevmed2, prevmed3, prevmed4, count, values1, values2, values3, values4, allowMultithreading);
                return new_branch.Count;
            }
        }

        /// <summary>Gets the indeces of the median values at the given position during bulk additions.</summary>
        private void GetMedianIndexes(int count, int child_index, int depth, int previous1, int previous2, int previous3, int previous4, out int index1, out int index2, out int index3, out int index4)
        {
            if (depth == 1)
            {
                index1 = (count - 1) / 2;
                index2 = (count - 1) / 2;
                index3 = (count - 1) / 2;
                index4 = (count - 1) / 2;
                return;
            }

            int splits = Compute.Power(2, depth);
            int mid_child_range = count / splits;

            if (child_index >= 8)
            {
                index4 = previous4 + mid_child_range;
                child_index -= 8;
            }
            else
            {
                index4 = previous4 - mid_child_range;
            }

            if (child_index >= 4)
            {
                index3 = previous3 + mid_child_range;
                child_index -= 4;
            }
            else
            {
                index3 = previous3 - mid_child_range;
            }

            if (child_index >= 2)
            {
                index2 = previous2 + mid_child_range;
                child_index -= 2;
            }
            else
            {
                index2 = previous2 - mid_child_range;
            }

            if (child_index >= 1)
            {
                index1 = previous1 + mid_child_range;
                child_index -= 1;
            }
            else
            {
                index1 = previous1 - mid_child_range;
            }

        }

        #endregion

        #region single

        /// <summary>Adds an item to the tree.</summary>
        /// <param name="addition">The item to be added.</param>
        public void Add(T addition)
        {
            if (this._top.Count == int.MaxValue)
                throw new System.InvalidOperationException("(Count == int.MaxValue) max Omnitree size reached (change ints to longs if you need to).");

            // dynamic tree sizes
			Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);

            Omnitree.Vector<Axis1, Axis2, Axis3, Axis4> location = LocateVector(addition);

            // grow the first branch of the tree
            if (this._top is Leaf && (this._top as Leaf).Count >= _load)
            {
                Leaf top = this._top as Leaf;

                // create the new branch from the median values
                this._top = new Branch(DetermineMedians(top), Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>.None, null, -1);

                // iterate through the elements and add them to the appropriate children
                for (Leaf.Node list = top.Head; list != null; list = list.Next)
                    Add(list.Value, this._top, LocateVector(list.Value), 0);
            }

            this.Add(addition, this._top, location, 0);
        }
        
        /// <summary>Recursive version of the add function.</summary>
        /// <param name="addition">The item to be added.</param>
        /// <param name="node">The current node for tree trversal.</param>
        /// <param name="ms">The location of the addition.</param>
        /// <param name="depth">The current depth of iteration.</param>
        private void Add(T addition, Node node, Omnitree.Vector<Axis1, Axis2, Axis3, Axis4> location, int depth)
        {
            if (node is Leaf)
            {
                Leaf leaf = node as Leaf;
                if (depth >= _load || !(leaf.Count >= _load))
                {
                    leaf.Add(addition);
                    return;
                }
                else
                {
                    Branch parent = node.Parent;
                    int child_index = this.DetermineChildIndex(parent.PointOfDivision, location);
                    Branch growth = new Branch(DetermineMedians(leaf), leaf.Bounds, parent, child_index);
                    parent[child_index] = growth;
                    for (Leaf.Node list = leaf.Head; list != null; list = list.Next)
                    {
                        Omnitree.Vector<Axis1, Axis2, Axis3, Axis4> temp_location = LocateVector(list.Value);
                        if (EncapsulationCheck(growth.Bounds, temp_location))
                            Add(list.Value, growth, temp_location, depth);
                        else
                        {
                            ReduceParentCounts(parent, 1);
                            Add(list.Value, this._top, temp_location, depth);
                        }
                    }

                    Add(addition, growth, location, depth);
                    return;
                }
            }
            else
            {
                Branch branch = node as Branch;
                int child_index = this.DetermineChildIndex(branch.PointOfDivision, location); // determine the child "index" (0 through 2^Dimensions) the addition belongs in
                Node child_node = branch[child_index];

                // null children in branches are just empty leaves
                if (child_node == null)
                {
                    Leaf new_leaf = new Leaf(DetermineChildBounds(branch, child_index), branch, child_index);
                    branch[child_index] = new_leaf;
                    new_leaf.Add(addition);
                }
                else
                    // child exists already, continue adding
                    Add(addition, child_node, location, depth + 1);

                branch.Count++;
                return;
            }
        }

        /// <summary>Determins the dimensions of the child at the given index.</summary>
        /// <param name="leaf">The parent of the node to compute dimensions for.</param>
        /// <param name="child">The index of the child to compute dimensions for.</param>
        /// <param name="median1">The computed minimum dimensions of the child node along the 1D axis.</param>
        /// <param name="median2">The computed minimum dimensions of the child node along the 2D axis.</param>
        /// <param name="median3">The computed minimum dimensions of the child node along the 3D axis.</param>
        private Omnitree.Vector<Axis1, Axis2, Axis3, Axis4> DetermineMedians(Leaf leaf)
        {
            try
            {
                // extract the values
                Axis1[] values1 = new Axis1[leaf.Count];
                Axis2[] values2 = new Axis2[leaf.Count];
                Axis3[] values3 = new Axis3[leaf.Count];
                Axis4[] values4 = new Axis4[leaf.Count];
                Leaf.Node for_current = leaf.Head; // used in for loop
                for (int i = 0; i < leaf.Count; i++, for_current = for_current.Next)
                    this._locate(for_current.Value, out values1[i], out values2[i], out values3[i], out values4[i]);
                // sort the values
                if (_defaultCompare1) Array.Sort(values1);
                else Array.Sort(values1, Compare.ToSystemComparison(this._compare1));
                if (_defaultCompare2) Array.Sort(values2);
                else Array.Sort(values2, Compare.ToSystemComparison(this._compare2));
                if (_defaultCompare3) Array.Sort(values3);
                else Array.Sort(values3, Compare.ToSystemComparison(this._compare3));
                if (_defaultCompare4) Array.Sort(values4);
                else Array.Sort(values4, Compare.ToSystemComparison(this._compare4));
                // pull out the lazy medians (if even # of items... just take the left)
                int index = (leaf.Count - 1) / 2;
                return new Omnitree.Vector<Axis1, Axis2, Axis3, Axis4>(values1[index], values2[index], values3[index], values4[index]);
            }
            catch (Exception exception)
            {
				System.Diagnostics.Debugger.Break();
                // extract the values
                IndexedBigArray<Axis1> values1 = new IndexedBigArray<Axis1>(leaf.Count);
                IndexedBigArray<Axis2> values2 = new IndexedBigArray<Axis2>(leaf.Count);
                IndexedBigArray<Axis3> values3 = new IndexedBigArray<Axis3>(leaf.Count);
                IndexedBigArray<Axis4> values4 = new IndexedBigArray<Axis4>(leaf.Count);
                Leaf.Node for_current = leaf.Head; // used in for loop
                for (int i = 0; i < leaf.Count; i++, for_current = for_current.Next)
                {
                    Axis1 value1;
                    Axis2 value2;
                    Axis3 value3;
                    Axis4 value4;
                    this._locate(for_current.Value, out value1, out value2, out value3, out value4);
                    values1[i] = value1;
                    values2[i] = value2;
                    values3[i] = value3;
                    values4[i] = value4;
                }
                // sort the values
                if (_defaultCompare1) Towel.Algorithms.Sort.Merge(Compare.Default, (int sorting_index) => { return values1[sorting_index]; }, (int sorting_index, Axis1 axis1) => { values1[sorting_index] = axis1; }, 0, (int)values1.Length);
                else Towel.Algorithms.Sort.Merge(_compare1, (int sorting_index) => { return values1[sorting_index]; }, (int sorting_index, Axis1 axis1) => { values1[sorting_index] = axis1; }, 0, (int)values1.Length);
                if (_defaultCompare2) Towel.Algorithms.Sort.Merge(Compare.Default, (int sorting_index) => { return values2[sorting_index]; }, (int sorting_index, Axis2 axis2) => { values2[sorting_index] = axis2; }, 0, (int)values1.Length);
                else Towel.Algorithms.Sort.Merge(_compare2, (int sorting_index) => { return values2[sorting_index]; }, (int sorting_index, Axis2 axis2) => { values2[sorting_index] = axis2; }, 0, (int)values1.Length);
                if (_defaultCompare3) Towel.Algorithms.Sort.Merge(Compare.Default, (int sorting_index) => { return values3[sorting_index]; }, (int sorting_index, Axis3 axis3) => { values3[sorting_index] = axis3; }, 0, (int)values1.Length);
                else Towel.Algorithms.Sort.Merge(_compare3, (int sorting_index) => { return values3[sorting_index]; }, (int sorting_index, Axis3 axis3) => { values3[sorting_index] = axis3; }, 0, (int)values1.Length);
                if (_defaultCompare4) Towel.Algorithms.Sort.Merge(Compare.Default, (int sorting_index) => { return values4[sorting_index]; }, (int sorting_index, Axis4 axis4) => { values4[sorting_index] = axis4; }, 0, (int)values1.Length);
                else Towel.Algorithms.Sort.Merge(_compare4, (int sorting_index) => { return values4[sorting_index]; }, (int sorting_index, Axis4 axis4) => { values4[sorting_index] = axis4; }, 0, (int)values1.Length);
                // pull out the lazy medians (if even # of items... just take the left)
                int index = (leaf.Count - 1) / 2;
                return new Omnitree.Vector<Axis1, Axis2, Axis3, Axis4>(values1[index], values2[index], values3[index], values4[index]);
            }
        }

        #endregion

        #region Add Helpers

        private Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4> DetermineChildBounds(Branch branch, int child_index)
        {

            Omnitree.Bound<Axis4> min4, max4;
            if (child_index >= 8)
            {
                min4 = branch.PointOfDivision.Axis4;
                max4 = branch.Bounds.Max4;
                child_index -= 8;
            }
            else
            {
                min4 = branch.Bounds.Min4;
                max4 = branch.PointOfDivision.Axis4;
            }

            Omnitree.Bound<Axis3> min3, max3;
            if (child_index >= 4)
            {
                min3 = branch.PointOfDivision.Axis3;
                max3 = branch.Bounds.Max3;
                child_index -= 4;
            }
            else
            {
                min3 = branch.Bounds.Min3;
                max3 = branch.PointOfDivision.Axis3;
            }

            Omnitree.Bound<Axis2> min2, max2;
            if (child_index >= 2)
            {
                min2 = branch.PointOfDivision.Axis2;
                max2 = branch.Bounds.Max2;
                child_index -= 2;
            }
            else
            {
                min2 = branch.Bounds.Min2;
                max2 = branch.PointOfDivision.Axis2;
            }

            Omnitree.Bound<Axis1> min1, max1;
            if (child_index >= 1)
            {
                min1 = branch.PointOfDivision.Axis1;
                max1 = branch.Bounds.Max1;
                child_index -= 1;
            }
            else
            {
                min1 = branch.Bounds.Min1;
                max1 = branch.PointOfDivision.Axis1;
            }

            return new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>(min1, max1, min2, max2, min3, max3, min4, max4);
        }

        #endregion

        #endregion

        #region Clear

        /// <summary>Returns the tree to an empty state.</summary>
        public void Clear()
        {
            this._top = new Leaf(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>.None, null, -1);
			Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
        }

        #endregion

        #region Clone

        /// <summary>Creates a shallow clone of this data structure.</summary>
        /// <returns>A shallow clone of this data structure.</returns>
        public OmnitreePointsLinked<T, Axis1, Axis2, Axis3, Axis4> Clone()
        {
            return new OmnitreePointsLinked<T, Axis1, Axis2, Axis3, Axis4>(this);
        }

        #endregion

        #region Count

        /// <summary>Counts the number of items in a sub space.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
        /// <returns>The number of items in the provided sub space.</returns>
        public int CountSubSpace(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4)
        {
            return CountSubSpace(_top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>(min1, max1, min2, max2, min3, max3, min4, max4));
        }
        /// <summary>Counts the number of items in a sub space.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
        /// <returns>The number of items in the provided sub space.</returns>
        public int CountSubSpace(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4)
        {
            return CountSubSpace(_top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>(min1, max1, min2, max2, min3, max3, min4, max4));
        }
        /// <summary>Counts the number of items in a sub space.</summary>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
        /// <returns>The number of items in the provided sub space.</returns>
        public int CountSubSpace(Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4)
        {
            return CountSubSpace(_top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>(axis1, axis1, axis2, axis2, axis3, axis3, axis4, axis4));
        }
        /// <summary>Counts the number of items in a sub space.</summary>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
        /// <returns>The number of items in the provided sub space.</returns>
        public int CountSubSpace(Omnitree.Bound<Axis1> axis1, Omnitree.Bound<Axis2> axis2, Omnitree.Bound<Axis3> axis3, Omnitree.Bound<Axis4> axis4)
        {
            return CountSubSpace(_top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>(axis1, axis1, axis2, axis2, axis3, axis3, axis4, axis4));
        }
        /// <summary>Counts the number of items in a sub space.</summary>
        /// <param name="node">The current traversal node.</param>
        /// <returns>The number of items in the provided sub space.</returns>
        private int CountSubSpace(Node node, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4> bounds)
        {
            // adjust min/max values
            int count = 0;
            if (EncapsulationCheck(bounds, node.Bounds))
                count += node.Count;
            else if (node is Leaf)
            {
                for (Leaf.Node list = (node as Leaf).Head; list != null; list = list.Next)
                    if (EncapsulationCheck(bounds, LocateVector(list.Value)))
                        count++;
            }
            else
            {
                Branch branch = node as Branch;
                if (!StraddlesLines(branch.Bounds, branch.PointOfDivision))
                {
                    int child_index = DetermineChildIndex(branch.PointOfDivision, new Omnitree.Vector<Axis1, Axis2, Axis3, Axis4>(bounds.Min1.Value, bounds.Min2.Value, bounds.Min3.Value, bounds.Min4.Value));
                    Node child = branch[child_index];
                    if (child != null)
                      count += this.CountSubSpace(child, bounds);
                }
                else
                {
                    foreach (Node child in (node as Branch).Children)
                        count += this.CountSubSpace(child, bounds);
                }
            }
            return count;
        }

        #endregion

        #region Update

        /// <summary>Iterates through the entire tree and ensures each item is in the proper leaf.</summary>
        public void Update()
        {
            this.Update(this._top, 0);
        }

        /// <summary>Recursive version of the Update method.</summary>
        /// <param name="node">The current node of iteration.</param>
        /// <param name="depth">The current depth of iteration.</param>
        private int Update(Node node, int depth)
        {
            int removals = 0;

            if (node is Leaf)
            {
                Leaf leaf = node as Leaf;
                Leaf.Node current = leaf.Head;
                Leaf.Node previous = null;
                while (current != null)
                {
                    Omnitree.Vector<Axis1, Axis2, Axis3, Axis4> location = LocateVector(current.Value);
                    if (!this.EncapsulationCheck(node.Bounds, location))
                    {
                        removals++;
                        T updated = current.Value;
                        if (previous == null)
                        {
                            leaf.Head = current.Next;
                            goto HeadRemoved;
                        }
                        else
                            previous.Next = current.Next;

                        Node whereToAdd = GetEncapsulationParent(node.Parent, location);

                        if (whereToAdd == null)
                            throw new System.Exception("an item was updated outside the range of the omnitree");

                        this.Add(updated, whereToAdd, location, whereToAdd.Depth);
                    }
                    previous = current;
                HeadRemoved:
                    current = current.Next;
                }
                leaf.Count -= removals;
                return removals;
            }
            else
            {
                Branch branch = node as Branch;
                int skipped = 0;
                for (int i = 0; i + skipped < branch.Children.Length; )
                {
                    removals += this.Update(branch.Children[i], depth + 1);
                    if (branch.Children[i].Count == 0)
                        branch.Children[i] = branch.Children[branch.Children.Length - skipped++ - 1];
                    else
                        i++;
                }
                Node[] newArray = new Node[branch.Children.Length - skipped];
                Array.Copy(branch.Children, newArray, newArray.Length);
                branch.Children = newArray;

                branch.Count -= removals;

                if (branch.Count < _load && branch.Count != 0)
                    ShrinkChild(branch.Parent, branch.Index);
            }

            return removals;
        }

        /// <summary>Iterates through the provided dimensions and ensures each item is in the proper leaf.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
        public void Update(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4)
        {
            this.Update(new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>(min1, max1, min2, max2, min3, max3, min4, max4), this._top, 0);
        }
        /// <summary>Iterates through the provided dimensions and ensures each item is in the proper leaf.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
        public void Update(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4)
        {
            this.Update(new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>(min1, max1, min2, max2, min3, max3, min4, max4), this._top, 0);
        }
        /// <summary>Iterates through the provided dimensions and ensures each item is in the proper leaf.</summary>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
        public void Update(Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4)
        {
            this.Update(new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>(axis1, axis1, axis2, axis2, axis3, axis3, axis4, axis4), this._top, 0);
        }
        /// <summary>Iterates through the provided dimensions and ensures each item is in the proper leaf.</summary>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
        public void Update(Omnitree.Bound<Axis1> axis1, Omnitree.Bound<Axis2> axis2, Omnitree.Bound<Axis3> axis3, Omnitree.Bound<Axis4> axis4)
        {
            this.Update(new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>(axis1, axis1, axis2, axis2, axis3, axis3, axis4, axis4), this._top, 0);
        }
        private int Update(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4> bounds, Node node, int depth)
        {
            if (!InclusionCheck(bounds, node.Bounds))
                return 0;

            int removals = 0;

            if (node is Leaf)
            {
                Leaf leaf = node as Leaf;
                Leaf.Node current = leaf.Head;
                Leaf.Node previous = null;
                while (current != null)
                {
                    Omnitree.Vector<Axis1, Axis2, Axis3, Axis4> location = LocateVector(current.Value);
                    if (!this.EncapsulationCheck(node.Bounds, location))
                    {
                        removals++;
                        T updated = current.Value;
                        if (previous == null)
                        {
                            leaf.Head = current.Next;
                            goto HeadRemoved;
                        }
                        else
                            previous.Next = current.Next;
                        Node whereToAdd = GetEncapsulationParent(node.Parent, location);
                        if (whereToAdd == null)
                            throw new System.Exception("an item was updates outside the range of the omnitree");
                        this.Add(updated, whereToAdd, location, whereToAdd.Depth);
                    }
                    previous = current;
                HeadRemoved:
                    current = current.Next;
                }
                leaf.Count -= removals;
                return removals;
            }
            else
            {
                Branch branch = node as Branch;
                int skipped = 0;
                for (int i = 0; i + skipped < branch.Children.Length; )
                {
                    removals += this.Update(branch.Children[i], depth + 1);
                    if (branch.Children[i].Count == 0)
                        branch.Children[i] = branch.Children[branch.Children.Length - skipped++ - 1];
                    else
                        i++;
                }
                Node[] newArray = new Node[branch.Children.Length - skipped];
                Array.Copy(branch.Children, newArray, newArray.Length);
                branch.Children = newArray;

                branch.Count -= removals;

                if (branch.Count < _load && branch.Count != 0)
                    ShrinkChild(branch.Parent, branch.Index);
            }

            return removals;
        }

        #endregion

        #region Remove

        /// <summary>Removes all the items qualified by the delegate.</summary>
        /// <param name="where">The predicate to qualify removals.</param>
        public void Remove(Predicate<T> where)
        {
            this.Remove(this._top, where);
			Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
        }

        /// <summary>Recursive version of the remove method.</summary>
        /// <param name="node">The current node of traversal.</param>
        /// <param name="where">The predicate to qualify removals.</param>
        private int Remove(Node node, Predicate<T> where)
        {
            int removals = 0;
            if (node is Leaf)
            {
                Leaf leaf = node as Leaf;
                while (leaf.Head != null && where(leaf.Head.Value))
                {
                    leaf.Head = leaf.Head.Next;
                    removals++;
                }
                if (leaf.Head != null)
                {
                    Leaf.Node list = leaf.Head;
                    while (list.Next != null)
                    {
                        if (where(list.Next.Value))
                        {
                            list.Next = list.Next.Next;
                            removals++;
                        }
                    }
                }

                leaf.Count -= removals;
                return removals;
            }
            else
            {
                Branch branch = node as Branch;
                int skipped = 0;
                for (int i = 0; i + skipped < branch.Children.Length; )
                {
                    removals += this.Remove(branch.Children[i], where);
                    if (branch.Children[i].Count == 0)
                        branch.Children[i] = branch.Children[branch.Children.Length - skipped++ - 1];
                    else
                        i++;
                }
                Node[] newArray = new Node[branch.Children.Length - skipped];
                Array.Copy(branch.Children, newArray, newArray.Length);
                branch.Children = newArray;

                branch.Count -= removals;

                if (branch.Count < _load && branch.Count != 0)
                    ShrinkChild(branch.Parent, branch.Index);

                return removals;
            }
        }

        /// <summary>Removes all the items in a given space.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
        /// <returns>The number of items that were removed.</returns>
        public void Remove(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4)
        {
            this.Remove(this._top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>(min1, max1, min2, max2, min3, max3, min4, max4));
            Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
        }
        /// <summary>Removes all the items in a given space.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
        /// <returns>The number of items that were removed.</returns>
        public void Remove(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4)
        {
            this.Remove(this._top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>(min1, max1, min2, max2, min3, max3, min4, max4));
            Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
        }
        private int Remove(Node node, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4> bounds)
        {
            int removals = 0;
            if (InclusionCheck(bounds, node.Bounds))
            {
                if (node is Leaf)
                {
                    Leaf leaf = node as Leaf;
                    Leaf.Node current_node = leaf.Head;
                    Leaf.Node previous_node = null;
                    while (current_node != null)
                    {
                        Leaf.Node temp_previous = current_node;
                        if (EncapsulationCheck(bounds, LocateVector(current_node.Value)))
                        {
                            removals++;
                            if (current_node == leaf.Head)
                                leaf.Head = leaf.Head.Next;
                            else
                            {
                                previous_node.Next = current_node.Next;
                                temp_previous = previous_node;
                            }
                        }
                        previous_node = temp_previous;
                        current_node = current_node.Next;
                    }
                    leaf.Count -= removals;
                }
                else
                {
                    Branch branch = node as Branch;
                    int skipped = 0;
                    for (int i = 0; i + skipped < branch.Children.Length; )
                    {
                        removals += this.Remove(branch.Children[i], bounds);
                        if (branch.Children[i].Count == 0)
                            branch.Children[i] = branch.Children[branch.Children.Length - skipped++ - 1];
                        else
                            i++;
                    }
                    Node[] newArray = new Node[branch.Children.Length - skipped];
                    Array.Copy(branch.Children, newArray, newArray.Length);
                    branch.Children = newArray;

                    branch.Count -= removals;
                    // convert this branch back into a leaf
                    // Note: if count is zero, it will be chopped off
                    if (branch.Count < _load && branch.Count > 0)
                        ShrinkChild(branch.Parent, branch.Index);
                }
            }

            return removals;
        }

        /// <summary>Removes all the items in a given space validated by a predicate.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
        /// <param name="where">The equality constraint of the removal.</param>
        public void Remove(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Predicate<T> where)
        {
            this.Remove(this._top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>(min1, max1, min2, max2, min3, max3, min4, max4), where);
            Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
        }
        /// <summary>Removes all the items in a given space validated by a predicate.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
        /// <param name="where">The equality constraint of the removal.</param>
        public void Remove(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Predicate<T> where)
        {
            this.Remove(this._top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>(min1, max1, min2, max2, min3, max3, min4, max4), where);
			Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
        }
        private int Remove(Node node, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4> bounds, Predicate<T> where)
        {
            if (!InclusionCheck(node.Bounds, bounds))
                return 0;
            int removals = 0;
            if (node is Leaf)
            {
                Leaf leaf = node as Leaf;
                Leaf.Node current = leaf.Head;
                Leaf.Node previous = null;
                while (current != null)
                {
                    if (this.EncapsulationCheck(bounds, LocateVector(current.Value)) && where(current.Value))
                    {
                        removals++;
                        if (previous == null)
                        {
                            leaf.Head = current.Next;
                            goto HeadRemoved;
                        }
                        else
                            previous.Next = current.Next;
                    }
                    previous = current;
                HeadRemoved:
                    current = current.Next;
                }

                leaf.Count -= removals;
                return removals;
            }
            else
            {
                Branch branch = node as Branch;
                int skipped = 0;
                for (int i = 0; i + skipped < branch.Children.Length; )
                {
                    removals += this.Remove(branch.Children[i], bounds, where);
                    if (branch.Children[i].Count == 0)
                        branch.Children[i] = branch.Children[branch.Children.Length - skipped++ - 1];
                    else
                        i++;
                }
                Node[] newArray = new Node[branch.Children.Length - skipped];
                Array.Copy(branch.Children, newArray, newArray.Length);
                branch.Children = newArray;

                node.Count -= removals;

                if (node.Count < _load && node.Count != 0)
                    ShrinkChild(node.Parent, node.Index);

                return removals;
            }
        }

        /// <summary>Removes all instances of a given value.</summary>
        public void Remove(T removal)
        {
            Axis1 axis1;
            Axis2 axis2;
            Axis3 axis3;
            Axis4 axis4;
            this._locate(removal, out axis1, out axis2, out axis3, out axis4);
            this.Remove(axis1, axis2, axis3, axis4, (T item) => { return this._equate(item, removal); });
        }
        /// <summary>Removes all the items in a given space.</summary>
        /// <param name="axis1">The axis of the removal along the  1D axis.</param>
		/// <param name="axis2">The axis of the removal along the  2D axis.</param>
		/// <param name="axis3">The axis of the removal along the  3D axis.</param>
		/// <param name="axis4">The axis of the removal along the  4D axis.</param>
        /// <returns>The number of items that were removed.</returns>
        public void Remove(Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4)
        {
            this.Remove(this._top, new Omnitree.Vector<Axis1, Axis2, Axis3, Axis4>(axis1, axis2, axis3, axis4));
            Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
        }
        private int Remove(Node node, Omnitree.Vector<Axis1, Axis2, Axis3, Axis4> vector)
        {
            int removals = 0;
            if (node is Leaf)
            {
                Leaf leaf = node as Leaf;
                Leaf.Node current_node = leaf.Head;
                Leaf.Node previous_node = null;
                while (current_node != null)
                {
                    Leaf.Node temp_previous = current_node;
                    if (EqualsCheck(vector, LocateVector(current_node.Value)))
                    {
                        removals++;
                        if (current_node == leaf.Head)
                            leaf.Head = leaf.Head.Next;
                        else
                        {
                            previous_node.Next = current_node.Next;
                            temp_previous = previous_node;
                        }
                    }
                    previous_node = temp_previous;
                    current_node = current_node.Next;
                }
                leaf.Count -= removals;
            }
            else
            {
                Branch branch = node as Branch;
                int child_index = DetermineChildIndex(branch.PointOfDivision, vector);
                removals += Remove(branch[child_index], vector);
                branch.Count -= removals;
                // convert this branch back into a leaf
                // Note: if count is zero, it will be chopped off
                if (branch.Count < _load && branch.Count > 0)
                    ShrinkChild(branch.Parent, branch.Index);
            }

            return removals;
        }

        /// <summary>Removes all the items in a given space validated by a predicate.</summary>
        /// <param name="axis1">The axis of the removal along the  1D axis.</param>
		/// <param name="axis2">The axis of the removal along the  2D axis.</param>
		/// <param name="axis3">The axis of the removal along the  3D axis.</param>
		/// <param name="axis4">The axis of the removal along the  4D axis.</param>
        /// <param name="where">The equality constraint of the removal.</param>
        public void Remove(Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Predicate<T> where)
        {
            this.Remove(this._top, new Omnitree.Vector<Axis1, Axis2, Axis3, Axis4>(axis1, axis2, axis3, axis4), where);
            Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
        }
        private int Remove(Node node, Omnitree.Vector<Axis1, Axis2, Axis3, Axis4> vector, Predicate<T> where)
        {
            int removals = 0;
            if (node is Leaf)
            {
                Leaf leaf = node as Leaf;
                Leaf.Node current_node = leaf.Head;
                Leaf.Node previous_node = null;
                while (current_node != null)
                {
                    Leaf.Node temp_previous = current_node;
                    if (EqualsCheck(vector, LocateVector(current_node.Value)) && where(current_node.Value))
                    {
                        removals++;
                        if (current_node == leaf.Head)
                            leaf.Head = leaf.Head.Next;
                        else
                        {
                            previous_node.Next = current_node.Next;
                            temp_previous = previous_node;
                        }
                    }
                    previous_node = temp_previous;
                    current_node = current_node.Next;
                }
                leaf.Count -= removals;
            }
            else
            {
                Branch branch = node as Branch;
                int child_index = DetermineChildIndex(branch.PointOfDivision, vector);
                removals += Remove(branch[child_index], vector, where);
                branch.Count -= removals;
                // convert this branch back into a leaf
                // Note: if count is zero, it will be chopped off
                if (branch.Count < _load && branch.Count > 0)
                    ShrinkChild(branch.Parent, branch.Index);
            }
            return removals;
        }

        #endregion

        #region Stepper And IEnumerable

        /// <summary>Traverses every item in the tree and performs the delegate in them.</summary>
        /// <param name="function">The delegate to perform on every item in the tree.</param>
        public void Stepper(Step<T> function)
        {
            this.Stepper(function, this._top);
        }
        private void Stepper(Step<T> function, Node node)
        {
            if (node is Leaf)
            {
                Leaf.Node list = (node as Leaf).Head;
                while (list != null)
                {
                    function(list.Value);
                    list = list.Next;
                }
            }
            else
            {
                foreach (Node child in (node as Branch).Children)
                    this.Stepper(function, child);
            }
        }

        /// <summary>Traverses every item in the tree and performs the delegate in them.</summary>
        /// <param name="function">The delegate to perform on every item in the tree.</param>
        public StepStatus Stepper(StepBreak<T> function)
        {
            return Stepper(function, _top);
        }
        private StepStatus Stepper(StepBreak<T> function, Node node)
        {
            StepStatus status = StepStatus.Continue;
            if (node is Leaf)
            {
                for (Leaf.Node list = (node as Leaf).Head; list != null; list = list.Next)
                    if ((status = function(list._value)) != StepStatus.Continue)
                        break;
            }
            else
            {
                foreach (Node child in (node as Branch).Children)
                    if ((status = Stepper(function, child)) != StepStatus.Continue)
                        break;
            }
            return status;
        }

        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="function">The delegate to perform on all items in the tree within the given bounds.</param>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
        public void Stepper(Step<T> function, Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4)
        {
            Stepper(function, _top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>(min1, max1, min2, max2, min3, max3, min4, max4));
        }
        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="function">The delegate to perform on all items in the tree within the given bounds.</param>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
        public void Stepper(Step<T> function, Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4)
        {
            Stepper(function, _top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>(min1, max1, min2, max2, min3, max3, min4, max4));
        }
        private void Stepper(Step<T> function, Node node, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4> bounds)
        {
            if (node is Leaf)
            {
                for (Leaf.Node list = (node as Leaf).Head; list != null; list = list.Next)
                    if (EncapsulationCheck(bounds, LocateVector(list.Value)))
                        function(list.Value);
            }
            else
            {
                foreach (Node child in (node as Branch).Children)
                    // optimization: stop bounds checking if space encapsulates node
                    if (EncapsulationCheck(bounds, child.Bounds))
                        this.Stepper(function, child);
                    else if (InclusionCheck(child.Bounds, bounds))
                        this.Stepper(function, child, bounds);
            }
        }

        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
        public StepStatus Stepper(StepBreak<T> function, Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4)
        {
            return Stepper(function, _top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>(min1, max1, min2, max2, min3, max3, min4, max4));
        }
        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
        public StepStatus Stepper(StepBreak<T> function, Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4)
        {
            return Stepper(function, _top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>(min1, max1, min2, max2, min3, max3, min4, max4));
        }
        private StepStatus Stepper(StepBreak<T> function, Node node, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4> bounds)
        {
            StepStatus status = StepStatus.Continue;
            if (node is Leaf)
            {
                for (Leaf.Node list = (node as Leaf).Head; list != null; list = list.Next)
                    if (EncapsulationCheck(bounds, LocateVector(list.Value)) &&
                        (status = function(list.Value)) != StepStatus.Continue)
                        break;
            }
            else
            {
                foreach (Node child in (node as Branch).Children)
                    // optimization: stop bounds checking if space encapsulates node
                    if (EncapsulationCheck(bounds, child.Bounds) &&
                        (status = this.Stepper(function, child)) != StepStatus.Continue)
                        break;
                    else if (!InclusionCheck(child.Bounds, bounds) &&
                        (status = this.Stepper(function, child, bounds)) != StepStatus.Continue)
                        break;
            }
            return status;
        }

        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="axis1">The axis of the removal along the  1D axis.</param>
		/// <param name="axis2">The axis of the removal along the  2D axis.</param>
		/// <param name="axis3">The axis of the removal along the  3D axis.</param>
		/// <param name="axis4">The axis of the removal along the  4D axis.</param>
        public void Stepper(Step<T> function, Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4)
        {
            Stepper(function, _top, new Omnitree.Vector<Axis1, Axis2, Axis3, Axis4>(axis1, axis2, axis3, axis4));
        }
        private void Stepper(Step<T> function, Node node, Omnitree.Vector<Axis1, Axis2, Axis3, Axis4> vector)
        {
            Node current = node;
            while (current != null)
            {
                if (current is Leaf)
                {
                    for (Leaf.Node leaf_node = (current as Leaf).Head; leaf_node != null; leaf_node = leaf_node.Next)
                        if (EqualsCheck(vector, LocateVector(leaf_node.Value)))
                            function(leaf_node.Value);
                    break;
                }
                else
                {
                    Branch branch = current as Branch;
                    int child_index = DetermineChildIndex(branch.PointOfDivision, vector);
                    current = branch[child_index];
                }
            }
        }

        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="function">The delegate to perform on all items in the tree within the given bounds.</param>
        /// <param name="axis1">The axis of the removal along the  1D axis.</param>
		/// <param name="axis2">The axis of the removal along the  2D axis.</param>
		/// <param name="axis3">The axis of the removal along the  3D axis.</param>
		/// <param name="axis4">The axis of the removal along the  4D axis.</param>
        public StepStatus Stepper(StepBreak<T> function, Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4)
        {
            return Stepper(function, _top, new Omnitree.Vector<Axis1, Axis2, Axis3, Axis4>(axis1, axis2, axis3, axis4));
        }
        private StepStatus Stepper(StepBreak<T> function, Node node, Omnitree.Vector<Axis1, Axis2, Axis3, Axis4> vector)
        {
            Node current = node;
            while (current != null)
            {
                if (current is Leaf)
                {
                    for (Leaf.Node list = (current as Leaf).Head; list != null; list = list.Next)
                    {
                        StepStatus status = StepStatus.Continue;
                        if (EqualsCheck(vector, LocateVector(list.Value)) &&
                            (status = function(list.Value)) != StepStatus.Continue)
                            return status;
                    }
                }
                else
                {
                    Branch branch = current as Branch;
                    int child_index = DetermineChildIndex(branch.PointOfDivision, vector);
                    current = branch[child_index];
                }
            }
            return StepStatus.Continue;
        }

        /// <summary>FOR COMPATIBILITY ONLY. AVOID IF POSSIBLE.</summary>
        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
        {
            throw new System.NotImplementedException();
            //return (this.ToArray() as System.Collections.Generic.IEnumerable<T>).GetEnumerator();
        }

        /// <summary>FOR COMPATIBILITY ONLY. AVOID IF POSSIBLE.</summary>
        System.Collections.Generic.IEnumerator<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator()
        {
            throw new System.NotImplementedException();
            //return (this.ToArray() as System.Collections.Generic.IEnumerable<T>).GetEnumerator();
        }

        #endregion

        #region Helpers

        private bool StraddlesLines(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4> bounds, Omnitree.Vector<Axis1, Axis2, Axis3, Axis4> vector)
        {
			if ((!bounds.Min1.Exists || (bounds.Min1.Exists && this._compare1(bounds.Min1.Value, vector.Axis1) != Comparison.Greater)) &&
				(!bounds.Max1.Exists || (bounds.Max1.Exists && this._compare1(bounds.Max1.Value, vector.Axis1) != Comparison.Less)))
				return true;
			if ((!bounds.Min2.Exists || (bounds.Min2.Exists && this._compare2(bounds.Min2.Value, vector.Axis2) != Comparison.Greater)) &&
				(!bounds.Max2.Exists || (bounds.Max2.Exists && this._compare2(bounds.Max2.Value, vector.Axis2) != Comparison.Less)))
				return true;
			if ((!bounds.Min3.Exists || (bounds.Min3.Exists && this._compare3(bounds.Min3.Value, vector.Axis3) != Comparison.Greater)) &&
				(!bounds.Max3.Exists || (bounds.Max3.Exists && this._compare3(bounds.Max3.Value, vector.Axis3) != Comparison.Less)))
				return true;
			if ((!bounds.Min4.Exists || (bounds.Min4.Exists && this._compare4(bounds.Min4.Value, vector.Axis4) != Comparison.Greater)) &&
				(!bounds.Max4.Exists || (bounds.Max4.Exists && this._compare4(bounds.Max4.Value, vector.Axis4) != Comparison.Less)))
				return true;
            return false;
        }

        /// <summary>Computes the child index that contains the desired dimensions.</summary>
        /// <param name="node">The branch .</param>
        /// <param name="vector">The dimensions to determine the child index.</param>
        /// <returns>The computed child index based on the coordinates relative to the center of the node.</returns>
        private int DetermineChildIndex(Omnitree.Vector<Axis1, Axis2, Axis3, Axis4> pointOfDivision, Omnitree.Vector<Axis1, Axis2, Axis3, Axis4> vector)
        {
            int child = 0;
            if (!(this._compare1(vector.Axis1, pointOfDivision.Axis1) == Comparison.Less))
                child += 1 << 0;
            if (!(this._compare2(vector.Axis2, pointOfDivision.Axis2) == Comparison.Less))
                child += 1 << 1;
            if (!(this._compare3(vector.Axis3, pointOfDivision.Axis3) == Comparison.Less))
                child += 1 << 2;
            if (!(this._compare4(vector.Axis4, pointOfDivision.Axis4) == Comparison.Less))
                child += 1 << 3;
            return child;
        }

        /// <summary>Converts a branch back into a leaf when the count is reduced.</summary>
        /// <param name="parent">The parent to shrink a child of.</param>
        /// <param name="child">The index of the child to shrink.</param>
        private void ShrinkChild(Branch parent, int child_index)
        {
            Leaf leaf;
            Node removal = null;
            if (parent == null) // top of tree
            {
                removal = this._top;
                leaf = new Leaf(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>.None, null, -1);
                this._top = leaf;
            }
            else // non-top branch
            {
                removal = parent[child_index];
                leaf = new Leaf(removal.Bounds, removal.Parent, removal.Index);
                parent[child_index] = leaf;
            }

            this.Stepper((T step) => { leaf.Add(step); }, removal);
        }

        /// <summary>Reduces the counts of all the parents of a given node by a given amount.</summary>
        /// <param name="parent">The starting parent of the reduction.</param>
        /// <param name="reduction">The amount to reduce the parent counts by.</param>
        private void ReduceParentCounts(Node parent, int reduction)
        {
            IncreaseParentCounts(parent, -reduction);
        }

        /// <summary>Increases the counts of all the parents of a given node by a given amount.</summary>
        /// <param name="parent">The starting parent of the increase.</param>
        /// <param name="increase">The amount to increase the parent counts by.</param>
        private void IncreaseParentCounts(Node parent, int increase)
        {
            Node looper = parent;
            while (looper != null)
            {
                looper.Count += increase;
                looper = looper.Parent;
            }
        }

        /// <summary>Checks a node for inclusion (overlap) between two bounds.</summary>
        /// <returns>True if the spaces overlap; False if not.</returns>
        private bool InclusionCheck(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4> a, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4> b)
        {

            if (a.Max1.Exists && b.Min1.Exists && this._compare1(a.Max1.Value, b.Min1.Value) == Comparison.Less)
                return false;
            else if (a.Min1.Exists && b.Max1.Exists && this._compare1(a.Min1.Value, b.Max1.Value) == Comparison.Greater)
                return false;

            if (a.Max2.Exists && b.Min2.Exists && this._compare2(a.Max2.Value, b.Min2.Value) == Comparison.Less)
                return false;
            else if (a.Min2.Exists && b.Max2.Exists && this._compare2(a.Min2.Value, b.Max2.Value) == Comparison.Greater)
                return false;

            if (a.Max3.Exists && b.Min3.Exists && this._compare3(a.Max3.Value, b.Min3.Value) == Comparison.Less)
                return false;
            else if (a.Min3.Exists && b.Max3.Exists && this._compare3(a.Min3.Value, b.Max3.Value) == Comparison.Greater)
                return false;

            if (a.Max4.Exists && b.Min4.Exists && this._compare4(a.Max4.Value, b.Min4.Value) == Comparison.Less)
                return false;
            else if (a.Min4.Exists && b.Max4.Exists && this._compare4(a.Min4.Value, b.Max4.Value) == Comparison.Greater)
                return false;

            return true;
        }

        /// <summary>Checks if a space encapsulates a point.</summary>
        /// <returns>True if the space encapsulates the point; False if not.</returns>
        private bool EncapsulationCheck(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4> bounds, Omnitree.Vector<Axis1, Axis2, Axis3, Axis4> vector)
        {
            // if the location is not outside the bounds, it must be inside

            if (bounds.Min1.Exists && this._compare1(vector.Axis1, bounds.Min1.Value) == Comparison.Less)
                return false;
            else if (bounds.Max1.Exists && this._compare1(vector.Axis1, bounds.Max1.Value) == Comparison.Greater)
                return false;

            if (bounds.Min2.Exists && this._compare2(vector.Axis2, bounds.Min2.Value) == Comparison.Less)
                return false;
            else if (bounds.Max2.Exists && this._compare2(vector.Axis2, bounds.Max2.Value) == Comparison.Greater)
                return false;

            if (bounds.Min3.Exists && this._compare3(vector.Axis3, bounds.Min3.Value) == Comparison.Less)
                return false;
            else if (bounds.Max3.Exists && this._compare3(vector.Axis3, bounds.Max3.Value) == Comparison.Greater)
                return false;

            if (bounds.Min4.Exists && this._compare4(vector.Axis4, bounds.Min4.Value) == Comparison.Less)
                return false;
            else if (bounds.Max4.Exists && this._compare4(vector.Axis4, bounds.Max4.Value) == Comparison.Greater)
                return false;

            return true;
        }

        /// <summary>Checks if a space (left) encapsulates another space (right).</summary>
        /// <returns>True if the left space encapsulates the right; False if not.</returns>
        private bool EncapsulationCheck(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4> a, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4> b)
        {
            if ((a.Min1.Exists && !b.Min1.Exists) || (a.Min2.Exists && !b.Min2.Exists) || (a.Min3.Exists && !b.Min3.Exists) || (a.Min4.Exists && !b.Min4.Exists))
                return false;
			if ((a.Max1.Exists && !b.Max1.Exists) || (a.Max2.Exists && !b.Max2.Exists) || (a.Max3.Exists && !b.Max3.Exists) || (a.Max4.Exists && !b.Max4.Exists))
                return false;

            if (b.Min1.Exists && a.Min1.Exists && this._compare1(a.Min1.Value, b.Min1.Value) != Comparison.Less)
                return false;
            if (b.Max1.Exists && a.Max1.Exists && this._compare1(a.Max1.Value, b.Max1.Value) != Comparison.Greater)
                return false;

            if (b.Min2.Exists && a.Min2.Exists && this._compare2(a.Min2.Value, b.Min2.Value) != Comparison.Less)
                return false;
            if (b.Max2.Exists && a.Max2.Exists && this._compare2(a.Max2.Value, b.Max2.Value) != Comparison.Greater)
                return false;

            if (b.Min3.Exists && a.Min3.Exists && this._compare3(a.Min3.Value, b.Min3.Value) != Comparison.Less)
                return false;
            if (b.Max3.Exists && a.Max3.Exists && this._compare3(a.Max3.Value, b.Max3.Value) != Comparison.Greater)
                return false;

            if (b.Min4.Exists && a.Min4.Exists && this._compare4(a.Min4.Value, b.Min4.Value) != Comparison.Less)
                return false;
            if (b.Max4.Exists && a.Max4.Exists && this._compare4(a.Max4.Value, b.Max4.Value) != Comparison.Greater)
                return false;

            return true;
        }

        /// <summary>Checks for equality between two locations.</summary>
        /// <returns>True if equal; False if not;</returns>
        private bool EqualsCheck(Omnitree.Vector<Axis1, Axis2, Axis3, Axis4> a, Omnitree.Vector<Axis1, Axis2, Axis3, Axis4> b)
        {

            if (!this._equate1(a.Axis1, b.Axis1))
                return false;

            if (!this._equate2(a.Axis2, b.Axis2))
                return false;

            if (!this._equate3(a.Axis3, b.Axis3))
                return false;

            if (!this._equate4(a.Axis4, b.Axis4))
                return false;

            return true;
        }

        /// <summary>Gets the nearest parent that encapsulates a location.</summary>
        /// <param name="node">The starting node to find the encapsulating parent of the location.</param>
        /// <param name="coordinate1">The coordinate along the 1D axis.</param>
        /// <param name="coordinate2">The coordinate along the 2D axis.</param>
        /// <param name="coordinate3">The coordinate along the 3D axis.</param>
        /// <returns>The nearest node that encapsulates the given location.</returns>
        private Node GetEncapsulationParent(Node node, Omnitree.Vector<Axis1, Axis2, Axis3, Axis4> vector)
        {
            while (node != null && !EncapsulationCheck(node.Bounds, vector))
                node = node.Parent;
            return node;
        }

        private Omnitree.Vector<Axis1, Axis2, Axis3, Axis4> LocateVector(T value)
        {
            Axis1 axis1;
            Axis2 axis2;
            Axis3 axis3;
            Axis4 axis4;
            this._locate(value, out axis1, out axis2, out axis3, out axis4);
            return new Omnitree.Vector<Axis1, Axis2, Axis3, Axis4>(axis1, axis2, axis3, axis4);
        }

        #endregion

        #endregion
    }

    #endregion

    #region 5 Dimensional

    public interface IOmnitreePoints<T, Axis1, Axis2, Axis3, Axis4, Axis5> : IDataStructure<T>,
            DataStructure.ICountable,
            DataStructure.IAddable<T>,
            DataStructure.IClearable,
            DataStructure.IRemovable<T>,
            DataStructure.IEquating<T>
    {
        #region Properties

        /// <summary>Steps through the values at a given location.</summary>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
		/// <param name="axis5">The coordinate along the 5D axis.</param>
        /// <returns>A Stepper of the items at the given coordinates.</returns>
        Stepper<T> this[Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Axis5 axis5] { get; }
        /// <summary>The number of dimensions in this tree.</summary>
        int Dimensions { get; }

        #endregion

        #region Methods

        /// <summary>Counts the number of items in a sub space.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
        /// <returns>The number of items in the provided sub space.</returns>
        int CountSubSpace(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5);

        /// <summary>Iterates through the entire tree and ensures each item is in the proper leaf.</summary>
        void Update();
        /// <summary>Iterates through the provided dimensions and ensures each item is in the proper leaf.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
        void Update(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5);

        /// <summary>Removes all the items in a given space.</summary>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
		/// <param name="axis5">The coordinate along the 5D axis.</param>
        void Remove(Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Axis5 axis5);
        /// <summary>Removes all the items in a given space.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
        void Remove(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5);
        /// <summary>Removes all the items in a given space where equality is met.</summary>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
		/// <param name="axis5">The coordinate along the 5D axis.</param>
        /// <param name="where">The equality constraint of the removal.</param>
        void Remove(Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Axis5 axis5, Predicate<T> where);
        /// <summary>Removes all the items in a given space where predicate is met.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
        /// <param name="where">The predicate constraint of the removal.</param>
        void Remove(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5, Predicate<T> where);

        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="step">The step function to perform on all items in the tree within the given bounds.</param>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
        void Stepper(Step<T> step, Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5);
        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="step">The step function to perform on all items in the tree within the given bounds.</param>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
        StepStatus Stepper(StepBreak<T> step, Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5);
        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="step">The step function to perform on all items in the tree within the given bounds.</param>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
		/// <param name="axis5">The coordinate along the 5D axis.</param>
        void Stepper(Step<T> step, Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Axis5 axis5);
        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="step">The step function to perform on all items in the tree within the given bounds.</param>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
		/// <param name="axis5">The coordinate along the 5D axis.</param>
        StepStatus Stepper(StepBreak<T> function, Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Axis5 axis5);

        #endregion
    }

    public class OmnitreePointsLinked<T, Axis1, Axis2, Axis3, Axis4, Axis5> : IOmnitreePoints<T, Axis1, Axis2, Axis3, Axis4, Axis5>
    {
        private const int _dimensions = 5;
        internal static int _children_per_node = (int)BigInteger.Pow(2, 5);

        private Node _top;

		private int _naturalLogLower = 1; // caching the next time to calculate loads (lower count)
		private int _naturalLogUpper = -1; // caching the next time to calculate loads (upper count)
		private int _load; // ln(count); min = _defaultLoad
        private Omnitree.Location<T, Axis1, Axis2, Axis3, Axis4, Axis5> _locate;

        private bool _defaultEquate;
        private Equate<T> _equate;


        private bool _defaultEquate1;
        private Equate<Axis1> _equate1;

        private bool _defaultEquate2;
        private Equate<Axis2> _equate2;

        private bool _defaultEquate3;
        private Equate<Axis3> _equate3;

        private bool _defaultEquate4;
        private Equate<Axis4> _equate4;

        private bool _defaultEquate5;
        private Equate<Axis5> _equate5;



        private bool _defaultCompare1;
        private Compare<Axis1> _compare1;

        private bool _defaultCompare2;
        private Compare<Axis2> _compare2;

        private bool _defaultCompare3;
        private Compare<Axis3> _compare3;

        private bool _defaultCompare4;
        private Compare<Axis4> _compare4;

        private bool _defaultCompare5;
        private Compare<Axis5> _compare5;


        // allows median overriding for custom optimizations (USE AT YOUR OWN RISK)
        private Omnitree.SubdivisionOverride<T, Axis1, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>> _subdivisionOverride1;
        private Omnitree.SubdivisionOverride<T, Axis2, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>> _subdivisionOverride2;
        private Omnitree.SubdivisionOverride<T, Axis3, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>> _subdivisionOverride3;
        private Omnitree.SubdivisionOverride<T, Axis4, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>> _subdivisionOverride4;
        private Omnitree.SubdivisionOverride<T, Axis5, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>> _subdivisionOverride5;

        #region Nested Types

        /// <summary>Can be a leaf or a branch.</summary>
        public abstract class Node
        {
            internal Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5> _bounds;
            internal Branch _parent;
            internal int _index;
            internal int _count;

            /// <summary>The parent of this node.</summary>
            public Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5> Bounds { get { return this._bounds; } }
            /// <summary>The parent of this node.</summary>
            public Branch Parent { get { return this._parent; } }
            /// <summary>The computed child index of this node (see the "Notes" region in "Omnitree.cs" for the algorithm.</summary>
            public int Index { get { return this._index; } }
            /// <summary>The number of elements stored in this node and its children.</summary>
            public int Count { get { return this._count; } set { this._count = value; } }

            /// <summary>The depth this node is located in the Omnitree.</summary>
            public int Depth
            {
                get
                {
                    int depth = -1;
                    for (Node looper = this; looper != null; looper = looper.Parent)
                        depth++;
                    return depth;
                }
            }

            /// <summary>Constructs a node.</summary>
            /// <param name="bounds">The bounds of this node.</param>
            /// <param name="parent">The parent of this node.</param>
            /// <param name="index">The number of elements stored in this node and its children.</param>
            public Node(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5> bounds, Branch parent, int index)
            {
                this._bounds = bounds;
                this._parent = parent;
                this._index = index;
            }

            internal Node(Node nodeToClone)
            {
                this._bounds = nodeToClone._bounds;
                this._parent = nodeToClone._parent;
                this._index = nodeToClone._index;
                this._count = nodeToClone._count;
            }

            internal abstract Node Clone();
        }

        /// <summary>A branch in the tree. Only contains nodes.</summary>
        public class Branch : Node
        {
            private Node[] _children;
            private Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5> _pointOfDivision;

            public Node[] Children { get { return this._children; } set { this._children = value; } }
            public Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5> PointOfDivision { get { return this._pointOfDivision; } internal set { this._pointOfDivision = value; } }
            
            /// <summary>Gets child by index.</summary>
            /// <param name="child_index">The index of the child to get.</param>
            /// <returns>The child of the given index or null if non-existent.</returns>
            public Node this[int child_index]
            {
                get
                {
                    if (this._children == null)
                        return null;
                    if (this._children.Length == OmnitreePointsLinked<T, Axis1, Axis2, Axis3, Axis4, Axis5>._children_per_node)
                        return this._children[(int)child_index];
                    foreach (Node node in this._children)
                        if (node.Index == child_index)
                            return node;
                    return null;
                }
                set
                {
                    // This error check should be unnecessary... but fuck it... might as well
                    if (value.Index != child_index)
                        throw new System.Exception("Bug in Omnitree (index/property mis-match when setting a child on a branch)");

                    // no children yet
                    if (this._children == null)
                    {
                        this._children = new Node[] { value };
                        return;
                    }
                    // max children overwrite
                    else if (this._children.Length == OmnitreePointsLinked<T, Axis1, Axis2, Axis3, Axis4, Axis5>._children_per_node)
                    {
                        this._children[(int)child_index] = value;
                        return;
                    }
                    // non-max child overwrite
                    for (int i = 0; i < this._children.Length; i++)
                        if (this._children[i].Index == child_index)
                        {
                            this._children[i] = value;
                            return;
                        }
                    // new child
                    Node[] newArray = new Node[this._children.Length + 1];
                    if (newArray.Length == OmnitreePointsLinked<T, Axis1, Axis2, Axis3, Axis4, Axis5>._children_per_node)
                    {
                        // new child resulting in a max children branch (sorting required)
                        for (int i = 0; i < this._children.Length; i++)
                        {
                            newArray[(int)this._children[i]._index] = this._children[i];
                        }
                        newArray[(int)value._index] = value;
                    }
                    else
                    {
                        // new child resulting in a non-max children branch
                        Array.Copy(this._children, newArray, this._children.Length);
                        newArray[newArray.Length - 1] = value;
                    }
                    this._children = newArray;
                }
            }

            public Branch(Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5> pointOfDivision, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5> bounds, Branch parent, int index)
                : base(bounds, parent, index)
            {
                this._pointOfDivision = pointOfDivision;
            }

            public Branch(Branch branchToClone)
                : base(branchToClone)
            {
                this._children = branchToClone._children.Clone() as Node[];
                this._pointOfDivision = branchToClone._pointOfDivision;
            }

            internal override Node Clone()
            {
                return new Branch(this);
            }
        }

        /// <summary>A branch in the tree. Only contains items.</summary>
        public class Leaf : Node
        {
            public class Node
            {
                internal T _value;
                internal Leaf.Node _next;

                public T Value { get { return _value; } set { _value = value; } }
                public Leaf.Node Next { get { return _next; } set { _next = value; } }

                public Node(T value, Leaf.Node next)
                {
                    _value = value;
                    _next = next;
                }
            }

            private Leaf.Node _head;

            public Leaf.Node Head { get { return this._head; } set { this._head = value; } }

            internal Leaf(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5> bounds, Branch parent, int index)
                : base(bounds, parent, index)
            { }

            internal Leaf(Leaf leafToClone)
                : base(leafToClone)
            {
                this._head = new Node(leafToClone._head.Value, null);

                Node this_looper = this._head;
                Node other_looper = leafToClone._head;

                while (other_looper != null)
                {
                    this_looper.Next = new Node(other_looper.Next.Value, null);
                    this_looper = this_looper.Next;
                    other_looper = other_looper.Next;
                }
            }

            public void Add(T addition)
            {
                this._head = new Leaf.Node(addition, this._head);
                this.Count++;
            }

            internal override OmnitreePointsLinked<T, Axis1, Axis2, Axis3, Axis4, Axis5>.Node Clone()
            {
                return new Leaf(this);
            }
        }

        #endregion

        #region Constructors

        /// <summary>This constructor is for cloning purposes</summary>
        private OmnitreePointsLinked(OmnitreePointsLinked<T, Axis1, Axis2, Axis3, Axis4, Axis5> omnitree)
        {
            this._top = omnitree._top.Clone();
            this._load = omnitree._load;
            this._locate = omnitree._locate;
            this._defaultEquate = omnitree._defaultEquate;
            this._equate = omnitree._equate;

            this._defaultEquate1 = omnitree._defaultEquate1;
            this._equate1 = omnitree._equate1;
            this._defaultEquate2 = omnitree._defaultEquate2;
            this._equate2 = omnitree._equate2;
            this._defaultEquate3 = omnitree._defaultEquate3;
            this._equate3 = omnitree._equate3;
            this._defaultEquate4 = omnitree._defaultEquate4;
            this._equate4 = omnitree._equate4;
            this._defaultEquate5 = omnitree._defaultEquate5;
            this._equate5 = omnitree._equate5;

            this._defaultCompare1 = omnitree._defaultCompare1;
            this._compare1 = omnitree._compare1;
            this._defaultCompare2 = omnitree._defaultCompare2;
            this._compare2 = omnitree._compare2;
            this._defaultCompare3 = omnitree._defaultCompare3;
            this._compare3 = omnitree._compare3;
            this._defaultCompare4 = omnitree._defaultCompare4;
            this._compare4 = omnitree._compare4;
            this._defaultCompare5 = omnitree._defaultCompare5;
            this._compare5 = omnitree._compare5;

            this._subdivisionOverride1 = omnitree._subdivisionOverride1;
            this._subdivisionOverride2 = omnitree._subdivisionOverride2;
            this._subdivisionOverride3 = omnitree._subdivisionOverride3;
            this._subdivisionOverride4 = omnitree._subdivisionOverride4;
            this._subdivisionOverride5 = omnitree._subdivisionOverride5;
        }

        private OmnitreePointsLinked(
            Omnitree.Location<T, Axis1, Axis2, Axis3, Axis4, Axis5> locate,

            bool defaultEquate,
            Equate<T> equate,

            bool defaultEquate1,
            Equate<Axis1> equateAxis1,
            bool defaultEquate2,
            Equate<Axis2> equateAxis2,
            bool defaultEquate3,
            Equate<Axis3> equateAxis3,
            bool defaultEquate4,
            Equate<Axis4> equateAxis4,
            bool defaultEquate5,
            Equate<Axis5> equateAxis5,

            bool defaultCompare1,
            Compare<Axis1> compare1,
            bool defaultCompare2,
            Compare<Axis2> compare2,
            bool defaultCompare3,
            Compare<Axis3> compare3,
            bool defaultCompare4,
            Compare<Axis4> compare4,
            bool defaultCompare5,
            Compare<Axis5> compare5,

            Omnitree.SubdivisionOverride<T, Axis1, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>> subdivisionOverride1,
            Omnitree.SubdivisionOverride<T, Axis2, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>> subdivisionOverride2,
            Omnitree.SubdivisionOverride<T, Axis3, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>> subdivisionOverride3,
            Omnitree.SubdivisionOverride<T, Axis4, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>> subdivisionOverride4,
            Omnitree.SubdivisionOverride<T, Axis5, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>> subdivisionOverride5)
        {
			if (locate == null)
			{
				throw new ArgumentNullException(nameof(locate));
			}
			if (equate == null)
			{
				throw new ArgumentNullException(nameof(equate));
			}

			if (equateAxis1 == null)
			{
				throw new ArgumentNullException(nameof(equateAxis1));
			}
			if (equateAxis2 == null)
			{
				throw new ArgumentNullException(nameof(equateAxis2));
			}
			if (equateAxis3 == null)
			{
				throw new ArgumentNullException(nameof(equateAxis3));
			}
			if (equateAxis4 == null)
			{
				throw new ArgumentNullException(nameof(equateAxis4));
			}
			if (equateAxis5 == null)
			{
				throw new ArgumentNullException(nameof(equateAxis5));
			}

			if (compare1 == null)
			{
				throw new ArgumentNullException(nameof(compare1));
			}
			if (compare2 == null)
			{
				throw new ArgumentNullException(nameof(compare2));
			}
			if (compare3 == null)
			{
				throw new ArgumentNullException(nameof(compare3));
			}
			if (compare4 == null)
			{
				throw new ArgumentNullException(nameof(compare4));
			}
			if (compare5 == null)
			{
				throw new ArgumentNullException(nameof(compare5));
			}

            this._locate = locate;
            this._defaultEquate = defaultEquate;
            this._equate = equate;

            this._defaultEquate1 = defaultEquate1;
            this._equate1 = equateAxis1;
            this._defaultEquate2 = defaultEquate2;
            this._equate2 = equateAxis2;
            this._defaultEquate3 = defaultEquate3;
            this._equate3 = equateAxis3;
            this._defaultEquate4 = defaultEquate4;
            this._equate4 = equateAxis4;
            this._defaultEquate5 = defaultEquate5;
            this._equate5 = equateAxis5;

            this._defaultCompare1 = defaultCompare1;
            this._compare1 = compare1;
            this._defaultCompare2 = defaultCompare2;
            this._compare2 = compare2;
            this._defaultCompare3 = defaultCompare3;
            this._compare3 = compare3;
            this._defaultCompare4 = defaultCompare4;
            this._compare4 = compare4;
            this._defaultCompare5 = defaultCompare5;
            this._compare5 = compare5;

            this._subdivisionOverride1 = subdivisionOverride1;
            this._subdivisionOverride2 = subdivisionOverride2;
            this._subdivisionOverride3 = subdivisionOverride3;
            this._subdivisionOverride4 = subdivisionOverride4;
            this._subdivisionOverride5 = subdivisionOverride5;

            this._top = new Leaf(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>.None, null, -1);
            Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
        }

        private OmnitreePointsLinked(
            Omnitree.Location<T, Axis1, Axis2, Axis3, Axis4, Axis5> locate,
            Equate<T> equate,

            Equate<Axis1> equateAxis1,
            Equate<Axis2> equateAxis2,
            Equate<Axis3> equateAxis3,
            Equate<Axis4> equateAxis4,
            Equate<Axis5> equateAxis5,

            Compare<Axis1> compare1,
            Compare<Axis2> compare2,
            Compare<Axis3> compare3,
            Compare<Axis4> compare4,
            Compare<Axis5> compare5,

            Omnitree.SubdivisionOverride<T, Axis1, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>> subdivisionOverride1,
            Omnitree.SubdivisionOverride<T, Axis2, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>> subdivisionOverride2,
            Omnitree.SubdivisionOverride<T, Axis3, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>> subdivisionOverride3,
            Omnitree.SubdivisionOverride<T, Axis4, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>> subdivisionOverride4,
            Omnitree.SubdivisionOverride<T, Axis5, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>> subdivisionOverride5)
            : this(
            locate,

            false,
            equate,

            false,
            equateAxis1,
            false,
            equateAxis2,
            false,
            equateAxis3,
            false,
            equateAxis4,
            false,
            equateAxis5,

            false,
            compare1,
            false,
            compare2,
            false,
            compare3,
            false,
            compare4,
            false,
            compare5,

            subdivisionOverride1,
            subdivisionOverride2,
            subdivisionOverride3,
            subdivisionOverride4,
            subdivisionOverride5)
        { }

        public OmnitreePointsLinked(
            Omnitree.Location<T, Axis1, Axis2, Axis3, Axis4, Axis5> locate,

            Equate<T> equate,

            Equate<Axis1> equateAxis1,
            Equate<Axis2> equateAxis2,
            Equate<Axis3> equateAxis3,
            Equate<Axis4> equateAxis4,
            Equate<Axis5> equateAxis5,

            Compare<Axis1> compare1,
            Compare<Axis2> compare2,
            Compare<Axis3> compare3,
            Compare<Axis4> compare4,
            Compare<Axis5> compare5)
            : this(
                locate,

                false,
                equate,

                false,
                equateAxis1,
                false,
                equateAxis2,
                false,
                equateAxis3,
                false,
                equateAxis4,
                false,
                equateAxis5,

                false,
                compare1,
                false,
                compare2,
                false,
                compare3,
                false,
                compare4,
                false,
                compare5,

                null,
                null,
                null,
                null,
                null)
        { }



        public OmnitreePointsLinked(
            Omnitree.Location<T, Axis1, Axis2, Axis3, Axis4, Axis5> locate,

            Equate<T> equate,

            Compare<Axis1> compare1,
            Compare<Axis2> compare2,
            Compare<Axis3> compare3,
            Compare<Axis4> compare4,
            Compare<Axis5> compare5)
            : this(
                locate,
                false,
                equate,

                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,

                false,
                compare1,
                false,
                compare2,
                false,
                compare3,
                false,
                compare4,
                false,
                compare5,

                null,
                null,
                null,
                null,
                null)
        { }

        public OmnitreePointsLinked(
            Omnitree.Location<T, Axis1, Axis2, Axis3, Axis4, Axis5> locate,
            Equate<T> equate,

            Compare<Axis1> compare1,
            Compare<Axis2> compare2,
            Compare<Axis3> compare3,
            Compare<Axis4> compare4,
            Compare<Axis5> compare5,

            Omnitree.SubdivisionOverride<T, Axis1, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>> subdivisionOverride1,
            Omnitree.SubdivisionOverride<T, Axis2, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>> subdivisionOverride2,
            Omnitree.SubdivisionOverride<T, Axis3, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>> subdivisionOverride3,
            Omnitree.SubdivisionOverride<T, Axis4, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>> subdivisionOverride4,
            Omnitree.SubdivisionOverride<T, Axis5, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>> subdivisionOverride5)
            : this(
                locate,

                false,
                equate,

                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,

                false,
                compare1,
                false,
                compare2,
                false,
                compare3,
                false,
                compare4,
                false,
                compare5,

                subdivisionOverride1,
                subdivisionOverride2,
                subdivisionOverride3,
                subdivisionOverride4,
                subdivisionOverride5)
        { }

        public OmnitreePointsLinked(
            Omnitree.Location<T, Axis1, Axis2, Axis3, Axis4, Axis5> locate,

            Compare<Axis1> compare1,
            Compare<Axis2> compare2,
            Compare<Axis3> compare3,
            Compare<Axis4> compare4,
            Compare<Axis5> compare5)
            : this(
                locate,
                true,
                Towel.Equate.Default,

                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,

                false,
                compare1,
                false,
                compare2,
                false,
                compare3,
                false,
                compare4,
                false,
                compare5,

                null,
                null,
                null,
                null,
                null)
        { }

        public OmnitreePointsLinked(
            Omnitree.Location<T, Axis1, Axis2, Axis3, Axis4, Axis5> locate,

            Compare<Axis1> compare1,
            Compare<Axis2> compare2,
            Compare<Axis3> compare3,
            Compare<Axis4> compare4,
            Compare<Axis5> compare5,

            Omnitree.SubdivisionOverride<T, Axis1, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>> subdivisionOverride1,
            Omnitree.SubdivisionOverride<T, Axis2, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>> subdivisionOverride2,
            Omnitree.SubdivisionOverride<T, Axis3, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>> subdivisionOverride3,
            Omnitree.SubdivisionOverride<T, Axis4, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>> subdivisionOverride4,
            Omnitree.SubdivisionOverride<T, Axis5, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>> subdivisionOverride5)
            : this(
                locate,

                true,
                Towel.Equate.Default,

                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,

                false,
                compare1,
                false,
                compare2,
                false,
                compare3,
                false,
                compare4,
                false,
                compare5,

                subdivisionOverride1,
                subdivisionOverride2,
                subdivisionOverride3,
                subdivisionOverride4,
                subdivisionOverride5)
        { }

        public OmnitreePointsLinked(
            Omnitree.Location<T, Axis1, Axis2, Axis3, Axis4, Axis5> locate,
            Equate<T> equate)
            : this(
                locate,

                false,
                equate,

                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,

                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,

                null,
                null,
                null,
                null,
                null)
        { }

        public OmnitreePointsLinked(
            Omnitree.Location<T, Axis1, Axis2, Axis3, Axis4, Axis5> locate,
            Equate<T> equate,
            Omnitree.SubdivisionOverride<T, Axis1, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>> subdivisionOverride1,
            Omnitree.SubdivisionOverride<T, Axis2, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>> subdivisionOverride2,
            Omnitree.SubdivisionOverride<T, Axis3, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>> subdivisionOverride3,
            Omnitree.SubdivisionOverride<T, Axis4, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>> subdivisionOverride4,
            Omnitree.SubdivisionOverride<T, Axis5, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>> subdivisionOverride5)
            : this(
                locate,

                false,
                equate,

                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,

                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,

                subdivisionOverride1,
                subdivisionOverride2,
                subdivisionOverride3,
                subdivisionOverride4,
                subdivisionOverride5)
        { }

        public OmnitreePointsLinked(
            Omnitree.Location<T, Axis1, Axis2, Axis3, Axis4, Axis5> locate)
            : this(
                locate,

                true,
                Towel.Equate.Default,

                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,

                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,

                null,
                null,
                null,
                null,
                null)
        { }

        public OmnitreePointsLinked(
            Omnitree.Location<T, Axis1, Axis2, Axis3, Axis4, Axis5> locate,
            Omnitree.SubdivisionOverride<T, Axis1, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>> subdivisionOverride1,
            Omnitree.SubdivisionOverride<T, Axis2, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>> subdivisionOverride2,
            Omnitree.SubdivisionOverride<T, Axis3, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>> subdivisionOverride3,
            Omnitree.SubdivisionOverride<T, Axis4, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>> subdivisionOverride4,
            Omnitree.SubdivisionOverride<T, Axis5, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>> subdivisionOverride5)
            : this(
                locate,

                true,
                Towel.Equate.Default,

                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,

                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,

                subdivisionOverride1,
                subdivisionOverride2,
                subdivisionOverride3,
                subdivisionOverride4,
                subdivisionOverride5)
        { }

        #endregion

        #region Properties

        /// <summary>Steps through all the items at a given coordinate.</summary>
        /// <param name="axis1">The coordinate along axis 1.</param>
        /// <param name="axis2">The coordinate along axis 2.</param>
        /// <param name="axis3">The coordinate along axis 3.</param>
        /// <param name="axis4">The coordinate along axis 4.</param>
        /// <param name="axis5">The coordinate along axis 5.</param>
        /// <returns>The stepper for the items at the given coordinate.</returns>
        public Stepper<T> this[Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Axis5 axis5]
        {
            get
            {
                return (Step<T> step) => { this.Stepper(step, axis1, axis2, axis3, axis4, axis5); };
            }
        }

        /// <summary>The number of dimensions in this tree.</summary>
        public int Dimensions { get { return _dimensions; } }

        /// <summary>The function for equating keys in this table.</summary>
        public Equate<T> Equate { get { return this._equate; } }

        /// <summary>The location function the Omnitree is using.</summary>
        public Omnitree.Location<T, Axis1, Axis2, Axis3, Axis4, Axis5> Locate { get { return this._locate; } }


        /// <summary>The comparison function the Omnitree is using along the 1D axis.</summary>
        public Compare<Axis1> Compare1 { get { return this._compare1; } }
        /// <summary>The comparison function the Omnitree is using along the 2D axis.</summary>
        public Compare<Axis2> Compare2 { get { return this._compare2; } }
        /// <summary>The comparison function the Omnitree is using along the 3D axis.</summary>
        public Compare<Axis3> Compare3 { get { return this._compare3; } }
        /// <summary>The comparison function the Omnitree is using along the 4D axis.</summary>
        public Compare<Axis4> Compare4 { get { return this._compare4; } }
        /// <summary>The comparison function the Omnitree is using along the 5D axis.</summary>
        public Compare<Axis5> Compare5 { get { return this._compare5; } }

        /// <summary>The function for equating values along the 1D axis.</summary>
        public Equate<Axis1> EquateAxis1 { get { return this._equate1; } }
        /// <summary>The function for equating values along the 2D axis.</summary>
        public Equate<Axis2> EquateAxis2 { get { return this._equate2; } }
        /// <summary>The function for equating values along the 3D axis.</summary>
        public Equate<Axis3> EquateAxis3 { get { return this._equate3; } }
        /// <summary>The function for equating values along the 4D axis.</summary>
        public Equate<Axis4> EquateAxis4 { get { return this._equate4; } }
        /// <summary>The function for equating values along the 5D axis.</summary>
        public Equate<Axis5> EquateAxis5 { get { return this._equate5; } }

        /// <summary>The current number of items in the tree.</summary>
        public int Count { get { return this._top.Count; } }

        private delegate void MaxDepthFinder(Node node, int current_depth, ref int max_depth);
        /// <summary>Finds the current maximum depth of the tree. NOT AN O(1) OPERATION. Intended for educational purposes only.</summary>
        public int MaxDepth
        {
            get
            {
                MaxDepthFinder maxDepthFinder = null;
                maxDepthFinder =
                        (Node node, int current_depth, ref int max_depth) =>
                        {
                            if (current_depth > max_depth)
                                max_depth = current_depth;
                            if (node is Branch)
                                foreach (Node child in (node as Branch).Children)
                                    maxDepthFinder(child, current_depth + 1, ref max_depth);
                        };
                int _max_depth = -1;
                maxDepthFinder(this._top, 0, ref _max_depth);
                return _max_depth;
            }
        }

        private delegate void NodeCountFinder(Node node, ref int current_count);
        /// <summary>Counts the current number of nodes in the tree. NOT AN O(1) OPERATION. Intended for educational purposes only.</summary>
        public int NodeCount
        {
            get
            {
                NodeCountFinder nodeCountFinder = null;
                nodeCountFinder =
                        (Node node, ref int current_count) =>
                        {
                            current_count++;
                            if (node is Branch)
                                foreach (Node child in (node as Branch).Children)
                                    nodeCountFinder(child, ref current_count);
                        };

                int _current_count = 0;
                nodeCountFinder(this._top, ref _current_count);
                return _current_count;
            }
        }

        private delegate void BranchCountFinder(Node node, ref int current_count);
        /// <summary>Counts the current number of branches in the tree. NOT AN O(1) OPERATION. Intended for educational purposes only.</summary>
        public int BranchCount
        {
            get
            {
                BranchCountFinder branchCountFinder = null;
                branchCountFinder =
                        (Node node, ref int current_count) =>
                        {
                            if (node is Branch)
                            {
                                current_count++;
                                foreach (Node child in (node as Branch).Children)
                                    branchCountFinder(child, ref current_count);
                            }
                        };

                int _current_count = 0;
                branchCountFinder(this._top, ref _current_count);
                return _current_count;
            }
        }

        private delegate void LeafCountFinder(Node node, ref int current_count);
        /// <summary>Counts the current number of leaves in the tree. NOT AN O(1) OPERATION. Intended for educational purposes only.</summary>
        public int LeafCount
        {
            get
            {
                LeafCountFinder leafCountFinder = null;
                leafCountFinder =
                        (Node node, ref int current_count) =>
                        {
                            if (node is Leaf)
                                current_count++;
                            else
                                foreach (Node child in (node as Branch).Children)
                                    leafCountFinder(child, ref current_count);
                        };

                int _current_count = 0;
                leafCountFinder(this._top, ref _current_count);
                return _current_count;
            }
        }

        #endregion

        #region Methods

        #region Add

        #region Bulk

        public void Add(IndexedBigArray<T> additions, bool allowMultithreading)
        {
            if (additions.Length > int.MaxValue)
                throw new System.Exception("The maximum size of the Omnitree was exceeded during bulk addition.");

            if (this._top.Count != 0 || (int)additions.Length <= _load)
            {
                for (ulong i = 0; i < additions.Length; i++)
                    this.Add(additions[i]);
            }
            else
            {
                // adjust the loads prior to additions
				Omnitree.ComputeLoads((int)additions.Length, ref _naturalLogLower, ref _naturalLogUpper, ref _load);

                Branch new_top = new Branch(Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5>.Default, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>.None, null, -1);
                new_top.Count = (int)additions.Length;


                // prepare data for median computations
                IndexedBigArray<Axis1> values1;
                IAsyncResult result1 = null;
                if (this._subdivisionOverride1 != null)
                    values1 = null;
                else
                {
                    values1 = null;
                    Towel.Parallels.Parallel.Operation operation = () =>
                    {
                        values1 = new IndexedBigArray<Axis1>(additions.Length);
                        for (ulong i = 0; i < additions.Length; i++)
                            values1[i] = LocateVector(additions[i]).Axis1;
                        Towel.Algorithms.Sort.Merge(this._compare1, (int i) => { return values1[(ulong)i]; }, (int i, Axis1 value) => { values1[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
                    };

                    if (allowMultithreading)
                        result1 = Towel.Parallels.Parallel.Thread(operation);
                    else
                        operation();
                }

                // prepare data for median computations
                IndexedBigArray<Axis2> values2;
                IAsyncResult result2 = null;
                if (this._subdivisionOverride2 != null)
                    values2 = null;
                else
                {
                    values2 = null;
                    Towel.Parallels.Parallel.Operation operation = () =>
                    {
                        values2 = new IndexedBigArray<Axis2>(additions.Length);
                        for (ulong i = 0; i < additions.Length; i++)
                            values2[i] = LocateVector(additions[i]).Axis2;
                        Towel.Algorithms.Sort.Merge(this._compare2, (int i) => { return values2[(ulong)i]; }, (int i, Axis2 value) => { values2[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
                    };

                    if (allowMultithreading)
                        result2 = Towel.Parallels.Parallel.Thread(operation);
                    else
                        operation();
                }

                // prepare data for median computations
                IndexedBigArray<Axis3> values3;
                IAsyncResult result3 = null;
                if (this._subdivisionOverride3 != null)
                    values3 = null;
                else
                {
                    values3 = null;
                    Towel.Parallels.Parallel.Operation operation = () =>
                    {
                        values3 = new IndexedBigArray<Axis3>(additions.Length);
                        for (ulong i = 0; i < additions.Length; i++)
                            values3[i] = LocateVector(additions[i]).Axis3;
                        Towel.Algorithms.Sort.Merge(this._compare3, (int i) => { return values3[(ulong)i]; }, (int i, Axis3 value) => { values3[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
                    };

                    if (allowMultithreading)
                        result3 = Towel.Parallels.Parallel.Thread(operation);
                    else
                        operation();
                }

                // prepare data for median computations
                IndexedBigArray<Axis4> values4;
                IAsyncResult result4 = null;
                if (this._subdivisionOverride4 != null)
                    values4 = null;
                else
                {
                    values4 = null;
                    Towel.Parallels.Parallel.Operation operation = () =>
                    {
                        values4 = new IndexedBigArray<Axis4>(additions.Length);
                        for (ulong i = 0; i < additions.Length; i++)
                            values4[i] = LocateVector(additions[i]).Axis4;
                        Towel.Algorithms.Sort.Merge(this._compare4, (int i) => { return values4[(ulong)i]; }, (int i, Axis4 value) => { values4[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
                    };

                    if (allowMultithreading)
                        result4 = Towel.Parallels.Parallel.Thread(operation);
                    else
                        operation();
                }

                // prepare data for median computations
                IndexedBigArray<Axis5> values5;
                IAsyncResult result5 = null;
                if (this._subdivisionOverride5 != null)
                    values5 = null;
                else
                {
                    values5 = null;
                    Towel.Parallels.Parallel.Operation operation = () =>
                    {
                        values5 = new IndexedBigArray<Axis5>(additions.Length);
                        for (ulong i = 0; i < additions.Length; i++)
                            values5[i] = LocateVector(additions[i]).Axis5;
                        Towel.Algorithms.Sort.Merge(this._compare5, (int i) => { return values5[(ulong)i]; }, (int i, Axis5 value) => { values5[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
                    };

                    if (allowMultithreading)
                        result5 = Towel.Parallels.Parallel.Thread(operation);
                    else
                        operation();
                }



                if (this._subdivisionOverride1 == null && allowMultithreading)
                    result1.AsyncWaitHandle.WaitOne();

                if (this._subdivisionOverride2 == null && allowMultithreading)
                    result2.AsyncWaitHandle.WaitOne();

                if (this._subdivisionOverride3 == null && allowMultithreading)
                    result3.AsyncWaitHandle.WaitOne();

                if (this._subdivisionOverride4 == null && allowMultithreading)
                    result4.AsyncWaitHandle.WaitOne();

                if (this._subdivisionOverride5 == null && allowMultithreading)
                    result5.AsyncWaitHandle.WaitOne();


                // build the tree
                Add(new_top, 1, -1, additions.Stepper(), (int)additions.Length, int.MinValue, int.MinValue, int.MinValue, int.MinValue, int.MinValue, (int)additions.Length, (int index) => { return values1[index]; }, (int index) => { return values2[index]; }, (int index) => { return values3[index]; }, (int index) => { return values4[index]; }, (int index) => { return values5[index]; }, allowMultithreading);
                
                this._top = new_top;
            }
        }

        public void Add(bool allowMultithreading, params T[] additions)
        {
            if (additions.Length > int.MaxValue)
                throw new System.Exception("The maximum size of the Omnitree was exceeded during bulk addition.");

            if (this._top.Count != 0 || (int)additions.Length <= _load)
            {
                for (int i = 0; i < additions.Length; i++)
                    this.Add(additions[i]);
            }
            else
            {
                // adjust the loads prior to additions
				Omnitree.ComputeLoads((int)additions.Length, ref _naturalLogLower, ref _naturalLogUpper, ref _load);

                Branch new_top = new Branch(Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5>.Default, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>.None, null, -1);
                new_top.Count = (int)additions.Length;


                // prepare data for median computations
                IndexedBigArray<Axis1> values1;
                IAsyncResult result1 = null;
                if (this._subdivisionOverride1 != null)
                    values1 = null;
                else
                {
                    values1 = null;
                    Towel.Parallels.Parallel.Operation operation = () =>
                    {
                        values1 = new IndexedBigArray<Axis1>(additions.Length);
                        for (int i = 0; i < additions.Length; i++)
                            values1[i] = LocateVector(additions[i]).Axis1;
                        Towel.Algorithms.Sort.Merge(this._compare1, (int i) => { return values1[(ulong)i]; }, (int i, Axis1 value) => { values1[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
                    };

                    if (allowMultithreading)
                        result1 = Towel.Parallels.Parallel.Thread(operation);
                    else
                        operation();
                }

                // prepare data for median computations
                IndexedBigArray<Axis2> values2;
                IAsyncResult result2 = null;
                if (this._subdivisionOverride2 != null)
                    values2 = null;
                else
                {
                    values2 = null;
                    Towel.Parallels.Parallel.Operation operation = () =>
                    {
                        values2 = new IndexedBigArray<Axis2>(additions.Length);
                        for (int i = 0; i < additions.Length; i++)
                            values2[i] = LocateVector(additions[i]).Axis2;
                        Towel.Algorithms.Sort.Merge(this._compare2, (int i) => { return values2[(ulong)i]; }, (int i, Axis2 value) => { values2[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
                    };

                    if (allowMultithreading)
                        result2 = Towel.Parallels.Parallel.Thread(operation);
                    else
                        operation();
                }

                // prepare data for median computations
                IndexedBigArray<Axis3> values3;
                IAsyncResult result3 = null;
                if (this._subdivisionOverride3 != null)
                    values3 = null;
                else
                {
                    values3 = null;
                    Towel.Parallels.Parallel.Operation operation = () =>
                    {
                        values3 = new IndexedBigArray<Axis3>(additions.Length);
                        for (int i = 0; i < additions.Length; i++)
                            values3[i] = LocateVector(additions[i]).Axis3;
                        Towel.Algorithms.Sort.Merge(this._compare3, (int i) => { return values3[(ulong)i]; }, (int i, Axis3 value) => { values3[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
                    };

                    if (allowMultithreading)
                        result3 = Towel.Parallels.Parallel.Thread(operation);
                    else
                        operation();
                }

                // prepare data for median computations
                IndexedBigArray<Axis4> values4;
                IAsyncResult result4 = null;
                if (this._subdivisionOverride4 != null)
                    values4 = null;
                else
                {
                    values4 = null;
                    Towel.Parallels.Parallel.Operation operation = () =>
                    {
                        values4 = new IndexedBigArray<Axis4>(additions.Length);
                        for (int i = 0; i < additions.Length; i++)
                            values4[i] = LocateVector(additions[i]).Axis4;
                        Towel.Algorithms.Sort.Merge(this._compare4, (int i) => { return values4[(ulong)i]; }, (int i, Axis4 value) => { values4[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
                    };

                    if (allowMultithreading)
                        result4 = Towel.Parallels.Parallel.Thread(operation);
                    else
                        operation();
                }

                // prepare data for median computations
                IndexedBigArray<Axis5> values5;
                IAsyncResult result5 = null;
                if (this._subdivisionOverride5 != null)
                    values5 = null;
                else
                {
                    values5 = null;
                    Towel.Parallels.Parallel.Operation operation = () =>
                    {
                        values5 = new IndexedBigArray<Axis5>(additions.Length);
                        for (int i = 0; i < additions.Length; i++)
                            values5[i] = LocateVector(additions[i]).Axis5;
                        Towel.Algorithms.Sort.Merge(this._compare5, (int i) => { return values5[(ulong)i]; }, (int i, Axis5 value) => { values5[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
                    };

                    if (allowMultithreading)
                        result5 = Towel.Parallels.Parallel.Thread(operation);
                    else
                        operation();
                }



                if (this._subdivisionOverride1 == null && allowMultithreading)
                    result1.AsyncWaitHandle.WaitOne();

                if (this._subdivisionOverride2 == null && allowMultithreading)
                    result2.AsyncWaitHandle.WaitOne();

                if (this._subdivisionOverride3 == null && allowMultithreading)
                    result3.AsyncWaitHandle.WaitOne();

                if (this._subdivisionOverride4 == null && allowMultithreading)
                    result4.AsyncWaitHandle.WaitOne();

                if (this._subdivisionOverride5 == null && allowMultithreading)
                    result5.AsyncWaitHandle.WaitOne();


                // build the tree
                Add(new_top, 1, -1, additions.Stepper(), additions.Length, int.MinValue, int.MinValue, int.MinValue, int.MinValue, int.MinValue, (int)additions.Length, (int index) => { return values1[index]; }, (int index) => { return values2[index]; }, (int index) => { return values3[index]; }, (int index) => { return values4[index]; }, (int index) => { return values5[index]; }, allowMultithreading);
                
                this._top = new_top;
            }
        }

        
        private int Add(Branch parent, int depth, int child, Stepper<T> additions, int parent_count, int prevmed1, int prevmed2, int prevmed3, int prevmed4, int prevmed5, int initial_count, Get<Axis1> values1, Get<Axis2> values2, Get<Axis3> values3, Get<Axis4> values4, Get<Axis5> values5, bool allowMultithreading)
        {
            Axis1 pointOfDivision1;
            Axis2 pointOfDivision2;
            Axis3 pointOfDivision3;
            Axis4 pointOfDivision4;
            Axis5 pointOfDivision5;

            int median_axis1 = -1;
            int median_axis2 = -1;
            int median_axis3 = -1;
            int median_axis4 = -1;
            int median_axis5 = -1;
            if (this._subdivisionOverride1 == null || this._subdivisionOverride2 == null || this._subdivisionOverride3 == null || this._subdivisionOverride4 == null || this._subdivisionOverride5 == null)
                GetMedianIndexes(initial_count, child, depth, prevmed1, prevmed2, prevmed3, prevmed4, prevmed5, out median_axis1, out median_axis2, out median_axis3, out median_axis4, out median_axis5);

            if (this._subdivisionOverride1 != null)
                pointOfDivision1 = this._subdivisionOverride1(parent.Bounds, additions);
            else
                pointOfDivision1 = values1(median_axis1);

            if (this._subdivisionOverride2 != null)
                pointOfDivision2 = this._subdivisionOverride2(parent.Bounds, additions);
            else
                pointOfDivision2 = values2(median_axis2);

            if (this._subdivisionOverride3 != null)
                pointOfDivision3 = this._subdivisionOverride3(parent.Bounds, additions);
            else
                pointOfDivision3 = values3(median_axis3);

            if (this._subdivisionOverride4 != null)
                pointOfDivision4 = this._subdivisionOverride4(parent.Bounds, additions);
            else
                pointOfDivision4 = values4(median_axis4);

            if (this._subdivisionOverride5 != null)
                pointOfDivision5 = this._subdivisionOverride5(parent.Bounds, additions);
            else
                pointOfDivision5 = values5(median_axis5);

            parent.PointOfDivision = new Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5>(pointOfDivision1, pointOfDivision2, pointOfDivision3, pointOfDivision4, pointOfDivision5);

            // divide the values along the medians
            IMap<IAddable<T>, int> collection_map = new MapHashLinked<IAddable<T>, int>();
            additions((T value) => 
            {
                int index = DetermineChildIndex(parent.PointOfDivision, LocateVector(value));
                IAddable<T> list = null;
                if (collection_map.TryGet(index, out list))
                {
                    list.Add(value);
                }
                else
                {
                    if (parent_count < 100000)
                        list = new AddableArray<T>();
                    else
                        list = new AddableLinked<T>();
                    collection_map.Add(index, list);
                    list.Add(value);
                }
            });

            if (depth == 1 && allowMultithreading)
            {
                // NOTE: Must assign placeholders before multithreading so that the threads do not overwrite each other
                collection_map.Keys((int key) => { parent[key] = new Leaf(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>.None, parent, key); });
                IAsyncResult[] handles = new IAsyncResult[Environment.ProcessorCount];
                for (int i = 0; i < handles.Length; i++)
                {
                    int multiTheadSafe_i = i; // used as catpure variable below making it multithread-safe
                    handles[i] = Towel.Parallels.Parallel.Thread(() =>
                    {
                        Step.EveryNth<Link<IAddable<T>, int>>(collection_map.Pairs, multiTheadSafe_i + 1)(
                        (Link<IAddable<T>, int> link) =>
                            {
                                ReversedChildBuilding(parent, link._2, depth, link._1.Stepper, link._1.Count, median_axis1, median_axis2, median_axis3, median_axis4, median_axis5, initial_count, values1, values2, values3, values4, values5, allowMultithreading);
                            });
                    });
                }
                
                foreach (IAsyncResult handle in handles)
                {
                    handle.AsyncWaitHandle.WaitOne();
                }
            }
            else
            {
                collection_map.Pairs((Link<IAddable<T>, int> link) =>
                { 
                    ReversedChildBuilding(parent, link._2, depth, link._1.Stepper, link._1.Count, median_axis1, median_axis2, median_axis3, median_axis4, median_axis5, initial_count, values1, values2, values3, values4, values5, allowMultithreading);
                });
            }

            int count = 0;
            foreach (Node node in parent.Children)
                count += node.Count;
            return count;
        }

        int ReversedChildBuilding(Branch parent, int child_index, int depth, Stepper<T> additions, int count, int prevmed1, int prevmed2, int prevmed3, int prevmed4, int prevmed5, int initial_count, Get<Axis1> values1, Get<Axis2> values2, Get<Axis3> values3, Get<Axis4> values4, Get<Axis5> values5, bool allowMultithreading)
        {
            Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5> child_bounds = DetermineChildBounds(parent, child_index);
            if (depth >= _load || count <= _load)
            {
                Leaf new_leaf = new Leaf(child_bounds, parent, child_index);
                additions((T value) => { new_leaf.Add(value); });
                parent[new_leaf.Index] = new_leaf;
                return new_leaf.Count;
            }
            else
            {
                Branch new_branch = new Branch(Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5>.Default, child_bounds, parent, child_index);
                parent[new_branch.Index] = new_branch;
                new_branch.Count = Add(new_branch, depth + 1, child_index, additions, count, prevmed1, prevmed2, prevmed3, prevmed4, prevmed5, count, values1, values2, values3, values4, values5, allowMultithreading);
                return new_branch.Count;
            }
        }

        /// <summary>Gets the indeces of the median values at the given position during bulk additions.</summary>
        private void GetMedianIndexes(int count, int child_index, int depth, int previous1, int previous2, int previous3, int previous4, int previous5, out int index1, out int index2, out int index3, out int index4, out int index5)
        {
            if (depth == 1)
            {
                index1 = (count - 1) / 2;
                index2 = (count - 1) / 2;
                index3 = (count - 1) / 2;
                index4 = (count - 1) / 2;
                index5 = (count - 1) / 2;
                return;
            }

            int splits = Compute.Power(2, depth);
            int mid_child_range = count / splits;

            if (child_index >= 16)
            {
                index5 = previous5 + mid_child_range;
                child_index -= 16;
            }
            else
            {
                index5 = previous5 - mid_child_range;
            }

            if (child_index >= 8)
            {
                index4 = previous4 + mid_child_range;
                child_index -= 8;
            }
            else
            {
                index4 = previous4 - mid_child_range;
            }

            if (child_index >= 4)
            {
                index3 = previous3 + mid_child_range;
                child_index -= 4;
            }
            else
            {
                index3 = previous3 - mid_child_range;
            }

            if (child_index >= 2)
            {
                index2 = previous2 + mid_child_range;
                child_index -= 2;
            }
            else
            {
                index2 = previous2 - mid_child_range;
            }

            if (child_index >= 1)
            {
                index1 = previous1 + mid_child_range;
                child_index -= 1;
            }
            else
            {
                index1 = previous1 - mid_child_range;
            }

        }

        #endregion

        #region single

        /// <summary>Adds an item to the tree.</summary>
        /// <param name="addition">The item to be added.</param>
        public void Add(T addition)
        {
            if (this._top.Count == int.MaxValue)
                throw new System.InvalidOperationException("(Count == int.MaxValue) max Omnitree size reached (change ints to longs if you need to).");

            // dynamic tree sizes
			Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);

            Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5> location = LocateVector(addition);

            // grow the first branch of the tree
            if (this._top is Leaf && (this._top as Leaf).Count >= _load)
            {
                Leaf top = this._top as Leaf;

                // create the new branch from the median values
                this._top = new Branch(DetermineMedians(top), Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>.None, null, -1);

                // iterate through the elements and add them to the appropriate children
                for (Leaf.Node list = top.Head; list != null; list = list.Next)
                    Add(list.Value, this._top, LocateVector(list.Value), 0);
            }

            this.Add(addition, this._top, location, 0);
        }
        
        /// <summary>Recursive version of the add function.</summary>
        /// <param name="addition">The item to be added.</param>
        /// <param name="node">The current node for tree trversal.</param>
        /// <param name="ms">The location of the addition.</param>
        /// <param name="depth">The current depth of iteration.</param>
        private void Add(T addition, Node node, Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5> location, int depth)
        {
            if (node is Leaf)
            {
                Leaf leaf = node as Leaf;
                if (depth >= _load || !(leaf.Count >= _load))
                {
                    leaf.Add(addition);
                    return;
                }
                else
                {
                    Branch parent = node.Parent;
                    int child_index = this.DetermineChildIndex(parent.PointOfDivision, location);
                    Branch growth = new Branch(DetermineMedians(leaf), leaf.Bounds, parent, child_index);
                    parent[child_index] = growth;
                    for (Leaf.Node list = leaf.Head; list != null; list = list.Next)
                    {
                        Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5> temp_location = LocateVector(list.Value);
                        if (EncapsulationCheck(growth.Bounds, temp_location))
                            Add(list.Value, growth, temp_location, depth);
                        else
                        {
                            ReduceParentCounts(parent, 1);
                            Add(list.Value, this._top, temp_location, depth);
                        }
                    }

                    Add(addition, growth, location, depth);
                    return;
                }
            }
            else
            {
                Branch branch = node as Branch;
                int child_index = this.DetermineChildIndex(branch.PointOfDivision, location); // determine the child "index" (0 through 2^Dimensions) the addition belongs in
                Node child_node = branch[child_index];

                // null children in branches are just empty leaves
                if (child_node == null)
                {
                    Leaf new_leaf = new Leaf(DetermineChildBounds(branch, child_index), branch, child_index);
                    branch[child_index] = new_leaf;
                    new_leaf.Add(addition);
                }
                else
                    // child exists already, continue adding
                    Add(addition, child_node, location, depth + 1);

                branch.Count++;
                return;
            }
        }

        /// <summary>Determins the dimensions of the child at the given index.</summary>
        /// <param name="leaf">The parent of the node to compute dimensions for.</param>
        /// <param name="child">The index of the child to compute dimensions for.</param>
        /// <param name="median1">The computed minimum dimensions of the child node along the 1D axis.</param>
        /// <param name="median2">The computed minimum dimensions of the child node along the 2D axis.</param>
        /// <param name="median3">The computed minimum dimensions of the child node along the 3D axis.</param>
        private Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5> DetermineMedians(Leaf leaf)
        {
            try
            {
                // extract the values
                Axis1[] values1 = new Axis1[leaf.Count];
                Axis2[] values2 = new Axis2[leaf.Count];
                Axis3[] values3 = new Axis3[leaf.Count];
                Axis4[] values4 = new Axis4[leaf.Count];
                Axis5[] values5 = new Axis5[leaf.Count];
                Leaf.Node for_current = leaf.Head; // used in for loop
                for (int i = 0; i < leaf.Count; i++, for_current = for_current.Next)
                    this._locate(for_current.Value, out values1[i], out values2[i], out values3[i], out values4[i], out values5[i]);
                // sort the values
                if (_defaultCompare1) Array.Sort(values1);
                else Array.Sort(values1, Compare.ToSystemComparison(this._compare1));
                if (_defaultCompare2) Array.Sort(values2);
                else Array.Sort(values2, Compare.ToSystemComparison(this._compare2));
                if (_defaultCompare3) Array.Sort(values3);
                else Array.Sort(values3, Compare.ToSystemComparison(this._compare3));
                if (_defaultCompare4) Array.Sort(values4);
                else Array.Sort(values4, Compare.ToSystemComparison(this._compare4));
                if (_defaultCompare5) Array.Sort(values5);
                else Array.Sort(values5, Compare.ToSystemComparison(this._compare5));
                // pull out the lazy medians (if even # of items... just take the left)
                int index = (leaf.Count - 1) / 2;
                return new Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5>(values1[index], values2[index], values3[index], values4[index], values5[index]);
            }
            catch (Exception exception)
            {
				System.Diagnostics.Debugger.Break();
                // extract the values
                IndexedBigArray<Axis1> values1 = new IndexedBigArray<Axis1>(leaf.Count);
                IndexedBigArray<Axis2> values2 = new IndexedBigArray<Axis2>(leaf.Count);
                IndexedBigArray<Axis3> values3 = new IndexedBigArray<Axis3>(leaf.Count);
                IndexedBigArray<Axis4> values4 = new IndexedBigArray<Axis4>(leaf.Count);
                IndexedBigArray<Axis5> values5 = new IndexedBigArray<Axis5>(leaf.Count);
                Leaf.Node for_current = leaf.Head; // used in for loop
                for (int i = 0; i < leaf.Count; i++, for_current = for_current.Next)
                {
                    Axis1 value1;
                    Axis2 value2;
                    Axis3 value3;
                    Axis4 value4;
                    Axis5 value5;
                    this._locate(for_current.Value, out value1, out value2, out value3, out value4, out value5);
                    values1[i] = value1;
                    values2[i] = value2;
                    values3[i] = value3;
                    values4[i] = value4;
                    values5[i] = value5;
                }
                // sort the values
                if (_defaultCompare1) Towel.Algorithms.Sort.Merge(Compare.Default, (int sorting_index) => { return values1[sorting_index]; }, (int sorting_index, Axis1 axis1) => { values1[sorting_index] = axis1; }, 0, (int)values1.Length);
                else Towel.Algorithms.Sort.Merge(_compare1, (int sorting_index) => { return values1[sorting_index]; }, (int sorting_index, Axis1 axis1) => { values1[sorting_index] = axis1; }, 0, (int)values1.Length);
                if (_defaultCompare2) Towel.Algorithms.Sort.Merge(Compare.Default, (int sorting_index) => { return values2[sorting_index]; }, (int sorting_index, Axis2 axis2) => { values2[sorting_index] = axis2; }, 0, (int)values1.Length);
                else Towel.Algorithms.Sort.Merge(_compare2, (int sorting_index) => { return values2[sorting_index]; }, (int sorting_index, Axis2 axis2) => { values2[sorting_index] = axis2; }, 0, (int)values1.Length);
                if (_defaultCompare3) Towel.Algorithms.Sort.Merge(Compare.Default, (int sorting_index) => { return values3[sorting_index]; }, (int sorting_index, Axis3 axis3) => { values3[sorting_index] = axis3; }, 0, (int)values1.Length);
                else Towel.Algorithms.Sort.Merge(_compare3, (int sorting_index) => { return values3[sorting_index]; }, (int sorting_index, Axis3 axis3) => { values3[sorting_index] = axis3; }, 0, (int)values1.Length);
                if (_defaultCompare4) Towel.Algorithms.Sort.Merge(Compare.Default, (int sorting_index) => { return values4[sorting_index]; }, (int sorting_index, Axis4 axis4) => { values4[sorting_index] = axis4; }, 0, (int)values1.Length);
                else Towel.Algorithms.Sort.Merge(_compare4, (int sorting_index) => { return values4[sorting_index]; }, (int sorting_index, Axis4 axis4) => { values4[sorting_index] = axis4; }, 0, (int)values1.Length);
                if (_defaultCompare5) Towel.Algorithms.Sort.Merge(Compare.Default, (int sorting_index) => { return values5[sorting_index]; }, (int sorting_index, Axis5 axis5) => { values5[sorting_index] = axis5; }, 0, (int)values1.Length);
                else Towel.Algorithms.Sort.Merge(_compare5, (int sorting_index) => { return values5[sorting_index]; }, (int sorting_index, Axis5 axis5) => { values5[sorting_index] = axis5; }, 0, (int)values1.Length);
                // pull out the lazy medians (if even # of items... just take the left)
                int index = (leaf.Count - 1) / 2;
                return new Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5>(values1[index], values2[index], values3[index], values4[index], values5[index]);
            }
        }

        #endregion

        #region Add Helpers

        private Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5> DetermineChildBounds(Branch branch, int child_index)
        {

            Omnitree.Bound<Axis5> min5, max5;
            if (child_index >= 16)
            {
                min5 = branch.PointOfDivision.Axis5;
                max5 = branch.Bounds.Max5;
                child_index -= 16;
            }
            else
            {
                min5 = branch.Bounds.Min5;
                max5 = branch.PointOfDivision.Axis5;
            }

            Omnitree.Bound<Axis4> min4, max4;
            if (child_index >= 8)
            {
                min4 = branch.PointOfDivision.Axis4;
                max4 = branch.Bounds.Max4;
                child_index -= 8;
            }
            else
            {
                min4 = branch.Bounds.Min4;
                max4 = branch.PointOfDivision.Axis4;
            }

            Omnitree.Bound<Axis3> min3, max3;
            if (child_index >= 4)
            {
                min3 = branch.PointOfDivision.Axis3;
                max3 = branch.Bounds.Max3;
                child_index -= 4;
            }
            else
            {
                min3 = branch.Bounds.Min3;
                max3 = branch.PointOfDivision.Axis3;
            }

            Omnitree.Bound<Axis2> min2, max2;
            if (child_index >= 2)
            {
                min2 = branch.PointOfDivision.Axis2;
                max2 = branch.Bounds.Max2;
                child_index -= 2;
            }
            else
            {
                min2 = branch.Bounds.Min2;
                max2 = branch.PointOfDivision.Axis2;
            }

            Omnitree.Bound<Axis1> min1, max1;
            if (child_index >= 1)
            {
                min1 = branch.PointOfDivision.Axis1;
                max1 = branch.Bounds.Max1;
                child_index -= 1;
            }
            else
            {
                min1 = branch.Bounds.Min1;
                max1 = branch.PointOfDivision.Axis1;
            }

            return new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5);
        }

        #endregion

        #endregion

        #region Clear

        /// <summary>Returns the tree to an empty state.</summary>
        public void Clear()
        {
            this._top = new Leaf(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>.None, null, -1);
			Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
        }

        #endregion

        #region Clone

        /// <summary>Creates a shallow clone of this data structure.</summary>
        /// <returns>A shallow clone of this data structure.</returns>
        public OmnitreePointsLinked<T, Axis1, Axis2, Axis3, Axis4, Axis5> Clone()
        {
            return new OmnitreePointsLinked<T, Axis1, Axis2, Axis3, Axis4, Axis5>(this);
        }

        #endregion

        #region Count

        /// <summary>Counts the number of items in a sub space.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
        /// <returns>The number of items in the provided sub space.</returns>
        public int CountSubSpace(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5)
        {
            return CountSubSpace(_top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5));
        }
        /// <summary>Counts the number of items in a sub space.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
        /// <returns>The number of items in the provided sub space.</returns>
        public int CountSubSpace(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5)
        {
            return CountSubSpace(_top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5));
        }
        /// <summary>Counts the number of items in a sub space.</summary>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
		/// <param name="axis5">The coordinate along the 5D axis.</param>
        /// <returns>The number of items in the provided sub space.</returns>
        public int CountSubSpace(Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Axis5 axis5)
        {
            return CountSubSpace(_top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>(axis1, axis1, axis2, axis2, axis3, axis3, axis4, axis4, axis5, axis5));
        }
        /// <summary>Counts the number of items in a sub space.</summary>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
		/// <param name="axis5">The coordinate along the 5D axis.</param>
        /// <returns>The number of items in the provided sub space.</returns>
        public int CountSubSpace(Omnitree.Bound<Axis1> axis1, Omnitree.Bound<Axis2> axis2, Omnitree.Bound<Axis3> axis3, Omnitree.Bound<Axis4> axis4, Omnitree.Bound<Axis5> axis5)
        {
            return CountSubSpace(_top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>(axis1, axis1, axis2, axis2, axis3, axis3, axis4, axis4, axis5, axis5));
        }
        /// <summary>Counts the number of items in a sub space.</summary>
        /// <param name="node">The current traversal node.</param>
        /// <returns>The number of items in the provided sub space.</returns>
        private int CountSubSpace(Node node, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5> bounds)
        {
            // adjust min/max values
            int count = 0;
            if (EncapsulationCheck(bounds, node.Bounds))
                count += node.Count;
            else if (node is Leaf)
            {
                for (Leaf.Node list = (node as Leaf).Head; list != null; list = list.Next)
                    if (EncapsulationCheck(bounds, LocateVector(list.Value)))
                        count++;
            }
            else
            {
                Branch branch = node as Branch;
                if (!StraddlesLines(branch.Bounds, branch.PointOfDivision))
                {
                    int child_index = DetermineChildIndex(branch.PointOfDivision, new Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5>(bounds.Min1.Value, bounds.Min2.Value, bounds.Min3.Value, bounds.Min4.Value, bounds.Min5.Value));
                    Node child = branch[child_index];
                    if (child != null)
                      count += this.CountSubSpace(child, bounds);
                }
                else
                {
                    foreach (Node child in (node as Branch).Children)
                        count += this.CountSubSpace(child, bounds);
                }
            }
            return count;
        }

        #endregion

        #region Update

        /// <summary>Iterates through the entire tree and ensures each item is in the proper leaf.</summary>
        public void Update()
        {
            this.Update(this._top, 0);
        }

        /// <summary>Recursive version of the Update method.</summary>
        /// <param name="node">The current node of iteration.</param>
        /// <param name="depth">The current depth of iteration.</param>
        private int Update(Node node, int depth)
        {
            int removals = 0;

            if (node is Leaf)
            {
                Leaf leaf = node as Leaf;
                Leaf.Node current = leaf.Head;
                Leaf.Node previous = null;
                while (current != null)
                {
                    Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5> location = LocateVector(current.Value);
                    if (!this.EncapsulationCheck(node.Bounds, location))
                    {
                        removals++;
                        T updated = current.Value;
                        if (previous == null)
                        {
                            leaf.Head = current.Next;
                            goto HeadRemoved;
                        }
                        else
                            previous.Next = current.Next;

                        Node whereToAdd = GetEncapsulationParent(node.Parent, location);

                        if (whereToAdd == null)
                            throw new System.Exception("an item was updated outside the range of the omnitree");

                        this.Add(updated, whereToAdd, location, whereToAdd.Depth);
                    }
                    previous = current;
                HeadRemoved:
                    current = current.Next;
                }
                leaf.Count -= removals;
                return removals;
            }
            else
            {
                Branch branch = node as Branch;
                int skipped = 0;
                for (int i = 0; i + skipped < branch.Children.Length; )
                {
                    removals += this.Update(branch.Children[i], depth + 1);
                    if (branch.Children[i].Count == 0)
                        branch.Children[i] = branch.Children[branch.Children.Length - skipped++ - 1];
                    else
                        i++;
                }
                Node[] newArray = new Node[branch.Children.Length - skipped];
                Array.Copy(branch.Children, newArray, newArray.Length);
                branch.Children = newArray;

                branch.Count -= removals;

                if (branch.Count < _load && branch.Count != 0)
                    ShrinkChild(branch.Parent, branch.Index);
            }

            return removals;
        }

        /// <summary>Iterates through the provided dimensions and ensures each item is in the proper leaf.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
        public void Update(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5)
        {
            this.Update(new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5), this._top, 0);
        }
        /// <summary>Iterates through the provided dimensions and ensures each item is in the proper leaf.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
        public void Update(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5)
        {
            this.Update(new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5), this._top, 0);
        }
        /// <summary>Iterates through the provided dimensions and ensures each item is in the proper leaf.</summary>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
		/// <param name="axis5">The coordinate along the 5D axis.</param>
        public void Update(Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Axis5 axis5)
        {
            this.Update(new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>(axis1, axis1, axis2, axis2, axis3, axis3, axis4, axis4, axis5, axis5), this._top, 0);
        }
        /// <summary>Iterates through the provided dimensions and ensures each item is in the proper leaf.</summary>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
		/// <param name="axis5">The coordinate along the 5D axis.</param>
        public void Update(Omnitree.Bound<Axis1> axis1, Omnitree.Bound<Axis2> axis2, Omnitree.Bound<Axis3> axis3, Omnitree.Bound<Axis4> axis4, Omnitree.Bound<Axis5> axis5)
        {
            this.Update(new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>(axis1, axis1, axis2, axis2, axis3, axis3, axis4, axis4, axis5, axis5), this._top, 0);
        }
        private int Update(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5> bounds, Node node, int depth)
        {
            if (!InclusionCheck(bounds, node.Bounds))
                return 0;

            int removals = 0;

            if (node is Leaf)
            {
                Leaf leaf = node as Leaf;
                Leaf.Node current = leaf.Head;
                Leaf.Node previous = null;
                while (current != null)
                {
                    Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5> location = LocateVector(current.Value);
                    if (!this.EncapsulationCheck(node.Bounds, location))
                    {
                        removals++;
                        T updated = current.Value;
                        if (previous == null)
                        {
                            leaf.Head = current.Next;
                            goto HeadRemoved;
                        }
                        else
                            previous.Next = current.Next;
                        Node whereToAdd = GetEncapsulationParent(node.Parent, location);
                        if (whereToAdd == null)
                            throw new System.Exception("an item was updates outside the range of the omnitree");
                        this.Add(updated, whereToAdd, location, whereToAdd.Depth);
                    }
                    previous = current;
                HeadRemoved:
                    current = current.Next;
                }
                leaf.Count -= removals;
                return removals;
            }
            else
            {
                Branch branch = node as Branch;
                int skipped = 0;
                for (int i = 0; i + skipped < branch.Children.Length; )
                {
                    removals += this.Update(branch.Children[i], depth + 1);
                    if (branch.Children[i].Count == 0)
                        branch.Children[i] = branch.Children[branch.Children.Length - skipped++ - 1];
                    else
                        i++;
                }
                Node[] newArray = new Node[branch.Children.Length - skipped];
                Array.Copy(branch.Children, newArray, newArray.Length);
                branch.Children = newArray;

                branch.Count -= removals;

                if (branch.Count < _load && branch.Count != 0)
                    ShrinkChild(branch.Parent, branch.Index);
            }

            return removals;
        }

        #endregion

        #region Remove

        /// <summary>Removes all the items qualified by the delegate.</summary>
        /// <param name="where">The predicate to qualify removals.</param>
        public void Remove(Predicate<T> where)
        {
            this.Remove(this._top, where);
			Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
        }

        /// <summary>Recursive version of the remove method.</summary>
        /// <param name="node">The current node of traversal.</param>
        /// <param name="where">The predicate to qualify removals.</param>
        private int Remove(Node node, Predicate<T> where)
        {
            int removals = 0;
            if (node is Leaf)
            {
                Leaf leaf = node as Leaf;
                while (leaf.Head != null && where(leaf.Head.Value))
                {
                    leaf.Head = leaf.Head.Next;
                    removals++;
                }
                if (leaf.Head != null)
                {
                    Leaf.Node list = leaf.Head;
                    while (list.Next != null)
                    {
                        if (where(list.Next.Value))
                        {
                            list.Next = list.Next.Next;
                            removals++;
                        }
                    }
                }

                leaf.Count -= removals;
                return removals;
            }
            else
            {
                Branch branch = node as Branch;
                int skipped = 0;
                for (int i = 0; i + skipped < branch.Children.Length; )
                {
                    removals += this.Remove(branch.Children[i], where);
                    if (branch.Children[i].Count == 0)
                        branch.Children[i] = branch.Children[branch.Children.Length - skipped++ - 1];
                    else
                        i++;
                }
                Node[] newArray = new Node[branch.Children.Length - skipped];
                Array.Copy(branch.Children, newArray, newArray.Length);
                branch.Children = newArray;

                branch.Count -= removals;

                if (branch.Count < _load && branch.Count != 0)
                    ShrinkChild(branch.Parent, branch.Index);

                return removals;
            }
        }

        /// <summary>Removes all the items in a given space.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
        /// <returns>The number of items that were removed.</returns>
        public void Remove(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5)
        {
            this.Remove(this._top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5));
            Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
        }
        /// <summary>Removes all the items in a given space.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
        /// <returns>The number of items that were removed.</returns>
        public void Remove(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5)
        {
            this.Remove(this._top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5));
            Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
        }
        private int Remove(Node node, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5> bounds)
        {
            int removals = 0;
            if (InclusionCheck(bounds, node.Bounds))
            {
                if (node is Leaf)
                {
                    Leaf leaf = node as Leaf;
                    Leaf.Node current_node = leaf.Head;
                    Leaf.Node previous_node = null;
                    while (current_node != null)
                    {
                        Leaf.Node temp_previous = current_node;
                        if (EncapsulationCheck(bounds, LocateVector(current_node.Value)))
                        {
                            removals++;
                            if (current_node == leaf.Head)
                                leaf.Head = leaf.Head.Next;
                            else
                            {
                                previous_node.Next = current_node.Next;
                                temp_previous = previous_node;
                            }
                        }
                        previous_node = temp_previous;
                        current_node = current_node.Next;
                    }
                    leaf.Count -= removals;
                }
                else
                {
                    Branch branch = node as Branch;
                    int skipped = 0;
                    for (int i = 0; i + skipped < branch.Children.Length; )
                    {
                        removals += this.Remove(branch.Children[i], bounds);
                        if (branch.Children[i].Count == 0)
                            branch.Children[i] = branch.Children[branch.Children.Length - skipped++ - 1];
                        else
                            i++;
                    }
                    Node[] newArray = new Node[branch.Children.Length - skipped];
                    Array.Copy(branch.Children, newArray, newArray.Length);
                    branch.Children = newArray;

                    branch.Count -= removals;
                    // convert this branch back into a leaf
                    // Note: if count is zero, it will be chopped off
                    if (branch.Count < _load && branch.Count > 0)
                        ShrinkChild(branch.Parent, branch.Index);
                }
            }

            return removals;
        }

        /// <summary>Removes all the items in a given space validated by a predicate.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
        /// <param name="where">The equality constraint of the removal.</param>
        public void Remove(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5, Predicate<T> where)
        {
            this.Remove(this._top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5), where);
            Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
        }
        /// <summary>Removes all the items in a given space validated by a predicate.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
        /// <param name="where">The equality constraint of the removal.</param>
        public void Remove(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5, Predicate<T> where)
        {
            this.Remove(this._top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5), where);
			Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
        }
        private int Remove(Node node, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5> bounds, Predicate<T> where)
        {
            if (!InclusionCheck(node.Bounds, bounds))
                return 0;
            int removals = 0;
            if (node is Leaf)
            {
                Leaf leaf = node as Leaf;
                Leaf.Node current = leaf.Head;
                Leaf.Node previous = null;
                while (current != null)
                {
                    if (this.EncapsulationCheck(bounds, LocateVector(current.Value)) && where(current.Value))
                    {
                        removals++;
                        if (previous == null)
                        {
                            leaf.Head = current.Next;
                            goto HeadRemoved;
                        }
                        else
                            previous.Next = current.Next;
                    }
                    previous = current;
                HeadRemoved:
                    current = current.Next;
                }

                leaf.Count -= removals;
                return removals;
            }
            else
            {
                Branch branch = node as Branch;
                int skipped = 0;
                for (int i = 0; i + skipped < branch.Children.Length; )
                {
                    removals += this.Remove(branch.Children[i], bounds, where);
                    if (branch.Children[i].Count == 0)
                        branch.Children[i] = branch.Children[branch.Children.Length - skipped++ - 1];
                    else
                        i++;
                }
                Node[] newArray = new Node[branch.Children.Length - skipped];
                Array.Copy(branch.Children, newArray, newArray.Length);
                branch.Children = newArray;

                node.Count -= removals;

                if (node.Count < _load && node.Count != 0)
                    ShrinkChild(node.Parent, node.Index);

                return removals;
            }
        }

        /// <summary>Removes all instances of a given value.</summary>
        public void Remove(T removal)
        {
            Axis1 axis1;
            Axis2 axis2;
            Axis3 axis3;
            Axis4 axis4;
            Axis5 axis5;
            this._locate(removal, out axis1, out axis2, out axis3, out axis4, out axis5);
            this.Remove(axis1, axis2, axis3, axis4, axis5, (T item) => { return this._equate(item, removal); });
        }
        /// <summary>Removes all the items in a given space.</summary>
        /// <param name="axis1">The axis of the removal along the  1D axis.</param>
		/// <param name="axis2">The axis of the removal along the  2D axis.</param>
		/// <param name="axis3">The axis of the removal along the  3D axis.</param>
		/// <param name="axis4">The axis of the removal along the  4D axis.</param>
		/// <param name="axis5">The axis of the removal along the  5D axis.</param>
        /// <returns>The number of items that were removed.</returns>
        public void Remove(Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Axis5 axis5)
        {
            this.Remove(this._top, new Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5>(axis1, axis2, axis3, axis4, axis5));
            Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
        }
        private int Remove(Node node, Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5> vector)
        {
            int removals = 0;
            if (node is Leaf)
            {
                Leaf leaf = node as Leaf;
                Leaf.Node current_node = leaf.Head;
                Leaf.Node previous_node = null;
                while (current_node != null)
                {
                    Leaf.Node temp_previous = current_node;
                    if (EqualsCheck(vector, LocateVector(current_node.Value)))
                    {
                        removals++;
                        if (current_node == leaf.Head)
                            leaf.Head = leaf.Head.Next;
                        else
                        {
                            previous_node.Next = current_node.Next;
                            temp_previous = previous_node;
                        }
                    }
                    previous_node = temp_previous;
                    current_node = current_node.Next;
                }
                leaf.Count -= removals;
            }
            else
            {
                Branch branch = node as Branch;
                int child_index = DetermineChildIndex(branch.PointOfDivision, vector);
                removals += Remove(branch[child_index], vector);
                branch.Count -= removals;
                // convert this branch back into a leaf
                // Note: if count is zero, it will be chopped off
                if (branch.Count < _load && branch.Count > 0)
                    ShrinkChild(branch.Parent, branch.Index);
            }

            return removals;
        }

        /// <summary>Removes all the items in a given space validated by a predicate.</summary>
        /// <param name="axis1">The axis of the removal along the  1D axis.</param>
		/// <param name="axis2">The axis of the removal along the  2D axis.</param>
		/// <param name="axis3">The axis of the removal along the  3D axis.</param>
		/// <param name="axis4">The axis of the removal along the  4D axis.</param>
		/// <param name="axis5">The axis of the removal along the  5D axis.</param>
        /// <param name="where">The equality constraint of the removal.</param>
        public void Remove(Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Axis5 axis5, Predicate<T> where)
        {
            this.Remove(this._top, new Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5>(axis1, axis2, axis3, axis4, axis5), where);
            Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
        }
        private int Remove(Node node, Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5> vector, Predicate<T> where)
        {
            int removals = 0;
            if (node is Leaf)
            {
                Leaf leaf = node as Leaf;
                Leaf.Node current_node = leaf.Head;
                Leaf.Node previous_node = null;
                while (current_node != null)
                {
                    Leaf.Node temp_previous = current_node;
                    if (EqualsCheck(vector, LocateVector(current_node.Value)) && where(current_node.Value))
                    {
                        removals++;
                        if (current_node == leaf.Head)
                            leaf.Head = leaf.Head.Next;
                        else
                        {
                            previous_node.Next = current_node.Next;
                            temp_previous = previous_node;
                        }
                    }
                    previous_node = temp_previous;
                    current_node = current_node.Next;
                }
                leaf.Count -= removals;
            }
            else
            {
                Branch branch = node as Branch;
                int child_index = DetermineChildIndex(branch.PointOfDivision, vector);
                removals += Remove(branch[child_index], vector, where);
                branch.Count -= removals;
                // convert this branch back into a leaf
                // Note: if count is zero, it will be chopped off
                if (branch.Count < _load && branch.Count > 0)
                    ShrinkChild(branch.Parent, branch.Index);
            }
            return removals;
        }

        #endregion

        #region Stepper And IEnumerable

        /// <summary>Traverses every item in the tree and performs the delegate in them.</summary>
        /// <param name="function">The delegate to perform on every item in the tree.</param>
        public void Stepper(Step<T> function)
        {
            this.Stepper(function, this._top);
        }
        private void Stepper(Step<T> function, Node node)
        {
            if (node is Leaf)
            {
                Leaf.Node list = (node as Leaf).Head;
                while (list != null)
                {
                    function(list.Value);
                    list = list.Next;
                }
            }
            else
            {
                foreach (Node child in (node as Branch).Children)
                    this.Stepper(function, child);
            }
        }

        /// <summary>Traverses every item in the tree and performs the delegate in them.</summary>
        /// <param name="function">The delegate to perform on every item in the tree.</param>
        public StepStatus Stepper(StepBreak<T> function)
        {
            return Stepper(function, _top);
        }
        private StepStatus Stepper(StepBreak<T> function, Node node)
        {
            StepStatus status = StepStatus.Continue;
            if (node is Leaf)
            {
                for (Leaf.Node list = (node as Leaf).Head; list != null; list = list.Next)
                    if ((status = function(list._value)) != StepStatus.Continue)
                        break;
            }
            else
            {
                foreach (Node child in (node as Branch).Children)
                    if ((status = Stepper(function, child)) != StepStatus.Continue)
                        break;
            }
            return status;
        }

        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="function">The delegate to perform on all items in the tree within the given bounds.</param>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
        public void Stepper(Step<T> function, Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5)
        {
            Stepper(function, _top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5));
        }
        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="function">The delegate to perform on all items in the tree within the given bounds.</param>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
        public void Stepper(Step<T> function, Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5)
        {
            Stepper(function, _top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5));
        }
        private void Stepper(Step<T> function, Node node, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5> bounds)
        {
            if (node is Leaf)
            {
                for (Leaf.Node list = (node as Leaf).Head; list != null; list = list.Next)
                    if (EncapsulationCheck(bounds, LocateVector(list.Value)))
                        function(list.Value);
            }
            else
            {
                foreach (Node child in (node as Branch).Children)
                    // optimization: stop bounds checking if space encapsulates node
                    if (EncapsulationCheck(bounds, child.Bounds))
                        this.Stepper(function, child);
                    else if (InclusionCheck(child.Bounds, bounds))
                        this.Stepper(function, child, bounds);
            }
        }

        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
        public StepStatus Stepper(StepBreak<T> function, Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5)
        {
            return Stepper(function, _top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5));
        }
        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
        public StepStatus Stepper(StepBreak<T> function, Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5)
        {
            return Stepper(function, _top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5));
        }
        private StepStatus Stepper(StepBreak<T> function, Node node, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5> bounds)
        {
            StepStatus status = StepStatus.Continue;
            if (node is Leaf)
            {
                for (Leaf.Node list = (node as Leaf).Head; list != null; list = list.Next)
                    if (EncapsulationCheck(bounds, LocateVector(list.Value)) &&
                        (status = function(list.Value)) != StepStatus.Continue)
                        break;
            }
            else
            {
                foreach (Node child in (node as Branch).Children)
                    // optimization: stop bounds checking if space encapsulates node
                    if (EncapsulationCheck(bounds, child.Bounds) &&
                        (status = this.Stepper(function, child)) != StepStatus.Continue)
                        break;
                    else if (!InclusionCheck(child.Bounds, bounds) &&
                        (status = this.Stepper(function, child, bounds)) != StepStatus.Continue)
                        break;
            }
            return status;
        }

        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="axis1">The axis of the removal along the  1D axis.</param>
		/// <param name="axis2">The axis of the removal along the  2D axis.</param>
		/// <param name="axis3">The axis of the removal along the  3D axis.</param>
		/// <param name="axis4">The axis of the removal along the  4D axis.</param>
		/// <param name="axis5">The axis of the removal along the  5D axis.</param>
        public void Stepper(Step<T> function, Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Axis5 axis5)
        {
            Stepper(function, _top, new Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5>(axis1, axis2, axis3, axis4, axis5));
        }
        private void Stepper(Step<T> function, Node node, Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5> vector)
        {
            Node current = node;
            while (current != null)
            {
                if (current is Leaf)
                {
                    for (Leaf.Node leaf_node = (current as Leaf).Head; leaf_node != null; leaf_node = leaf_node.Next)
                        if (EqualsCheck(vector, LocateVector(leaf_node.Value)))
                            function(leaf_node.Value);
                    break;
                }
                else
                {
                    Branch branch = current as Branch;
                    int child_index = DetermineChildIndex(branch.PointOfDivision, vector);
                    current = branch[child_index];
                }
            }
        }

        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="function">The delegate to perform on all items in the tree within the given bounds.</param>
        /// <param name="axis1">The axis of the removal along the  1D axis.</param>
		/// <param name="axis2">The axis of the removal along the  2D axis.</param>
		/// <param name="axis3">The axis of the removal along the  3D axis.</param>
		/// <param name="axis4">The axis of the removal along the  4D axis.</param>
		/// <param name="axis5">The axis of the removal along the  5D axis.</param>
        public StepStatus Stepper(StepBreak<T> function, Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Axis5 axis5)
        {
            return Stepper(function, _top, new Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5>(axis1, axis2, axis3, axis4, axis5));
        }
        private StepStatus Stepper(StepBreak<T> function, Node node, Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5> vector)
        {
            Node current = node;
            while (current != null)
            {
                if (current is Leaf)
                {
                    for (Leaf.Node list = (current as Leaf).Head; list != null; list = list.Next)
                    {
                        StepStatus status = StepStatus.Continue;
                        if (EqualsCheck(vector, LocateVector(list.Value)) &&
                            (status = function(list.Value)) != StepStatus.Continue)
                            return status;
                    }
                }
                else
                {
                    Branch branch = current as Branch;
                    int child_index = DetermineChildIndex(branch.PointOfDivision, vector);
                    current = branch[child_index];
                }
            }
            return StepStatus.Continue;
        }

        /// <summary>FOR COMPATIBILITY ONLY. AVOID IF POSSIBLE.</summary>
        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
        {
            throw new System.NotImplementedException();
            //return (this.ToArray() as System.Collections.Generic.IEnumerable<T>).GetEnumerator();
        }

        /// <summary>FOR COMPATIBILITY ONLY. AVOID IF POSSIBLE.</summary>
        System.Collections.Generic.IEnumerator<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator()
        {
            throw new System.NotImplementedException();
            //return (this.ToArray() as System.Collections.Generic.IEnumerable<T>).GetEnumerator();
        }

        #endregion

        #region Helpers

        private bool StraddlesLines(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5> bounds, Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5> vector)
        {
			if ((!bounds.Min1.Exists || (bounds.Min1.Exists && this._compare1(bounds.Min1.Value, vector.Axis1) != Comparison.Greater)) &&
				(!bounds.Max1.Exists || (bounds.Max1.Exists && this._compare1(bounds.Max1.Value, vector.Axis1) != Comparison.Less)))
				return true;
			if ((!bounds.Min2.Exists || (bounds.Min2.Exists && this._compare2(bounds.Min2.Value, vector.Axis2) != Comparison.Greater)) &&
				(!bounds.Max2.Exists || (bounds.Max2.Exists && this._compare2(bounds.Max2.Value, vector.Axis2) != Comparison.Less)))
				return true;
			if ((!bounds.Min3.Exists || (bounds.Min3.Exists && this._compare3(bounds.Min3.Value, vector.Axis3) != Comparison.Greater)) &&
				(!bounds.Max3.Exists || (bounds.Max3.Exists && this._compare3(bounds.Max3.Value, vector.Axis3) != Comparison.Less)))
				return true;
			if ((!bounds.Min4.Exists || (bounds.Min4.Exists && this._compare4(bounds.Min4.Value, vector.Axis4) != Comparison.Greater)) &&
				(!bounds.Max4.Exists || (bounds.Max4.Exists && this._compare4(bounds.Max4.Value, vector.Axis4) != Comparison.Less)))
				return true;
			if ((!bounds.Min5.Exists || (bounds.Min5.Exists && this._compare5(bounds.Min5.Value, vector.Axis5) != Comparison.Greater)) &&
				(!bounds.Max5.Exists || (bounds.Max5.Exists && this._compare5(bounds.Max5.Value, vector.Axis5) != Comparison.Less)))
				return true;
            return false;
        }

        /// <summary>Computes the child index that contains the desired dimensions.</summary>
        /// <param name="node">The branch .</param>
        /// <param name="vector">The dimensions to determine the child index.</param>
        /// <returns>The computed child index based on the coordinates relative to the center of the node.</returns>
        private int DetermineChildIndex(Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5> pointOfDivision, Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5> vector)
        {
            int child = 0;
            if (!(this._compare1(vector.Axis1, pointOfDivision.Axis1) == Comparison.Less))
                child += 1 << 0;
            if (!(this._compare2(vector.Axis2, pointOfDivision.Axis2) == Comparison.Less))
                child += 1 << 1;
            if (!(this._compare3(vector.Axis3, pointOfDivision.Axis3) == Comparison.Less))
                child += 1 << 2;
            if (!(this._compare4(vector.Axis4, pointOfDivision.Axis4) == Comparison.Less))
                child += 1 << 3;
            if (!(this._compare5(vector.Axis5, pointOfDivision.Axis5) == Comparison.Less))
                child += 1 << 4;
            return child;
        }

        /// <summary>Converts a branch back into a leaf when the count is reduced.</summary>
        /// <param name="parent">The parent to shrink a child of.</param>
        /// <param name="child">The index of the child to shrink.</param>
        private void ShrinkChild(Branch parent, int child_index)
        {
            Leaf leaf;
            Node removal = null;
            if (parent == null) // top of tree
            {
                removal = this._top;
                leaf = new Leaf(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>.None, null, -1);
                this._top = leaf;
            }
            else // non-top branch
            {
                removal = parent[child_index];
                leaf = new Leaf(removal.Bounds, removal.Parent, removal.Index);
                parent[child_index] = leaf;
            }

            this.Stepper((T step) => { leaf.Add(step); }, removal);
        }

        /// <summary>Reduces the counts of all the parents of a given node by a given amount.</summary>
        /// <param name="parent">The starting parent of the reduction.</param>
        /// <param name="reduction">The amount to reduce the parent counts by.</param>
        private void ReduceParentCounts(Node parent, int reduction)
        {
            IncreaseParentCounts(parent, -reduction);
        }

        /// <summary>Increases the counts of all the parents of a given node by a given amount.</summary>
        /// <param name="parent">The starting parent of the increase.</param>
        /// <param name="increase">The amount to increase the parent counts by.</param>
        private void IncreaseParentCounts(Node parent, int increase)
        {
            Node looper = parent;
            while (looper != null)
            {
                looper.Count += increase;
                looper = looper.Parent;
            }
        }

        /// <summary>Checks a node for inclusion (overlap) between two bounds.</summary>
        /// <returns>True if the spaces overlap; False if not.</returns>
        private bool InclusionCheck(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5> a, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5> b)
        {

            if (a.Max1.Exists && b.Min1.Exists && this._compare1(a.Max1.Value, b.Min1.Value) == Comparison.Less)
                return false;
            else if (a.Min1.Exists && b.Max1.Exists && this._compare1(a.Min1.Value, b.Max1.Value) == Comparison.Greater)
                return false;

            if (a.Max2.Exists && b.Min2.Exists && this._compare2(a.Max2.Value, b.Min2.Value) == Comparison.Less)
                return false;
            else if (a.Min2.Exists && b.Max2.Exists && this._compare2(a.Min2.Value, b.Max2.Value) == Comparison.Greater)
                return false;

            if (a.Max3.Exists && b.Min3.Exists && this._compare3(a.Max3.Value, b.Min3.Value) == Comparison.Less)
                return false;
            else if (a.Min3.Exists && b.Max3.Exists && this._compare3(a.Min3.Value, b.Max3.Value) == Comparison.Greater)
                return false;

            if (a.Max4.Exists && b.Min4.Exists && this._compare4(a.Max4.Value, b.Min4.Value) == Comparison.Less)
                return false;
            else if (a.Min4.Exists && b.Max4.Exists && this._compare4(a.Min4.Value, b.Max4.Value) == Comparison.Greater)
                return false;

            if (a.Max5.Exists && b.Min5.Exists && this._compare5(a.Max5.Value, b.Min5.Value) == Comparison.Less)
                return false;
            else if (a.Min5.Exists && b.Max5.Exists && this._compare5(a.Min5.Value, b.Max5.Value) == Comparison.Greater)
                return false;

            return true;
        }

        /// <summary>Checks if a space encapsulates a point.</summary>
        /// <returns>True if the space encapsulates the point; False if not.</returns>
        private bool EncapsulationCheck(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5> bounds, Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5> vector)
        {
            // if the location is not outside the bounds, it must be inside

            if (bounds.Min1.Exists && this._compare1(vector.Axis1, bounds.Min1.Value) == Comparison.Less)
                return false;
            else if (bounds.Max1.Exists && this._compare1(vector.Axis1, bounds.Max1.Value) == Comparison.Greater)
                return false;

            if (bounds.Min2.Exists && this._compare2(vector.Axis2, bounds.Min2.Value) == Comparison.Less)
                return false;
            else if (bounds.Max2.Exists && this._compare2(vector.Axis2, bounds.Max2.Value) == Comparison.Greater)
                return false;

            if (bounds.Min3.Exists && this._compare3(vector.Axis3, bounds.Min3.Value) == Comparison.Less)
                return false;
            else if (bounds.Max3.Exists && this._compare3(vector.Axis3, bounds.Max3.Value) == Comparison.Greater)
                return false;

            if (bounds.Min4.Exists && this._compare4(vector.Axis4, bounds.Min4.Value) == Comparison.Less)
                return false;
            else if (bounds.Max4.Exists && this._compare4(vector.Axis4, bounds.Max4.Value) == Comparison.Greater)
                return false;

            if (bounds.Min5.Exists && this._compare5(vector.Axis5, bounds.Min5.Value) == Comparison.Less)
                return false;
            else if (bounds.Max5.Exists && this._compare5(vector.Axis5, bounds.Max5.Value) == Comparison.Greater)
                return false;

            return true;
        }

        /// <summary>Checks if a space (left) encapsulates another space (right).</summary>
        /// <returns>True if the left space encapsulates the right; False if not.</returns>
        private bool EncapsulationCheck(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5> a, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5> b)
        {
            if ((a.Min1.Exists && !b.Min1.Exists) || (a.Min2.Exists && !b.Min2.Exists) || (a.Min3.Exists && !b.Min3.Exists) || (a.Min4.Exists && !b.Min4.Exists) || (a.Min5.Exists && !b.Min5.Exists))
                return false;
			if ((a.Max1.Exists && !b.Max1.Exists) || (a.Max2.Exists && !b.Max2.Exists) || (a.Max3.Exists && !b.Max3.Exists) || (a.Max4.Exists && !b.Max4.Exists) || (a.Max5.Exists && !b.Max5.Exists))
                return false;

            if (b.Min1.Exists && a.Min1.Exists && this._compare1(a.Min1.Value, b.Min1.Value) != Comparison.Less)
                return false;
            if (b.Max1.Exists && a.Max1.Exists && this._compare1(a.Max1.Value, b.Max1.Value) != Comparison.Greater)
                return false;

            if (b.Min2.Exists && a.Min2.Exists && this._compare2(a.Min2.Value, b.Min2.Value) != Comparison.Less)
                return false;
            if (b.Max2.Exists && a.Max2.Exists && this._compare2(a.Max2.Value, b.Max2.Value) != Comparison.Greater)
                return false;

            if (b.Min3.Exists && a.Min3.Exists && this._compare3(a.Min3.Value, b.Min3.Value) != Comparison.Less)
                return false;
            if (b.Max3.Exists && a.Max3.Exists && this._compare3(a.Max3.Value, b.Max3.Value) != Comparison.Greater)
                return false;

            if (b.Min4.Exists && a.Min4.Exists && this._compare4(a.Min4.Value, b.Min4.Value) != Comparison.Less)
                return false;
            if (b.Max4.Exists && a.Max4.Exists && this._compare4(a.Max4.Value, b.Max4.Value) != Comparison.Greater)
                return false;

            if (b.Min5.Exists && a.Min5.Exists && this._compare5(a.Min5.Value, b.Min5.Value) != Comparison.Less)
                return false;
            if (b.Max5.Exists && a.Max5.Exists && this._compare5(a.Max5.Value, b.Max5.Value) != Comparison.Greater)
                return false;

            return true;
        }

        /// <summary>Checks for equality between two locations.</summary>
        /// <returns>True if equal; False if not;</returns>
        private bool EqualsCheck(Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5> a, Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5> b)
        {

            if (!this._equate1(a.Axis1, b.Axis1))
                return false;

            if (!this._equate2(a.Axis2, b.Axis2))
                return false;

            if (!this._equate3(a.Axis3, b.Axis3))
                return false;

            if (!this._equate4(a.Axis4, b.Axis4))
                return false;

            if (!this._equate5(a.Axis5, b.Axis5))
                return false;

            return true;
        }

        /// <summary>Gets the nearest parent that encapsulates a location.</summary>
        /// <param name="node">The starting node to find the encapsulating parent of the location.</param>
        /// <param name="coordinate1">The coordinate along the 1D axis.</param>
        /// <param name="coordinate2">The coordinate along the 2D axis.</param>
        /// <param name="coordinate3">The coordinate along the 3D axis.</param>
        /// <returns>The nearest node that encapsulates the given location.</returns>
        private Node GetEncapsulationParent(Node node, Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5> vector)
        {
            while (node != null && !EncapsulationCheck(node.Bounds, vector))
                node = node.Parent;
            return node;
        }

        private Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5> LocateVector(T value)
        {
            Axis1 axis1;
            Axis2 axis2;
            Axis3 axis3;
            Axis4 axis4;
            Axis5 axis5;
            this._locate(value, out axis1, out axis2, out axis3, out axis4, out axis5);
            return new Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5>(axis1, axis2, axis3, axis4, axis5);
        }

        #endregion

        #endregion
    }

    #endregion

    #region 6 Dimensional

    public interface IOmnitreePoints<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> : IDataStructure<T>,
            DataStructure.ICountable,
            DataStructure.IAddable<T>,
            DataStructure.IClearable,
            DataStructure.IRemovable<T>,
            DataStructure.IEquating<T>
    {
        #region Properties

        /// <summary>Steps through the values at a given location.</summary>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
		/// <param name="axis5">The coordinate along the 5D axis.</param>
		/// <param name="axis6">The coordinate along the 6D axis.</param>
        /// <returns>A Stepper of the items at the given coordinates.</returns>
        Stepper<T> this[Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Axis5 axis5, Axis6 axis6] { get; }
        /// <summary>The number of dimensions in this tree.</summary>
        int Dimensions { get; }

        #endregion

        #region Methods

        /// <summary>Counts the number of items in a sub space.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
        /// <returns>The number of items in the provided sub space.</returns>
        int CountSubSpace(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5, Omnitree.Bound<Axis6> min6, Omnitree.Bound<Axis6> max6);

        /// <summary>Iterates through the entire tree and ensures each item is in the proper leaf.</summary>
        void Update();
        /// <summary>Iterates through the provided dimensions and ensures each item is in the proper leaf.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
        void Update(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5, Omnitree.Bound<Axis6> min6, Omnitree.Bound<Axis6> max6);

        /// <summary>Removes all the items in a given space.</summary>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
		/// <param name="axis5">The coordinate along the 5D axis.</param>
		/// <param name="axis6">The coordinate along the 6D axis.</param>
        void Remove(Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Axis5 axis5, Axis6 axis6);
        /// <summary>Removes all the items in a given space.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
        void Remove(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5, Omnitree.Bound<Axis6> min6, Omnitree.Bound<Axis6> max6);
        /// <summary>Removes all the items in a given space where equality is met.</summary>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
		/// <param name="axis5">The coordinate along the 5D axis.</param>
		/// <param name="axis6">The coordinate along the 6D axis.</param>
        /// <param name="where">The equality constraint of the removal.</param>
        void Remove(Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Axis5 axis5, Axis6 axis6, Predicate<T> where);
        /// <summary>Removes all the items in a given space where predicate is met.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
        /// <param name="where">The predicate constraint of the removal.</param>
        void Remove(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5, Omnitree.Bound<Axis6> min6, Omnitree.Bound<Axis6> max6, Predicate<T> where);

        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="step">The step function to perform on all items in the tree within the given bounds.</param>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
        void Stepper(Step<T> step, Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5, Omnitree.Bound<Axis6> min6, Omnitree.Bound<Axis6> max6);
        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="step">The step function to perform on all items in the tree within the given bounds.</param>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
        StepStatus Stepper(StepBreak<T> step, Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5, Omnitree.Bound<Axis6> min6, Omnitree.Bound<Axis6> max6);
        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="step">The step function to perform on all items in the tree within the given bounds.</param>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
		/// <param name="axis5">The coordinate along the 5D axis.</param>
		/// <param name="axis6">The coordinate along the 6D axis.</param>
        void Stepper(Step<T> step, Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Axis5 axis5, Axis6 axis6);
        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="step">The step function to perform on all items in the tree within the given bounds.</param>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
		/// <param name="axis5">The coordinate along the 5D axis.</param>
		/// <param name="axis6">The coordinate along the 6D axis.</param>
        StepStatus Stepper(StepBreak<T> function, Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Axis5 axis5, Axis6 axis6);

        #endregion
    }

    public class OmnitreePointsLinked<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> : IOmnitreePoints<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>
    {
        private const int _dimensions = 6;
        internal static int _children_per_node = (int)BigInteger.Pow(2, 6);

        private Node _top;

		private int _naturalLogLower = 1; // caching the next time to calculate loads (lower count)
		private int _naturalLogUpper = -1; // caching the next time to calculate loads (upper count)
		private int _load; // ln(count); min = _defaultLoad
        private Omnitree.Location<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> _locate;

        private bool _defaultEquate;
        private Equate<T> _equate;


        private bool _defaultEquate1;
        private Equate<Axis1> _equate1;

        private bool _defaultEquate2;
        private Equate<Axis2> _equate2;

        private bool _defaultEquate3;
        private Equate<Axis3> _equate3;

        private bool _defaultEquate4;
        private Equate<Axis4> _equate4;

        private bool _defaultEquate5;
        private Equate<Axis5> _equate5;

        private bool _defaultEquate6;
        private Equate<Axis6> _equate6;



        private bool _defaultCompare1;
        private Compare<Axis1> _compare1;

        private bool _defaultCompare2;
        private Compare<Axis2> _compare2;

        private bool _defaultCompare3;
        private Compare<Axis3> _compare3;

        private bool _defaultCompare4;
        private Compare<Axis4> _compare4;

        private bool _defaultCompare5;
        private Compare<Axis5> _compare5;

        private bool _defaultCompare6;
        private Compare<Axis6> _compare6;


        // allows median overriding for custom optimizations (USE AT YOUR OWN RISK)
        private Omnitree.SubdivisionOverride<T, Axis1, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>> _subdivisionOverride1;
        private Omnitree.SubdivisionOverride<T, Axis2, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>> _subdivisionOverride2;
        private Omnitree.SubdivisionOverride<T, Axis3, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>> _subdivisionOverride3;
        private Omnitree.SubdivisionOverride<T, Axis4, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>> _subdivisionOverride4;
        private Omnitree.SubdivisionOverride<T, Axis5, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>> _subdivisionOverride5;
        private Omnitree.SubdivisionOverride<T, Axis6, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>> _subdivisionOverride6;

        #region Nested Types

        /// <summary>Can be a leaf or a branch.</summary>
        public abstract class Node
        {
            internal Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> _bounds;
            internal Branch _parent;
            internal int _index;
            internal int _count;

            /// <summary>The parent of this node.</summary>
            public Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> Bounds { get { return this._bounds; } }
            /// <summary>The parent of this node.</summary>
            public Branch Parent { get { return this._parent; } }
            /// <summary>The computed child index of this node (see the "Notes" region in "Omnitree.cs" for the algorithm.</summary>
            public int Index { get { return this._index; } }
            /// <summary>The number of elements stored in this node and its children.</summary>
            public int Count { get { return this._count; } set { this._count = value; } }

            /// <summary>The depth this node is located in the Omnitree.</summary>
            public int Depth
            {
                get
                {
                    int depth = -1;
                    for (Node looper = this; looper != null; looper = looper.Parent)
                        depth++;
                    return depth;
                }
            }

            /// <summary>Constructs a node.</summary>
            /// <param name="bounds">The bounds of this node.</param>
            /// <param name="parent">The parent of this node.</param>
            /// <param name="index">The number of elements stored in this node and its children.</param>
            public Node(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> bounds, Branch parent, int index)
            {
                this._bounds = bounds;
                this._parent = parent;
                this._index = index;
            }

            internal Node(Node nodeToClone)
            {
                this._bounds = nodeToClone._bounds;
                this._parent = nodeToClone._parent;
                this._index = nodeToClone._index;
                this._count = nodeToClone._count;
            }

            internal abstract Node Clone();
        }

        /// <summary>A branch in the tree. Only contains nodes.</summary>
        public class Branch : Node
        {
            private Node[] _children;
            private Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> _pointOfDivision;

            public Node[] Children { get { return this._children; } set { this._children = value; } }
            public Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> PointOfDivision { get { return this._pointOfDivision; } internal set { this._pointOfDivision = value; } }
            
            /// <summary>Gets child by index.</summary>
            /// <param name="child_index">The index of the child to get.</param>
            /// <returns>The child of the given index or null if non-existent.</returns>
            public Node this[int child_index]
            {
                get
                {
                    if (this._children == null)
                        return null;
                    if (this._children.Length == OmnitreePointsLinked<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>._children_per_node)
                        return this._children[(int)child_index];
                    foreach (Node node in this._children)
                        if (node.Index == child_index)
                            return node;
                    return null;
                }
                set
                {
                    // This error check should be unnecessary... but fuck it... might as well
                    if (value.Index != child_index)
                        throw new System.Exception("Bug in Omnitree (index/property mis-match when setting a child on a branch)");

                    // no children yet
                    if (this._children == null)
                    {
                        this._children = new Node[] { value };
                        return;
                    }
                    // max children overwrite
                    else if (this._children.Length == OmnitreePointsLinked<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>._children_per_node)
                    {
                        this._children[(int)child_index] = value;
                        return;
                    }
                    // non-max child overwrite
                    for (int i = 0; i < this._children.Length; i++)
                        if (this._children[i].Index == child_index)
                        {
                            this._children[i] = value;
                            return;
                        }
                    // new child
                    Node[] newArray = new Node[this._children.Length + 1];
                    if (newArray.Length == OmnitreePointsLinked<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>._children_per_node)
                    {
                        // new child resulting in a max children branch (sorting required)
                        for (int i = 0; i < this._children.Length; i++)
                        {
                            newArray[(int)this._children[i]._index] = this._children[i];
                        }
                        newArray[(int)value._index] = value;
                    }
                    else
                    {
                        // new child resulting in a non-max children branch
                        Array.Copy(this._children, newArray, this._children.Length);
                        newArray[newArray.Length - 1] = value;
                    }
                    this._children = newArray;
                }
            }

            public Branch(Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> pointOfDivision, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> bounds, Branch parent, int index)
                : base(bounds, parent, index)
            {
                this._pointOfDivision = pointOfDivision;
            }

            public Branch(Branch branchToClone)
                : base(branchToClone)
            {
                this._children = branchToClone._children.Clone() as Node[];
                this._pointOfDivision = branchToClone._pointOfDivision;
            }

            internal override Node Clone()
            {
                return new Branch(this);
            }
        }

        /// <summary>A branch in the tree. Only contains items.</summary>
        public class Leaf : Node
        {
            public class Node
            {
                internal T _value;
                internal Leaf.Node _next;

                public T Value { get { return _value; } set { _value = value; } }
                public Leaf.Node Next { get { return _next; } set { _next = value; } }

                public Node(T value, Leaf.Node next)
                {
                    _value = value;
                    _next = next;
                }
            }

            private Leaf.Node _head;

            public Leaf.Node Head { get { return this._head; } set { this._head = value; } }

            internal Leaf(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> bounds, Branch parent, int index)
                : base(bounds, parent, index)
            { }

            internal Leaf(Leaf leafToClone)
                : base(leafToClone)
            {
                this._head = new Node(leafToClone._head.Value, null);

                Node this_looper = this._head;
                Node other_looper = leafToClone._head;

                while (other_looper != null)
                {
                    this_looper.Next = new Node(other_looper.Next.Value, null);
                    this_looper = this_looper.Next;
                    other_looper = other_looper.Next;
                }
            }

            public void Add(T addition)
            {
                this._head = new Leaf.Node(addition, this._head);
                this.Count++;
            }

            internal override OmnitreePointsLinked<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>.Node Clone()
            {
                return new Leaf(this);
            }
        }

        #endregion

        #region Constructors

        /// <summary>This constructor is for cloning purposes</summary>
        private OmnitreePointsLinked(OmnitreePointsLinked<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> omnitree)
        {
            this._top = omnitree._top.Clone();
            this._load = omnitree._load;
            this._locate = omnitree._locate;
            this._defaultEquate = omnitree._defaultEquate;
            this._equate = omnitree._equate;

            this._defaultEquate1 = omnitree._defaultEquate1;
            this._equate1 = omnitree._equate1;
            this._defaultEquate2 = omnitree._defaultEquate2;
            this._equate2 = omnitree._equate2;
            this._defaultEquate3 = omnitree._defaultEquate3;
            this._equate3 = omnitree._equate3;
            this._defaultEquate4 = omnitree._defaultEquate4;
            this._equate4 = omnitree._equate4;
            this._defaultEquate5 = omnitree._defaultEquate5;
            this._equate5 = omnitree._equate5;
            this._defaultEquate6 = omnitree._defaultEquate6;
            this._equate6 = omnitree._equate6;

            this._defaultCompare1 = omnitree._defaultCompare1;
            this._compare1 = omnitree._compare1;
            this._defaultCompare2 = omnitree._defaultCompare2;
            this._compare2 = omnitree._compare2;
            this._defaultCompare3 = omnitree._defaultCompare3;
            this._compare3 = omnitree._compare3;
            this._defaultCompare4 = omnitree._defaultCompare4;
            this._compare4 = omnitree._compare4;
            this._defaultCompare5 = omnitree._defaultCompare5;
            this._compare5 = omnitree._compare5;
            this._defaultCompare6 = omnitree._defaultCompare6;
            this._compare6 = omnitree._compare6;

            this._subdivisionOverride1 = omnitree._subdivisionOverride1;
            this._subdivisionOverride2 = omnitree._subdivisionOverride2;
            this._subdivisionOverride3 = omnitree._subdivisionOverride3;
            this._subdivisionOverride4 = omnitree._subdivisionOverride4;
            this._subdivisionOverride5 = omnitree._subdivisionOverride5;
            this._subdivisionOverride6 = omnitree._subdivisionOverride6;
        }

        private OmnitreePointsLinked(
            Omnitree.Location<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> locate,

            bool defaultEquate,
            Equate<T> equate,

            bool defaultEquate1,
            Equate<Axis1> equateAxis1,
            bool defaultEquate2,
            Equate<Axis2> equateAxis2,
            bool defaultEquate3,
            Equate<Axis3> equateAxis3,
            bool defaultEquate4,
            Equate<Axis4> equateAxis4,
            bool defaultEquate5,
            Equate<Axis5> equateAxis5,
            bool defaultEquate6,
            Equate<Axis6> equateAxis6,

            bool defaultCompare1,
            Compare<Axis1> compare1,
            bool defaultCompare2,
            Compare<Axis2> compare2,
            bool defaultCompare3,
            Compare<Axis3> compare3,
            bool defaultCompare4,
            Compare<Axis4> compare4,
            bool defaultCompare5,
            Compare<Axis5> compare5,
            bool defaultCompare6,
            Compare<Axis6> compare6,

            Omnitree.SubdivisionOverride<T, Axis1, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>> subdivisionOverride1,
            Omnitree.SubdivisionOverride<T, Axis2, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>> subdivisionOverride2,
            Omnitree.SubdivisionOverride<T, Axis3, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>> subdivisionOverride3,
            Omnitree.SubdivisionOverride<T, Axis4, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>> subdivisionOverride4,
            Omnitree.SubdivisionOverride<T, Axis5, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>> subdivisionOverride5,
            Omnitree.SubdivisionOverride<T, Axis6, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>> subdivisionOverride6)
        {
			if (locate == null)
			{
				throw new ArgumentNullException(nameof(locate));
			}
			if (equate == null)
			{
				throw new ArgumentNullException(nameof(equate));
			}

			if (equateAxis1 == null)
			{
				throw new ArgumentNullException(nameof(equateAxis1));
			}
			if (equateAxis2 == null)
			{
				throw new ArgumentNullException(nameof(equateAxis2));
			}
			if (equateAxis3 == null)
			{
				throw new ArgumentNullException(nameof(equateAxis3));
			}
			if (equateAxis4 == null)
			{
				throw new ArgumentNullException(nameof(equateAxis4));
			}
			if (equateAxis5 == null)
			{
				throw new ArgumentNullException(nameof(equateAxis5));
			}
			if (equateAxis6 == null)
			{
				throw new ArgumentNullException(nameof(equateAxis6));
			}

			if (compare1 == null)
			{
				throw new ArgumentNullException(nameof(compare1));
			}
			if (compare2 == null)
			{
				throw new ArgumentNullException(nameof(compare2));
			}
			if (compare3 == null)
			{
				throw new ArgumentNullException(nameof(compare3));
			}
			if (compare4 == null)
			{
				throw new ArgumentNullException(nameof(compare4));
			}
			if (compare5 == null)
			{
				throw new ArgumentNullException(nameof(compare5));
			}
			if (compare6 == null)
			{
				throw new ArgumentNullException(nameof(compare6));
			}

            this._locate = locate;
            this._defaultEquate = defaultEquate;
            this._equate = equate;

            this._defaultEquate1 = defaultEquate1;
            this._equate1 = equateAxis1;
            this._defaultEquate2 = defaultEquate2;
            this._equate2 = equateAxis2;
            this._defaultEquate3 = defaultEquate3;
            this._equate3 = equateAxis3;
            this._defaultEquate4 = defaultEquate4;
            this._equate4 = equateAxis4;
            this._defaultEquate5 = defaultEquate5;
            this._equate5 = equateAxis5;
            this._defaultEquate6 = defaultEquate6;
            this._equate6 = equateAxis6;

            this._defaultCompare1 = defaultCompare1;
            this._compare1 = compare1;
            this._defaultCompare2 = defaultCompare2;
            this._compare2 = compare2;
            this._defaultCompare3 = defaultCompare3;
            this._compare3 = compare3;
            this._defaultCompare4 = defaultCompare4;
            this._compare4 = compare4;
            this._defaultCompare5 = defaultCompare5;
            this._compare5 = compare5;
            this._defaultCompare6 = defaultCompare6;
            this._compare6 = compare6;

            this._subdivisionOverride1 = subdivisionOverride1;
            this._subdivisionOverride2 = subdivisionOverride2;
            this._subdivisionOverride3 = subdivisionOverride3;
            this._subdivisionOverride4 = subdivisionOverride4;
            this._subdivisionOverride5 = subdivisionOverride5;
            this._subdivisionOverride6 = subdivisionOverride6;

            this._top = new Leaf(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>.None, null, -1);
            Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
        }

        private OmnitreePointsLinked(
            Omnitree.Location<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> locate,
            Equate<T> equate,

            Equate<Axis1> equateAxis1,
            Equate<Axis2> equateAxis2,
            Equate<Axis3> equateAxis3,
            Equate<Axis4> equateAxis4,
            Equate<Axis5> equateAxis5,
            Equate<Axis6> equateAxis6,

            Compare<Axis1> compare1,
            Compare<Axis2> compare2,
            Compare<Axis3> compare3,
            Compare<Axis4> compare4,
            Compare<Axis5> compare5,
            Compare<Axis6> compare6,

            Omnitree.SubdivisionOverride<T, Axis1, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>> subdivisionOverride1,
            Omnitree.SubdivisionOverride<T, Axis2, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>> subdivisionOverride2,
            Omnitree.SubdivisionOverride<T, Axis3, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>> subdivisionOverride3,
            Omnitree.SubdivisionOverride<T, Axis4, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>> subdivisionOverride4,
            Omnitree.SubdivisionOverride<T, Axis5, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>> subdivisionOverride5,
            Omnitree.SubdivisionOverride<T, Axis6, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>> subdivisionOverride6)
            : this(
            locate,

            false,
            equate,

            false,
            equateAxis1,
            false,
            equateAxis2,
            false,
            equateAxis3,
            false,
            equateAxis4,
            false,
            equateAxis5,
            false,
            equateAxis6,

            false,
            compare1,
            false,
            compare2,
            false,
            compare3,
            false,
            compare4,
            false,
            compare5,
            false,
            compare6,

            subdivisionOverride1,
            subdivisionOverride2,
            subdivisionOverride3,
            subdivisionOverride4,
            subdivisionOverride5,
            subdivisionOverride6)
        { }

        public OmnitreePointsLinked(
            Omnitree.Location<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> locate,

            Equate<T> equate,

            Equate<Axis1> equateAxis1,
            Equate<Axis2> equateAxis2,
            Equate<Axis3> equateAxis3,
            Equate<Axis4> equateAxis4,
            Equate<Axis5> equateAxis5,
            Equate<Axis6> equateAxis6,

            Compare<Axis1> compare1,
            Compare<Axis2> compare2,
            Compare<Axis3> compare3,
            Compare<Axis4> compare4,
            Compare<Axis5> compare5,
            Compare<Axis6> compare6)
            : this(
                locate,

                false,
                equate,

                false,
                equateAxis1,
                false,
                equateAxis2,
                false,
                equateAxis3,
                false,
                equateAxis4,
                false,
                equateAxis5,
                false,
                equateAxis6,

                false,
                compare1,
                false,
                compare2,
                false,
                compare3,
                false,
                compare4,
                false,
                compare5,
                false,
                compare6,

                null,
                null,
                null,
                null,
                null,
                null)
        { }



        public OmnitreePointsLinked(
            Omnitree.Location<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> locate,

            Equate<T> equate,

            Compare<Axis1> compare1,
            Compare<Axis2> compare2,
            Compare<Axis3> compare3,
            Compare<Axis4> compare4,
            Compare<Axis5> compare5,
            Compare<Axis6> compare6)
            : this(
                locate,
                false,
                equate,

                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,

                false,
                compare1,
                false,
                compare2,
                false,
                compare3,
                false,
                compare4,
                false,
                compare5,
                false,
                compare6,

                null,
                null,
                null,
                null,
                null,
                null)
        { }

        public OmnitreePointsLinked(
            Omnitree.Location<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> locate,
            Equate<T> equate,

            Compare<Axis1> compare1,
            Compare<Axis2> compare2,
            Compare<Axis3> compare3,
            Compare<Axis4> compare4,
            Compare<Axis5> compare5,
            Compare<Axis6> compare6,

            Omnitree.SubdivisionOverride<T, Axis1, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>> subdivisionOverride1,
            Omnitree.SubdivisionOverride<T, Axis2, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>> subdivisionOverride2,
            Omnitree.SubdivisionOverride<T, Axis3, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>> subdivisionOverride3,
            Omnitree.SubdivisionOverride<T, Axis4, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>> subdivisionOverride4,
            Omnitree.SubdivisionOverride<T, Axis5, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>> subdivisionOverride5,
            Omnitree.SubdivisionOverride<T, Axis6, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>> subdivisionOverride6)
            : this(
                locate,

                false,
                equate,

                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,

                false,
                compare1,
                false,
                compare2,
                false,
                compare3,
                false,
                compare4,
                false,
                compare5,
                false,
                compare6,

                subdivisionOverride1,
                subdivisionOverride2,
                subdivisionOverride3,
                subdivisionOverride4,
                subdivisionOverride5,
                subdivisionOverride6)
        { }

        public OmnitreePointsLinked(
            Omnitree.Location<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> locate,

            Compare<Axis1> compare1,
            Compare<Axis2> compare2,
            Compare<Axis3> compare3,
            Compare<Axis4> compare4,
            Compare<Axis5> compare5,
            Compare<Axis6> compare6)
            : this(
                locate,
                true,
                Towel.Equate.Default,

                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,

                false,
                compare1,
                false,
                compare2,
                false,
                compare3,
                false,
                compare4,
                false,
                compare5,
                false,
                compare6,

                null,
                null,
                null,
                null,
                null,
                null)
        { }

        public OmnitreePointsLinked(
            Omnitree.Location<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> locate,

            Compare<Axis1> compare1,
            Compare<Axis2> compare2,
            Compare<Axis3> compare3,
            Compare<Axis4> compare4,
            Compare<Axis5> compare5,
            Compare<Axis6> compare6,

            Omnitree.SubdivisionOverride<T, Axis1, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>> subdivisionOverride1,
            Omnitree.SubdivisionOverride<T, Axis2, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>> subdivisionOverride2,
            Omnitree.SubdivisionOverride<T, Axis3, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>> subdivisionOverride3,
            Omnitree.SubdivisionOverride<T, Axis4, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>> subdivisionOverride4,
            Omnitree.SubdivisionOverride<T, Axis5, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>> subdivisionOverride5,
            Omnitree.SubdivisionOverride<T, Axis6, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>> subdivisionOverride6)
            : this(
                locate,

                true,
                Towel.Equate.Default,

                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,

                false,
                compare1,
                false,
                compare2,
                false,
                compare3,
                false,
                compare4,
                false,
                compare5,
                false,
                compare6,

                subdivisionOverride1,
                subdivisionOverride2,
                subdivisionOverride3,
                subdivisionOverride4,
                subdivisionOverride5,
                subdivisionOverride6)
        { }

        public OmnitreePointsLinked(
            Omnitree.Location<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> locate,
            Equate<T> equate)
            : this(
                locate,

                false,
                equate,

                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,

                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,

                null,
                null,
                null,
                null,
                null,
                null)
        { }

        public OmnitreePointsLinked(
            Omnitree.Location<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> locate,
            Equate<T> equate,
            Omnitree.SubdivisionOverride<T, Axis1, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>> subdivisionOverride1,
            Omnitree.SubdivisionOverride<T, Axis2, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>> subdivisionOverride2,
            Omnitree.SubdivisionOverride<T, Axis3, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>> subdivisionOverride3,
            Omnitree.SubdivisionOverride<T, Axis4, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>> subdivisionOverride4,
            Omnitree.SubdivisionOverride<T, Axis5, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>> subdivisionOverride5,
            Omnitree.SubdivisionOverride<T, Axis6, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>> subdivisionOverride6)
            : this(
                locate,

                false,
                equate,

                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,

                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,

                subdivisionOverride1,
                subdivisionOverride2,
                subdivisionOverride3,
                subdivisionOverride4,
                subdivisionOverride5,
                subdivisionOverride6)
        { }

        public OmnitreePointsLinked(
            Omnitree.Location<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> locate)
            : this(
                locate,

                true,
                Towel.Equate.Default,

                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,

                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,

                null,
                null,
                null,
                null,
                null,
                null)
        { }

        public OmnitreePointsLinked(
            Omnitree.Location<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> locate,
            Omnitree.SubdivisionOverride<T, Axis1, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>> subdivisionOverride1,
            Omnitree.SubdivisionOverride<T, Axis2, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>> subdivisionOverride2,
            Omnitree.SubdivisionOverride<T, Axis3, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>> subdivisionOverride3,
            Omnitree.SubdivisionOverride<T, Axis4, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>> subdivisionOverride4,
            Omnitree.SubdivisionOverride<T, Axis5, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>> subdivisionOverride5,
            Omnitree.SubdivisionOverride<T, Axis6, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>> subdivisionOverride6)
            : this(
                locate,

                true,
                Towel.Equate.Default,

                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,

                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,

                subdivisionOverride1,
                subdivisionOverride2,
                subdivisionOverride3,
                subdivisionOverride4,
                subdivisionOverride5,
                subdivisionOverride6)
        { }

        #endregion

        #region Properties

        /// <summary>Steps through all the items at a given coordinate.</summary>
        /// <param name="axis1">The coordinate along axis 1.</param>
        /// <param name="axis2">The coordinate along axis 2.</param>
        /// <param name="axis3">The coordinate along axis 3.</param>
        /// <param name="axis4">The coordinate along axis 4.</param>
        /// <param name="axis5">The coordinate along axis 5.</param>
        /// <param name="axis6">The coordinate along axis 6.</param>
        /// <returns>The stepper for the items at the given coordinate.</returns>
        public Stepper<T> this[Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Axis5 axis5, Axis6 axis6]
        {
            get
            {
                return (Step<T> step) => { this.Stepper(step, axis1, axis2, axis3, axis4, axis5, axis6); };
            }
        }

        /// <summary>The number of dimensions in this tree.</summary>
        public int Dimensions { get { return _dimensions; } }

        /// <summary>The function for equating keys in this table.</summary>
        public Equate<T> Equate { get { return this._equate; } }

        /// <summary>The location function the Omnitree is using.</summary>
        public Omnitree.Location<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> Locate { get { return this._locate; } }


        /// <summary>The comparison function the Omnitree is using along the 1D axis.</summary>
        public Compare<Axis1> Compare1 { get { return this._compare1; } }
        /// <summary>The comparison function the Omnitree is using along the 2D axis.</summary>
        public Compare<Axis2> Compare2 { get { return this._compare2; } }
        /// <summary>The comparison function the Omnitree is using along the 3D axis.</summary>
        public Compare<Axis3> Compare3 { get { return this._compare3; } }
        /// <summary>The comparison function the Omnitree is using along the 4D axis.</summary>
        public Compare<Axis4> Compare4 { get { return this._compare4; } }
        /// <summary>The comparison function the Omnitree is using along the 5D axis.</summary>
        public Compare<Axis5> Compare5 { get { return this._compare5; } }
        /// <summary>The comparison function the Omnitree is using along the 6D axis.</summary>
        public Compare<Axis6> Compare6 { get { return this._compare6; } }

        /// <summary>The function for equating values along the 1D axis.</summary>
        public Equate<Axis1> EquateAxis1 { get { return this._equate1; } }
        /// <summary>The function for equating values along the 2D axis.</summary>
        public Equate<Axis2> EquateAxis2 { get { return this._equate2; } }
        /// <summary>The function for equating values along the 3D axis.</summary>
        public Equate<Axis3> EquateAxis3 { get { return this._equate3; } }
        /// <summary>The function for equating values along the 4D axis.</summary>
        public Equate<Axis4> EquateAxis4 { get { return this._equate4; } }
        /// <summary>The function for equating values along the 5D axis.</summary>
        public Equate<Axis5> EquateAxis5 { get { return this._equate5; } }
        /// <summary>The function for equating values along the 6D axis.</summary>
        public Equate<Axis6> EquateAxis6 { get { return this._equate6; } }

        /// <summary>The current number of items in the tree.</summary>
        public int Count { get { return this._top.Count; } }

        private delegate void MaxDepthFinder(Node node, int current_depth, ref int max_depth);
        /// <summary>Finds the current maximum depth of the tree. NOT AN O(1) OPERATION. Intended for educational purposes only.</summary>
        public int MaxDepth
        {
            get
            {
                MaxDepthFinder maxDepthFinder = null;
                maxDepthFinder =
                        (Node node, int current_depth, ref int max_depth) =>
                        {
                            if (current_depth > max_depth)
                                max_depth = current_depth;
                            if (node is Branch)
                                foreach (Node child in (node as Branch).Children)
                                    maxDepthFinder(child, current_depth + 1, ref max_depth);
                        };
                int _max_depth = -1;
                maxDepthFinder(this._top, 0, ref _max_depth);
                return _max_depth;
            }
        }

        private delegate void NodeCountFinder(Node node, ref int current_count);
        /// <summary>Counts the current number of nodes in the tree. NOT AN O(1) OPERATION. Intended for educational purposes only.</summary>
        public int NodeCount
        {
            get
            {
                NodeCountFinder nodeCountFinder = null;
                nodeCountFinder =
                        (Node node, ref int current_count) =>
                        {
                            current_count++;
                            if (node is Branch)
                                foreach (Node child in (node as Branch).Children)
                                    nodeCountFinder(child, ref current_count);
                        };

                int _current_count = 0;
                nodeCountFinder(this._top, ref _current_count);
                return _current_count;
            }
        }

        private delegate void BranchCountFinder(Node node, ref int current_count);
        /// <summary>Counts the current number of branches in the tree. NOT AN O(1) OPERATION. Intended for educational purposes only.</summary>
        public int BranchCount
        {
            get
            {
                BranchCountFinder branchCountFinder = null;
                branchCountFinder =
                        (Node node, ref int current_count) =>
                        {
                            if (node is Branch)
                            {
                                current_count++;
                                foreach (Node child in (node as Branch).Children)
                                    branchCountFinder(child, ref current_count);
                            }
                        };

                int _current_count = 0;
                branchCountFinder(this._top, ref _current_count);
                return _current_count;
            }
        }

        private delegate void LeafCountFinder(Node node, ref int current_count);
        /// <summary>Counts the current number of leaves in the tree. NOT AN O(1) OPERATION. Intended for educational purposes only.</summary>
        public int LeafCount
        {
            get
            {
                LeafCountFinder leafCountFinder = null;
                leafCountFinder =
                        (Node node, ref int current_count) =>
                        {
                            if (node is Leaf)
                                current_count++;
                            else
                                foreach (Node child in (node as Branch).Children)
                                    leafCountFinder(child, ref current_count);
                        };

                int _current_count = 0;
                leafCountFinder(this._top, ref _current_count);
                return _current_count;
            }
        }

        #endregion

        #region Methods

        #region Add

        #region Bulk

        public void Add(IndexedBigArray<T> additions, bool allowMultithreading)
        {
            if (additions.Length > int.MaxValue)
                throw new System.Exception("The maximum size of the Omnitree was exceeded during bulk addition.");

            if (this._top.Count != 0 || (int)additions.Length <= _load)
            {
                for (ulong i = 0; i < additions.Length; i++)
                    this.Add(additions[i]);
            }
            else
            {
                // adjust the loads prior to additions
				Omnitree.ComputeLoads((int)additions.Length, ref _naturalLogLower, ref _naturalLogUpper, ref _load);

                Branch new_top = new Branch(Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>.Default, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>.None, null, -1);
                new_top.Count = (int)additions.Length;


                // prepare data for median computations
                IndexedBigArray<Axis1> values1;
                IAsyncResult result1 = null;
                if (this._subdivisionOverride1 != null)
                    values1 = null;
                else
                {
                    values1 = null;
                    Towel.Parallels.Parallel.Operation operation = () =>
                    {
                        values1 = new IndexedBigArray<Axis1>(additions.Length);
                        for (ulong i = 0; i < additions.Length; i++)
                            values1[i] = LocateVector(additions[i]).Axis1;
                        Towel.Algorithms.Sort.Merge(this._compare1, (int i) => { return values1[(ulong)i]; }, (int i, Axis1 value) => { values1[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
                    };

                    if (allowMultithreading)
                        result1 = Towel.Parallels.Parallel.Thread(operation);
                    else
                        operation();
                }

                // prepare data for median computations
                IndexedBigArray<Axis2> values2;
                IAsyncResult result2 = null;
                if (this._subdivisionOverride2 != null)
                    values2 = null;
                else
                {
                    values2 = null;
                    Towel.Parallels.Parallel.Operation operation = () =>
                    {
                        values2 = new IndexedBigArray<Axis2>(additions.Length);
                        for (ulong i = 0; i < additions.Length; i++)
                            values2[i] = LocateVector(additions[i]).Axis2;
                        Towel.Algorithms.Sort.Merge(this._compare2, (int i) => { return values2[(ulong)i]; }, (int i, Axis2 value) => { values2[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
                    };

                    if (allowMultithreading)
                        result2 = Towel.Parallels.Parallel.Thread(operation);
                    else
                        operation();
                }

                // prepare data for median computations
                IndexedBigArray<Axis3> values3;
                IAsyncResult result3 = null;
                if (this._subdivisionOverride3 != null)
                    values3 = null;
                else
                {
                    values3 = null;
                    Towel.Parallels.Parallel.Operation operation = () =>
                    {
                        values3 = new IndexedBigArray<Axis3>(additions.Length);
                        for (ulong i = 0; i < additions.Length; i++)
                            values3[i] = LocateVector(additions[i]).Axis3;
                        Towel.Algorithms.Sort.Merge(this._compare3, (int i) => { return values3[(ulong)i]; }, (int i, Axis3 value) => { values3[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
                    };

                    if (allowMultithreading)
                        result3 = Towel.Parallels.Parallel.Thread(operation);
                    else
                        operation();
                }

                // prepare data for median computations
                IndexedBigArray<Axis4> values4;
                IAsyncResult result4 = null;
                if (this._subdivisionOverride4 != null)
                    values4 = null;
                else
                {
                    values4 = null;
                    Towel.Parallels.Parallel.Operation operation = () =>
                    {
                        values4 = new IndexedBigArray<Axis4>(additions.Length);
                        for (ulong i = 0; i < additions.Length; i++)
                            values4[i] = LocateVector(additions[i]).Axis4;
                        Towel.Algorithms.Sort.Merge(this._compare4, (int i) => { return values4[(ulong)i]; }, (int i, Axis4 value) => { values4[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
                    };

                    if (allowMultithreading)
                        result4 = Towel.Parallels.Parallel.Thread(operation);
                    else
                        operation();
                }

                // prepare data for median computations
                IndexedBigArray<Axis5> values5;
                IAsyncResult result5 = null;
                if (this._subdivisionOverride5 != null)
                    values5 = null;
                else
                {
                    values5 = null;
                    Towel.Parallels.Parallel.Operation operation = () =>
                    {
                        values5 = new IndexedBigArray<Axis5>(additions.Length);
                        for (ulong i = 0; i < additions.Length; i++)
                            values5[i] = LocateVector(additions[i]).Axis5;
                        Towel.Algorithms.Sort.Merge(this._compare5, (int i) => { return values5[(ulong)i]; }, (int i, Axis5 value) => { values5[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
                    };

                    if (allowMultithreading)
                        result5 = Towel.Parallels.Parallel.Thread(operation);
                    else
                        operation();
                }

                // prepare data for median computations
                IndexedBigArray<Axis6> values6;
                IAsyncResult result6 = null;
                if (this._subdivisionOverride6 != null)
                    values6 = null;
                else
                {
                    values6 = null;
                    Towel.Parallels.Parallel.Operation operation = () =>
                    {
                        values6 = new IndexedBigArray<Axis6>(additions.Length);
                        for (ulong i = 0; i < additions.Length; i++)
                            values6[i] = LocateVector(additions[i]).Axis6;
                        Towel.Algorithms.Sort.Merge(this._compare6, (int i) => { return values6[(ulong)i]; }, (int i, Axis6 value) => { values6[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
                    };

                    if (allowMultithreading)
                        result6 = Towel.Parallels.Parallel.Thread(operation);
                    else
                        operation();
                }



                if (this._subdivisionOverride1 == null && allowMultithreading)
                    result1.AsyncWaitHandle.WaitOne();

                if (this._subdivisionOverride2 == null && allowMultithreading)
                    result2.AsyncWaitHandle.WaitOne();

                if (this._subdivisionOverride3 == null && allowMultithreading)
                    result3.AsyncWaitHandle.WaitOne();

                if (this._subdivisionOverride4 == null && allowMultithreading)
                    result4.AsyncWaitHandle.WaitOne();

                if (this._subdivisionOverride5 == null && allowMultithreading)
                    result5.AsyncWaitHandle.WaitOne();

                if (this._subdivisionOverride6 == null && allowMultithreading)
                    result6.AsyncWaitHandle.WaitOne();


                // build the tree
                Add(new_top, 1, -1, additions.Stepper(), (int)additions.Length, int.MinValue, int.MinValue, int.MinValue, int.MinValue, int.MinValue, int.MinValue, (int)additions.Length, (int index) => { return values1[index]; }, (int index) => { return values2[index]; }, (int index) => { return values3[index]; }, (int index) => { return values4[index]; }, (int index) => { return values5[index]; }, (int index) => { return values6[index]; }, allowMultithreading);
                
                this._top = new_top;
            }
        }

        public void Add(bool allowMultithreading, params T[] additions)
        {
            if (additions.Length > int.MaxValue)
                throw new System.Exception("The maximum size of the Omnitree was exceeded during bulk addition.");

            if (this._top.Count != 0 || (int)additions.Length <= _load)
            {
                for (int i = 0; i < additions.Length; i++)
                    this.Add(additions[i]);
            }
            else
            {
                // adjust the loads prior to additions
				Omnitree.ComputeLoads((int)additions.Length, ref _naturalLogLower, ref _naturalLogUpper, ref _load);

                Branch new_top = new Branch(Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>.Default, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>.None, null, -1);
                new_top.Count = (int)additions.Length;


                // prepare data for median computations
                IndexedBigArray<Axis1> values1;
                IAsyncResult result1 = null;
                if (this._subdivisionOverride1 != null)
                    values1 = null;
                else
                {
                    values1 = null;
                    Towel.Parallels.Parallel.Operation operation = () =>
                    {
                        values1 = new IndexedBigArray<Axis1>(additions.Length);
                        for (int i = 0; i < additions.Length; i++)
                            values1[i] = LocateVector(additions[i]).Axis1;
                        Towel.Algorithms.Sort.Merge(this._compare1, (int i) => { return values1[(ulong)i]; }, (int i, Axis1 value) => { values1[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
                    };

                    if (allowMultithreading)
                        result1 = Towel.Parallels.Parallel.Thread(operation);
                    else
                        operation();
                }

                // prepare data for median computations
                IndexedBigArray<Axis2> values2;
                IAsyncResult result2 = null;
                if (this._subdivisionOverride2 != null)
                    values2 = null;
                else
                {
                    values2 = null;
                    Towel.Parallels.Parallel.Operation operation = () =>
                    {
                        values2 = new IndexedBigArray<Axis2>(additions.Length);
                        for (int i = 0; i < additions.Length; i++)
                            values2[i] = LocateVector(additions[i]).Axis2;
                        Towel.Algorithms.Sort.Merge(this._compare2, (int i) => { return values2[(ulong)i]; }, (int i, Axis2 value) => { values2[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
                    };

                    if (allowMultithreading)
                        result2 = Towel.Parallels.Parallel.Thread(operation);
                    else
                        operation();
                }

                // prepare data for median computations
                IndexedBigArray<Axis3> values3;
                IAsyncResult result3 = null;
                if (this._subdivisionOverride3 != null)
                    values3 = null;
                else
                {
                    values3 = null;
                    Towel.Parallels.Parallel.Operation operation = () =>
                    {
                        values3 = new IndexedBigArray<Axis3>(additions.Length);
                        for (int i = 0; i < additions.Length; i++)
                            values3[i] = LocateVector(additions[i]).Axis3;
                        Towel.Algorithms.Sort.Merge(this._compare3, (int i) => { return values3[(ulong)i]; }, (int i, Axis3 value) => { values3[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
                    };

                    if (allowMultithreading)
                        result3 = Towel.Parallels.Parallel.Thread(operation);
                    else
                        operation();
                }

                // prepare data for median computations
                IndexedBigArray<Axis4> values4;
                IAsyncResult result4 = null;
                if (this._subdivisionOverride4 != null)
                    values4 = null;
                else
                {
                    values4 = null;
                    Towel.Parallels.Parallel.Operation operation = () =>
                    {
                        values4 = new IndexedBigArray<Axis4>(additions.Length);
                        for (int i = 0; i < additions.Length; i++)
                            values4[i] = LocateVector(additions[i]).Axis4;
                        Towel.Algorithms.Sort.Merge(this._compare4, (int i) => { return values4[(ulong)i]; }, (int i, Axis4 value) => { values4[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
                    };

                    if (allowMultithreading)
                        result4 = Towel.Parallels.Parallel.Thread(operation);
                    else
                        operation();
                }

                // prepare data for median computations
                IndexedBigArray<Axis5> values5;
                IAsyncResult result5 = null;
                if (this._subdivisionOverride5 != null)
                    values5 = null;
                else
                {
                    values5 = null;
                    Towel.Parallels.Parallel.Operation operation = () =>
                    {
                        values5 = new IndexedBigArray<Axis5>(additions.Length);
                        for (int i = 0; i < additions.Length; i++)
                            values5[i] = LocateVector(additions[i]).Axis5;
                        Towel.Algorithms.Sort.Merge(this._compare5, (int i) => { return values5[(ulong)i]; }, (int i, Axis5 value) => { values5[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
                    };

                    if (allowMultithreading)
                        result5 = Towel.Parallels.Parallel.Thread(operation);
                    else
                        operation();
                }

                // prepare data for median computations
                IndexedBigArray<Axis6> values6;
                IAsyncResult result6 = null;
                if (this._subdivisionOverride6 != null)
                    values6 = null;
                else
                {
                    values6 = null;
                    Towel.Parallels.Parallel.Operation operation = () =>
                    {
                        values6 = new IndexedBigArray<Axis6>(additions.Length);
                        for (int i = 0; i < additions.Length; i++)
                            values6[i] = LocateVector(additions[i]).Axis6;
                        Towel.Algorithms.Sort.Merge(this._compare6, (int i) => { return values6[(ulong)i]; }, (int i, Axis6 value) => { values6[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
                    };

                    if (allowMultithreading)
                        result6 = Towel.Parallels.Parallel.Thread(operation);
                    else
                        operation();
                }



                if (this._subdivisionOverride1 == null && allowMultithreading)
                    result1.AsyncWaitHandle.WaitOne();

                if (this._subdivisionOverride2 == null && allowMultithreading)
                    result2.AsyncWaitHandle.WaitOne();

                if (this._subdivisionOverride3 == null && allowMultithreading)
                    result3.AsyncWaitHandle.WaitOne();

                if (this._subdivisionOverride4 == null && allowMultithreading)
                    result4.AsyncWaitHandle.WaitOne();

                if (this._subdivisionOverride5 == null && allowMultithreading)
                    result5.AsyncWaitHandle.WaitOne();

                if (this._subdivisionOverride6 == null && allowMultithreading)
                    result6.AsyncWaitHandle.WaitOne();


                // build the tree
                Add(new_top, 1, -1, additions.Stepper(), additions.Length, int.MinValue, int.MinValue, int.MinValue, int.MinValue, int.MinValue, int.MinValue, (int)additions.Length, (int index) => { return values1[index]; }, (int index) => { return values2[index]; }, (int index) => { return values3[index]; }, (int index) => { return values4[index]; }, (int index) => { return values5[index]; }, (int index) => { return values6[index]; }, allowMultithreading);
                
                this._top = new_top;
            }
        }

        
        private int Add(Branch parent, int depth, int child, Stepper<T> additions, int parent_count, int prevmed1, int prevmed2, int prevmed3, int prevmed4, int prevmed5, int prevmed6, int initial_count, Get<Axis1> values1, Get<Axis2> values2, Get<Axis3> values3, Get<Axis4> values4, Get<Axis5> values5, Get<Axis6> values6, bool allowMultithreading)
        {
            Axis1 pointOfDivision1;
            Axis2 pointOfDivision2;
            Axis3 pointOfDivision3;
            Axis4 pointOfDivision4;
            Axis5 pointOfDivision5;
            Axis6 pointOfDivision6;

            int median_axis1 = -1;
            int median_axis2 = -1;
            int median_axis3 = -1;
            int median_axis4 = -1;
            int median_axis5 = -1;
            int median_axis6 = -1;
            if (this._subdivisionOverride1 == null || this._subdivisionOverride2 == null || this._subdivisionOverride3 == null || this._subdivisionOverride4 == null || this._subdivisionOverride5 == null || this._subdivisionOverride6 == null)
                GetMedianIndexes(initial_count, child, depth, prevmed1, prevmed2, prevmed3, prevmed4, prevmed5, prevmed6, out median_axis1, out median_axis2, out median_axis3, out median_axis4, out median_axis5, out median_axis6);

            if (this._subdivisionOverride1 != null)
                pointOfDivision1 = this._subdivisionOverride1(parent.Bounds, additions);
            else
                pointOfDivision1 = values1(median_axis1);

            if (this._subdivisionOverride2 != null)
                pointOfDivision2 = this._subdivisionOverride2(parent.Bounds, additions);
            else
                pointOfDivision2 = values2(median_axis2);

            if (this._subdivisionOverride3 != null)
                pointOfDivision3 = this._subdivisionOverride3(parent.Bounds, additions);
            else
                pointOfDivision3 = values3(median_axis3);

            if (this._subdivisionOverride4 != null)
                pointOfDivision4 = this._subdivisionOverride4(parent.Bounds, additions);
            else
                pointOfDivision4 = values4(median_axis4);

            if (this._subdivisionOverride5 != null)
                pointOfDivision5 = this._subdivisionOverride5(parent.Bounds, additions);
            else
                pointOfDivision5 = values5(median_axis5);

            if (this._subdivisionOverride6 != null)
                pointOfDivision6 = this._subdivisionOverride6(parent.Bounds, additions);
            else
                pointOfDivision6 = values6(median_axis6);

            parent.PointOfDivision = new Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>(pointOfDivision1, pointOfDivision2, pointOfDivision3, pointOfDivision4, pointOfDivision5, pointOfDivision6);

            // divide the values along the medians
            IMap<IAddable<T>, int> collection_map = new MapHashLinked<IAddable<T>, int>();
            additions((T value) => 
            {
                int index = DetermineChildIndex(parent.PointOfDivision, LocateVector(value));
                IAddable<T> list = null;
                if (collection_map.TryGet(index, out list))
                {
                    list.Add(value);
                }
                else
                {
                    if (parent_count < 100000)
                        list = new AddableArray<T>();
                    else
                        list = new AddableLinked<T>();
                    collection_map.Add(index, list);
                    list.Add(value);
                }
            });

            if (depth == 1 && allowMultithreading)
            {
                // NOTE: Must assign placeholders before multithreading so that the threads do not overwrite each other
                collection_map.Keys((int key) => { parent[key] = new Leaf(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>.None, parent, key); });
                IAsyncResult[] handles = new IAsyncResult[Environment.ProcessorCount];
                for (int i = 0; i < handles.Length; i++)
                {
                    int multiTheadSafe_i = i; // used as catpure variable below making it multithread-safe
                    handles[i] = Towel.Parallels.Parallel.Thread(() =>
                    {
                        Step.EveryNth<Link<IAddable<T>, int>>(collection_map.Pairs, multiTheadSafe_i + 1)(
                        (Link<IAddable<T>, int> link) =>
                            {
                                ReversedChildBuilding(parent, link._2, depth, link._1.Stepper, link._1.Count, median_axis1, median_axis2, median_axis3, median_axis4, median_axis5, median_axis6, initial_count, values1, values2, values3, values4, values5, values6, allowMultithreading);
                            });
                    });
                }
                
                foreach (IAsyncResult handle in handles)
                {
                    handle.AsyncWaitHandle.WaitOne();
                }
            }
            else
            {
                collection_map.Pairs((Link<IAddable<T>, int> link) =>
                { 
                    ReversedChildBuilding(parent, link._2, depth, link._1.Stepper, link._1.Count, median_axis1, median_axis2, median_axis3, median_axis4, median_axis5, median_axis6, initial_count, values1, values2, values3, values4, values5, values6, allowMultithreading);
                });
            }

            int count = 0;
            foreach (Node node in parent.Children)
                count += node.Count;
            return count;
        }

        int ReversedChildBuilding(Branch parent, int child_index, int depth, Stepper<T> additions, int count, int prevmed1, int prevmed2, int prevmed3, int prevmed4, int prevmed5, int prevmed6, int initial_count, Get<Axis1> values1, Get<Axis2> values2, Get<Axis3> values3, Get<Axis4> values4, Get<Axis5> values5, Get<Axis6> values6, bool allowMultithreading)
        {
            Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> child_bounds = DetermineChildBounds(parent, child_index);
            if (depth >= _load || count <= _load)
            {
                Leaf new_leaf = new Leaf(child_bounds, parent, child_index);
                additions((T value) => { new_leaf.Add(value); });
                parent[new_leaf.Index] = new_leaf;
                return new_leaf.Count;
            }
            else
            {
                Branch new_branch = new Branch(Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>.Default, child_bounds, parent, child_index);
                parent[new_branch.Index] = new_branch;
                new_branch.Count = Add(new_branch, depth + 1, child_index, additions, count, prevmed1, prevmed2, prevmed3, prevmed4, prevmed5, prevmed6, count, values1, values2, values3, values4, values5, values6, allowMultithreading);
                return new_branch.Count;
            }
        }

        /// <summary>Gets the indeces of the median values at the given position during bulk additions.</summary>
        private void GetMedianIndexes(int count, int child_index, int depth, int previous1, int previous2, int previous3, int previous4, int previous5, int previous6, out int index1, out int index2, out int index3, out int index4, out int index5, out int index6)
        {
            if (depth == 1)
            {
                index1 = (count - 1) / 2;
                index2 = (count - 1) / 2;
                index3 = (count - 1) / 2;
                index4 = (count - 1) / 2;
                index5 = (count - 1) / 2;
                index6 = (count - 1) / 2;
                return;
            }

            int splits = Compute.Power(2, depth);
            int mid_child_range = count / splits;

            if (child_index >= 32)
            {
                index6 = previous6 + mid_child_range;
                child_index -= 32;
            }
            else
            {
                index6 = previous6 - mid_child_range;
            }

            if (child_index >= 16)
            {
                index5 = previous5 + mid_child_range;
                child_index -= 16;
            }
            else
            {
                index5 = previous5 - mid_child_range;
            }

            if (child_index >= 8)
            {
                index4 = previous4 + mid_child_range;
                child_index -= 8;
            }
            else
            {
                index4 = previous4 - mid_child_range;
            }

            if (child_index >= 4)
            {
                index3 = previous3 + mid_child_range;
                child_index -= 4;
            }
            else
            {
                index3 = previous3 - mid_child_range;
            }

            if (child_index >= 2)
            {
                index2 = previous2 + mid_child_range;
                child_index -= 2;
            }
            else
            {
                index2 = previous2 - mid_child_range;
            }

            if (child_index >= 1)
            {
                index1 = previous1 + mid_child_range;
                child_index -= 1;
            }
            else
            {
                index1 = previous1 - mid_child_range;
            }

        }

        #endregion

        #region single

        /// <summary>Adds an item to the tree.</summary>
        /// <param name="addition">The item to be added.</param>
        public void Add(T addition)
        {
            if (this._top.Count == int.MaxValue)
                throw new System.InvalidOperationException("(Count == int.MaxValue) max Omnitree size reached (change ints to longs if you need to).");

            // dynamic tree sizes
			Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);

            Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> location = LocateVector(addition);

            // grow the first branch of the tree
            if (this._top is Leaf && (this._top as Leaf).Count >= _load)
            {
                Leaf top = this._top as Leaf;

                // create the new branch from the median values
                this._top = new Branch(DetermineMedians(top), Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>.None, null, -1);

                // iterate through the elements and add them to the appropriate children
                for (Leaf.Node list = top.Head; list != null; list = list.Next)
                    Add(list.Value, this._top, LocateVector(list.Value), 0);
            }

            this.Add(addition, this._top, location, 0);
        }
        
        /// <summary>Recursive version of the add function.</summary>
        /// <param name="addition">The item to be added.</param>
        /// <param name="node">The current node for tree trversal.</param>
        /// <param name="ms">The location of the addition.</param>
        /// <param name="depth">The current depth of iteration.</param>
        private void Add(T addition, Node node, Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> location, int depth)
        {
            if (node is Leaf)
            {
                Leaf leaf = node as Leaf;
                if (depth >= _load || !(leaf.Count >= _load))
                {
                    leaf.Add(addition);
                    return;
                }
                else
                {
                    Branch parent = node.Parent;
                    int child_index = this.DetermineChildIndex(parent.PointOfDivision, location);
                    Branch growth = new Branch(DetermineMedians(leaf), leaf.Bounds, parent, child_index);
                    parent[child_index] = growth;
                    for (Leaf.Node list = leaf.Head; list != null; list = list.Next)
                    {
                        Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> temp_location = LocateVector(list.Value);
                        if (EncapsulationCheck(growth.Bounds, temp_location))
                            Add(list.Value, growth, temp_location, depth);
                        else
                        {
                            ReduceParentCounts(parent, 1);
                            Add(list.Value, this._top, temp_location, depth);
                        }
                    }

                    Add(addition, growth, location, depth);
                    return;
                }
            }
            else
            {
                Branch branch = node as Branch;
                int child_index = this.DetermineChildIndex(branch.PointOfDivision, location); // determine the child "index" (0 through 2^Dimensions) the addition belongs in
                Node child_node = branch[child_index];

                // null children in branches are just empty leaves
                if (child_node == null)
                {
                    Leaf new_leaf = new Leaf(DetermineChildBounds(branch, child_index), branch, child_index);
                    branch[child_index] = new_leaf;
                    new_leaf.Add(addition);
                }
                else
                    // child exists already, continue adding
                    Add(addition, child_node, location, depth + 1);

                branch.Count++;
                return;
            }
        }

        /// <summary>Determins the dimensions of the child at the given index.</summary>
        /// <param name="leaf">The parent of the node to compute dimensions for.</param>
        /// <param name="child">The index of the child to compute dimensions for.</param>
        /// <param name="median1">The computed minimum dimensions of the child node along the 1D axis.</param>
        /// <param name="median2">The computed minimum dimensions of the child node along the 2D axis.</param>
        /// <param name="median3">The computed minimum dimensions of the child node along the 3D axis.</param>
        private Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> DetermineMedians(Leaf leaf)
        {
            try
            {
                // extract the values
                Axis1[] values1 = new Axis1[leaf.Count];
                Axis2[] values2 = new Axis2[leaf.Count];
                Axis3[] values3 = new Axis3[leaf.Count];
                Axis4[] values4 = new Axis4[leaf.Count];
                Axis5[] values5 = new Axis5[leaf.Count];
                Axis6[] values6 = new Axis6[leaf.Count];
                Leaf.Node for_current = leaf.Head; // used in for loop
                for (int i = 0; i < leaf.Count; i++, for_current = for_current.Next)
                    this._locate(for_current.Value, out values1[i], out values2[i], out values3[i], out values4[i], out values5[i], out values6[i]);
                // sort the values
                if (_defaultCompare1) Array.Sort(values1);
                else Array.Sort(values1, Compare.ToSystemComparison(this._compare1));
                if (_defaultCompare2) Array.Sort(values2);
                else Array.Sort(values2, Compare.ToSystemComparison(this._compare2));
                if (_defaultCompare3) Array.Sort(values3);
                else Array.Sort(values3, Compare.ToSystemComparison(this._compare3));
                if (_defaultCompare4) Array.Sort(values4);
                else Array.Sort(values4, Compare.ToSystemComparison(this._compare4));
                if (_defaultCompare5) Array.Sort(values5);
                else Array.Sort(values5, Compare.ToSystemComparison(this._compare5));
                if (_defaultCompare6) Array.Sort(values6);
                else Array.Sort(values6, Compare.ToSystemComparison(this._compare6));
                // pull out the lazy medians (if even # of items... just take the left)
                int index = (leaf.Count - 1) / 2;
                return new Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>(values1[index], values2[index], values3[index], values4[index], values5[index], values6[index]);
            }
            catch (Exception exception)
            {
				System.Diagnostics.Debugger.Break();
                // extract the values
                IndexedBigArray<Axis1> values1 = new IndexedBigArray<Axis1>(leaf.Count);
                IndexedBigArray<Axis2> values2 = new IndexedBigArray<Axis2>(leaf.Count);
                IndexedBigArray<Axis3> values3 = new IndexedBigArray<Axis3>(leaf.Count);
                IndexedBigArray<Axis4> values4 = new IndexedBigArray<Axis4>(leaf.Count);
                IndexedBigArray<Axis5> values5 = new IndexedBigArray<Axis5>(leaf.Count);
                IndexedBigArray<Axis6> values6 = new IndexedBigArray<Axis6>(leaf.Count);
                Leaf.Node for_current = leaf.Head; // used in for loop
                for (int i = 0; i < leaf.Count; i++, for_current = for_current.Next)
                {
                    Axis1 value1;
                    Axis2 value2;
                    Axis3 value3;
                    Axis4 value4;
                    Axis5 value5;
                    Axis6 value6;
                    this._locate(for_current.Value, out value1, out value2, out value3, out value4, out value5, out value6);
                    values1[i] = value1;
                    values2[i] = value2;
                    values3[i] = value3;
                    values4[i] = value4;
                    values5[i] = value5;
                    values6[i] = value6;
                }
                // sort the values
                if (_defaultCompare1) Towel.Algorithms.Sort.Merge(Compare.Default, (int sorting_index) => { return values1[sorting_index]; }, (int sorting_index, Axis1 axis1) => { values1[sorting_index] = axis1; }, 0, (int)values1.Length);
                else Towel.Algorithms.Sort.Merge(_compare1, (int sorting_index) => { return values1[sorting_index]; }, (int sorting_index, Axis1 axis1) => { values1[sorting_index] = axis1; }, 0, (int)values1.Length);
                if (_defaultCompare2) Towel.Algorithms.Sort.Merge(Compare.Default, (int sorting_index) => { return values2[sorting_index]; }, (int sorting_index, Axis2 axis2) => { values2[sorting_index] = axis2; }, 0, (int)values1.Length);
                else Towel.Algorithms.Sort.Merge(_compare2, (int sorting_index) => { return values2[sorting_index]; }, (int sorting_index, Axis2 axis2) => { values2[sorting_index] = axis2; }, 0, (int)values1.Length);
                if (_defaultCompare3) Towel.Algorithms.Sort.Merge(Compare.Default, (int sorting_index) => { return values3[sorting_index]; }, (int sorting_index, Axis3 axis3) => { values3[sorting_index] = axis3; }, 0, (int)values1.Length);
                else Towel.Algorithms.Sort.Merge(_compare3, (int sorting_index) => { return values3[sorting_index]; }, (int sorting_index, Axis3 axis3) => { values3[sorting_index] = axis3; }, 0, (int)values1.Length);
                if (_defaultCompare4) Towel.Algorithms.Sort.Merge(Compare.Default, (int sorting_index) => { return values4[sorting_index]; }, (int sorting_index, Axis4 axis4) => { values4[sorting_index] = axis4; }, 0, (int)values1.Length);
                else Towel.Algorithms.Sort.Merge(_compare4, (int sorting_index) => { return values4[sorting_index]; }, (int sorting_index, Axis4 axis4) => { values4[sorting_index] = axis4; }, 0, (int)values1.Length);
                if (_defaultCompare5) Towel.Algorithms.Sort.Merge(Compare.Default, (int sorting_index) => { return values5[sorting_index]; }, (int sorting_index, Axis5 axis5) => { values5[sorting_index] = axis5; }, 0, (int)values1.Length);
                else Towel.Algorithms.Sort.Merge(_compare5, (int sorting_index) => { return values5[sorting_index]; }, (int sorting_index, Axis5 axis5) => { values5[sorting_index] = axis5; }, 0, (int)values1.Length);
                if (_defaultCompare6) Towel.Algorithms.Sort.Merge(Compare.Default, (int sorting_index) => { return values6[sorting_index]; }, (int sorting_index, Axis6 axis6) => { values6[sorting_index] = axis6; }, 0, (int)values1.Length);
                else Towel.Algorithms.Sort.Merge(_compare6, (int sorting_index) => { return values6[sorting_index]; }, (int sorting_index, Axis6 axis6) => { values6[sorting_index] = axis6; }, 0, (int)values1.Length);
                // pull out the lazy medians (if even # of items... just take the left)
                int index = (leaf.Count - 1) / 2;
                return new Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>(values1[index], values2[index], values3[index], values4[index], values5[index], values6[index]);
            }
        }

        #endregion

        #region Add Helpers

        private Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> DetermineChildBounds(Branch branch, int child_index)
        {

            Omnitree.Bound<Axis6> min6, max6;
            if (child_index >= 32)
            {
                min6 = branch.PointOfDivision.Axis6;
                max6 = branch.Bounds.Max6;
                child_index -= 32;
            }
            else
            {
                min6 = branch.Bounds.Min6;
                max6 = branch.PointOfDivision.Axis6;
            }

            Omnitree.Bound<Axis5> min5, max5;
            if (child_index >= 16)
            {
                min5 = branch.PointOfDivision.Axis5;
                max5 = branch.Bounds.Max5;
                child_index -= 16;
            }
            else
            {
                min5 = branch.Bounds.Min5;
                max5 = branch.PointOfDivision.Axis5;
            }

            Omnitree.Bound<Axis4> min4, max4;
            if (child_index >= 8)
            {
                min4 = branch.PointOfDivision.Axis4;
                max4 = branch.Bounds.Max4;
                child_index -= 8;
            }
            else
            {
                min4 = branch.Bounds.Min4;
                max4 = branch.PointOfDivision.Axis4;
            }

            Omnitree.Bound<Axis3> min3, max3;
            if (child_index >= 4)
            {
                min3 = branch.PointOfDivision.Axis3;
                max3 = branch.Bounds.Max3;
                child_index -= 4;
            }
            else
            {
                min3 = branch.Bounds.Min3;
                max3 = branch.PointOfDivision.Axis3;
            }

            Omnitree.Bound<Axis2> min2, max2;
            if (child_index >= 2)
            {
                min2 = branch.PointOfDivision.Axis2;
                max2 = branch.Bounds.Max2;
                child_index -= 2;
            }
            else
            {
                min2 = branch.Bounds.Min2;
                max2 = branch.PointOfDivision.Axis2;
            }

            Omnitree.Bound<Axis1> min1, max1;
            if (child_index >= 1)
            {
                min1 = branch.PointOfDivision.Axis1;
                max1 = branch.Bounds.Max1;
                child_index -= 1;
            }
            else
            {
                min1 = branch.Bounds.Min1;
                max1 = branch.PointOfDivision.Axis1;
            }

            return new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6);
        }

        #endregion

        #endregion

        #region Clear

        /// <summary>Returns the tree to an empty state.</summary>
        public void Clear()
        {
            this._top = new Leaf(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>.None, null, -1);
			Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
        }

        #endregion

        #region Clone

        /// <summary>Creates a shallow clone of this data structure.</summary>
        /// <returns>A shallow clone of this data structure.</returns>
        public OmnitreePointsLinked<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> Clone()
        {
            return new OmnitreePointsLinked<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>(this);
        }

        #endregion

        #region Count

        /// <summary>Counts the number of items in a sub space.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
        /// <returns>The number of items in the provided sub space.</returns>
        public int CountSubSpace(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5, Axis6 min6, Axis6 max6)
        {
            return CountSubSpace(_top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6));
        }
        /// <summary>Counts the number of items in a sub space.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
        /// <returns>The number of items in the provided sub space.</returns>
        public int CountSubSpace(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5, Omnitree.Bound<Axis6> min6, Omnitree.Bound<Axis6> max6)
        {
            return CountSubSpace(_top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6));
        }
        /// <summary>Counts the number of items in a sub space.</summary>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
		/// <param name="axis5">The coordinate along the 5D axis.</param>
		/// <param name="axis6">The coordinate along the 6D axis.</param>
        /// <returns>The number of items in the provided sub space.</returns>
        public int CountSubSpace(Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Axis5 axis5, Axis6 axis6)
        {
            return CountSubSpace(_top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>(axis1, axis1, axis2, axis2, axis3, axis3, axis4, axis4, axis5, axis5, axis6, axis6));
        }
        /// <summary>Counts the number of items in a sub space.</summary>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
		/// <param name="axis5">The coordinate along the 5D axis.</param>
		/// <param name="axis6">The coordinate along the 6D axis.</param>
        /// <returns>The number of items in the provided sub space.</returns>
        public int CountSubSpace(Omnitree.Bound<Axis1> axis1, Omnitree.Bound<Axis2> axis2, Omnitree.Bound<Axis3> axis3, Omnitree.Bound<Axis4> axis4, Omnitree.Bound<Axis5> axis5, Omnitree.Bound<Axis6> axis6)
        {
            return CountSubSpace(_top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>(axis1, axis1, axis2, axis2, axis3, axis3, axis4, axis4, axis5, axis5, axis6, axis6));
        }
        /// <summary>Counts the number of items in a sub space.</summary>
        /// <param name="node">The current traversal node.</param>
        /// <returns>The number of items in the provided sub space.</returns>
        private int CountSubSpace(Node node, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> bounds)
        {
            // adjust min/max values
            int count = 0;
            if (EncapsulationCheck(bounds, node.Bounds))
                count += node.Count;
            else if (node is Leaf)
            {
                for (Leaf.Node list = (node as Leaf).Head; list != null; list = list.Next)
                    if (EncapsulationCheck(bounds, LocateVector(list.Value)))
                        count++;
            }
            else
            {
                Branch branch = node as Branch;
                if (!StraddlesLines(branch.Bounds, branch.PointOfDivision))
                {
                    int child_index = DetermineChildIndex(branch.PointOfDivision, new Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>(bounds.Min1.Value, bounds.Min2.Value, bounds.Min3.Value, bounds.Min4.Value, bounds.Min5.Value, bounds.Min6.Value));
                    Node child = branch[child_index];
                    if (child != null)
                      count += this.CountSubSpace(child, bounds);
                }
                else
                {
                    foreach (Node child in (node as Branch).Children)
                        count += this.CountSubSpace(child, bounds);
                }
            }
            return count;
        }

        #endregion

        #region Update

        /// <summary>Iterates through the entire tree and ensures each item is in the proper leaf.</summary>
        public void Update()
        {
            this.Update(this._top, 0);
        }

        /// <summary>Recursive version of the Update method.</summary>
        /// <param name="node">The current node of iteration.</param>
        /// <param name="depth">The current depth of iteration.</param>
        private int Update(Node node, int depth)
        {
            int removals = 0;

            if (node is Leaf)
            {
                Leaf leaf = node as Leaf;
                Leaf.Node current = leaf.Head;
                Leaf.Node previous = null;
                while (current != null)
                {
                    Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> location = LocateVector(current.Value);
                    if (!this.EncapsulationCheck(node.Bounds, location))
                    {
                        removals++;
                        T updated = current.Value;
                        if (previous == null)
                        {
                            leaf.Head = current.Next;
                            goto HeadRemoved;
                        }
                        else
                            previous.Next = current.Next;

                        Node whereToAdd = GetEncapsulationParent(node.Parent, location);

                        if (whereToAdd == null)
                            throw new System.Exception("an item was updated outside the range of the omnitree");

                        this.Add(updated, whereToAdd, location, whereToAdd.Depth);
                    }
                    previous = current;
                HeadRemoved:
                    current = current.Next;
                }
                leaf.Count -= removals;
                return removals;
            }
            else
            {
                Branch branch = node as Branch;
                int skipped = 0;
                for (int i = 0; i + skipped < branch.Children.Length; )
                {
                    removals += this.Update(branch.Children[i], depth + 1);
                    if (branch.Children[i].Count == 0)
                        branch.Children[i] = branch.Children[branch.Children.Length - skipped++ - 1];
                    else
                        i++;
                }
                Node[] newArray = new Node[branch.Children.Length - skipped];
                Array.Copy(branch.Children, newArray, newArray.Length);
                branch.Children = newArray;

                branch.Count -= removals;

                if (branch.Count < _load && branch.Count != 0)
                    ShrinkChild(branch.Parent, branch.Index);
            }

            return removals;
        }

        /// <summary>Iterates through the provided dimensions and ensures each item is in the proper leaf.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
        public void Update(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5, Axis6 min6, Axis6 max6)
        {
            this.Update(new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6), this._top, 0);
        }
        /// <summary>Iterates through the provided dimensions and ensures each item is in the proper leaf.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
        public void Update(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5, Omnitree.Bound<Axis6> min6, Omnitree.Bound<Axis6> max6)
        {
            this.Update(new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6), this._top, 0);
        }
        /// <summary>Iterates through the provided dimensions and ensures each item is in the proper leaf.</summary>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
		/// <param name="axis5">The coordinate along the 5D axis.</param>
		/// <param name="axis6">The coordinate along the 6D axis.</param>
        public void Update(Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Axis5 axis5, Axis6 axis6)
        {
            this.Update(new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>(axis1, axis1, axis2, axis2, axis3, axis3, axis4, axis4, axis5, axis5, axis6, axis6), this._top, 0);
        }
        /// <summary>Iterates through the provided dimensions and ensures each item is in the proper leaf.</summary>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
		/// <param name="axis5">The coordinate along the 5D axis.</param>
		/// <param name="axis6">The coordinate along the 6D axis.</param>
        public void Update(Omnitree.Bound<Axis1> axis1, Omnitree.Bound<Axis2> axis2, Omnitree.Bound<Axis3> axis3, Omnitree.Bound<Axis4> axis4, Omnitree.Bound<Axis5> axis5, Omnitree.Bound<Axis6> axis6)
        {
            this.Update(new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>(axis1, axis1, axis2, axis2, axis3, axis3, axis4, axis4, axis5, axis5, axis6, axis6), this._top, 0);
        }
        private int Update(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> bounds, Node node, int depth)
        {
            if (!InclusionCheck(bounds, node.Bounds))
                return 0;

            int removals = 0;

            if (node is Leaf)
            {
                Leaf leaf = node as Leaf;
                Leaf.Node current = leaf.Head;
                Leaf.Node previous = null;
                while (current != null)
                {
                    Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> location = LocateVector(current.Value);
                    if (!this.EncapsulationCheck(node.Bounds, location))
                    {
                        removals++;
                        T updated = current.Value;
                        if (previous == null)
                        {
                            leaf.Head = current.Next;
                            goto HeadRemoved;
                        }
                        else
                            previous.Next = current.Next;
                        Node whereToAdd = GetEncapsulationParent(node.Parent, location);
                        if (whereToAdd == null)
                            throw new System.Exception("an item was updates outside the range of the omnitree");
                        this.Add(updated, whereToAdd, location, whereToAdd.Depth);
                    }
                    previous = current;
                HeadRemoved:
                    current = current.Next;
                }
                leaf.Count -= removals;
                return removals;
            }
            else
            {
                Branch branch = node as Branch;
                int skipped = 0;
                for (int i = 0; i + skipped < branch.Children.Length; )
                {
                    removals += this.Update(branch.Children[i], depth + 1);
                    if (branch.Children[i].Count == 0)
                        branch.Children[i] = branch.Children[branch.Children.Length - skipped++ - 1];
                    else
                        i++;
                }
                Node[] newArray = new Node[branch.Children.Length - skipped];
                Array.Copy(branch.Children, newArray, newArray.Length);
                branch.Children = newArray;

                branch.Count -= removals;

                if (branch.Count < _load && branch.Count != 0)
                    ShrinkChild(branch.Parent, branch.Index);
            }

            return removals;
        }

        #endregion

        #region Remove

        /// <summary>Removes all the items qualified by the delegate.</summary>
        /// <param name="where">The predicate to qualify removals.</param>
        public void Remove(Predicate<T> where)
        {
            this.Remove(this._top, where);
			Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
        }

        /// <summary>Recursive version of the remove method.</summary>
        /// <param name="node">The current node of traversal.</param>
        /// <param name="where">The predicate to qualify removals.</param>
        private int Remove(Node node, Predicate<T> where)
        {
            int removals = 0;
            if (node is Leaf)
            {
                Leaf leaf = node as Leaf;
                while (leaf.Head != null && where(leaf.Head.Value))
                {
                    leaf.Head = leaf.Head.Next;
                    removals++;
                }
                if (leaf.Head != null)
                {
                    Leaf.Node list = leaf.Head;
                    while (list.Next != null)
                    {
                        if (where(list.Next.Value))
                        {
                            list.Next = list.Next.Next;
                            removals++;
                        }
                    }
                }

                leaf.Count -= removals;
                return removals;
            }
            else
            {
                Branch branch = node as Branch;
                int skipped = 0;
                for (int i = 0; i + skipped < branch.Children.Length; )
                {
                    removals += this.Remove(branch.Children[i], where);
                    if (branch.Children[i].Count == 0)
                        branch.Children[i] = branch.Children[branch.Children.Length - skipped++ - 1];
                    else
                        i++;
                }
                Node[] newArray = new Node[branch.Children.Length - skipped];
                Array.Copy(branch.Children, newArray, newArray.Length);
                branch.Children = newArray;

                branch.Count -= removals;

                if (branch.Count < _load && branch.Count != 0)
                    ShrinkChild(branch.Parent, branch.Index);

                return removals;
            }
        }

        /// <summary>Removes all the items in a given space.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
        /// <returns>The number of items that were removed.</returns>
        public void Remove(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5, Axis6 min6, Axis6 max6)
        {
            this.Remove(this._top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6));
            Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
        }
        /// <summary>Removes all the items in a given space.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
        /// <returns>The number of items that were removed.</returns>
        public void Remove(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5, Omnitree.Bound<Axis6> min6, Omnitree.Bound<Axis6> max6)
        {
            this.Remove(this._top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6));
            Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
        }
        private int Remove(Node node, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> bounds)
        {
            int removals = 0;
            if (InclusionCheck(bounds, node.Bounds))
            {
                if (node is Leaf)
                {
                    Leaf leaf = node as Leaf;
                    Leaf.Node current_node = leaf.Head;
                    Leaf.Node previous_node = null;
                    while (current_node != null)
                    {
                        Leaf.Node temp_previous = current_node;
                        if (EncapsulationCheck(bounds, LocateVector(current_node.Value)))
                        {
                            removals++;
                            if (current_node == leaf.Head)
                                leaf.Head = leaf.Head.Next;
                            else
                            {
                                previous_node.Next = current_node.Next;
                                temp_previous = previous_node;
                            }
                        }
                        previous_node = temp_previous;
                        current_node = current_node.Next;
                    }
                    leaf.Count -= removals;
                }
                else
                {
                    Branch branch = node as Branch;
                    int skipped = 0;
                    for (int i = 0; i + skipped < branch.Children.Length; )
                    {
                        removals += this.Remove(branch.Children[i], bounds);
                        if (branch.Children[i].Count == 0)
                            branch.Children[i] = branch.Children[branch.Children.Length - skipped++ - 1];
                        else
                            i++;
                    }
                    Node[] newArray = new Node[branch.Children.Length - skipped];
                    Array.Copy(branch.Children, newArray, newArray.Length);
                    branch.Children = newArray;

                    branch.Count -= removals;
                    // convert this branch back into a leaf
                    // Note: if count is zero, it will be chopped off
                    if (branch.Count < _load && branch.Count > 0)
                        ShrinkChild(branch.Parent, branch.Index);
                }
            }

            return removals;
        }

        /// <summary>Removes all the items in a given space validated by a predicate.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
        /// <param name="where">The equality constraint of the removal.</param>
        public void Remove(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5, Axis6 min6, Axis6 max6, Predicate<T> where)
        {
            this.Remove(this._top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6), where);
            Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
        }
        /// <summary>Removes all the items in a given space validated by a predicate.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
        /// <param name="where">The equality constraint of the removal.</param>
        public void Remove(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5, Omnitree.Bound<Axis6> min6, Omnitree.Bound<Axis6> max6, Predicate<T> where)
        {
            this.Remove(this._top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6), where);
			Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
        }
        private int Remove(Node node, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> bounds, Predicate<T> where)
        {
            if (!InclusionCheck(node.Bounds, bounds))
                return 0;
            int removals = 0;
            if (node is Leaf)
            {
                Leaf leaf = node as Leaf;
                Leaf.Node current = leaf.Head;
                Leaf.Node previous = null;
                while (current != null)
                {
                    if (this.EncapsulationCheck(bounds, LocateVector(current.Value)) && where(current.Value))
                    {
                        removals++;
                        if (previous == null)
                        {
                            leaf.Head = current.Next;
                            goto HeadRemoved;
                        }
                        else
                            previous.Next = current.Next;
                    }
                    previous = current;
                HeadRemoved:
                    current = current.Next;
                }

                leaf.Count -= removals;
                return removals;
            }
            else
            {
                Branch branch = node as Branch;
                int skipped = 0;
                for (int i = 0; i + skipped < branch.Children.Length; )
                {
                    removals += this.Remove(branch.Children[i], bounds, where);
                    if (branch.Children[i].Count == 0)
                        branch.Children[i] = branch.Children[branch.Children.Length - skipped++ - 1];
                    else
                        i++;
                }
                Node[] newArray = new Node[branch.Children.Length - skipped];
                Array.Copy(branch.Children, newArray, newArray.Length);
                branch.Children = newArray;

                node.Count -= removals;

                if (node.Count < _load && node.Count != 0)
                    ShrinkChild(node.Parent, node.Index);

                return removals;
            }
        }

        /// <summary>Removes all instances of a given value.</summary>
        public void Remove(T removal)
        {
            Axis1 axis1;
            Axis2 axis2;
            Axis3 axis3;
            Axis4 axis4;
            Axis5 axis5;
            Axis6 axis6;
            this._locate(removal, out axis1, out axis2, out axis3, out axis4, out axis5, out axis6);
            this.Remove(axis1, axis2, axis3, axis4, axis5, axis6, (T item) => { return this._equate(item, removal); });
        }
        /// <summary>Removes all the items in a given space.</summary>
        /// <param name="axis1">The axis of the removal along the  1D axis.</param>
		/// <param name="axis2">The axis of the removal along the  2D axis.</param>
		/// <param name="axis3">The axis of the removal along the  3D axis.</param>
		/// <param name="axis4">The axis of the removal along the  4D axis.</param>
		/// <param name="axis5">The axis of the removal along the  5D axis.</param>
		/// <param name="axis6">The axis of the removal along the  6D axis.</param>
        /// <returns>The number of items that were removed.</returns>
        public void Remove(Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Axis5 axis5, Axis6 axis6)
        {
            this.Remove(this._top, new Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>(axis1, axis2, axis3, axis4, axis5, axis6));
            Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
        }
        private int Remove(Node node, Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> vector)
        {
            int removals = 0;
            if (node is Leaf)
            {
                Leaf leaf = node as Leaf;
                Leaf.Node current_node = leaf.Head;
                Leaf.Node previous_node = null;
                while (current_node != null)
                {
                    Leaf.Node temp_previous = current_node;
                    if (EqualsCheck(vector, LocateVector(current_node.Value)))
                    {
                        removals++;
                        if (current_node == leaf.Head)
                            leaf.Head = leaf.Head.Next;
                        else
                        {
                            previous_node.Next = current_node.Next;
                            temp_previous = previous_node;
                        }
                    }
                    previous_node = temp_previous;
                    current_node = current_node.Next;
                }
                leaf.Count -= removals;
            }
            else
            {
                Branch branch = node as Branch;
                int child_index = DetermineChildIndex(branch.PointOfDivision, vector);
                removals += Remove(branch[child_index], vector);
                branch.Count -= removals;
                // convert this branch back into a leaf
                // Note: if count is zero, it will be chopped off
                if (branch.Count < _load && branch.Count > 0)
                    ShrinkChild(branch.Parent, branch.Index);
            }

            return removals;
        }

        /// <summary>Removes all the items in a given space validated by a predicate.</summary>
        /// <param name="axis1">The axis of the removal along the  1D axis.</param>
		/// <param name="axis2">The axis of the removal along the  2D axis.</param>
		/// <param name="axis3">The axis of the removal along the  3D axis.</param>
		/// <param name="axis4">The axis of the removal along the  4D axis.</param>
		/// <param name="axis5">The axis of the removal along the  5D axis.</param>
		/// <param name="axis6">The axis of the removal along the  6D axis.</param>
        /// <param name="where">The equality constraint of the removal.</param>
        public void Remove(Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Axis5 axis5, Axis6 axis6, Predicate<T> where)
        {
            this.Remove(this._top, new Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>(axis1, axis2, axis3, axis4, axis5, axis6), where);
            Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
        }
        private int Remove(Node node, Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> vector, Predicate<T> where)
        {
            int removals = 0;
            if (node is Leaf)
            {
                Leaf leaf = node as Leaf;
                Leaf.Node current_node = leaf.Head;
                Leaf.Node previous_node = null;
                while (current_node != null)
                {
                    Leaf.Node temp_previous = current_node;
                    if (EqualsCheck(vector, LocateVector(current_node.Value)) && where(current_node.Value))
                    {
                        removals++;
                        if (current_node == leaf.Head)
                            leaf.Head = leaf.Head.Next;
                        else
                        {
                            previous_node.Next = current_node.Next;
                            temp_previous = previous_node;
                        }
                    }
                    previous_node = temp_previous;
                    current_node = current_node.Next;
                }
                leaf.Count -= removals;
            }
            else
            {
                Branch branch = node as Branch;
                int child_index = DetermineChildIndex(branch.PointOfDivision, vector);
                removals += Remove(branch[child_index], vector, where);
                branch.Count -= removals;
                // convert this branch back into a leaf
                // Note: if count is zero, it will be chopped off
                if (branch.Count < _load && branch.Count > 0)
                    ShrinkChild(branch.Parent, branch.Index);
            }
            return removals;
        }

        #endregion

        #region Stepper And IEnumerable

        /// <summary>Traverses every item in the tree and performs the delegate in them.</summary>
        /// <param name="function">The delegate to perform on every item in the tree.</param>
        public void Stepper(Step<T> function)
        {
            this.Stepper(function, this._top);
        }
        private void Stepper(Step<T> function, Node node)
        {
            if (node is Leaf)
            {
                Leaf.Node list = (node as Leaf).Head;
                while (list != null)
                {
                    function(list.Value);
                    list = list.Next;
                }
            }
            else
            {
                foreach (Node child in (node as Branch).Children)
                    this.Stepper(function, child);
            }
        }

        /// <summary>Traverses every item in the tree and performs the delegate in them.</summary>
        /// <param name="function">The delegate to perform on every item in the tree.</param>
        public StepStatus Stepper(StepBreak<T> function)
        {
            return Stepper(function, _top);
        }
        private StepStatus Stepper(StepBreak<T> function, Node node)
        {
            StepStatus status = StepStatus.Continue;
            if (node is Leaf)
            {
                for (Leaf.Node list = (node as Leaf).Head; list != null; list = list.Next)
                    if ((status = function(list._value)) != StepStatus.Continue)
                        break;
            }
            else
            {
                foreach (Node child in (node as Branch).Children)
                    if ((status = Stepper(function, child)) != StepStatus.Continue)
                        break;
            }
            return status;
        }

        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="function">The delegate to perform on all items in the tree within the given bounds.</param>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
        public void Stepper(Step<T> function, Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5, Axis6 min6, Axis6 max6)
        {
            Stepper(function, _top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6));
        }
        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="function">The delegate to perform on all items in the tree within the given bounds.</param>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
        public void Stepper(Step<T> function, Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5, Omnitree.Bound<Axis6> min6, Omnitree.Bound<Axis6> max6)
        {
            Stepper(function, _top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6));
        }
        private void Stepper(Step<T> function, Node node, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> bounds)
        {
            if (node is Leaf)
            {
                for (Leaf.Node list = (node as Leaf).Head; list != null; list = list.Next)
                    if (EncapsulationCheck(bounds, LocateVector(list.Value)))
                        function(list.Value);
            }
            else
            {
                foreach (Node child in (node as Branch).Children)
                    // optimization: stop bounds checking if space encapsulates node
                    if (EncapsulationCheck(bounds, child.Bounds))
                        this.Stepper(function, child);
                    else if (InclusionCheck(child.Bounds, bounds))
                        this.Stepper(function, child, bounds);
            }
        }

        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
        public StepStatus Stepper(StepBreak<T> function, Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5, Axis6 min6, Axis6 max6)
        {
            return Stepper(function, _top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6));
        }
        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
        public StepStatus Stepper(StepBreak<T> function, Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5, Omnitree.Bound<Axis6> min6, Omnitree.Bound<Axis6> max6)
        {
            return Stepper(function, _top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6));
        }
        private StepStatus Stepper(StepBreak<T> function, Node node, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> bounds)
        {
            StepStatus status = StepStatus.Continue;
            if (node is Leaf)
            {
                for (Leaf.Node list = (node as Leaf).Head; list != null; list = list.Next)
                    if (EncapsulationCheck(bounds, LocateVector(list.Value)) &&
                        (status = function(list.Value)) != StepStatus.Continue)
                        break;
            }
            else
            {
                foreach (Node child in (node as Branch).Children)
                    // optimization: stop bounds checking if space encapsulates node
                    if (EncapsulationCheck(bounds, child.Bounds) &&
                        (status = this.Stepper(function, child)) != StepStatus.Continue)
                        break;
                    else if (!InclusionCheck(child.Bounds, bounds) &&
                        (status = this.Stepper(function, child, bounds)) != StepStatus.Continue)
                        break;
            }
            return status;
        }

        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="axis1">The axis of the removal along the  1D axis.</param>
		/// <param name="axis2">The axis of the removal along the  2D axis.</param>
		/// <param name="axis3">The axis of the removal along the  3D axis.</param>
		/// <param name="axis4">The axis of the removal along the  4D axis.</param>
		/// <param name="axis5">The axis of the removal along the  5D axis.</param>
		/// <param name="axis6">The axis of the removal along the  6D axis.</param>
        public void Stepper(Step<T> function, Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Axis5 axis5, Axis6 axis6)
        {
            Stepper(function, _top, new Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>(axis1, axis2, axis3, axis4, axis5, axis6));
        }
        private void Stepper(Step<T> function, Node node, Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> vector)
        {
            Node current = node;
            while (current != null)
            {
                if (current is Leaf)
                {
                    for (Leaf.Node leaf_node = (current as Leaf).Head; leaf_node != null; leaf_node = leaf_node.Next)
                        if (EqualsCheck(vector, LocateVector(leaf_node.Value)))
                            function(leaf_node.Value);
                    break;
                }
                else
                {
                    Branch branch = current as Branch;
                    int child_index = DetermineChildIndex(branch.PointOfDivision, vector);
                    current = branch[child_index];
                }
            }
        }

        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="function">The delegate to perform on all items in the tree within the given bounds.</param>
        /// <param name="axis1">The axis of the removal along the  1D axis.</param>
		/// <param name="axis2">The axis of the removal along the  2D axis.</param>
		/// <param name="axis3">The axis of the removal along the  3D axis.</param>
		/// <param name="axis4">The axis of the removal along the  4D axis.</param>
		/// <param name="axis5">The axis of the removal along the  5D axis.</param>
		/// <param name="axis6">The axis of the removal along the  6D axis.</param>
        public StepStatus Stepper(StepBreak<T> function, Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Axis5 axis5, Axis6 axis6)
        {
            return Stepper(function, _top, new Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>(axis1, axis2, axis3, axis4, axis5, axis6));
        }
        private StepStatus Stepper(StepBreak<T> function, Node node, Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> vector)
        {
            Node current = node;
            while (current != null)
            {
                if (current is Leaf)
                {
                    for (Leaf.Node list = (current as Leaf).Head; list != null; list = list.Next)
                    {
                        StepStatus status = StepStatus.Continue;
                        if (EqualsCheck(vector, LocateVector(list.Value)) &&
                            (status = function(list.Value)) != StepStatus.Continue)
                            return status;
                    }
                }
                else
                {
                    Branch branch = current as Branch;
                    int child_index = DetermineChildIndex(branch.PointOfDivision, vector);
                    current = branch[child_index];
                }
            }
            return StepStatus.Continue;
        }

        /// <summary>FOR COMPATIBILITY ONLY. AVOID IF POSSIBLE.</summary>
        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
        {
            throw new System.NotImplementedException();
            //return (this.ToArray() as System.Collections.Generic.IEnumerable<T>).GetEnumerator();
        }

        /// <summary>FOR COMPATIBILITY ONLY. AVOID IF POSSIBLE.</summary>
        System.Collections.Generic.IEnumerator<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator()
        {
            throw new System.NotImplementedException();
            //return (this.ToArray() as System.Collections.Generic.IEnumerable<T>).GetEnumerator();
        }

        #endregion

        #region Helpers

        private bool StraddlesLines(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> bounds, Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> vector)
        {
			if ((!bounds.Min1.Exists || (bounds.Min1.Exists && this._compare1(bounds.Min1.Value, vector.Axis1) != Comparison.Greater)) &&
				(!bounds.Max1.Exists || (bounds.Max1.Exists && this._compare1(bounds.Max1.Value, vector.Axis1) != Comparison.Less)))
				return true;
			if ((!bounds.Min2.Exists || (bounds.Min2.Exists && this._compare2(bounds.Min2.Value, vector.Axis2) != Comparison.Greater)) &&
				(!bounds.Max2.Exists || (bounds.Max2.Exists && this._compare2(bounds.Max2.Value, vector.Axis2) != Comparison.Less)))
				return true;
			if ((!bounds.Min3.Exists || (bounds.Min3.Exists && this._compare3(bounds.Min3.Value, vector.Axis3) != Comparison.Greater)) &&
				(!bounds.Max3.Exists || (bounds.Max3.Exists && this._compare3(bounds.Max3.Value, vector.Axis3) != Comparison.Less)))
				return true;
			if ((!bounds.Min4.Exists || (bounds.Min4.Exists && this._compare4(bounds.Min4.Value, vector.Axis4) != Comparison.Greater)) &&
				(!bounds.Max4.Exists || (bounds.Max4.Exists && this._compare4(bounds.Max4.Value, vector.Axis4) != Comparison.Less)))
				return true;
			if ((!bounds.Min5.Exists || (bounds.Min5.Exists && this._compare5(bounds.Min5.Value, vector.Axis5) != Comparison.Greater)) &&
				(!bounds.Max5.Exists || (bounds.Max5.Exists && this._compare5(bounds.Max5.Value, vector.Axis5) != Comparison.Less)))
				return true;
			if ((!bounds.Min6.Exists || (bounds.Min6.Exists && this._compare6(bounds.Min6.Value, vector.Axis6) != Comparison.Greater)) &&
				(!bounds.Max6.Exists || (bounds.Max6.Exists && this._compare6(bounds.Max6.Value, vector.Axis6) != Comparison.Less)))
				return true;
            return false;
        }

        /// <summary>Computes the child index that contains the desired dimensions.</summary>
        /// <param name="node">The branch .</param>
        /// <param name="vector">The dimensions to determine the child index.</param>
        /// <returns>The computed child index based on the coordinates relative to the center of the node.</returns>
        private int DetermineChildIndex(Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> pointOfDivision, Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> vector)
        {
            int child = 0;
            if (!(this._compare1(vector.Axis1, pointOfDivision.Axis1) == Comparison.Less))
                child += 1 << 0;
            if (!(this._compare2(vector.Axis2, pointOfDivision.Axis2) == Comparison.Less))
                child += 1 << 1;
            if (!(this._compare3(vector.Axis3, pointOfDivision.Axis3) == Comparison.Less))
                child += 1 << 2;
            if (!(this._compare4(vector.Axis4, pointOfDivision.Axis4) == Comparison.Less))
                child += 1 << 3;
            if (!(this._compare5(vector.Axis5, pointOfDivision.Axis5) == Comparison.Less))
                child += 1 << 4;
            if (!(this._compare6(vector.Axis6, pointOfDivision.Axis6) == Comparison.Less))
                child += 1 << 5;
            return child;
        }

        /// <summary>Converts a branch back into a leaf when the count is reduced.</summary>
        /// <param name="parent">The parent to shrink a child of.</param>
        /// <param name="child">The index of the child to shrink.</param>
        private void ShrinkChild(Branch parent, int child_index)
        {
            Leaf leaf;
            Node removal = null;
            if (parent == null) // top of tree
            {
                removal = this._top;
                leaf = new Leaf(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>.None, null, -1);
                this._top = leaf;
            }
            else // non-top branch
            {
                removal = parent[child_index];
                leaf = new Leaf(removal.Bounds, removal.Parent, removal.Index);
                parent[child_index] = leaf;
            }

            this.Stepper((T step) => { leaf.Add(step); }, removal);
        }

        /// <summary>Reduces the counts of all the parents of a given node by a given amount.</summary>
        /// <param name="parent">The starting parent of the reduction.</param>
        /// <param name="reduction">The amount to reduce the parent counts by.</param>
        private void ReduceParentCounts(Node parent, int reduction)
        {
            IncreaseParentCounts(parent, -reduction);
        }

        /// <summary>Increases the counts of all the parents of a given node by a given amount.</summary>
        /// <param name="parent">The starting parent of the increase.</param>
        /// <param name="increase">The amount to increase the parent counts by.</param>
        private void IncreaseParentCounts(Node parent, int increase)
        {
            Node looper = parent;
            while (looper != null)
            {
                looper.Count += increase;
                looper = looper.Parent;
            }
        }

        /// <summary>Checks a node for inclusion (overlap) between two bounds.</summary>
        /// <returns>True if the spaces overlap; False if not.</returns>
        private bool InclusionCheck(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> a, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> b)
        {

            if (a.Max1.Exists && b.Min1.Exists && this._compare1(a.Max1.Value, b.Min1.Value) == Comparison.Less)
                return false;
            else if (a.Min1.Exists && b.Max1.Exists && this._compare1(a.Min1.Value, b.Max1.Value) == Comparison.Greater)
                return false;

            if (a.Max2.Exists && b.Min2.Exists && this._compare2(a.Max2.Value, b.Min2.Value) == Comparison.Less)
                return false;
            else if (a.Min2.Exists && b.Max2.Exists && this._compare2(a.Min2.Value, b.Max2.Value) == Comparison.Greater)
                return false;

            if (a.Max3.Exists && b.Min3.Exists && this._compare3(a.Max3.Value, b.Min3.Value) == Comparison.Less)
                return false;
            else if (a.Min3.Exists && b.Max3.Exists && this._compare3(a.Min3.Value, b.Max3.Value) == Comparison.Greater)
                return false;

            if (a.Max4.Exists && b.Min4.Exists && this._compare4(a.Max4.Value, b.Min4.Value) == Comparison.Less)
                return false;
            else if (a.Min4.Exists && b.Max4.Exists && this._compare4(a.Min4.Value, b.Max4.Value) == Comparison.Greater)
                return false;

            if (a.Max5.Exists && b.Min5.Exists && this._compare5(a.Max5.Value, b.Min5.Value) == Comparison.Less)
                return false;
            else if (a.Min5.Exists && b.Max5.Exists && this._compare5(a.Min5.Value, b.Max5.Value) == Comparison.Greater)
                return false;

            if (a.Max6.Exists && b.Min6.Exists && this._compare6(a.Max6.Value, b.Min6.Value) == Comparison.Less)
                return false;
            else if (a.Min6.Exists && b.Max6.Exists && this._compare6(a.Min6.Value, b.Max6.Value) == Comparison.Greater)
                return false;

            return true;
        }

        /// <summary>Checks if a space encapsulates a point.</summary>
        /// <returns>True if the space encapsulates the point; False if not.</returns>
        private bool EncapsulationCheck(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> bounds, Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> vector)
        {
            // if the location is not outside the bounds, it must be inside

            if (bounds.Min1.Exists && this._compare1(vector.Axis1, bounds.Min1.Value) == Comparison.Less)
                return false;
            else if (bounds.Max1.Exists && this._compare1(vector.Axis1, bounds.Max1.Value) == Comparison.Greater)
                return false;

            if (bounds.Min2.Exists && this._compare2(vector.Axis2, bounds.Min2.Value) == Comparison.Less)
                return false;
            else if (bounds.Max2.Exists && this._compare2(vector.Axis2, bounds.Max2.Value) == Comparison.Greater)
                return false;

            if (bounds.Min3.Exists && this._compare3(vector.Axis3, bounds.Min3.Value) == Comparison.Less)
                return false;
            else if (bounds.Max3.Exists && this._compare3(vector.Axis3, bounds.Max3.Value) == Comparison.Greater)
                return false;

            if (bounds.Min4.Exists && this._compare4(vector.Axis4, bounds.Min4.Value) == Comparison.Less)
                return false;
            else if (bounds.Max4.Exists && this._compare4(vector.Axis4, bounds.Max4.Value) == Comparison.Greater)
                return false;

            if (bounds.Min5.Exists && this._compare5(vector.Axis5, bounds.Min5.Value) == Comparison.Less)
                return false;
            else if (bounds.Max5.Exists && this._compare5(vector.Axis5, bounds.Max5.Value) == Comparison.Greater)
                return false;

            if (bounds.Min6.Exists && this._compare6(vector.Axis6, bounds.Min6.Value) == Comparison.Less)
                return false;
            else if (bounds.Max6.Exists && this._compare6(vector.Axis6, bounds.Max6.Value) == Comparison.Greater)
                return false;

            return true;
        }

        /// <summary>Checks if a space (left) encapsulates another space (right).</summary>
        /// <returns>True if the left space encapsulates the right; False if not.</returns>
        private bool EncapsulationCheck(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> a, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> b)
        {
            if ((a.Min1.Exists && !b.Min1.Exists) || (a.Min2.Exists && !b.Min2.Exists) || (a.Min3.Exists && !b.Min3.Exists) || (a.Min4.Exists && !b.Min4.Exists) || (a.Min5.Exists && !b.Min5.Exists) || (a.Min6.Exists && !b.Min6.Exists))
                return false;
			if ((a.Max1.Exists && !b.Max1.Exists) || (a.Max2.Exists && !b.Max2.Exists) || (a.Max3.Exists && !b.Max3.Exists) || (a.Max4.Exists && !b.Max4.Exists) || (a.Max5.Exists && !b.Max5.Exists) || (a.Max6.Exists && !b.Max6.Exists))
                return false;

            if (b.Min1.Exists && a.Min1.Exists && this._compare1(a.Min1.Value, b.Min1.Value) != Comparison.Less)
                return false;
            if (b.Max1.Exists && a.Max1.Exists && this._compare1(a.Max1.Value, b.Max1.Value) != Comparison.Greater)
                return false;

            if (b.Min2.Exists && a.Min2.Exists && this._compare2(a.Min2.Value, b.Min2.Value) != Comparison.Less)
                return false;
            if (b.Max2.Exists && a.Max2.Exists && this._compare2(a.Max2.Value, b.Max2.Value) != Comparison.Greater)
                return false;

            if (b.Min3.Exists && a.Min3.Exists && this._compare3(a.Min3.Value, b.Min3.Value) != Comparison.Less)
                return false;
            if (b.Max3.Exists && a.Max3.Exists && this._compare3(a.Max3.Value, b.Max3.Value) != Comparison.Greater)
                return false;

            if (b.Min4.Exists && a.Min4.Exists && this._compare4(a.Min4.Value, b.Min4.Value) != Comparison.Less)
                return false;
            if (b.Max4.Exists && a.Max4.Exists && this._compare4(a.Max4.Value, b.Max4.Value) != Comparison.Greater)
                return false;

            if (b.Min5.Exists && a.Min5.Exists && this._compare5(a.Min5.Value, b.Min5.Value) != Comparison.Less)
                return false;
            if (b.Max5.Exists && a.Max5.Exists && this._compare5(a.Max5.Value, b.Max5.Value) != Comparison.Greater)
                return false;

            if (b.Min6.Exists && a.Min6.Exists && this._compare6(a.Min6.Value, b.Min6.Value) != Comparison.Less)
                return false;
            if (b.Max6.Exists && a.Max6.Exists && this._compare6(a.Max6.Value, b.Max6.Value) != Comparison.Greater)
                return false;

            return true;
        }

        /// <summary>Checks for equality between two locations.</summary>
        /// <returns>True if equal; False if not;</returns>
        private bool EqualsCheck(Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> a, Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> b)
        {

            if (!this._equate1(a.Axis1, b.Axis1))
                return false;

            if (!this._equate2(a.Axis2, b.Axis2))
                return false;

            if (!this._equate3(a.Axis3, b.Axis3))
                return false;

            if (!this._equate4(a.Axis4, b.Axis4))
                return false;

            if (!this._equate5(a.Axis5, b.Axis5))
                return false;

            if (!this._equate6(a.Axis6, b.Axis6))
                return false;

            return true;
        }

        /// <summary>Gets the nearest parent that encapsulates a location.</summary>
        /// <param name="node">The starting node to find the encapsulating parent of the location.</param>
        /// <param name="coordinate1">The coordinate along the 1D axis.</param>
        /// <param name="coordinate2">The coordinate along the 2D axis.</param>
        /// <param name="coordinate3">The coordinate along the 3D axis.</param>
        /// <returns>The nearest node that encapsulates the given location.</returns>
        private Node GetEncapsulationParent(Node node, Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> vector)
        {
            while (node != null && !EncapsulationCheck(node.Bounds, vector))
                node = node.Parent;
            return node;
        }

        private Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> LocateVector(T value)
        {
            Axis1 axis1;
            Axis2 axis2;
            Axis3 axis3;
            Axis4 axis4;
            Axis5 axis5;
            Axis6 axis6;
            this._locate(value, out axis1, out axis2, out axis3, out axis4, out axis5, out axis6);
            return new Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>(axis1, axis2, axis3, axis4, axis5, axis6);
        }

        #endregion

        #endregion
    }

    #endregion

    #region 7 Dimensional

    public interface IOmnitreePoints<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> : IDataStructure<T>,
            DataStructure.ICountable,
            DataStructure.IAddable<T>,
            DataStructure.IClearable,
            DataStructure.IRemovable<T>,
            DataStructure.IEquating<T>
    {
        #region Properties

        /// <summary>Steps through the values at a given location.</summary>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
		/// <param name="axis5">The coordinate along the 5D axis.</param>
		/// <param name="axis6">The coordinate along the 6D axis.</param>
		/// <param name="axis7">The coordinate along the 7D axis.</param>
        /// <returns>A Stepper of the items at the given coordinates.</returns>
        Stepper<T> this[Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Axis5 axis5, Axis6 axis6, Axis7 axis7] { get; }
        /// <summary>The number of dimensions in this tree.</summary>
        int Dimensions { get; }

        #endregion

        #region Methods

        /// <summary>Counts the number of items in a sub space.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		/// <param name="min7">The minimum coordinate of the space along the 7 axis.</param>
		/// <param name="max7">The maximum coordinate of the space along the 7 axis.</param>
        /// <returns>The number of items in the provided sub space.</returns>
        int CountSubSpace(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5, Omnitree.Bound<Axis6> min6, Omnitree.Bound<Axis6> max6, Omnitree.Bound<Axis7> min7, Omnitree.Bound<Axis7> max7);

        /// <summary>Iterates through the entire tree and ensures each item is in the proper leaf.</summary>
        void Update();
        /// <summary>Iterates through the provided dimensions and ensures each item is in the proper leaf.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		/// <param name="min7">The minimum coordinate of the space along the 7 axis.</param>
		/// <param name="max7">The maximum coordinate of the space along the 7 axis.</param>
        void Update(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5, Omnitree.Bound<Axis6> min6, Omnitree.Bound<Axis6> max6, Omnitree.Bound<Axis7> min7, Omnitree.Bound<Axis7> max7);

        /// <summary>Removes all the items in a given space.</summary>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
		/// <param name="axis5">The coordinate along the 5D axis.</param>
		/// <param name="axis6">The coordinate along the 6D axis.</param>
		/// <param name="axis7">The coordinate along the 7D axis.</param>
        void Remove(Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Axis5 axis5, Axis6 axis6, Axis7 axis7);
        /// <summary>Removes all the items in a given space.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		/// <param name="min7">The minimum coordinate of the space along the 7 axis.</param>
		/// <param name="max7">The maximum coordinate of the space along the 7 axis.</param>
        void Remove(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5, Omnitree.Bound<Axis6> min6, Omnitree.Bound<Axis6> max6, Omnitree.Bound<Axis7> min7, Omnitree.Bound<Axis7> max7);
        /// <summary>Removes all the items in a given space where equality is met.</summary>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
		/// <param name="axis5">The coordinate along the 5D axis.</param>
		/// <param name="axis6">The coordinate along the 6D axis.</param>
		/// <param name="axis7">The coordinate along the 7D axis.</param>
        /// <param name="where">The equality constraint of the removal.</param>
        void Remove(Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Axis5 axis5, Axis6 axis6, Axis7 axis7, Predicate<T> where);
        /// <summary>Removes all the items in a given space where predicate is met.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		/// <param name="min7">The minimum coordinate of the space along the 7 axis.</param>
		/// <param name="max7">The maximum coordinate of the space along the 7 axis.</param>
        /// <param name="where">The predicate constraint of the removal.</param>
        void Remove(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5, Omnitree.Bound<Axis6> min6, Omnitree.Bound<Axis6> max6, Omnitree.Bound<Axis7> min7, Omnitree.Bound<Axis7> max7, Predicate<T> where);

        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="step">The step function to perform on all items in the tree within the given bounds.</param>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		/// <param name="min7">The minimum coordinate of the space along the 7 axis.</param>
		/// <param name="max7">The maximum coordinate of the space along the 7 axis.</param>
        void Stepper(Step<T> step, Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5, Omnitree.Bound<Axis6> min6, Omnitree.Bound<Axis6> max6, Omnitree.Bound<Axis7> min7, Omnitree.Bound<Axis7> max7);
        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="step">The step function to perform on all items in the tree within the given bounds.</param>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		/// <param name="min7">The minimum coordinate of the space along the 7 axis.</param>
		/// <param name="max7">The maximum coordinate of the space along the 7 axis.</param>
        StepStatus Stepper(StepBreak<T> step, Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5, Omnitree.Bound<Axis6> min6, Omnitree.Bound<Axis6> max6, Omnitree.Bound<Axis7> min7, Omnitree.Bound<Axis7> max7);
        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="step">The step function to perform on all items in the tree within the given bounds.</param>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
		/// <param name="axis5">The coordinate along the 5D axis.</param>
		/// <param name="axis6">The coordinate along the 6D axis.</param>
		/// <param name="axis7">The coordinate along the 7D axis.</param>
        void Stepper(Step<T> step, Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Axis5 axis5, Axis6 axis6, Axis7 axis7);
        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="step">The step function to perform on all items in the tree within the given bounds.</param>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
		/// <param name="axis5">The coordinate along the 5D axis.</param>
		/// <param name="axis6">The coordinate along the 6D axis.</param>
		/// <param name="axis7">The coordinate along the 7D axis.</param>
        StepStatus Stepper(StepBreak<T> function, Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Axis5 axis5, Axis6 axis6, Axis7 axis7);

        #endregion
    }

    public class OmnitreePointsLinked<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> : IOmnitreePoints<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>
    {
        private const int _dimensions = 7;
        internal static int _children_per_node = (int)BigInteger.Pow(2, 7);

        private Node _top;

		private int _naturalLogLower = 1; // caching the next time to calculate loads (lower count)
		private int _naturalLogUpper = -1; // caching the next time to calculate loads (upper count)
		private int _load; // ln(count); min = _defaultLoad
        private Omnitree.Location<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> _locate;

        private bool _defaultEquate;
        private Equate<T> _equate;


        private bool _defaultEquate1;
        private Equate<Axis1> _equate1;

        private bool _defaultEquate2;
        private Equate<Axis2> _equate2;

        private bool _defaultEquate3;
        private Equate<Axis3> _equate3;

        private bool _defaultEquate4;
        private Equate<Axis4> _equate4;

        private bool _defaultEquate5;
        private Equate<Axis5> _equate5;

        private bool _defaultEquate6;
        private Equate<Axis6> _equate6;

        private bool _defaultEquate7;
        private Equate<Axis7> _equate7;



        private bool _defaultCompare1;
        private Compare<Axis1> _compare1;

        private bool _defaultCompare2;
        private Compare<Axis2> _compare2;

        private bool _defaultCompare3;
        private Compare<Axis3> _compare3;

        private bool _defaultCompare4;
        private Compare<Axis4> _compare4;

        private bool _defaultCompare5;
        private Compare<Axis5> _compare5;

        private bool _defaultCompare6;
        private Compare<Axis6> _compare6;

        private bool _defaultCompare7;
        private Compare<Axis7> _compare7;


        // allows median overriding for custom optimizations (USE AT YOUR OWN RISK)
        private Omnitree.SubdivisionOverride<T, Axis1, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>> _subdivisionOverride1;
        private Omnitree.SubdivisionOverride<T, Axis2, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>> _subdivisionOverride2;
        private Omnitree.SubdivisionOverride<T, Axis3, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>> _subdivisionOverride3;
        private Omnitree.SubdivisionOverride<T, Axis4, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>> _subdivisionOverride4;
        private Omnitree.SubdivisionOverride<T, Axis5, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>> _subdivisionOverride5;
        private Omnitree.SubdivisionOverride<T, Axis6, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>> _subdivisionOverride6;
        private Omnitree.SubdivisionOverride<T, Axis7, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>> _subdivisionOverride7;

        #region Nested Types

        /// <summary>Can be a leaf or a branch.</summary>
        public abstract class Node
        {
            internal Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> _bounds;
            internal Branch _parent;
            internal int _index;
            internal int _count;

            /// <summary>The parent of this node.</summary>
            public Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> Bounds { get { return this._bounds; } }
            /// <summary>The parent of this node.</summary>
            public Branch Parent { get { return this._parent; } }
            /// <summary>The computed child index of this node (see the "Notes" region in "Omnitree.cs" for the algorithm.</summary>
            public int Index { get { return this._index; } }
            /// <summary>The number of elements stored in this node and its children.</summary>
            public int Count { get { return this._count; } set { this._count = value; } }

            /// <summary>The depth this node is located in the Omnitree.</summary>
            public int Depth
            {
                get
                {
                    int depth = -1;
                    for (Node looper = this; looper != null; looper = looper.Parent)
                        depth++;
                    return depth;
                }
            }

            /// <summary>Constructs a node.</summary>
            /// <param name="bounds">The bounds of this node.</param>
            /// <param name="parent">The parent of this node.</param>
            /// <param name="index">The number of elements stored in this node and its children.</param>
            public Node(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> bounds, Branch parent, int index)
            {
                this._bounds = bounds;
                this._parent = parent;
                this._index = index;
            }

            internal Node(Node nodeToClone)
            {
                this._bounds = nodeToClone._bounds;
                this._parent = nodeToClone._parent;
                this._index = nodeToClone._index;
                this._count = nodeToClone._count;
            }

            internal abstract Node Clone();
        }

        /// <summary>A branch in the tree. Only contains nodes.</summary>
        public class Branch : Node
        {
            private Node[] _children;
            private Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> _pointOfDivision;

            public Node[] Children { get { return this._children; } set { this._children = value; } }
            public Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> PointOfDivision { get { return this._pointOfDivision; } internal set { this._pointOfDivision = value; } }
            
            /// <summary>Gets child by index.</summary>
            /// <param name="child_index">The index of the child to get.</param>
            /// <returns>The child of the given index or null if non-existent.</returns>
            public Node this[int child_index]
            {
                get
                {
                    if (this._children == null)
                        return null;
                    if (this._children.Length == OmnitreePointsLinked<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>._children_per_node)
                        return this._children[(int)child_index];
                    foreach (Node node in this._children)
                        if (node.Index == child_index)
                            return node;
                    return null;
                }
                set
                {
                    // This error check should be unnecessary... but fuck it... might as well
                    if (value.Index != child_index)
                        throw new System.Exception("Bug in Omnitree (index/property mis-match when setting a child on a branch)");

                    // no children yet
                    if (this._children == null)
                    {
                        this._children = new Node[] { value };
                        return;
                    }
                    // max children overwrite
                    else if (this._children.Length == OmnitreePointsLinked<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>._children_per_node)
                    {
                        this._children[(int)child_index] = value;
                        return;
                    }
                    // non-max child overwrite
                    for (int i = 0; i < this._children.Length; i++)
                        if (this._children[i].Index == child_index)
                        {
                            this._children[i] = value;
                            return;
                        }
                    // new child
                    Node[] newArray = new Node[this._children.Length + 1];
                    if (newArray.Length == OmnitreePointsLinked<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>._children_per_node)
                    {
                        // new child resulting in a max children branch (sorting required)
                        for (int i = 0; i < this._children.Length; i++)
                        {
                            newArray[(int)this._children[i]._index] = this._children[i];
                        }
                        newArray[(int)value._index] = value;
                    }
                    else
                    {
                        // new child resulting in a non-max children branch
                        Array.Copy(this._children, newArray, this._children.Length);
                        newArray[newArray.Length - 1] = value;
                    }
                    this._children = newArray;
                }
            }

            public Branch(Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> pointOfDivision, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> bounds, Branch parent, int index)
                : base(bounds, parent, index)
            {
                this._pointOfDivision = pointOfDivision;
            }

            public Branch(Branch branchToClone)
                : base(branchToClone)
            {
                this._children = branchToClone._children.Clone() as Node[];
                this._pointOfDivision = branchToClone._pointOfDivision;
            }

            internal override Node Clone()
            {
                return new Branch(this);
            }
        }

        /// <summary>A branch in the tree. Only contains items.</summary>
        public class Leaf : Node
        {
            public class Node
            {
                internal T _value;
                internal Leaf.Node _next;

                public T Value { get { return _value; } set { _value = value; } }
                public Leaf.Node Next { get { return _next; } set { _next = value; } }

                public Node(T value, Leaf.Node next)
                {
                    _value = value;
                    _next = next;
                }
            }

            private Leaf.Node _head;

            public Leaf.Node Head { get { return this._head; } set { this._head = value; } }

            internal Leaf(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> bounds, Branch parent, int index)
                : base(bounds, parent, index)
            { }

            internal Leaf(Leaf leafToClone)
                : base(leafToClone)
            {
                this._head = new Node(leafToClone._head.Value, null);

                Node this_looper = this._head;
                Node other_looper = leafToClone._head;

                while (other_looper != null)
                {
                    this_looper.Next = new Node(other_looper.Next.Value, null);
                    this_looper = this_looper.Next;
                    other_looper = other_looper.Next;
                }
            }

            public void Add(T addition)
            {
                this._head = new Leaf.Node(addition, this._head);
                this.Count++;
            }

            internal override OmnitreePointsLinked<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>.Node Clone()
            {
                return new Leaf(this);
            }
        }

        #endregion

        #region Constructors

        /// <summary>This constructor is for cloning purposes</summary>
        private OmnitreePointsLinked(OmnitreePointsLinked<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> omnitree)
        {
            this._top = omnitree._top.Clone();
            this._load = omnitree._load;
            this._locate = omnitree._locate;
            this._defaultEquate = omnitree._defaultEquate;
            this._equate = omnitree._equate;

            this._defaultEquate1 = omnitree._defaultEquate1;
            this._equate1 = omnitree._equate1;
            this._defaultEquate2 = omnitree._defaultEquate2;
            this._equate2 = omnitree._equate2;
            this._defaultEquate3 = omnitree._defaultEquate3;
            this._equate3 = omnitree._equate3;
            this._defaultEquate4 = omnitree._defaultEquate4;
            this._equate4 = omnitree._equate4;
            this._defaultEquate5 = omnitree._defaultEquate5;
            this._equate5 = omnitree._equate5;
            this._defaultEquate6 = omnitree._defaultEquate6;
            this._equate6 = omnitree._equate6;
            this._defaultEquate7 = omnitree._defaultEquate7;
            this._equate7 = omnitree._equate7;

            this._defaultCompare1 = omnitree._defaultCompare1;
            this._compare1 = omnitree._compare1;
            this._defaultCompare2 = omnitree._defaultCompare2;
            this._compare2 = omnitree._compare2;
            this._defaultCompare3 = omnitree._defaultCompare3;
            this._compare3 = omnitree._compare3;
            this._defaultCompare4 = omnitree._defaultCompare4;
            this._compare4 = omnitree._compare4;
            this._defaultCompare5 = omnitree._defaultCompare5;
            this._compare5 = omnitree._compare5;
            this._defaultCompare6 = omnitree._defaultCompare6;
            this._compare6 = omnitree._compare6;
            this._defaultCompare7 = omnitree._defaultCompare7;
            this._compare7 = omnitree._compare7;

            this._subdivisionOverride1 = omnitree._subdivisionOverride1;
            this._subdivisionOverride2 = omnitree._subdivisionOverride2;
            this._subdivisionOverride3 = omnitree._subdivisionOverride3;
            this._subdivisionOverride4 = omnitree._subdivisionOverride4;
            this._subdivisionOverride5 = omnitree._subdivisionOverride5;
            this._subdivisionOverride6 = omnitree._subdivisionOverride6;
            this._subdivisionOverride7 = omnitree._subdivisionOverride7;
        }

        private OmnitreePointsLinked(
            Omnitree.Location<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> locate,

            bool defaultEquate,
            Equate<T> equate,

            bool defaultEquate1,
            Equate<Axis1> equateAxis1,
            bool defaultEquate2,
            Equate<Axis2> equateAxis2,
            bool defaultEquate3,
            Equate<Axis3> equateAxis3,
            bool defaultEquate4,
            Equate<Axis4> equateAxis4,
            bool defaultEquate5,
            Equate<Axis5> equateAxis5,
            bool defaultEquate6,
            Equate<Axis6> equateAxis6,
            bool defaultEquate7,
            Equate<Axis7> equateAxis7,

            bool defaultCompare1,
            Compare<Axis1> compare1,
            bool defaultCompare2,
            Compare<Axis2> compare2,
            bool defaultCompare3,
            Compare<Axis3> compare3,
            bool defaultCompare4,
            Compare<Axis4> compare4,
            bool defaultCompare5,
            Compare<Axis5> compare5,
            bool defaultCompare6,
            Compare<Axis6> compare6,
            bool defaultCompare7,
            Compare<Axis7> compare7,

            Omnitree.SubdivisionOverride<T, Axis1, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>> subdivisionOverride1,
            Omnitree.SubdivisionOverride<T, Axis2, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>> subdivisionOverride2,
            Omnitree.SubdivisionOverride<T, Axis3, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>> subdivisionOverride3,
            Omnitree.SubdivisionOverride<T, Axis4, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>> subdivisionOverride4,
            Omnitree.SubdivisionOverride<T, Axis5, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>> subdivisionOverride5,
            Omnitree.SubdivisionOverride<T, Axis6, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>> subdivisionOverride6,
            Omnitree.SubdivisionOverride<T, Axis7, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>> subdivisionOverride7)
        {
			if (locate == null)
			{
				throw new ArgumentNullException(nameof(locate));
			}
			if (equate == null)
			{
				throw new ArgumentNullException(nameof(equate));
			}

			if (equateAxis1 == null)
			{
				throw new ArgumentNullException(nameof(equateAxis1));
			}
			if (equateAxis2 == null)
			{
				throw new ArgumentNullException(nameof(equateAxis2));
			}
			if (equateAxis3 == null)
			{
				throw new ArgumentNullException(nameof(equateAxis3));
			}
			if (equateAxis4 == null)
			{
				throw new ArgumentNullException(nameof(equateAxis4));
			}
			if (equateAxis5 == null)
			{
				throw new ArgumentNullException(nameof(equateAxis5));
			}
			if (equateAxis6 == null)
			{
				throw new ArgumentNullException(nameof(equateAxis6));
			}
			if (equateAxis7 == null)
			{
				throw new ArgumentNullException(nameof(equateAxis7));
			}

			if (compare1 == null)
			{
				throw new ArgumentNullException(nameof(compare1));
			}
			if (compare2 == null)
			{
				throw new ArgumentNullException(nameof(compare2));
			}
			if (compare3 == null)
			{
				throw new ArgumentNullException(nameof(compare3));
			}
			if (compare4 == null)
			{
				throw new ArgumentNullException(nameof(compare4));
			}
			if (compare5 == null)
			{
				throw new ArgumentNullException(nameof(compare5));
			}
			if (compare6 == null)
			{
				throw new ArgumentNullException(nameof(compare6));
			}
			if (compare7 == null)
			{
				throw new ArgumentNullException(nameof(compare7));
			}

            this._locate = locate;
            this._defaultEquate = defaultEquate;
            this._equate = equate;

            this._defaultEquate1 = defaultEquate1;
            this._equate1 = equateAxis1;
            this._defaultEquate2 = defaultEquate2;
            this._equate2 = equateAxis2;
            this._defaultEquate3 = defaultEquate3;
            this._equate3 = equateAxis3;
            this._defaultEquate4 = defaultEquate4;
            this._equate4 = equateAxis4;
            this._defaultEquate5 = defaultEquate5;
            this._equate5 = equateAxis5;
            this._defaultEquate6 = defaultEquate6;
            this._equate6 = equateAxis6;
            this._defaultEquate7 = defaultEquate7;
            this._equate7 = equateAxis7;

            this._defaultCompare1 = defaultCompare1;
            this._compare1 = compare1;
            this._defaultCompare2 = defaultCompare2;
            this._compare2 = compare2;
            this._defaultCompare3 = defaultCompare3;
            this._compare3 = compare3;
            this._defaultCompare4 = defaultCompare4;
            this._compare4 = compare4;
            this._defaultCompare5 = defaultCompare5;
            this._compare5 = compare5;
            this._defaultCompare6 = defaultCompare6;
            this._compare6 = compare6;
            this._defaultCompare7 = defaultCompare7;
            this._compare7 = compare7;

            this._subdivisionOverride1 = subdivisionOverride1;
            this._subdivisionOverride2 = subdivisionOverride2;
            this._subdivisionOverride3 = subdivisionOverride3;
            this._subdivisionOverride4 = subdivisionOverride4;
            this._subdivisionOverride5 = subdivisionOverride5;
            this._subdivisionOverride6 = subdivisionOverride6;
            this._subdivisionOverride7 = subdivisionOverride7;

            this._top = new Leaf(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>.None, null, -1);
            Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
        }

        private OmnitreePointsLinked(
            Omnitree.Location<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> locate,
            Equate<T> equate,

            Equate<Axis1> equateAxis1,
            Equate<Axis2> equateAxis2,
            Equate<Axis3> equateAxis3,
            Equate<Axis4> equateAxis4,
            Equate<Axis5> equateAxis5,
            Equate<Axis6> equateAxis6,
            Equate<Axis7> equateAxis7,

            Compare<Axis1> compare1,
            Compare<Axis2> compare2,
            Compare<Axis3> compare3,
            Compare<Axis4> compare4,
            Compare<Axis5> compare5,
            Compare<Axis6> compare6,
            Compare<Axis7> compare7,

            Omnitree.SubdivisionOverride<T, Axis1, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>> subdivisionOverride1,
            Omnitree.SubdivisionOverride<T, Axis2, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>> subdivisionOverride2,
            Omnitree.SubdivisionOverride<T, Axis3, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>> subdivisionOverride3,
            Omnitree.SubdivisionOverride<T, Axis4, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>> subdivisionOverride4,
            Omnitree.SubdivisionOverride<T, Axis5, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>> subdivisionOverride5,
            Omnitree.SubdivisionOverride<T, Axis6, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>> subdivisionOverride6,
            Omnitree.SubdivisionOverride<T, Axis7, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>> subdivisionOverride7)
            : this(
            locate,

            false,
            equate,

            false,
            equateAxis1,
            false,
            equateAxis2,
            false,
            equateAxis3,
            false,
            equateAxis4,
            false,
            equateAxis5,
            false,
            equateAxis6,
            false,
            equateAxis7,

            false,
            compare1,
            false,
            compare2,
            false,
            compare3,
            false,
            compare4,
            false,
            compare5,
            false,
            compare6,
            false,
            compare7,

            subdivisionOverride1,
            subdivisionOverride2,
            subdivisionOverride3,
            subdivisionOverride4,
            subdivisionOverride5,
            subdivisionOverride6,
            subdivisionOverride7)
        { }

        public OmnitreePointsLinked(
            Omnitree.Location<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> locate,

            Equate<T> equate,

            Equate<Axis1> equateAxis1,
            Equate<Axis2> equateAxis2,
            Equate<Axis3> equateAxis3,
            Equate<Axis4> equateAxis4,
            Equate<Axis5> equateAxis5,
            Equate<Axis6> equateAxis6,
            Equate<Axis7> equateAxis7,

            Compare<Axis1> compare1,
            Compare<Axis2> compare2,
            Compare<Axis3> compare3,
            Compare<Axis4> compare4,
            Compare<Axis5> compare5,
            Compare<Axis6> compare6,
            Compare<Axis7> compare7)
            : this(
                locate,

                false,
                equate,

                false,
                equateAxis1,
                false,
                equateAxis2,
                false,
                equateAxis3,
                false,
                equateAxis4,
                false,
                equateAxis5,
                false,
                equateAxis6,
                false,
                equateAxis7,

                false,
                compare1,
                false,
                compare2,
                false,
                compare3,
                false,
                compare4,
                false,
                compare5,
                false,
                compare6,
                false,
                compare7,

                null,
                null,
                null,
                null,
                null,
                null,
                null)
        { }



        public OmnitreePointsLinked(
            Omnitree.Location<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> locate,

            Equate<T> equate,

            Compare<Axis1> compare1,
            Compare<Axis2> compare2,
            Compare<Axis3> compare3,
            Compare<Axis4> compare4,
            Compare<Axis5> compare5,
            Compare<Axis6> compare6,
            Compare<Axis7> compare7)
            : this(
                locate,
                false,
                equate,

                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,

                false,
                compare1,
                false,
                compare2,
                false,
                compare3,
                false,
                compare4,
                false,
                compare5,
                false,
                compare6,
                false,
                compare7,

                null,
                null,
                null,
                null,
                null,
                null,
                null)
        { }

        public OmnitreePointsLinked(
            Omnitree.Location<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> locate,
            Equate<T> equate,

            Compare<Axis1> compare1,
            Compare<Axis2> compare2,
            Compare<Axis3> compare3,
            Compare<Axis4> compare4,
            Compare<Axis5> compare5,
            Compare<Axis6> compare6,
            Compare<Axis7> compare7,

            Omnitree.SubdivisionOverride<T, Axis1, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>> subdivisionOverride1,
            Omnitree.SubdivisionOverride<T, Axis2, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>> subdivisionOverride2,
            Omnitree.SubdivisionOverride<T, Axis3, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>> subdivisionOverride3,
            Omnitree.SubdivisionOverride<T, Axis4, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>> subdivisionOverride4,
            Omnitree.SubdivisionOverride<T, Axis5, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>> subdivisionOverride5,
            Omnitree.SubdivisionOverride<T, Axis6, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>> subdivisionOverride6,
            Omnitree.SubdivisionOverride<T, Axis7, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>> subdivisionOverride7)
            : this(
                locate,

                false,
                equate,

                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,

                false,
                compare1,
                false,
                compare2,
                false,
                compare3,
                false,
                compare4,
                false,
                compare5,
                false,
                compare6,
                false,
                compare7,

                subdivisionOverride1,
                subdivisionOverride2,
                subdivisionOverride3,
                subdivisionOverride4,
                subdivisionOverride5,
                subdivisionOverride6,
                subdivisionOverride7)
        { }

        public OmnitreePointsLinked(
            Omnitree.Location<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> locate,

            Compare<Axis1> compare1,
            Compare<Axis2> compare2,
            Compare<Axis3> compare3,
            Compare<Axis4> compare4,
            Compare<Axis5> compare5,
            Compare<Axis6> compare6,
            Compare<Axis7> compare7)
            : this(
                locate,
                true,
                Towel.Equate.Default,

                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,

                false,
                compare1,
                false,
                compare2,
                false,
                compare3,
                false,
                compare4,
                false,
                compare5,
                false,
                compare6,
                false,
                compare7,

                null,
                null,
                null,
                null,
                null,
                null,
                null)
        { }

        public OmnitreePointsLinked(
            Omnitree.Location<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> locate,

            Compare<Axis1> compare1,
            Compare<Axis2> compare2,
            Compare<Axis3> compare3,
            Compare<Axis4> compare4,
            Compare<Axis5> compare5,
            Compare<Axis6> compare6,
            Compare<Axis7> compare7,

            Omnitree.SubdivisionOverride<T, Axis1, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>> subdivisionOverride1,
            Omnitree.SubdivisionOverride<T, Axis2, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>> subdivisionOverride2,
            Omnitree.SubdivisionOverride<T, Axis3, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>> subdivisionOverride3,
            Omnitree.SubdivisionOverride<T, Axis4, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>> subdivisionOverride4,
            Omnitree.SubdivisionOverride<T, Axis5, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>> subdivisionOverride5,
            Omnitree.SubdivisionOverride<T, Axis6, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>> subdivisionOverride6,
            Omnitree.SubdivisionOverride<T, Axis7, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>> subdivisionOverride7)
            : this(
                locate,

                true,
                Towel.Equate.Default,

                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,

                false,
                compare1,
                false,
                compare2,
                false,
                compare3,
                false,
                compare4,
                false,
                compare5,
                false,
                compare6,
                false,
                compare7,

                subdivisionOverride1,
                subdivisionOverride2,
                subdivisionOverride3,
                subdivisionOverride4,
                subdivisionOverride5,
                subdivisionOverride6,
                subdivisionOverride7)
        { }

        public OmnitreePointsLinked(
            Omnitree.Location<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> locate,
            Equate<T> equate)
            : this(
                locate,

                false,
                equate,

                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,

                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,

                null,
                null,
                null,
                null,
                null,
                null,
                null)
        { }

        public OmnitreePointsLinked(
            Omnitree.Location<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> locate,
            Equate<T> equate,
            Omnitree.SubdivisionOverride<T, Axis1, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>> subdivisionOverride1,
            Omnitree.SubdivisionOverride<T, Axis2, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>> subdivisionOverride2,
            Omnitree.SubdivisionOverride<T, Axis3, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>> subdivisionOverride3,
            Omnitree.SubdivisionOverride<T, Axis4, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>> subdivisionOverride4,
            Omnitree.SubdivisionOverride<T, Axis5, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>> subdivisionOverride5,
            Omnitree.SubdivisionOverride<T, Axis6, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>> subdivisionOverride6,
            Omnitree.SubdivisionOverride<T, Axis7, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>> subdivisionOverride7)
            : this(
                locate,

                false,
                equate,

                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,

                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,

                subdivisionOverride1,
                subdivisionOverride2,
                subdivisionOverride3,
                subdivisionOverride4,
                subdivisionOverride5,
                subdivisionOverride6,
                subdivisionOverride7)
        { }

        public OmnitreePointsLinked(
            Omnitree.Location<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> locate)
            : this(
                locate,

                true,
                Towel.Equate.Default,

                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,

                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,

                null,
                null,
                null,
                null,
                null,
                null,
                null)
        { }

        public OmnitreePointsLinked(
            Omnitree.Location<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> locate,
            Omnitree.SubdivisionOverride<T, Axis1, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>> subdivisionOverride1,
            Omnitree.SubdivisionOverride<T, Axis2, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>> subdivisionOverride2,
            Omnitree.SubdivisionOverride<T, Axis3, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>> subdivisionOverride3,
            Omnitree.SubdivisionOverride<T, Axis4, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>> subdivisionOverride4,
            Omnitree.SubdivisionOverride<T, Axis5, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>> subdivisionOverride5,
            Omnitree.SubdivisionOverride<T, Axis6, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>> subdivisionOverride6,
            Omnitree.SubdivisionOverride<T, Axis7, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>> subdivisionOverride7)
            : this(
                locate,

                true,
                Towel.Equate.Default,

                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,

                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,

                subdivisionOverride1,
                subdivisionOverride2,
                subdivisionOverride3,
                subdivisionOverride4,
                subdivisionOverride5,
                subdivisionOverride6,
                subdivisionOverride7)
        { }

        #endregion

        #region Properties

        /// <summary>Steps through all the items at a given coordinate.</summary>
        /// <param name="axis1">The coordinate along axis 1.</param>
        /// <param name="axis2">The coordinate along axis 2.</param>
        /// <param name="axis3">The coordinate along axis 3.</param>
        /// <param name="axis4">The coordinate along axis 4.</param>
        /// <param name="axis5">The coordinate along axis 5.</param>
        /// <param name="axis6">The coordinate along axis 6.</param>
        /// <param name="axis7">The coordinate along axis 7.</param>
        /// <returns>The stepper for the items at the given coordinate.</returns>
        public Stepper<T> this[Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Axis5 axis5, Axis6 axis6, Axis7 axis7]
        {
            get
            {
                return (Step<T> step) => { this.Stepper(step, axis1, axis2, axis3, axis4, axis5, axis6, axis7); };
            }
        }

        /// <summary>The number of dimensions in this tree.</summary>
        public int Dimensions { get { return _dimensions; } }

        /// <summary>The function for equating keys in this table.</summary>
        public Equate<T> Equate { get { return this._equate; } }

        /// <summary>The location function the Omnitree is using.</summary>
        public Omnitree.Location<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> Locate { get { return this._locate; } }


        /// <summary>The comparison function the Omnitree is using along the 1D axis.</summary>
        public Compare<Axis1> Compare1 { get { return this._compare1; } }
        /// <summary>The comparison function the Omnitree is using along the 2D axis.</summary>
        public Compare<Axis2> Compare2 { get { return this._compare2; } }
        /// <summary>The comparison function the Omnitree is using along the 3D axis.</summary>
        public Compare<Axis3> Compare3 { get { return this._compare3; } }
        /// <summary>The comparison function the Omnitree is using along the 4D axis.</summary>
        public Compare<Axis4> Compare4 { get { return this._compare4; } }
        /// <summary>The comparison function the Omnitree is using along the 5D axis.</summary>
        public Compare<Axis5> Compare5 { get { return this._compare5; } }
        /// <summary>The comparison function the Omnitree is using along the 6D axis.</summary>
        public Compare<Axis6> Compare6 { get { return this._compare6; } }
        /// <summary>The comparison function the Omnitree is using along the 7D axis.</summary>
        public Compare<Axis7> Compare7 { get { return this._compare7; } }

        /// <summary>The function for equating values along the 1D axis.</summary>
        public Equate<Axis1> EquateAxis1 { get { return this._equate1; } }
        /// <summary>The function for equating values along the 2D axis.</summary>
        public Equate<Axis2> EquateAxis2 { get { return this._equate2; } }
        /// <summary>The function for equating values along the 3D axis.</summary>
        public Equate<Axis3> EquateAxis3 { get { return this._equate3; } }
        /// <summary>The function for equating values along the 4D axis.</summary>
        public Equate<Axis4> EquateAxis4 { get { return this._equate4; } }
        /// <summary>The function for equating values along the 5D axis.</summary>
        public Equate<Axis5> EquateAxis5 { get { return this._equate5; } }
        /// <summary>The function for equating values along the 6D axis.</summary>
        public Equate<Axis6> EquateAxis6 { get { return this._equate6; } }
        /// <summary>The function for equating values along the 7D axis.</summary>
        public Equate<Axis7> EquateAxis7 { get { return this._equate7; } }

        /// <summary>The current number of items in the tree.</summary>
        public int Count { get { return this._top.Count; } }

        private delegate void MaxDepthFinder(Node node, int current_depth, ref int max_depth);
        /// <summary>Finds the current maximum depth of the tree. NOT AN O(1) OPERATION. Intended for educational purposes only.</summary>
        public int MaxDepth
        {
            get
            {
                MaxDepthFinder maxDepthFinder = null;
                maxDepthFinder =
                        (Node node, int current_depth, ref int max_depth) =>
                        {
                            if (current_depth > max_depth)
                                max_depth = current_depth;
                            if (node is Branch)
                                foreach (Node child in (node as Branch).Children)
                                    maxDepthFinder(child, current_depth + 1, ref max_depth);
                        };
                int _max_depth = -1;
                maxDepthFinder(this._top, 0, ref _max_depth);
                return _max_depth;
            }
        }

        private delegate void NodeCountFinder(Node node, ref int current_count);
        /// <summary>Counts the current number of nodes in the tree. NOT AN O(1) OPERATION. Intended for educational purposes only.</summary>
        public int NodeCount
        {
            get
            {
                NodeCountFinder nodeCountFinder = null;
                nodeCountFinder =
                        (Node node, ref int current_count) =>
                        {
                            current_count++;
                            if (node is Branch)
                                foreach (Node child in (node as Branch).Children)
                                    nodeCountFinder(child, ref current_count);
                        };

                int _current_count = 0;
                nodeCountFinder(this._top, ref _current_count);
                return _current_count;
            }
        }

        private delegate void BranchCountFinder(Node node, ref int current_count);
        /// <summary>Counts the current number of branches in the tree. NOT AN O(1) OPERATION. Intended for educational purposes only.</summary>
        public int BranchCount
        {
            get
            {
                BranchCountFinder branchCountFinder = null;
                branchCountFinder =
                        (Node node, ref int current_count) =>
                        {
                            if (node is Branch)
                            {
                                current_count++;
                                foreach (Node child in (node as Branch).Children)
                                    branchCountFinder(child, ref current_count);
                            }
                        };

                int _current_count = 0;
                branchCountFinder(this._top, ref _current_count);
                return _current_count;
            }
        }

        private delegate void LeafCountFinder(Node node, ref int current_count);
        /// <summary>Counts the current number of leaves in the tree. NOT AN O(1) OPERATION. Intended for educational purposes only.</summary>
        public int LeafCount
        {
            get
            {
                LeafCountFinder leafCountFinder = null;
                leafCountFinder =
                        (Node node, ref int current_count) =>
                        {
                            if (node is Leaf)
                                current_count++;
                            else
                                foreach (Node child in (node as Branch).Children)
                                    leafCountFinder(child, ref current_count);
                        };

                int _current_count = 0;
                leafCountFinder(this._top, ref _current_count);
                return _current_count;
            }
        }

        #endregion

        #region Methods

        #region Add

        #region Bulk

        public void Add(IndexedBigArray<T> additions, bool allowMultithreading)
        {
            if (additions.Length > int.MaxValue)
                throw new System.Exception("The maximum size of the Omnitree was exceeded during bulk addition.");

            if (this._top.Count != 0 || (int)additions.Length <= _load)
            {
                for (ulong i = 0; i < additions.Length; i++)
                    this.Add(additions[i]);
            }
            else
            {
                // adjust the loads prior to additions
				Omnitree.ComputeLoads((int)additions.Length, ref _naturalLogLower, ref _naturalLogUpper, ref _load);

                Branch new_top = new Branch(Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>.Default, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>.None, null, -1);
                new_top.Count = (int)additions.Length;


                // prepare data for median computations
                IndexedBigArray<Axis1> values1;
                IAsyncResult result1 = null;
                if (this._subdivisionOverride1 != null)
                    values1 = null;
                else
                {
                    values1 = null;
                    Towel.Parallels.Parallel.Operation operation = () =>
                    {
                        values1 = new IndexedBigArray<Axis1>(additions.Length);
                        for (ulong i = 0; i < additions.Length; i++)
                            values1[i] = LocateVector(additions[i]).Axis1;
                        Towel.Algorithms.Sort.Merge(this._compare1, (int i) => { return values1[(ulong)i]; }, (int i, Axis1 value) => { values1[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
                    };

                    if (allowMultithreading)
                        result1 = Towel.Parallels.Parallel.Thread(operation);
                    else
                        operation();
                }

                // prepare data for median computations
                IndexedBigArray<Axis2> values2;
                IAsyncResult result2 = null;
                if (this._subdivisionOverride2 != null)
                    values2 = null;
                else
                {
                    values2 = null;
                    Towel.Parallels.Parallel.Operation operation = () =>
                    {
                        values2 = new IndexedBigArray<Axis2>(additions.Length);
                        for (ulong i = 0; i < additions.Length; i++)
                            values2[i] = LocateVector(additions[i]).Axis2;
                        Towel.Algorithms.Sort.Merge(this._compare2, (int i) => { return values2[(ulong)i]; }, (int i, Axis2 value) => { values2[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
                    };

                    if (allowMultithreading)
                        result2 = Towel.Parallels.Parallel.Thread(operation);
                    else
                        operation();
                }

                // prepare data for median computations
                IndexedBigArray<Axis3> values3;
                IAsyncResult result3 = null;
                if (this._subdivisionOverride3 != null)
                    values3 = null;
                else
                {
                    values3 = null;
                    Towel.Parallels.Parallel.Operation operation = () =>
                    {
                        values3 = new IndexedBigArray<Axis3>(additions.Length);
                        for (ulong i = 0; i < additions.Length; i++)
                            values3[i] = LocateVector(additions[i]).Axis3;
                        Towel.Algorithms.Sort.Merge(this._compare3, (int i) => { return values3[(ulong)i]; }, (int i, Axis3 value) => { values3[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
                    };

                    if (allowMultithreading)
                        result3 = Towel.Parallels.Parallel.Thread(operation);
                    else
                        operation();
                }

                // prepare data for median computations
                IndexedBigArray<Axis4> values4;
                IAsyncResult result4 = null;
                if (this._subdivisionOverride4 != null)
                    values4 = null;
                else
                {
                    values4 = null;
                    Towel.Parallels.Parallel.Operation operation = () =>
                    {
                        values4 = new IndexedBigArray<Axis4>(additions.Length);
                        for (ulong i = 0; i < additions.Length; i++)
                            values4[i] = LocateVector(additions[i]).Axis4;
                        Towel.Algorithms.Sort.Merge(this._compare4, (int i) => { return values4[(ulong)i]; }, (int i, Axis4 value) => { values4[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
                    };

                    if (allowMultithreading)
                        result4 = Towel.Parallels.Parallel.Thread(operation);
                    else
                        operation();
                }

                // prepare data for median computations
                IndexedBigArray<Axis5> values5;
                IAsyncResult result5 = null;
                if (this._subdivisionOverride5 != null)
                    values5 = null;
                else
                {
                    values5 = null;
                    Towel.Parallels.Parallel.Operation operation = () =>
                    {
                        values5 = new IndexedBigArray<Axis5>(additions.Length);
                        for (ulong i = 0; i < additions.Length; i++)
                            values5[i] = LocateVector(additions[i]).Axis5;
                        Towel.Algorithms.Sort.Merge(this._compare5, (int i) => { return values5[(ulong)i]; }, (int i, Axis5 value) => { values5[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
                    };

                    if (allowMultithreading)
                        result5 = Towel.Parallels.Parallel.Thread(operation);
                    else
                        operation();
                }

                // prepare data for median computations
                IndexedBigArray<Axis6> values6;
                IAsyncResult result6 = null;
                if (this._subdivisionOverride6 != null)
                    values6 = null;
                else
                {
                    values6 = null;
                    Towel.Parallels.Parallel.Operation operation = () =>
                    {
                        values6 = new IndexedBigArray<Axis6>(additions.Length);
                        for (ulong i = 0; i < additions.Length; i++)
                            values6[i] = LocateVector(additions[i]).Axis6;
                        Towel.Algorithms.Sort.Merge(this._compare6, (int i) => { return values6[(ulong)i]; }, (int i, Axis6 value) => { values6[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
                    };

                    if (allowMultithreading)
                        result6 = Towel.Parallels.Parallel.Thread(operation);
                    else
                        operation();
                }

                // prepare data for median computations
                IndexedBigArray<Axis7> values7;
                IAsyncResult result7 = null;
                if (this._subdivisionOverride7 != null)
                    values7 = null;
                else
                {
                    values7 = null;
                    Towel.Parallels.Parallel.Operation operation = () =>
                    {
                        values7 = new IndexedBigArray<Axis7>(additions.Length);
                        for (ulong i = 0; i < additions.Length; i++)
                            values7[i] = LocateVector(additions[i]).Axis7;
                        Towel.Algorithms.Sort.Merge(this._compare7, (int i) => { return values7[(ulong)i]; }, (int i, Axis7 value) => { values7[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
                    };

                    if (allowMultithreading)
                        result7 = Towel.Parallels.Parallel.Thread(operation);
                    else
                        operation();
                }



                if (this._subdivisionOverride1 == null && allowMultithreading)
                    result1.AsyncWaitHandle.WaitOne();

                if (this._subdivisionOverride2 == null && allowMultithreading)
                    result2.AsyncWaitHandle.WaitOne();

                if (this._subdivisionOverride3 == null && allowMultithreading)
                    result3.AsyncWaitHandle.WaitOne();

                if (this._subdivisionOverride4 == null && allowMultithreading)
                    result4.AsyncWaitHandle.WaitOne();

                if (this._subdivisionOverride5 == null && allowMultithreading)
                    result5.AsyncWaitHandle.WaitOne();

                if (this._subdivisionOverride6 == null && allowMultithreading)
                    result6.AsyncWaitHandle.WaitOne();

                if (this._subdivisionOverride7 == null && allowMultithreading)
                    result7.AsyncWaitHandle.WaitOne();


                // build the tree
                Add(new_top, 1, -1, additions.Stepper(), (int)additions.Length, int.MinValue, int.MinValue, int.MinValue, int.MinValue, int.MinValue, int.MinValue, int.MinValue, (int)additions.Length, (int index) => { return values1[index]; }, (int index) => { return values2[index]; }, (int index) => { return values3[index]; }, (int index) => { return values4[index]; }, (int index) => { return values5[index]; }, (int index) => { return values6[index]; }, (int index) => { return values7[index]; }, allowMultithreading);
                
                this._top = new_top;
            }
        }

        public void Add(bool allowMultithreading, params T[] additions)
        {
            if (additions.Length > int.MaxValue)
                throw new System.Exception("The maximum size of the Omnitree was exceeded during bulk addition.");

            if (this._top.Count != 0 || (int)additions.Length <= _load)
            {
                for (int i = 0; i < additions.Length; i++)
                    this.Add(additions[i]);
            }
            else
            {
                // adjust the loads prior to additions
				Omnitree.ComputeLoads((int)additions.Length, ref _naturalLogLower, ref _naturalLogUpper, ref _load);

                Branch new_top = new Branch(Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>.Default, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>.None, null, -1);
                new_top.Count = (int)additions.Length;


                // prepare data for median computations
                IndexedBigArray<Axis1> values1;
                IAsyncResult result1 = null;
                if (this._subdivisionOverride1 != null)
                    values1 = null;
                else
                {
                    values1 = null;
                    Towel.Parallels.Parallel.Operation operation = () =>
                    {
                        values1 = new IndexedBigArray<Axis1>(additions.Length);
                        for (int i = 0; i < additions.Length; i++)
                            values1[i] = LocateVector(additions[i]).Axis1;
                        Towel.Algorithms.Sort.Merge(this._compare1, (int i) => { return values1[(ulong)i]; }, (int i, Axis1 value) => { values1[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
                    };

                    if (allowMultithreading)
                        result1 = Towel.Parallels.Parallel.Thread(operation);
                    else
                        operation();
                }

                // prepare data for median computations
                IndexedBigArray<Axis2> values2;
                IAsyncResult result2 = null;
                if (this._subdivisionOverride2 != null)
                    values2 = null;
                else
                {
                    values2 = null;
                    Towel.Parallels.Parallel.Operation operation = () =>
                    {
                        values2 = new IndexedBigArray<Axis2>(additions.Length);
                        for (int i = 0; i < additions.Length; i++)
                            values2[i] = LocateVector(additions[i]).Axis2;
                        Towel.Algorithms.Sort.Merge(this._compare2, (int i) => { return values2[(ulong)i]; }, (int i, Axis2 value) => { values2[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
                    };

                    if (allowMultithreading)
                        result2 = Towel.Parallels.Parallel.Thread(operation);
                    else
                        operation();
                }

                // prepare data for median computations
                IndexedBigArray<Axis3> values3;
                IAsyncResult result3 = null;
                if (this._subdivisionOverride3 != null)
                    values3 = null;
                else
                {
                    values3 = null;
                    Towel.Parallels.Parallel.Operation operation = () =>
                    {
                        values3 = new IndexedBigArray<Axis3>(additions.Length);
                        for (int i = 0; i < additions.Length; i++)
                            values3[i] = LocateVector(additions[i]).Axis3;
                        Towel.Algorithms.Sort.Merge(this._compare3, (int i) => { return values3[(ulong)i]; }, (int i, Axis3 value) => { values3[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
                    };

                    if (allowMultithreading)
                        result3 = Towel.Parallels.Parallel.Thread(operation);
                    else
                        operation();
                }

                // prepare data for median computations
                IndexedBigArray<Axis4> values4;
                IAsyncResult result4 = null;
                if (this._subdivisionOverride4 != null)
                    values4 = null;
                else
                {
                    values4 = null;
                    Towel.Parallels.Parallel.Operation operation = () =>
                    {
                        values4 = new IndexedBigArray<Axis4>(additions.Length);
                        for (int i = 0; i < additions.Length; i++)
                            values4[i] = LocateVector(additions[i]).Axis4;
                        Towel.Algorithms.Sort.Merge(this._compare4, (int i) => { return values4[(ulong)i]; }, (int i, Axis4 value) => { values4[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
                    };

                    if (allowMultithreading)
                        result4 = Towel.Parallels.Parallel.Thread(operation);
                    else
                        operation();
                }

                // prepare data for median computations
                IndexedBigArray<Axis5> values5;
                IAsyncResult result5 = null;
                if (this._subdivisionOverride5 != null)
                    values5 = null;
                else
                {
                    values5 = null;
                    Towel.Parallels.Parallel.Operation operation = () =>
                    {
                        values5 = new IndexedBigArray<Axis5>(additions.Length);
                        for (int i = 0; i < additions.Length; i++)
                            values5[i] = LocateVector(additions[i]).Axis5;
                        Towel.Algorithms.Sort.Merge(this._compare5, (int i) => { return values5[(ulong)i]; }, (int i, Axis5 value) => { values5[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
                    };

                    if (allowMultithreading)
                        result5 = Towel.Parallels.Parallel.Thread(operation);
                    else
                        operation();
                }

                // prepare data for median computations
                IndexedBigArray<Axis6> values6;
                IAsyncResult result6 = null;
                if (this._subdivisionOverride6 != null)
                    values6 = null;
                else
                {
                    values6 = null;
                    Towel.Parallels.Parallel.Operation operation = () =>
                    {
                        values6 = new IndexedBigArray<Axis6>(additions.Length);
                        for (int i = 0; i < additions.Length; i++)
                            values6[i] = LocateVector(additions[i]).Axis6;
                        Towel.Algorithms.Sort.Merge(this._compare6, (int i) => { return values6[(ulong)i]; }, (int i, Axis6 value) => { values6[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
                    };

                    if (allowMultithreading)
                        result6 = Towel.Parallels.Parallel.Thread(operation);
                    else
                        operation();
                }

                // prepare data for median computations
                IndexedBigArray<Axis7> values7;
                IAsyncResult result7 = null;
                if (this._subdivisionOverride7 != null)
                    values7 = null;
                else
                {
                    values7 = null;
                    Towel.Parallels.Parallel.Operation operation = () =>
                    {
                        values7 = new IndexedBigArray<Axis7>(additions.Length);
                        for (int i = 0; i < additions.Length; i++)
                            values7[i] = LocateVector(additions[i]).Axis7;
                        Towel.Algorithms.Sort.Merge(this._compare7, (int i) => { return values7[(ulong)i]; }, (int i, Axis7 value) => { values7[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
                    };

                    if (allowMultithreading)
                        result7 = Towel.Parallels.Parallel.Thread(operation);
                    else
                        operation();
                }



                if (this._subdivisionOverride1 == null && allowMultithreading)
                    result1.AsyncWaitHandle.WaitOne();

                if (this._subdivisionOverride2 == null && allowMultithreading)
                    result2.AsyncWaitHandle.WaitOne();

                if (this._subdivisionOverride3 == null && allowMultithreading)
                    result3.AsyncWaitHandle.WaitOne();

                if (this._subdivisionOverride4 == null && allowMultithreading)
                    result4.AsyncWaitHandle.WaitOne();

                if (this._subdivisionOverride5 == null && allowMultithreading)
                    result5.AsyncWaitHandle.WaitOne();

                if (this._subdivisionOverride6 == null && allowMultithreading)
                    result6.AsyncWaitHandle.WaitOne();

                if (this._subdivisionOverride7 == null && allowMultithreading)
                    result7.AsyncWaitHandle.WaitOne();


                // build the tree
                Add(new_top, 1, -1, additions.Stepper(), additions.Length, int.MinValue, int.MinValue, int.MinValue, int.MinValue, int.MinValue, int.MinValue, int.MinValue, (int)additions.Length, (int index) => { return values1[index]; }, (int index) => { return values2[index]; }, (int index) => { return values3[index]; }, (int index) => { return values4[index]; }, (int index) => { return values5[index]; }, (int index) => { return values6[index]; }, (int index) => { return values7[index]; }, allowMultithreading);
                
                this._top = new_top;
            }
        }

        
        private int Add(Branch parent, int depth, int child, Stepper<T> additions, int parent_count, int prevmed1, int prevmed2, int prevmed3, int prevmed4, int prevmed5, int prevmed6, int prevmed7, int initial_count, Get<Axis1> values1, Get<Axis2> values2, Get<Axis3> values3, Get<Axis4> values4, Get<Axis5> values5, Get<Axis6> values6, Get<Axis7> values7, bool allowMultithreading)
        {
            Axis1 pointOfDivision1;
            Axis2 pointOfDivision2;
            Axis3 pointOfDivision3;
            Axis4 pointOfDivision4;
            Axis5 pointOfDivision5;
            Axis6 pointOfDivision6;
            Axis7 pointOfDivision7;

            int median_axis1 = -1;
            int median_axis2 = -1;
            int median_axis3 = -1;
            int median_axis4 = -1;
            int median_axis5 = -1;
            int median_axis6 = -1;
            int median_axis7 = -1;
            if (this._subdivisionOverride1 == null || this._subdivisionOverride2 == null || this._subdivisionOverride3 == null || this._subdivisionOverride4 == null || this._subdivisionOverride5 == null || this._subdivisionOverride6 == null || this._subdivisionOverride7 == null)
                GetMedianIndexes(initial_count, child, depth, prevmed1, prevmed2, prevmed3, prevmed4, prevmed5, prevmed6, prevmed7, out median_axis1, out median_axis2, out median_axis3, out median_axis4, out median_axis5, out median_axis6, out median_axis7);

            if (this._subdivisionOverride1 != null)
                pointOfDivision1 = this._subdivisionOverride1(parent.Bounds, additions);
            else
                pointOfDivision1 = values1(median_axis1);

            if (this._subdivisionOverride2 != null)
                pointOfDivision2 = this._subdivisionOverride2(parent.Bounds, additions);
            else
                pointOfDivision2 = values2(median_axis2);

            if (this._subdivisionOverride3 != null)
                pointOfDivision3 = this._subdivisionOverride3(parent.Bounds, additions);
            else
                pointOfDivision3 = values3(median_axis3);

            if (this._subdivisionOverride4 != null)
                pointOfDivision4 = this._subdivisionOverride4(parent.Bounds, additions);
            else
                pointOfDivision4 = values4(median_axis4);

            if (this._subdivisionOverride5 != null)
                pointOfDivision5 = this._subdivisionOverride5(parent.Bounds, additions);
            else
                pointOfDivision5 = values5(median_axis5);

            if (this._subdivisionOverride6 != null)
                pointOfDivision6 = this._subdivisionOverride6(parent.Bounds, additions);
            else
                pointOfDivision6 = values6(median_axis6);

            if (this._subdivisionOverride7 != null)
                pointOfDivision7 = this._subdivisionOverride7(parent.Bounds, additions);
            else
                pointOfDivision7 = values7(median_axis7);

            parent.PointOfDivision = new Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>(pointOfDivision1, pointOfDivision2, pointOfDivision3, pointOfDivision4, pointOfDivision5, pointOfDivision6, pointOfDivision7);

            // divide the values along the medians
            IMap<IAddable<T>, int> collection_map = new MapHashLinked<IAddable<T>, int>();
            additions((T value) => 
            {
                int index = DetermineChildIndex(parent.PointOfDivision, LocateVector(value));
                IAddable<T> list = null;
                if (collection_map.TryGet(index, out list))
                {
                    list.Add(value);
                }
                else
                {
                    if (parent_count < 100000)
                        list = new AddableArray<T>();
                    else
                        list = new AddableLinked<T>();
                    collection_map.Add(index, list);
                    list.Add(value);
                }
            });

            if (depth == 1 && allowMultithreading)
            {
                // NOTE: Must assign placeholders before multithreading so that the threads do not overwrite each other
                collection_map.Keys((int key) => { parent[key] = new Leaf(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>.None, parent, key); });
                IAsyncResult[] handles = new IAsyncResult[Environment.ProcessorCount];
                for (int i = 0; i < handles.Length; i++)
                {
                    int multiTheadSafe_i = i; // used as catpure variable below making it multithread-safe
                    handles[i] = Towel.Parallels.Parallel.Thread(() =>
                    {
                        Step.EveryNth<Link<IAddable<T>, int>>(collection_map.Pairs, multiTheadSafe_i + 1)(
                        (Link<IAddable<T>, int> link) =>
                            {
                                ReversedChildBuilding(parent, link._2, depth, link._1.Stepper, link._1.Count, median_axis1, median_axis2, median_axis3, median_axis4, median_axis5, median_axis6, median_axis7, initial_count, values1, values2, values3, values4, values5, values6, values7, allowMultithreading);
                            });
                    });
                }
                
                foreach (IAsyncResult handle in handles)
                {
                    handle.AsyncWaitHandle.WaitOne();
                }
            }
            else
            {
                collection_map.Pairs((Link<IAddable<T>, int> link) =>
                { 
                    ReversedChildBuilding(parent, link._2, depth, link._1.Stepper, link._1.Count, median_axis1, median_axis2, median_axis3, median_axis4, median_axis5, median_axis6, median_axis7, initial_count, values1, values2, values3, values4, values5, values6, values7, allowMultithreading);
                });
            }

            int count = 0;
            foreach (Node node in parent.Children)
                count += node.Count;
            return count;
        }

        int ReversedChildBuilding(Branch parent, int child_index, int depth, Stepper<T> additions, int count, int prevmed1, int prevmed2, int prevmed3, int prevmed4, int prevmed5, int prevmed6, int prevmed7, int initial_count, Get<Axis1> values1, Get<Axis2> values2, Get<Axis3> values3, Get<Axis4> values4, Get<Axis5> values5, Get<Axis6> values6, Get<Axis7> values7, bool allowMultithreading)
        {
            Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> child_bounds = DetermineChildBounds(parent, child_index);
            if (depth >= _load || count <= _load)
            {
                Leaf new_leaf = new Leaf(child_bounds, parent, child_index);
                additions((T value) => { new_leaf.Add(value); });
                parent[new_leaf.Index] = new_leaf;
                return new_leaf.Count;
            }
            else
            {
                Branch new_branch = new Branch(Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>.Default, child_bounds, parent, child_index);
                parent[new_branch.Index] = new_branch;
                new_branch.Count = Add(new_branch, depth + 1, child_index, additions, count, prevmed1, prevmed2, prevmed3, prevmed4, prevmed5, prevmed6, prevmed7, count, values1, values2, values3, values4, values5, values6, values7, allowMultithreading);
                return new_branch.Count;
            }
        }

        /// <summary>Gets the indeces of the median values at the given position during bulk additions.</summary>
        private void GetMedianIndexes(int count, int child_index, int depth, int previous1, int previous2, int previous3, int previous4, int previous5, int previous6, int previous7, out int index1, out int index2, out int index3, out int index4, out int index5, out int index6, out int index7)
        {
            if (depth == 1)
            {
                index1 = (count - 1) / 2;
                index2 = (count - 1) / 2;
                index3 = (count - 1) / 2;
                index4 = (count - 1) / 2;
                index5 = (count - 1) / 2;
                index6 = (count - 1) / 2;
                index7 = (count - 1) / 2;
                return;
            }

            int splits = Compute.Power(2, depth);
            int mid_child_range = count / splits;

            if (child_index >= 64)
            {
                index7 = previous7 + mid_child_range;
                child_index -= 64;
            }
            else
            {
                index7 = previous7 - mid_child_range;
            }

            if (child_index >= 32)
            {
                index6 = previous6 + mid_child_range;
                child_index -= 32;
            }
            else
            {
                index6 = previous6 - mid_child_range;
            }

            if (child_index >= 16)
            {
                index5 = previous5 + mid_child_range;
                child_index -= 16;
            }
            else
            {
                index5 = previous5 - mid_child_range;
            }

            if (child_index >= 8)
            {
                index4 = previous4 + mid_child_range;
                child_index -= 8;
            }
            else
            {
                index4 = previous4 - mid_child_range;
            }

            if (child_index >= 4)
            {
                index3 = previous3 + mid_child_range;
                child_index -= 4;
            }
            else
            {
                index3 = previous3 - mid_child_range;
            }

            if (child_index >= 2)
            {
                index2 = previous2 + mid_child_range;
                child_index -= 2;
            }
            else
            {
                index2 = previous2 - mid_child_range;
            }

            if (child_index >= 1)
            {
                index1 = previous1 + mid_child_range;
                child_index -= 1;
            }
            else
            {
                index1 = previous1 - mid_child_range;
            }

        }

        #endregion

        #region single

        /// <summary>Adds an item to the tree.</summary>
        /// <param name="addition">The item to be added.</param>
        public void Add(T addition)
        {
            if (this._top.Count == int.MaxValue)
                throw new System.InvalidOperationException("(Count == int.MaxValue) max Omnitree size reached (change ints to longs if you need to).");

            // dynamic tree sizes
			Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);

            Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> location = LocateVector(addition);

            // grow the first branch of the tree
            if (this._top is Leaf && (this._top as Leaf).Count >= _load)
            {
                Leaf top = this._top as Leaf;

                // create the new branch from the median values
                this._top = new Branch(DetermineMedians(top), Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>.None, null, -1);

                // iterate through the elements and add them to the appropriate children
                for (Leaf.Node list = top.Head; list != null; list = list.Next)
                    Add(list.Value, this._top, LocateVector(list.Value), 0);
            }

            this.Add(addition, this._top, location, 0);
        }
        
        /// <summary>Recursive version of the add function.</summary>
        /// <param name="addition">The item to be added.</param>
        /// <param name="node">The current node for tree trversal.</param>
        /// <param name="ms">The location of the addition.</param>
        /// <param name="depth">The current depth of iteration.</param>
        private void Add(T addition, Node node, Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> location, int depth)
        {
            if (node is Leaf)
            {
                Leaf leaf = node as Leaf;
                if (depth >= _load || !(leaf.Count >= _load))
                {
                    leaf.Add(addition);
                    return;
                }
                else
                {
                    Branch parent = node.Parent;
                    int child_index = this.DetermineChildIndex(parent.PointOfDivision, location);
                    Branch growth = new Branch(DetermineMedians(leaf), leaf.Bounds, parent, child_index);
                    parent[child_index] = growth;
                    for (Leaf.Node list = leaf.Head; list != null; list = list.Next)
                    {
                        Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> temp_location = LocateVector(list.Value);
                        if (EncapsulationCheck(growth.Bounds, temp_location))
                            Add(list.Value, growth, temp_location, depth);
                        else
                        {
                            ReduceParentCounts(parent, 1);
                            Add(list.Value, this._top, temp_location, depth);
                        }
                    }

                    Add(addition, growth, location, depth);
                    return;
                }
            }
            else
            {
                Branch branch = node as Branch;
                int child_index = this.DetermineChildIndex(branch.PointOfDivision, location); // determine the child "index" (0 through 2^Dimensions) the addition belongs in
                Node child_node = branch[child_index];

                // null children in branches are just empty leaves
                if (child_node == null)
                {
                    Leaf new_leaf = new Leaf(DetermineChildBounds(branch, child_index), branch, child_index);
                    branch[child_index] = new_leaf;
                    new_leaf.Add(addition);
                }
                else
                    // child exists already, continue adding
                    Add(addition, child_node, location, depth + 1);

                branch.Count++;
                return;
            }
        }

        /// <summary>Determins the dimensions of the child at the given index.</summary>
        /// <param name="leaf">The parent of the node to compute dimensions for.</param>
        /// <param name="child">The index of the child to compute dimensions for.</param>
        /// <param name="median1">The computed minimum dimensions of the child node along the 1D axis.</param>
        /// <param name="median2">The computed minimum dimensions of the child node along the 2D axis.</param>
        /// <param name="median3">The computed minimum dimensions of the child node along the 3D axis.</param>
        private Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> DetermineMedians(Leaf leaf)
        {
            try
            {
                // extract the values
                Axis1[] values1 = new Axis1[leaf.Count];
                Axis2[] values2 = new Axis2[leaf.Count];
                Axis3[] values3 = new Axis3[leaf.Count];
                Axis4[] values4 = new Axis4[leaf.Count];
                Axis5[] values5 = new Axis5[leaf.Count];
                Axis6[] values6 = new Axis6[leaf.Count];
                Axis7[] values7 = new Axis7[leaf.Count];
                Leaf.Node for_current = leaf.Head; // used in for loop
                for (int i = 0; i < leaf.Count; i++, for_current = for_current.Next)
                    this._locate(for_current.Value, out values1[i], out values2[i], out values3[i], out values4[i], out values5[i], out values6[i], out values7[i]);
                // sort the values
                if (_defaultCompare1) Array.Sort(values1);
                else Array.Sort(values1, Compare.ToSystemComparison(this._compare1));
                if (_defaultCompare2) Array.Sort(values2);
                else Array.Sort(values2, Compare.ToSystemComparison(this._compare2));
                if (_defaultCompare3) Array.Sort(values3);
                else Array.Sort(values3, Compare.ToSystemComparison(this._compare3));
                if (_defaultCompare4) Array.Sort(values4);
                else Array.Sort(values4, Compare.ToSystemComparison(this._compare4));
                if (_defaultCompare5) Array.Sort(values5);
                else Array.Sort(values5, Compare.ToSystemComparison(this._compare5));
                if (_defaultCompare6) Array.Sort(values6);
                else Array.Sort(values6, Compare.ToSystemComparison(this._compare6));
                if (_defaultCompare7) Array.Sort(values7);
                else Array.Sort(values7, Compare.ToSystemComparison(this._compare7));
                // pull out the lazy medians (if even # of items... just take the left)
                int index = (leaf.Count - 1) / 2;
                return new Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>(values1[index], values2[index], values3[index], values4[index], values5[index], values6[index], values7[index]);
            }
            catch (Exception exception)
            {
				System.Diagnostics.Debugger.Break();
                // extract the values
                IndexedBigArray<Axis1> values1 = new IndexedBigArray<Axis1>(leaf.Count);
                IndexedBigArray<Axis2> values2 = new IndexedBigArray<Axis2>(leaf.Count);
                IndexedBigArray<Axis3> values3 = new IndexedBigArray<Axis3>(leaf.Count);
                IndexedBigArray<Axis4> values4 = new IndexedBigArray<Axis4>(leaf.Count);
                IndexedBigArray<Axis5> values5 = new IndexedBigArray<Axis5>(leaf.Count);
                IndexedBigArray<Axis6> values6 = new IndexedBigArray<Axis6>(leaf.Count);
                IndexedBigArray<Axis7> values7 = new IndexedBigArray<Axis7>(leaf.Count);
                Leaf.Node for_current = leaf.Head; // used in for loop
                for (int i = 0; i < leaf.Count; i++, for_current = for_current.Next)
                {
                    Axis1 value1;
                    Axis2 value2;
                    Axis3 value3;
                    Axis4 value4;
                    Axis5 value5;
                    Axis6 value6;
                    Axis7 value7;
                    this._locate(for_current.Value, out value1, out value2, out value3, out value4, out value5, out value6, out value7);
                    values1[i] = value1;
                    values2[i] = value2;
                    values3[i] = value3;
                    values4[i] = value4;
                    values5[i] = value5;
                    values6[i] = value6;
                    values7[i] = value7;
                }
                // sort the values
                if (_defaultCompare1) Towel.Algorithms.Sort.Merge(Compare.Default, (int sorting_index) => { return values1[sorting_index]; }, (int sorting_index, Axis1 axis1) => { values1[sorting_index] = axis1; }, 0, (int)values1.Length);
                else Towel.Algorithms.Sort.Merge(_compare1, (int sorting_index) => { return values1[sorting_index]; }, (int sorting_index, Axis1 axis1) => { values1[sorting_index] = axis1; }, 0, (int)values1.Length);
                if (_defaultCompare2) Towel.Algorithms.Sort.Merge(Compare.Default, (int sorting_index) => { return values2[sorting_index]; }, (int sorting_index, Axis2 axis2) => { values2[sorting_index] = axis2; }, 0, (int)values1.Length);
                else Towel.Algorithms.Sort.Merge(_compare2, (int sorting_index) => { return values2[sorting_index]; }, (int sorting_index, Axis2 axis2) => { values2[sorting_index] = axis2; }, 0, (int)values1.Length);
                if (_defaultCompare3) Towel.Algorithms.Sort.Merge(Compare.Default, (int sorting_index) => { return values3[sorting_index]; }, (int sorting_index, Axis3 axis3) => { values3[sorting_index] = axis3; }, 0, (int)values1.Length);
                else Towel.Algorithms.Sort.Merge(_compare3, (int sorting_index) => { return values3[sorting_index]; }, (int sorting_index, Axis3 axis3) => { values3[sorting_index] = axis3; }, 0, (int)values1.Length);
                if (_defaultCompare4) Towel.Algorithms.Sort.Merge(Compare.Default, (int sorting_index) => { return values4[sorting_index]; }, (int sorting_index, Axis4 axis4) => { values4[sorting_index] = axis4; }, 0, (int)values1.Length);
                else Towel.Algorithms.Sort.Merge(_compare4, (int sorting_index) => { return values4[sorting_index]; }, (int sorting_index, Axis4 axis4) => { values4[sorting_index] = axis4; }, 0, (int)values1.Length);
                if (_defaultCompare5) Towel.Algorithms.Sort.Merge(Compare.Default, (int sorting_index) => { return values5[sorting_index]; }, (int sorting_index, Axis5 axis5) => { values5[sorting_index] = axis5; }, 0, (int)values1.Length);
                else Towel.Algorithms.Sort.Merge(_compare5, (int sorting_index) => { return values5[sorting_index]; }, (int sorting_index, Axis5 axis5) => { values5[sorting_index] = axis5; }, 0, (int)values1.Length);
                if (_defaultCompare6) Towel.Algorithms.Sort.Merge(Compare.Default, (int sorting_index) => { return values6[sorting_index]; }, (int sorting_index, Axis6 axis6) => { values6[sorting_index] = axis6; }, 0, (int)values1.Length);
                else Towel.Algorithms.Sort.Merge(_compare6, (int sorting_index) => { return values6[sorting_index]; }, (int sorting_index, Axis6 axis6) => { values6[sorting_index] = axis6; }, 0, (int)values1.Length);
                if (_defaultCompare7) Towel.Algorithms.Sort.Merge(Compare.Default, (int sorting_index) => { return values7[sorting_index]; }, (int sorting_index, Axis7 axis7) => { values7[sorting_index] = axis7; }, 0, (int)values1.Length);
                else Towel.Algorithms.Sort.Merge(_compare7, (int sorting_index) => { return values7[sorting_index]; }, (int sorting_index, Axis7 axis7) => { values7[sorting_index] = axis7; }, 0, (int)values1.Length);
                // pull out the lazy medians (if even # of items... just take the left)
                int index = (leaf.Count - 1) / 2;
                return new Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>(values1[index], values2[index], values3[index], values4[index], values5[index], values6[index], values7[index]);
            }
        }

        #endregion

        #region Add Helpers

        private Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> DetermineChildBounds(Branch branch, int child_index)
        {

            Omnitree.Bound<Axis7> min7, max7;
            if (child_index >= 64)
            {
                min7 = branch.PointOfDivision.Axis7;
                max7 = branch.Bounds.Max7;
                child_index -= 64;
            }
            else
            {
                min7 = branch.Bounds.Min7;
                max7 = branch.PointOfDivision.Axis7;
            }

            Omnitree.Bound<Axis6> min6, max6;
            if (child_index >= 32)
            {
                min6 = branch.PointOfDivision.Axis6;
                max6 = branch.Bounds.Max6;
                child_index -= 32;
            }
            else
            {
                min6 = branch.Bounds.Min6;
                max6 = branch.PointOfDivision.Axis6;
            }

            Omnitree.Bound<Axis5> min5, max5;
            if (child_index >= 16)
            {
                min5 = branch.PointOfDivision.Axis5;
                max5 = branch.Bounds.Max5;
                child_index -= 16;
            }
            else
            {
                min5 = branch.Bounds.Min5;
                max5 = branch.PointOfDivision.Axis5;
            }

            Omnitree.Bound<Axis4> min4, max4;
            if (child_index >= 8)
            {
                min4 = branch.PointOfDivision.Axis4;
                max4 = branch.Bounds.Max4;
                child_index -= 8;
            }
            else
            {
                min4 = branch.Bounds.Min4;
                max4 = branch.PointOfDivision.Axis4;
            }

            Omnitree.Bound<Axis3> min3, max3;
            if (child_index >= 4)
            {
                min3 = branch.PointOfDivision.Axis3;
                max3 = branch.Bounds.Max3;
                child_index -= 4;
            }
            else
            {
                min3 = branch.Bounds.Min3;
                max3 = branch.PointOfDivision.Axis3;
            }

            Omnitree.Bound<Axis2> min2, max2;
            if (child_index >= 2)
            {
                min2 = branch.PointOfDivision.Axis2;
                max2 = branch.Bounds.Max2;
                child_index -= 2;
            }
            else
            {
                min2 = branch.Bounds.Min2;
                max2 = branch.PointOfDivision.Axis2;
            }

            Omnitree.Bound<Axis1> min1, max1;
            if (child_index >= 1)
            {
                min1 = branch.PointOfDivision.Axis1;
                max1 = branch.Bounds.Max1;
                child_index -= 1;
            }
            else
            {
                min1 = branch.Bounds.Min1;
                max1 = branch.PointOfDivision.Axis1;
            }

            return new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6, min7, max7);
        }

        #endregion

        #endregion

        #region Clear

        /// <summary>Returns the tree to an empty state.</summary>
        public void Clear()
        {
            this._top = new Leaf(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>.None, null, -1);
			Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
        }

        #endregion

        #region Clone

        /// <summary>Creates a shallow clone of this data structure.</summary>
        /// <returns>A shallow clone of this data structure.</returns>
        public OmnitreePointsLinked<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> Clone()
        {
            return new OmnitreePointsLinked<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>(this);
        }

        #endregion

        #region Count

        /// <summary>Counts the number of items in a sub space.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		/// <param name="min7">The minimum coordinate of the space along the 7 axis.</param>
		/// <param name="max7">The maximum coordinate of the space along the 7 axis.</param>
        /// <returns>The number of items in the provided sub space.</returns>
        public int CountSubSpace(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5, Axis6 min6, Axis6 max6, Axis7 min7, Axis7 max7)
        {
            return CountSubSpace(_top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6, min7, max7));
        }
        /// <summary>Counts the number of items in a sub space.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		/// <param name="min7">The minimum coordinate of the space along the 7 axis.</param>
		/// <param name="max7">The maximum coordinate of the space along the 7 axis.</param>
        /// <returns>The number of items in the provided sub space.</returns>
        public int CountSubSpace(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5, Omnitree.Bound<Axis6> min6, Omnitree.Bound<Axis6> max6, Omnitree.Bound<Axis7> min7, Omnitree.Bound<Axis7> max7)
        {
            return CountSubSpace(_top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6, min7, max7));
        }
        /// <summary>Counts the number of items in a sub space.</summary>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
		/// <param name="axis5">The coordinate along the 5D axis.</param>
		/// <param name="axis6">The coordinate along the 6D axis.</param>
		/// <param name="axis7">The coordinate along the 7D axis.</param>
        /// <returns>The number of items in the provided sub space.</returns>
        public int CountSubSpace(Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Axis5 axis5, Axis6 axis6, Axis7 axis7)
        {
            return CountSubSpace(_top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>(axis1, axis1, axis2, axis2, axis3, axis3, axis4, axis4, axis5, axis5, axis6, axis6, axis7, axis7));
        }
        /// <summary>Counts the number of items in a sub space.</summary>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
		/// <param name="axis5">The coordinate along the 5D axis.</param>
		/// <param name="axis6">The coordinate along the 6D axis.</param>
		/// <param name="axis7">The coordinate along the 7D axis.</param>
        /// <returns>The number of items in the provided sub space.</returns>
        public int CountSubSpace(Omnitree.Bound<Axis1> axis1, Omnitree.Bound<Axis2> axis2, Omnitree.Bound<Axis3> axis3, Omnitree.Bound<Axis4> axis4, Omnitree.Bound<Axis5> axis5, Omnitree.Bound<Axis6> axis6, Omnitree.Bound<Axis7> axis7)
        {
            return CountSubSpace(_top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>(axis1, axis1, axis2, axis2, axis3, axis3, axis4, axis4, axis5, axis5, axis6, axis6, axis7, axis7));
        }
        /// <summary>Counts the number of items in a sub space.</summary>
        /// <param name="node">The current traversal node.</param>
        /// <returns>The number of items in the provided sub space.</returns>
        private int CountSubSpace(Node node, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> bounds)
        {
            // adjust min/max values
            int count = 0;
            if (EncapsulationCheck(bounds, node.Bounds))
                count += node.Count;
            else if (node is Leaf)
            {
                for (Leaf.Node list = (node as Leaf).Head; list != null; list = list.Next)
                    if (EncapsulationCheck(bounds, LocateVector(list.Value)))
                        count++;
            }
            else
            {
                Branch branch = node as Branch;
                if (!StraddlesLines(branch.Bounds, branch.PointOfDivision))
                {
                    int child_index = DetermineChildIndex(branch.PointOfDivision, new Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>(bounds.Min1.Value, bounds.Min2.Value, bounds.Min3.Value, bounds.Min4.Value, bounds.Min5.Value, bounds.Min6.Value, bounds.Min7.Value));
                    Node child = branch[child_index];
                    if (child != null)
                      count += this.CountSubSpace(child, bounds);
                }
                else
                {
                    foreach (Node child in (node as Branch).Children)
                        count += this.CountSubSpace(child, bounds);
                }
            }
            return count;
        }

        #endregion

        #region Update

        /// <summary>Iterates through the entire tree and ensures each item is in the proper leaf.</summary>
        public void Update()
        {
            this.Update(this._top, 0);
        }

        /// <summary>Recursive version of the Update method.</summary>
        /// <param name="node">The current node of iteration.</param>
        /// <param name="depth">The current depth of iteration.</param>
        private int Update(Node node, int depth)
        {
            int removals = 0;

            if (node is Leaf)
            {
                Leaf leaf = node as Leaf;
                Leaf.Node current = leaf.Head;
                Leaf.Node previous = null;
                while (current != null)
                {
                    Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> location = LocateVector(current.Value);
                    if (!this.EncapsulationCheck(node.Bounds, location))
                    {
                        removals++;
                        T updated = current.Value;
                        if (previous == null)
                        {
                            leaf.Head = current.Next;
                            goto HeadRemoved;
                        }
                        else
                            previous.Next = current.Next;

                        Node whereToAdd = GetEncapsulationParent(node.Parent, location);

                        if (whereToAdd == null)
                            throw new System.Exception("an item was updated outside the range of the omnitree");

                        this.Add(updated, whereToAdd, location, whereToAdd.Depth);
                    }
                    previous = current;
                HeadRemoved:
                    current = current.Next;
                }
                leaf.Count -= removals;
                return removals;
            }
            else
            {
                Branch branch = node as Branch;
                int skipped = 0;
                for (int i = 0; i + skipped < branch.Children.Length; )
                {
                    removals += this.Update(branch.Children[i], depth + 1);
                    if (branch.Children[i].Count == 0)
                        branch.Children[i] = branch.Children[branch.Children.Length - skipped++ - 1];
                    else
                        i++;
                }
                Node[] newArray = new Node[branch.Children.Length - skipped];
                Array.Copy(branch.Children, newArray, newArray.Length);
                branch.Children = newArray;

                branch.Count -= removals;

                if (branch.Count < _load && branch.Count != 0)
                    ShrinkChild(branch.Parent, branch.Index);
            }

            return removals;
        }

        /// <summary>Iterates through the provided dimensions and ensures each item is in the proper leaf.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		/// <param name="min7">The minimum coordinate of the space along the 7 axis.</param>
		/// <param name="max7">The maximum coordinate of the space along the 7 axis.</param>
        public void Update(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5, Axis6 min6, Axis6 max6, Axis7 min7, Axis7 max7)
        {
            this.Update(new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6, min7, max7), this._top, 0);
        }
        /// <summary>Iterates through the provided dimensions and ensures each item is in the proper leaf.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		/// <param name="min7">The minimum coordinate of the space along the 7 axis.</param>
		/// <param name="max7">The maximum coordinate of the space along the 7 axis.</param>
        public void Update(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5, Omnitree.Bound<Axis6> min6, Omnitree.Bound<Axis6> max6, Omnitree.Bound<Axis7> min7, Omnitree.Bound<Axis7> max7)
        {
            this.Update(new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6, min7, max7), this._top, 0);
        }
        /// <summary>Iterates through the provided dimensions and ensures each item is in the proper leaf.</summary>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
		/// <param name="axis5">The coordinate along the 5D axis.</param>
		/// <param name="axis6">The coordinate along the 6D axis.</param>
		/// <param name="axis7">The coordinate along the 7D axis.</param>
        public void Update(Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Axis5 axis5, Axis6 axis6, Axis7 axis7)
        {
            this.Update(new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>(axis1, axis1, axis2, axis2, axis3, axis3, axis4, axis4, axis5, axis5, axis6, axis6, axis7, axis7), this._top, 0);
        }
        /// <summary>Iterates through the provided dimensions and ensures each item is in the proper leaf.</summary>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
		/// <param name="axis5">The coordinate along the 5D axis.</param>
		/// <param name="axis6">The coordinate along the 6D axis.</param>
		/// <param name="axis7">The coordinate along the 7D axis.</param>
        public void Update(Omnitree.Bound<Axis1> axis1, Omnitree.Bound<Axis2> axis2, Omnitree.Bound<Axis3> axis3, Omnitree.Bound<Axis4> axis4, Omnitree.Bound<Axis5> axis5, Omnitree.Bound<Axis6> axis6, Omnitree.Bound<Axis7> axis7)
        {
            this.Update(new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>(axis1, axis1, axis2, axis2, axis3, axis3, axis4, axis4, axis5, axis5, axis6, axis6, axis7, axis7), this._top, 0);
        }
        private int Update(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> bounds, Node node, int depth)
        {
            if (!InclusionCheck(bounds, node.Bounds))
                return 0;

            int removals = 0;

            if (node is Leaf)
            {
                Leaf leaf = node as Leaf;
                Leaf.Node current = leaf.Head;
                Leaf.Node previous = null;
                while (current != null)
                {
                    Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> location = LocateVector(current.Value);
                    if (!this.EncapsulationCheck(node.Bounds, location))
                    {
                        removals++;
                        T updated = current.Value;
                        if (previous == null)
                        {
                            leaf.Head = current.Next;
                            goto HeadRemoved;
                        }
                        else
                            previous.Next = current.Next;
                        Node whereToAdd = GetEncapsulationParent(node.Parent, location);
                        if (whereToAdd == null)
                            throw new System.Exception("an item was updates outside the range of the omnitree");
                        this.Add(updated, whereToAdd, location, whereToAdd.Depth);
                    }
                    previous = current;
                HeadRemoved:
                    current = current.Next;
                }
                leaf.Count -= removals;
                return removals;
            }
            else
            {
                Branch branch = node as Branch;
                int skipped = 0;
                for (int i = 0; i + skipped < branch.Children.Length; )
                {
                    removals += this.Update(branch.Children[i], depth + 1);
                    if (branch.Children[i].Count == 0)
                        branch.Children[i] = branch.Children[branch.Children.Length - skipped++ - 1];
                    else
                        i++;
                }
                Node[] newArray = new Node[branch.Children.Length - skipped];
                Array.Copy(branch.Children, newArray, newArray.Length);
                branch.Children = newArray;

                branch.Count -= removals;

                if (branch.Count < _load && branch.Count != 0)
                    ShrinkChild(branch.Parent, branch.Index);
            }

            return removals;
        }

        #endregion

        #region Remove

        /// <summary>Removes all the items qualified by the delegate.</summary>
        /// <param name="where">The predicate to qualify removals.</param>
        public void Remove(Predicate<T> where)
        {
            this.Remove(this._top, where);
			Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
        }

        /// <summary>Recursive version of the remove method.</summary>
        /// <param name="node">The current node of traversal.</param>
        /// <param name="where">The predicate to qualify removals.</param>
        private int Remove(Node node, Predicate<T> where)
        {
            int removals = 0;
            if (node is Leaf)
            {
                Leaf leaf = node as Leaf;
                while (leaf.Head != null && where(leaf.Head.Value))
                {
                    leaf.Head = leaf.Head.Next;
                    removals++;
                }
                if (leaf.Head != null)
                {
                    Leaf.Node list = leaf.Head;
                    while (list.Next != null)
                    {
                        if (where(list.Next.Value))
                        {
                            list.Next = list.Next.Next;
                            removals++;
                        }
                    }
                }

                leaf.Count -= removals;
                return removals;
            }
            else
            {
                Branch branch = node as Branch;
                int skipped = 0;
                for (int i = 0; i + skipped < branch.Children.Length; )
                {
                    removals += this.Remove(branch.Children[i], where);
                    if (branch.Children[i].Count == 0)
                        branch.Children[i] = branch.Children[branch.Children.Length - skipped++ - 1];
                    else
                        i++;
                }
                Node[] newArray = new Node[branch.Children.Length - skipped];
                Array.Copy(branch.Children, newArray, newArray.Length);
                branch.Children = newArray;

                branch.Count -= removals;

                if (branch.Count < _load && branch.Count != 0)
                    ShrinkChild(branch.Parent, branch.Index);

                return removals;
            }
        }

        /// <summary>Removes all the items in a given space.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		/// <param name="min7">The minimum coordinate of the space along the 7 axis.</param>
		/// <param name="max7">The maximum coordinate of the space along the 7 axis.</param>
        /// <returns>The number of items that were removed.</returns>
        public void Remove(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5, Axis6 min6, Axis6 max6, Axis7 min7, Axis7 max7)
        {
            this.Remove(this._top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6, min7, max7));
            Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
        }
        /// <summary>Removes all the items in a given space.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		/// <param name="min7">The minimum coordinate of the space along the 7 axis.</param>
		/// <param name="max7">The maximum coordinate of the space along the 7 axis.</param>
        /// <returns>The number of items that were removed.</returns>
        public void Remove(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5, Omnitree.Bound<Axis6> min6, Omnitree.Bound<Axis6> max6, Omnitree.Bound<Axis7> min7, Omnitree.Bound<Axis7> max7)
        {
            this.Remove(this._top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6, min7, max7));
            Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
        }
        private int Remove(Node node, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> bounds)
        {
            int removals = 0;
            if (InclusionCheck(bounds, node.Bounds))
            {
                if (node is Leaf)
                {
                    Leaf leaf = node as Leaf;
                    Leaf.Node current_node = leaf.Head;
                    Leaf.Node previous_node = null;
                    while (current_node != null)
                    {
                        Leaf.Node temp_previous = current_node;
                        if (EncapsulationCheck(bounds, LocateVector(current_node.Value)))
                        {
                            removals++;
                            if (current_node == leaf.Head)
                                leaf.Head = leaf.Head.Next;
                            else
                            {
                                previous_node.Next = current_node.Next;
                                temp_previous = previous_node;
                            }
                        }
                        previous_node = temp_previous;
                        current_node = current_node.Next;
                    }
                    leaf.Count -= removals;
                }
                else
                {
                    Branch branch = node as Branch;
                    int skipped = 0;
                    for (int i = 0; i + skipped < branch.Children.Length; )
                    {
                        removals += this.Remove(branch.Children[i], bounds);
                        if (branch.Children[i].Count == 0)
                            branch.Children[i] = branch.Children[branch.Children.Length - skipped++ - 1];
                        else
                            i++;
                    }
                    Node[] newArray = new Node[branch.Children.Length - skipped];
                    Array.Copy(branch.Children, newArray, newArray.Length);
                    branch.Children = newArray;

                    branch.Count -= removals;
                    // convert this branch back into a leaf
                    // Note: if count is zero, it will be chopped off
                    if (branch.Count < _load && branch.Count > 0)
                        ShrinkChild(branch.Parent, branch.Index);
                }
            }

            return removals;
        }

        /// <summary>Removes all the items in a given space validated by a predicate.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		/// <param name="min7">The minimum coordinate of the space along the 7 axis.</param>
		/// <param name="max7">The maximum coordinate of the space along the 7 axis.</param>
        /// <param name="where">The equality constraint of the removal.</param>
        public void Remove(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5, Axis6 min6, Axis6 max6, Axis7 min7, Axis7 max7, Predicate<T> where)
        {
            this.Remove(this._top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6, min7, max7), where);
            Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
        }
        /// <summary>Removes all the items in a given space validated by a predicate.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		/// <param name="min7">The minimum coordinate of the space along the 7 axis.</param>
		/// <param name="max7">The maximum coordinate of the space along the 7 axis.</param>
        /// <param name="where">The equality constraint of the removal.</param>
        public void Remove(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5, Omnitree.Bound<Axis6> min6, Omnitree.Bound<Axis6> max6, Omnitree.Bound<Axis7> min7, Omnitree.Bound<Axis7> max7, Predicate<T> where)
        {
            this.Remove(this._top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6, min7, max7), where);
			Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
        }
        private int Remove(Node node, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> bounds, Predicate<T> where)
        {
            if (!InclusionCheck(node.Bounds, bounds))
                return 0;
            int removals = 0;
            if (node is Leaf)
            {
                Leaf leaf = node as Leaf;
                Leaf.Node current = leaf.Head;
                Leaf.Node previous = null;
                while (current != null)
                {
                    if (this.EncapsulationCheck(bounds, LocateVector(current.Value)) && where(current.Value))
                    {
                        removals++;
                        if (previous == null)
                        {
                            leaf.Head = current.Next;
                            goto HeadRemoved;
                        }
                        else
                            previous.Next = current.Next;
                    }
                    previous = current;
                HeadRemoved:
                    current = current.Next;
                }

                leaf.Count -= removals;
                return removals;
            }
            else
            {
                Branch branch = node as Branch;
                int skipped = 0;
                for (int i = 0; i + skipped < branch.Children.Length; )
                {
                    removals += this.Remove(branch.Children[i], bounds, where);
                    if (branch.Children[i].Count == 0)
                        branch.Children[i] = branch.Children[branch.Children.Length - skipped++ - 1];
                    else
                        i++;
                }
                Node[] newArray = new Node[branch.Children.Length - skipped];
                Array.Copy(branch.Children, newArray, newArray.Length);
                branch.Children = newArray;

                node.Count -= removals;

                if (node.Count < _load && node.Count != 0)
                    ShrinkChild(node.Parent, node.Index);

                return removals;
            }
        }

        /// <summary>Removes all instances of a given value.</summary>
        public void Remove(T removal)
        {
            Axis1 axis1;
            Axis2 axis2;
            Axis3 axis3;
            Axis4 axis4;
            Axis5 axis5;
            Axis6 axis6;
            Axis7 axis7;
            this._locate(removal, out axis1, out axis2, out axis3, out axis4, out axis5, out axis6, out axis7);
            this.Remove(axis1, axis2, axis3, axis4, axis5, axis6, axis7, (T item) => { return this._equate(item, removal); });
        }
        /// <summary>Removes all the items in a given space.</summary>
        /// <param name="axis1">The axis of the removal along the  1D axis.</param>
		/// <param name="axis2">The axis of the removal along the  2D axis.</param>
		/// <param name="axis3">The axis of the removal along the  3D axis.</param>
		/// <param name="axis4">The axis of the removal along the  4D axis.</param>
		/// <param name="axis5">The axis of the removal along the  5D axis.</param>
		/// <param name="axis6">The axis of the removal along the  6D axis.</param>
		/// <param name="axis7">The axis of the removal along the  7D axis.</param>
        /// <returns>The number of items that were removed.</returns>
        public void Remove(Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Axis5 axis5, Axis6 axis6, Axis7 axis7)
        {
            this.Remove(this._top, new Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>(axis1, axis2, axis3, axis4, axis5, axis6, axis7));
            Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
        }
        private int Remove(Node node, Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> vector)
        {
            int removals = 0;
            if (node is Leaf)
            {
                Leaf leaf = node as Leaf;
                Leaf.Node current_node = leaf.Head;
                Leaf.Node previous_node = null;
                while (current_node != null)
                {
                    Leaf.Node temp_previous = current_node;
                    if (EqualsCheck(vector, LocateVector(current_node.Value)))
                    {
                        removals++;
                        if (current_node == leaf.Head)
                            leaf.Head = leaf.Head.Next;
                        else
                        {
                            previous_node.Next = current_node.Next;
                            temp_previous = previous_node;
                        }
                    }
                    previous_node = temp_previous;
                    current_node = current_node.Next;
                }
                leaf.Count -= removals;
            }
            else
            {
                Branch branch = node as Branch;
                int child_index = DetermineChildIndex(branch.PointOfDivision, vector);
                removals += Remove(branch[child_index], vector);
                branch.Count -= removals;
                // convert this branch back into a leaf
                // Note: if count is zero, it will be chopped off
                if (branch.Count < _load && branch.Count > 0)
                    ShrinkChild(branch.Parent, branch.Index);
            }

            return removals;
        }

        /// <summary>Removes all the items in a given space validated by a predicate.</summary>
        /// <param name="axis1">The axis of the removal along the  1D axis.</param>
		/// <param name="axis2">The axis of the removal along the  2D axis.</param>
		/// <param name="axis3">The axis of the removal along the  3D axis.</param>
		/// <param name="axis4">The axis of the removal along the  4D axis.</param>
		/// <param name="axis5">The axis of the removal along the  5D axis.</param>
		/// <param name="axis6">The axis of the removal along the  6D axis.</param>
		/// <param name="axis7">The axis of the removal along the  7D axis.</param>
        /// <param name="where">The equality constraint of the removal.</param>
        public void Remove(Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Axis5 axis5, Axis6 axis6, Axis7 axis7, Predicate<T> where)
        {
            this.Remove(this._top, new Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>(axis1, axis2, axis3, axis4, axis5, axis6, axis7), where);
            Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
        }
        private int Remove(Node node, Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> vector, Predicate<T> where)
        {
            int removals = 0;
            if (node is Leaf)
            {
                Leaf leaf = node as Leaf;
                Leaf.Node current_node = leaf.Head;
                Leaf.Node previous_node = null;
                while (current_node != null)
                {
                    Leaf.Node temp_previous = current_node;
                    if (EqualsCheck(vector, LocateVector(current_node.Value)) && where(current_node.Value))
                    {
                        removals++;
                        if (current_node == leaf.Head)
                            leaf.Head = leaf.Head.Next;
                        else
                        {
                            previous_node.Next = current_node.Next;
                            temp_previous = previous_node;
                        }
                    }
                    previous_node = temp_previous;
                    current_node = current_node.Next;
                }
                leaf.Count -= removals;
            }
            else
            {
                Branch branch = node as Branch;
                int child_index = DetermineChildIndex(branch.PointOfDivision, vector);
                removals += Remove(branch[child_index], vector, where);
                branch.Count -= removals;
                // convert this branch back into a leaf
                // Note: if count is zero, it will be chopped off
                if (branch.Count < _load && branch.Count > 0)
                    ShrinkChild(branch.Parent, branch.Index);
            }
            return removals;
        }

        #endregion

        #region Stepper And IEnumerable

        /// <summary>Traverses every item in the tree and performs the delegate in them.</summary>
        /// <param name="function">The delegate to perform on every item in the tree.</param>
        public void Stepper(Step<T> function)
        {
            this.Stepper(function, this._top);
        }
        private void Stepper(Step<T> function, Node node)
        {
            if (node is Leaf)
            {
                Leaf.Node list = (node as Leaf).Head;
                while (list != null)
                {
                    function(list.Value);
                    list = list.Next;
                }
            }
            else
            {
                foreach (Node child in (node as Branch).Children)
                    this.Stepper(function, child);
            }
        }

        /// <summary>Traverses every item in the tree and performs the delegate in them.</summary>
        /// <param name="function">The delegate to perform on every item in the tree.</param>
        public StepStatus Stepper(StepBreak<T> function)
        {
            return Stepper(function, _top);
        }
        private StepStatus Stepper(StepBreak<T> function, Node node)
        {
            StepStatus status = StepStatus.Continue;
            if (node is Leaf)
            {
                for (Leaf.Node list = (node as Leaf).Head; list != null; list = list.Next)
                    if ((status = function(list._value)) != StepStatus.Continue)
                        break;
            }
            else
            {
                foreach (Node child in (node as Branch).Children)
                    if ((status = Stepper(function, child)) != StepStatus.Continue)
                        break;
            }
            return status;
        }

        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="function">The delegate to perform on all items in the tree within the given bounds.</param>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		/// <param name="min7">The minimum coordinate of the space along the 7 axis.</param>
		/// <param name="max7">The maximum coordinate of the space along the 7 axis.</param>
        public void Stepper(Step<T> function, Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5, Axis6 min6, Axis6 max6, Axis7 min7, Axis7 max7)
        {
            Stepper(function, _top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6, min7, max7));
        }
        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="function">The delegate to perform on all items in the tree within the given bounds.</param>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		/// <param name="min7">The minimum coordinate of the space along the 7 axis.</param>
		/// <param name="max7">The maximum coordinate of the space along the 7 axis.</param>
        public void Stepper(Step<T> function, Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5, Omnitree.Bound<Axis6> min6, Omnitree.Bound<Axis6> max6, Omnitree.Bound<Axis7> min7, Omnitree.Bound<Axis7> max7)
        {
            Stepper(function, _top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6, min7, max7));
        }
        private void Stepper(Step<T> function, Node node, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> bounds)
        {
            if (node is Leaf)
            {
                for (Leaf.Node list = (node as Leaf).Head; list != null; list = list.Next)
                    if (EncapsulationCheck(bounds, LocateVector(list.Value)))
                        function(list.Value);
            }
            else
            {
                foreach (Node child in (node as Branch).Children)
                    // optimization: stop bounds checking if space encapsulates node
                    if (EncapsulationCheck(bounds, child.Bounds))
                        this.Stepper(function, child);
                    else if (InclusionCheck(child.Bounds, bounds))
                        this.Stepper(function, child, bounds);
            }
        }

        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		/// <param name="min7">The minimum coordinate of the space along the 7 axis.</param>
		/// <param name="max7">The maximum coordinate of the space along the 7 axis.</param>
        public StepStatus Stepper(StepBreak<T> function, Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5, Axis6 min6, Axis6 max6, Axis7 min7, Axis7 max7)
        {
            return Stepper(function, _top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6, min7, max7));
        }
        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		/// <param name="min7">The minimum coordinate of the space along the 7 axis.</param>
		/// <param name="max7">The maximum coordinate of the space along the 7 axis.</param>
        public StepStatus Stepper(StepBreak<T> function, Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5, Omnitree.Bound<Axis6> min6, Omnitree.Bound<Axis6> max6, Omnitree.Bound<Axis7> min7, Omnitree.Bound<Axis7> max7)
        {
            return Stepper(function, _top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6, min7, max7));
        }
        private StepStatus Stepper(StepBreak<T> function, Node node, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> bounds)
        {
            StepStatus status = StepStatus.Continue;
            if (node is Leaf)
            {
                for (Leaf.Node list = (node as Leaf).Head; list != null; list = list.Next)
                    if (EncapsulationCheck(bounds, LocateVector(list.Value)) &&
                        (status = function(list.Value)) != StepStatus.Continue)
                        break;
            }
            else
            {
                foreach (Node child in (node as Branch).Children)
                    // optimization: stop bounds checking if space encapsulates node
                    if (EncapsulationCheck(bounds, child.Bounds) &&
                        (status = this.Stepper(function, child)) != StepStatus.Continue)
                        break;
                    else if (!InclusionCheck(child.Bounds, bounds) &&
                        (status = this.Stepper(function, child, bounds)) != StepStatus.Continue)
                        break;
            }
            return status;
        }

        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="axis1">The axis of the removal along the  1D axis.</param>
		/// <param name="axis2">The axis of the removal along the  2D axis.</param>
		/// <param name="axis3">The axis of the removal along the  3D axis.</param>
		/// <param name="axis4">The axis of the removal along the  4D axis.</param>
		/// <param name="axis5">The axis of the removal along the  5D axis.</param>
		/// <param name="axis6">The axis of the removal along the  6D axis.</param>
		/// <param name="axis7">The axis of the removal along the  7D axis.</param>
        public void Stepper(Step<T> function, Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Axis5 axis5, Axis6 axis6, Axis7 axis7)
        {
            Stepper(function, _top, new Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>(axis1, axis2, axis3, axis4, axis5, axis6, axis7));
        }
        private void Stepper(Step<T> function, Node node, Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> vector)
        {
            Node current = node;
            while (current != null)
            {
                if (current is Leaf)
                {
                    for (Leaf.Node leaf_node = (current as Leaf).Head; leaf_node != null; leaf_node = leaf_node.Next)
                        if (EqualsCheck(vector, LocateVector(leaf_node.Value)))
                            function(leaf_node.Value);
                    break;
                }
                else
                {
                    Branch branch = current as Branch;
                    int child_index = DetermineChildIndex(branch.PointOfDivision, vector);
                    current = branch[child_index];
                }
            }
        }

        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="function">The delegate to perform on all items in the tree within the given bounds.</param>
        /// <param name="axis1">The axis of the removal along the  1D axis.</param>
		/// <param name="axis2">The axis of the removal along the  2D axis.</param>
		/// <param name="axis3">The axis of the removal along the  3D axis.</param>
		/// <param name="axis4">The axis of the removal along the  4D axis.</param>
		/// <param name="axis5">The axis of the removal along the  5D axis.</param>
		/// <param name="axis6">The axis of the removal along the  6D axis.</param>
		/// <param name="axis7">The axis of the removal along the  7D axis.</param>
        public StepStatus Stepper(StepBreak<T> function, Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Axis5 axis5, Axis6 axis6, Axis7 axis7)
        {
            return Stepper(function, _top, new Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>(axis1, axis2, axis3, axis4, axis5, axis6, axis7));
        }
        private StepStatus Stepper(StepBreak<T> function, Node node, Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> vector)
        {
            Node current = node;
            while (current != null)
            {
                if (current is Leaf)
                {
                    for (Leaf.Node list = (current as Leaf).Head; list != null; list = list.Next)
                    {
                        StepStatus status = StepStatus.Continue;
                        if (EqualsCheck(vector, LocateVector(list.Value)) &&
                            (status = function(list.Value)) != StepStatus.Continue)
                            return status;
                    }
                }
                else
                {
                    Branch branch = current as Branch;
                    int child_index = DetermineChildIndex(branch.PointOfDivision, vector);
                    current = branch[child_index];
                }
            }
            return StepStatus.Continue;
        }

        /// <summary>FOR COMPATIBILITY ONLY. AVOID IF POSSIBLE.</summary>
        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
        {
            throw new System.NotImplementedException();
            //return (this.ToArray() as System.Collections.Generic.IEnumerable<T>).GetEnumerator();
        }

        /// <summary>FOR COMPATIBILITY ONLY. AVOID IF POSSIBLE.</summary>
        System.Collections.Generic.IEnumerator<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator()
        {
            throw new System.NotImplementedException();
            //return (this.ToArray() as System.Collections.Generic.IEnumerable<T>).GetEnumerator();
        }

        #endregion

        #region Helpers

        private bool StraddlesLines(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> bounds, Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> vector)
        {
			if ((!bounds.Min1.Exists || (bounds.Min1.Exists && this._compare1(bounds.Min1.Value, vector.Axis1) != Comparison.Greater)) &&
				(!bounds.Max1.Exists || (bounds.Max1.Exists && this._compare1(bounds.Max1.Value, vector.Axis1) != Comparison.Less)))
				return true;
			if ((!bounds.Min2.Exists || (bounds.Min2.Exists && this._compare2(bounds.Min2.Value, vector.Axis2) != Comparison.Greater)) &&
				(!bounds.Max2.Exists || (bounds.Max2.Exists && this._compare2(bounds.Max2.Value, vector.Axis2) != Comparison.Less)))
				return true;
			if ((!bounds.Min3.Exists || (bounds.Min3.Exists && this._compare3(bounds.Min3.Value, vector.Axis3) != Comparison.Greater)) &&
				(!bounds.Max3.Exists || (bounds.Max3.Exists && this._compare3(bounds.Max3.Value, vector.Axis3) != Comparison.Less)))
				return true;
			if ((!bounds.Min4.Exists || (bounds.Min4.Exists && this._compare4(bounds.Min4.Value, vector.Axis4) != Comparison.Greater)) &&
				(!bounds.Max4.Exists || (bounds.Max4.Exists && this._compare4(bounds.Max4.Value, vector.Axis4) != Comparison.Less)))
				return true;
			if ((!bounds.Min5.Exists || (bounds.Min5.Exists && this._compare5(bounds.Min5.Value, vector.Axis5) != Comparison.Greater)) &&
				(!bounds.Max5.Exists || (bounds.Max5.Exists && this._compare5(bounds.Max5.Value, vector.Axis5) != Comparison.Less)))
				return true;
			if ((!bounds.Min6.Exists || (bounds.Min6.Exists && this._compare6(bounds.Min6.Value, vector.Axis6) != Comparison.Greater)) &&
				(!bounds.Max6.Exists || (bounds.Max6.Exists && this._compare6(bounds.Max6.Value, vector.Axis6) != Comparison.Less)))
				return true;
			if ((!bounds.Min7.Exists || (bounds.Min7.Exists && this._compare7(bounds.Min7.Value, vector.Axis7) != Comparison.Greater)) &&
				(!bounds.Max7.Exists || (bounds.Max7.Exists && this._compare7(bounds.Max7.Value, vector.Axis7) != Comparison.Less)))
				return true;
            return false;
        }

        /// <summary>Computes the child index that contains the desired dimensions.</summary>
        /// <param name="node">The branch .</param>
        /// <param name="vector">The dimensions to determine the child index.</param>
        /// <returns>The computed child index based on the coordinates relative to the center of the node.</returns>
        private int DetermineChildIndex(Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> pointOfDivision, Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> vector)
        {
            int child = 0;
            if (!(this._compare1(vector.Axis1, pointOfDivision.Axis1) == Comparison.Less))
                child += 1 << 0;
            if (!(this._compare2(vector.Axis2, pointOfDivision.Axis2) == Comparison.Less))
                child += 1 << 1;
            if (!(this._compare3(vector.Axis3, pointOfDivision.Axis3) == Comparison.Less))
                child += 1 << 2;
            if (!(this._compare4(vector.Axis4, pointOfDivision.Axis4) == Comparison.Less))
                child += 1 << 3;
            if (!(this._compare5(vector.Axis5, pointOfDivision.Axis5) == Comparison.Less))
                child += 1 << 4;
            if (!(this._compare6(vector.Axis6, pointOfDivision.Axis6) == Comparison.Less))
                child += 1 << 5;
            if (!(this._compare7(vector.Axis7, pointOfDivision.Axis7) == Comparison.Less))
                child += 1 << 6;
            return child;
        }

        /// <summary>Converts a branch back into a leaf when the count is reduced.</summary>
        /// <param name="parent">The parent to shrink a child of.</param>
        /// <param name="child">The index of the child to shrink.</param>
        private void ShrinkChild(Branch parent, int child_index)
        {
            Leaf leaf;
            Node removal = null;
            if (parent == null) // top of tree
            {
                removal = this._top;
                leaf = new Leaf(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>.None, null, -1);
                this._top = leaf;
            }
            else // non-top branch
            {
                removal = parent[child_index];
                leaf = new Leaf(removal.Bounds, removal.Parent, removal.Index);
                parent[child_index] = leaf;
            }

            this.Stepper((T step) => { leaf.Add(step); }, removal);
        }

        /// <summary>Reduces the counts of all the parents of a given node by a given amount.</summary>
        /// <param name="parent">The starting parent of the reduction.</param>
        /// <param name="reduction">The amount to reduce the parent counts by.</param>
        private void ReduceParentCounts(Node parent, int reduction)
        {
            IncreaseParentCounts(parent, -reduction);
        }

        /// <summary>Increases the counts of all the parents of a given node by a given amount.</summary>
        /// <param name="parent">The starting parent of the increase.</param>
        /// <param name="increase">The amount to increase the parent counts by.</param>
        private void IncreaseParentCounts(Node parent, int increase)
        {
            Node looper = parent;
            while (looper != null)
            {
                looper.Count += increase;
                looper = looper.Parent;
            }
        }

        /// <summary>Checks a node for inclusion (overlap) between two bounds.</summary>
        /// <returns>True if the spaces overlap; False if not.</returns>
        private bool InclusionCheck(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> a, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> b)
        {

            if (a.Max1.Exists && b.Min1.Exists && this._compare1(a.Max1.Value, b.Min1.Value) == Comparison.Less)
                return false;
            else if (a.Min1.Exists && b.Max1.Exists && this._compare1(a.Min1.Value, b.Max1.Value) == Comparison.Greater)
                return false;

            if (a.Max2.Exists && b.Min2.Exists && this._compare2(a.Max2.Value, b.Min2.Value) == Comparison.Less)
                return false;
            else if (a.Min2.Exists && b.Max2.Exists && this._compare2(a.Min2.Value, b.Max2.Value) == Comparison.Greater)
                return false;

            if (a.Max3.Exists && b.Min3.Exists && this._compare3(a.Max3.Value, b.Min3.Value) == Comparison.Less)
                return false;
            else if (a.Min3.Exists && b.Max3.Exists && this._compare3(a.Min3.Value, b.Max3.Value) == Comparison.Greater)
                return false;

            if (a.Max4.Exists && b.Min4.Exists && this._compare4(a.Max4.Value, b.Min4.Value) == Comparison.Less)
                return false;
            else if (a.Min4.Exists && b.Max4.Exists && this._compare4(a.Min4.Value, b.Max4.Value) == Comparison.Greater)
                return false;

            if (a.Max5.Exists && b.Min5.Exists && this._compare5(a.Max5.Value, b.Min5.Value) == Comparison.Less)
                return false;
            else if (a.Min5.Exists && b.Max5.Exists && this._compare5(a.Min5.Value, b.Max5.Value) == Comparison.Greater)
                return false;

            if (a.Max6.Exists && b.Min6.Exists && this._compare6(a.Max6.Value, b.Min6.Value) == Comparison.Less)
                return false;
            else if (a.Min6.Exists && b.Max6.Exists && this._compare6(a.Min6.Value, b.Max6.Value) == Comparison.Greater)
                return false;

            if (a.Max7.Exists && b.Min7.Exists && this._compare7(a.Max7.Value, b.Min7.Value) == Comparison.Less)
                return false;
            else if (a.Min7.Exists && b.Max7.Exists && this._compare7(a.Min7.Value, b.Max7.Value) == Comparison.Greater)
                return false;

            return true;
        }

        /// <summary>Checks if a space encapsulates a point.</summary>
        /// <returns>True if the space encapsulates the point; False if not.</returns>
        private bool EncapsulationCheck(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> bounds, Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> vector)
        {
            // if the location is not outside the bounds, it must be inside

            if (bounds.Min1.Exists && this._compare1(vector.Axis1, bounds.Min1.Value) == Comparison.Less)
                return false;
            else if (bounds.Max1.Exists && this._compare1(vector.Axis1, bounds.Max1.Value) == Comparison.Greater)
                return false;

            if (bounds.Min2.Exists && this._compare2(vector.Axis2, bounds.Min2.Value) == Comparison.Less)
                return false;
            else if (bounds.Max2.Exists && this._compare2(vector.Axis2, bounds.Max2.Value) == Comparison.Greater)
                return false;

            if (bounds.Min3.Exists && this._compare3(vector.Axis3, bounds.Min3.Value) == Comparison.Less)
                return false;
            else if (bounds.Max3.Exists && this._compare3(vector.Axis3, bounds.Max3.Value) == Comparison.Greater)
                return false;

            if (bounds.Min4.Exists && this._compare4(vector.Axis4, bounds.Min4.Value) == Comparison.Less)
                return false;
            else if (bounds.Max4.Exists && this._compare4(vector.Axis4, bounds.Max4.Value) == Comparison.Greater)
                return false;

            if (bounds.Min5.Exists && this._compare5(vector.Axis5, bounds.Min5.Value) == Comparison.Less)
                return false;
            else if (bounds.Max5.Exists && this._compare5(vector.Axis5, bounds.Max5.Value) == Comparison.Greater)
                return false;

            if (bounds.Min6.Exists && this._compare6(vector.Axis6, bounds.Min6.Value) == Comparison.Less)
                return false;
            else if (bounds.Max6.Exists && this._compare6(vector.Axis6, bounds.Max6.Value) == Comparison.Greater)
                return false;

            if (bounds.Min7.Exists && this._compare7(vector.Axis7, bounds.Min7.Value) == Comparison.Less)
                return false;
            else if (bounds.Max7.Exists && this._compare7(vector.Axis7, bounds.Max7.Value) == Comparison.Greater)
                return false;

            return true;
        }

        /// <summary>Checks if a space (left) encapsulates another space (right).</summary>
        /// <returns>True if the left space encapsulates the right; False if not.</returns>
        private bool EncapsulationCheck(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> a, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> b)
        {
            if ((a.Min1.Exists && !b.Min1.Exists) || (a.Min2.Exists && !b.Min2.Exists) || (a.Min3.Exists && !b.Min3.Exists) || (a.Min4.Exists && !b.Min4.Exists) || (a.Min5.Exists && !b.Min5.Exists) || (a.Min6.Exists && !b.Min6.Exists) || (a.Min7.Exists && !b.Min7.Exists))
                return false;
			if ((a.Max1.Exists && !b.Max1.Exists) || (a.Max2.Exists && !b.Max2.Exists) || (a.Max3.Exists && !b.Max3.Exists) || (a.Max4.Exists && !b.Max4.Exists) || (a.Max5.Exists && !b.Max5.Exists) || (a.Max6.Exists && !b.Max6.Exists) || (a.Max7.Exists && !b.Max7.Exists))
                return false;

            if (b.Min1.Exists && a.Min1.Exists && this._compare1(a.Min1.Value, b.Min1.Value) != Comparison.Less)
                return false;
            if (b.Max1.Exists && a.Max1.Exists && this._compare1(a.Max1.Value, b.Max1.Value) != Comparison.Greater)
                return false;

            if (b.Min2.Exists && a.Min2.Exists && this._compare2(a.Min2.Value, b.Min2.Value) != Comparison.Less)
                return false;
            if (b.Max2.Exists && a.Max2.Exists && this._compare2(a.Max2.Value, b.Max2.Value) != Comparison.Greater)
                return false;

            if (b.Min3.Exists && a.Min3.Exists && this._compare3(a.Min3.Value, b.Min3.Value) != Comparison.Less)
                return false;
            if (b.Max3.Exists && a.Max3.Exists && this._compare3(a.Max3.Value, b.Max3.Value) != Comparison.Greater)
                return false;

            if (b.Min4.Exists && a.Min4.Exists && this._compare4(a.Min4.Value, b.Min4.Value) != Comparison.Less)
                return false;
            if (b.Max4.Exists && a.Max4.Exists && this._compare4(a.Max4.Value, b.Max4.Value) != Comparison.Greater)
                return false;

            if (b.Min5.Exists && a.Min5.Exists && this._compare5(a.Min5.Value, b.Min5.Value) != Comparison.Less)
                return false;
            if (b.Max5.Exists && a.Max5.Exists && this._compare5(a.Max5.Value, b.Max5.Value) != Comparison.Greater)
                return false;

            if (b.Min6.Exists && a.Min6.Exists && this._compare6(a.Min6.Value, b.Min6.Value) != Comparison.Less)
                return false;
            if (b.Max6.Exists && a.Max6.Exists && this._compare6(a.Max6.Value, b.Max6.Value) != Comparison.Greater)
                return false;

            if (b.Min7.Exists && a.Min7.Exists && this._compare7(a.Min7.Value, b.Min7.Value) != Comparison.Less)
                return false;
            if (b.Max7.Exists && a.Max7.Exists && this._compare7(a.Max7.Value, b.Max7.Value) != Comparison.Greater)
                return false;

            return true;
        }

        /// <summary>Checks for equality between two locations.</summary>
        /// <returns>True if equal; False if not;</returns>
        private bool EqualsCheck(Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> a, Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> b)
        {

            if (!this._equate1(a.Axis1, b.Axis1))
                return false;

            if (!this._equate2(a.Axis2, b.Axis2))
                return false;

            if (!this._equate3(a.Axis3, b.Axis3))
                return false;

            if (!this._equate4(a.Axis4, b.Axis4))
                return false;

            if (!this._equate5(a.Axis5, b.Axis5))
                return false;

            if (!this._equate6(a.Axis6, b.Axis6))
                return false;

            if (!this._equate7(a.Axis7, b.Axis7))
                return false;

            return true;
        }

        /// <summary>Gets the nearest parent that encapsulates a location.</summary>
        /// <param name="node">The starting node to find the encapsulating parent of the location.</param>
        /// <param name="coordinate1">The coordinate along the 1D axis.</param>
        /// <param name="coordinate2">The coordinate along the 2D axis.</param>
        /// <param name="coordinate3">The coordinate along the 3D axis.</param>
        /// <returns>The nearest node that encapsulates the given location.</returns>
        private Node GetEncapsulationParent(Node node, Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> vector)
        {
            while (node != null && !EncapsulationCheck(node.Bounds, vector))
                node = node.Parent;
            return node;
        }

        private Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> LocateVector(T value)
        {
            Axis1 axis1;
            Axis2 axis2;
            Axis3 axis3;
            Axis4 axis4;
            Axis5 axis5;
            Axis6 axis6;
            Axis7 axis7;
            this._locate(value, out axis1, out axis2, out axis3, out axis4, out axis5, out axis6, out axis7);
            return new Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>(axis1, axis2, axis3, axis4, axis5, axis6, axis7);
        }

        #endregion

        #endregion
    }

    #endregion

    #endregion

	#region OmnitreeBounds
    
    // NOTE: the ND version can be found int "Omnitree_ND.cs"

    #region 1 Dimensional

    public interface IOmnitreeBounds<T, Axis1> : IDataStructure<T>,
            DataStructure.ICountable,
            DataStructure.IAddable<T>,
            DataStructure.IClearable,
            DataStructure.IRemovable<T>,
            DataStructure.IEquating<T>
    {
        #region Properties

        /// <summary>The number of dimensions in this tree.</summary>
        int Dimensions { get; }

        #endregion

        #region Methods

        /// <summary>Counts the number of items encapsulated by a sub space.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
        /// <returns>The number of items in the provided sub space.</returns>
        int CountSubSpaceEncapsulated(Axis1 min1, Axis1 max1);

		/// <summary>Counts the number of items overlapped by a sub space.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
        /// <returns>The number of items in the provided sub space.</returns>
        int CountSubSpaceOverlapped(Axis1 min1, Axis1 max1);

        /// <summary>Iterates through the entire tree and ensures each item is in the proper leaf.</summary>
        void Update();
        /// <summary>Iterates through the provided dimensions and ensures each item is in the proper leaf.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
        void Update(Axis1 min1, Axis1 max1);

        /// <summary>Removes all the items in a given space.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
        void RemoveEncapsulated(Axis1 min1, Axis1 max1);
        /// <summary>Removes all the items in a given space where predicate is met.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
        /// <param name="where">The predicate constraint of the removal.</param>
        void RemoveEncapsulated(Axis1 min1, Axis1 max1, Predicate<T> where);

		/// <summary>Removes all the items in a given space.</summary>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
        void RemoveOverlapped(Axis1 axis1);
        /// <summary>Removes all the items in a given space.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
        void RemoveOverlapped(Axis1 min1, Axis1 max1);
        /// <summary>Removes all the items in a given space where equality is met.</summary>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
        /// <param name="where">The equality constraint of the removal.</param>
        void RemoveOverlapped(Axis1 axis1, Predicate<T> where);
        /// <summary>Removes all the items in a given space where predicate is met.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
        /// <param name="where">The predicate constraint of the removal.</param>
        void RemoveOverlapped(Axis1 min1, Axis1 max1, Predicate<T> where);

        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="step">The step function to perform on all items in the tree within the given bounds.</param>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
        void StepperEncapsulated(Step<T> step, Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1);
        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="step">The step function to perform on all items in the tree within the given bounds.</param>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
        StepStatus StepperEncapsulated(StepBreak<T> step, Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1);
        
		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="step">The step function to perform on all items in the tree within the given bounds.</param>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
        void StepperOverlapped(Step<T> step, Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1);
        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="step">The step function to perform on all items in the tree within the given bounds.</param>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
        StepStatus StepperOverlapped(StepBreak<T> step, Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1);

		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="step">The step function to perform on all items in the tree within the given bounds.</param>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
        void StepperOverlapped(Step<T> step, Axis1 axis1);
        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="step">The step function to perform on all items in the tree within the given bounds.</param>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
        StepStatus StepperOverlapped(StepBreak<T> function, Axis1 axis1);

        #endregion
    }

    public class OmnitreeBoundsLinked<T, Axis1> : IOmnitreeBounds<T, Axis1>
    {
        private const int _dimensions = 1;
        internal static int _children_per_node = (int)BigInteger.Pow(2, 1);

        private Node _top;

		private int _naturalLogLower = 1; // caching the next time to calculate loads (lower count)
		private int _naturalLogUpper = -1; // caching the next time to calculate loads (upper count)
        private int _load; // ln(count); min = _defaultLoad
        private Omnitree.GetBounds<T, Axis1> _getBounds;

        private bool _defaultEquate;
        private Equate<T> _equate;


        private bool _defaultEquate1;
        private Equate<Axis1> _equate1;



        private bool _defaultCompare1;
        private Compare<Axis1> _compare1;


        // allows median overriding for custom optimizations (USE AT YOUR OWN RISK)
        private Omnitree.SubdivisionOverride<T, Axis1, Omnitree.Bounds<Axis1>> _subdivisionOverride1;

        #region Nested Types

        /// <summary>Can be a leaf or a branch.</summary>
        internal class Node
        {
            public class ValueNode
            {
                internal T _value;
                internal ValueNode _next;

                public T Value { get { return _value; } set { _value = value; } }
                public ValueNode Next { get { return _next; } set { _next = value; } }

                public ValueNode(T value, ValueNode next)
                {
                    _value = value;
                    _next = next;
                }
            }

            internal Omnitree.Bounds<Axis1> _bounds;
            internal Node _parent;
            internal int _index;
            internal int _count;
            internal ValueNode _head;
            private Node[] _children;
            private Omnitree.Vector<Axis1>? _pointOfDivision;

            /// <summary>The parent of this node.</summary>
            public Omnitree.Bounds<Axis1> Bounds { get { return this._bounds; } }
            /// <summary>The parent of this node.</summary>
            public Node Parent { get { return this._parent; } }
            /// <summary>The computed child index of this node (see the "Notes" region in "Omnitree.cs" for the algorithm.</summary>
            public int Index { get { return this._index; } }
            /// <summary>The number of elements stored in this node and its children.</summary>
            public int Count { get { return this._count; } set { this._count = value; } }
            /// <summary>The first object stored in this node.</summary>
            public ValueNode Head { get { return this._head; } set { this._head = value; } }
            public Node[] Children { get { return this._children; } set { this._children = value; } }
            public Omnitree.Vector<Axis1>? PointOfDivision { get { return this._pointOfDivision; } internal set { this._pointOfDivision = value; } }

            /// <summary>Gets child by index.</summary>
            /// <param name="child_index">The index of the child to get.</param>
            /// <returns>The child of the given index or null if non-existent.</returns>
            public Node this[int child_index]
            {
                get
                {
                    if (this._children == null)
                        return null;
                    if (this._children.Length == OmnitreePointsLinked<T, Axis1>._children_per_node)
                        return this._children[(int)child_index];
                    foreach (Node node in this._children)
                        if (node.Index == child_index)
                            return node;
                    return null;
                }
                set
                {
                    // This error check should be unnecessary... but fuck it... might as well
                    if (value.Index != child_index)
                        throw new System.Exception("Bug in Omnitree (index/property mis-match when setting a child on a branch)");

                    // no children yet
                    if (this._children == null)
                    {
                        this._children = new Node[] { value };
                        return;
                    }
                    // max children overwrite
                    else if (this._children.Length == OmnitreePointsLinked<T, Axis1>._children_per_node)
                    {
                        this._children[(int)child_index] = value;
                        return;
                    }
                    // non-max child overwrite
                    for (int i = 0; i < this._children.Length; i++)
                        if (this._children[i].Index == child_index)
                        {
                            this._children[i] = value;
                            return;
                        }
                    // new child
                    Node[] newArray = new Node[this._children.Length + 1];
                    if (newArray.Length == OmnitreePointsLinked<T, Axis1>._children_per_node)
                    {
                        // new child resulting in a max children branch (sorting required)
                        for (int i = 0; i < this._children.Length; i++)
                        {
                            newArray[(int)this._children[i]._index] = this._children[i];
                        }
                        newArray[(int)value._index] = value;
                    }
                    else
                    {
                        // new child resulting in a non-max children branch
                        Array.Copy(this._children, newArray, this._children.Length);
                        newArray[newArray.Length - 1] = value;
                    }
                    this._children = newArray;
                }
            }

            /// <summary>The depth this node is located in the Omnitree.</summary>
            public int Depth
            {
                get
                {
                    int depth = -1;
                    for (Node looper = this; looper != null; looper = looper.Parent)
                        depth++;
                    return depth;
                }
            }

            /// <summary>Constructs a node.</summary>
            /// <param name="bounds">The bounds of this node.</param>
            /// <param name="parent">The parent of this node.</param>
            /// <param name="index">The number of elements stored in this node and its children.</param>
            public Node(Omnitree.Bounds<Axis1> bounds, Node parent, int index)
            {
                this._bounds = bounds;
                this._parent = parent;
                this._index = index;
            }

            public Node(Omnitree.Vector<Axis1> pointOfDivision, Omnitree.Bounds<Axis1> bounds, Node parent, int index)
                : this(bounds, parent, index)
            {
                this._pointOfDivision = pointOfDivision;
            }

            internal Node(Node nodeToClone)
            {
                this._bounds = nodeToClone._bounds;
                this._parent = nodeToClone._parent;
                this._index = nodeToClone._index;
                this._count = nodeToClone._count;

                this._children = nodeToClone._children.Clone() as Node[];
                this._pointOfDivision = nodeToClone._pointOfDivision;

                ValueNode this_looper = this._head;
                ValueNode other_looper = nodeToClone._head;

                while (other_looper != null)
                {
                    this_looper.Next = new ValueNode(other_looper.Next.Value, null);
                    this_looper = this_looper.Next;
                    other_looper = other_looper.Next;
                }
            }

            public void Add(T addition)
            {
                this._head = new ValueNode(addition, this._head);
                this.Count++;
            }

            internal Node Clone()
            {
                return new Node(this);
            }
        }
        
        #endregion

        #region Constructors

        /// <summary>This constructor is for cloning purposes</summary>
        private OmnitreeBoundsLinked(OmnitreeBoundsLinked<T, Axis1> omnitree)
        {
            this._top = omnitree._top.Clone();
            this._load = omnitree._load;
            this._getBounds = omnitree._getBounds;
            this._defaultEquate = omnitree._defaultEquate;
            this._equate = omnitree._equate;

            this._defaultEquate1 = omnitree._defaultEquate1;
            this._equate1 = omnitree._equate1;

            this._defaultCompare1 = omnitree._defaultCompare1;
            this._compare1 = omnitree._compare1;

            this._subdivisionOverride1 = omnitree._subdivisionOverride1;
        }

        private OmnitreeBoundsLinked(
            Omnitree.GetBounds<T, Axis1> getBounds,

            bool defaultEquate,
            Equate<T> equate,

            bool defaultEquate1,
            Equate<Axis1> equateAxis1,

            bool defaultCompare1,
            Compare<Axis1> compare1,

            Omnitree.SubdivisionOverride<T, Axis1, Omnitree.Bounds<Axis1>> subdivisionOverride1)
        {
			if (getBounds == null)
			{
				throw new ArgumentNullException(nameof(getBounds));
			}
			if (equate == null)
			{
				throw new ArgumentNullException(nameof(equate));
			}

			if (equateAxis1 == null)
			{
				throw new ArgumentNullException(nameof(equateAxis1));
			}

			if (compare1 == null)
			{
				throw new ArgumentNullException(nameof(compare1));
			}

            this._getBounds = getBounds;
            this._defaultEquate = defaultEquate;
            this._equate = equate;

            this._defaultEquate1 = defaultEquate1;
            this._equate1 = equateAxis1;

            this._defaultCompare1 = defaultCompare1;
            this._compare1 = compare1;

            this._subdivisionOverride1 = subdivisionOverride1;

            this._top = new Node(Omnitree.Bounds<Axis1>.None, null, -1);
            Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
        }

        private OmnitreeBoundsLinked(
            Omnitree.GetBounds<T, Axis1> getBounds,
            Equate<T> equate,

            Equate<Axis1> equateAxis1,

            Compare<Axis1> compare1,

            Omnitree.SubdivisionOverride<T, Axis1, Omnitree.Bounds<Axis1>> subdivisionOverride1)
            : this(
            getBounds,

            false,
            equate,

            false,
            equateAxis1,

            false,
            compare1,

            subdivisionOverride1)
        { }

        public OmnitreeBoundsLinked(
            Omnitree.GetBounds<T, Axis1> getBounds,

            Equate<T> equate,

            Equate<Axis1> equateAxis1,

            Compare<Axis1> compare1)
            : this(
                getBounds,

                false,
                equate,

                false,
                equateAxis1,

                false,
                compare1,

                null)
        { }



        public OmnitreeBoundsLinked(
            Omnitree.GetBounds<T, Axis1> getBounds,

            Equate<T> equate,

            Compare<Axis1> compare1)
            : this(
                getBounds,
                false,
                equate,

                true,
                Towel.Equate.Default,

                false,
                compare1,

                null)
        { }

        public OmnitreeBoundsLinked(
            Omnitree.GetBounds<T, Axis1> getBounds,
            Equate<T> equate,

            Compare<Axis1> compare1,

            Omnitree.SubdivisionOverride<T, Axis1, Omnitree.Bounds<Axis1>> subdivisionOverride1)
            : this(
                getBounds,

                false,
                equate,

                true,
                Towel.Equate.Default,

                false,
                compare1,

                subdivisionOverride1)
        { }

        public OmnitreeBoundsLinked(
            Omnitree.GetBounds<T, Axis1> getBounds,

            Compare<Axis1> compare1)
            : this(
                getBounds,
                true,
                Towel.Equate.Default,

                true,
                Towel.Equate.Default,

                false,
                compare1,

                null)
        { }

        public OmnitreeBoundsLinked(
            Omnitree.GetBounds<T, Axis1> getBounds,

            Compare<Axis1> compare1,

            Omnitree.SubdivisionOverride<T, Axis1, Omnitree.Bounds<Axis1>> subdivisionOverride1)
            : this(
                getBounds,

                true,
                Towel.Equate.Default,

                true,
                Towel.Equate.Default,

                false,
                compare1,

                subdivisionOverride1)
        { }

        public OmnitreeBoundsLinked(
            Omnitree.GetBounds<T, Axis1> getBounds,
            Equate<T> equate)
            : this(
                getBounds,

                false,
                equate,

                true,
                Towel.Equate.Default,

                true,
                Compare.Default,

                null)
        { }

        public OmnitreeBoundsLinked(
            Omnitree.GetBounds<T, Axis1> getBounds,
            Equate<T> equate,
            Omnitree.SubdivisionOverride<T, Axis1, Omnitree.Bounds<Axis1>> subdivisionOverride1)
            : this(
                getBounds,

                false,
                equate,

                true,
                Towel.Equate.Default,

                true,
                Compare.Default,

                subdivisionOverride1)
        { }

        public OmnitreeBoundsLinked(
            Omnitree.GetBounds<T, Axis1> getBounds)
            : this(
                getBounds,

                true,
                Towel.Equate.Default,

                true,
                Towel.Equate.Default,

                true,
                Compare.Default,

                null)
        { }

		public OmnitreeBoundsLinked(
            Omnitree.GetBoundings<T, Axis1> getBoundings)
            : this(
                Omnitree.ConvertToGetBounds(getBoundings),

                true,
                Towel.Equate.Default,

                true,
                Towel.Equate.Default,

                true,
                Compare.Default,

                null)
        { }

        public OmnitreeBoundsLinked(
            Omnitree.GetBounds<T, Axis1> getBounds,
            Omnitree.SubdivisionOverride<T, Axis1, Omnitree.Bounds<Axis1>> subdivisionOverride1)
            : this(
                getBounds,

                true,
                Towel.Equate.Default,

                true,
                Towel.Equate.Default,

                true,
                Compare.Default,

                subdivisionOverride1)
        { }

        #endregion

        #region Properties

        /// <summary>The number of dimensions in this tree.</summary>
        public int Dimensions { get { return _dimensions; } }

        /// <summary>The function for equating keys in this table.</summary>
        public Equate<T> Equate { get { return this._equate; } }

        /// <summary>The location function the Omnitree is using.</summary>
        public Omnitree.GetBounds<T, Axis1> GetBounds { get { return this._getBounds; } }

        /// <summary>The comparison function the Omnitree is using along the 1D axis.</summary>
        public Compare<Axis1> Compare1 { get { return this._compare1; } }

        /// <summary>The function for equating values along the 1D axis.</summary>
        public Equate<Axis1> EquateAxis1 { get { return this._equate1; } }

        /// <summary>The current number of items in the tree.</summary>
        public int Count { get { return this._top.Count; } }

        private delegate void MaxDepthFinder(Node node, int current_depth, ref int max_depth);
        /// <summary>Finds the current maximum depth of the tree. NOT AN O(1) OPERATION. Intended for educational purposes only.</summary>
        public int MaxDepth
        {
            get
            {
                MaxDepthFinder maxDepthFinder = null;
                maxDepthFinder =
                        (Node node, int current_depth, ref int max_depth) =>
                        {
                            if (current_depth > max_depth)
                                max_depth = current_depth;
                            foreach (Node child in node.Children)
                                maxDepthFinder(child, current_depth + 1, ref max_depth);
                        };
                int _max_depth = -1;
                maxDepthFinder(this._top, 0, ref _max_depth);
                return _max_depth;
            }
        }

        private delegate void NodeCountFinder(Node node, ref int current_count);
        /// <summary>Counts the current number of nodes in the tree. NOT AN O(1) OPERATION. Intended for educational purposes only.</summary>
        public int NodeCount
        {
            get
            {
                NodeCountFinder nodeCountFinder = null;
                nodeCountFinder =
                        (Node node, ref int current_count) =>
                        {
                            current_count++;
                            foreach (Node child in node.Children)
                                nodeCountFinder(child, ref current_count);
                        };

                int _current_count = 0;
                nodeCountFinder(this._top, ref _current_count);
                return _current_count;
            }
        }

        #endregion

        #region Methods

        #region Add

        #region Bulk

		// not yet implemented

//        public void Add(IndexedBigArray<T> additions, bool allowMultithreading)
//        {
//            if (additions.Length > int.MaxValue)
//                throw new System.Exception("The maximum size of the Omnitree was exceeded during bulk addition.");
//
//            if (this._top.Count != 0 || (int)additions.Length <= _load)
//            {
//                for (ulong i = 0; i < additions.Length; i++)
//                    this.Add(additions[i]);
//            }
//            else
//            {
//                // adjust the loads prior to additions
//                ComputeLoads((int)additions.Length);
//
//                Node new_top = new Node(Omnitree.Bounds<Axis1>.None, null, -1);
//                new_top.Count = (int)additions.Length;
//
//
//                // prepare data for median computations
//                IndexedBigArray<Axis1> values1;
//                IAsyncResult result1 = null;
//                if (this._subdivisionOverride1 != null)
//                    values1 = null;
//                else
//                {
//                    values1 = null;
//                    Towel.Parallels.Parallel.Operation operation = () =>
//                    {
//                        values1 = new IndexedBigArray<Axis1>(additions.Length * 2);
//                        for (ulong i = 0; i < additions.Length; i++)
//						{
//							Omnitree.Bounds<Axis1> bounds = GetBoundings(additions[i]);
//                            values1[i * 2] = bounds.Min1;
//							values1[i * 2 + 1] = bounds.Max1;
//						}
//
//                        Towel.Algorithms.Sort.Merge(this._compare1, (int i) => { return values1[(ulong)i]; }, (int i, Axis1 value) => { values1[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
//                    };
//
//                    if (allowMultithreading)
//                        result1 = Towel.Parallels.Parallel.Thread(operation);
//                    else
//                        operation();
//                }
//
//
//
//                if (this._subdivisionOverride1 == null && allowMultithreading)
//                    result1.AsyncWaitHandle.WaitOne();
//
//                // build the tree
//                Add(new_top, 1, -1, additions.Stepper(), (int)additions.Length, int.MinValue, (int)additions.Length, (int index) => { return values1[index]; }, allowMultithreading);
//                
//                this._top = new_top;
//            }
//        }
//
//        public void Add(bool allowMultithreading, params T[] additions)
//        {
//            if (additions.Length > int.MaxValue)
//                throw new System.Exception("The maximum size of the Omnitree was exceeded during bulk addition.");
//
//            if (this._top.Count != 0 || (int)additions.Length <= _load)
//            {
//                for (int i = 0; i < additions.Length; i++)
//                    this.Add(additions[i]);
//            }
//            else
//            {
//                // adjust the loads prior to additions
//                ComputeLoads((int)additions.Length);
//
//                Node new_top = new Node(Omnitree.Bounds<Axis1>.None, null, -1);
//                new_top.Count = (int)additions.Length;
//
//
//                // prepare data for median computations
//                IndexedBigArray<Axis1> values1;
//                IAsyncResult result1 = null;
//                if (this._subdivisionOverride1 != null)
//                    values1 = null;
//                else
//                {
//                    values1 = null;
//                    Towel.Parallels.Parallel.Operation operation = () =>
//                    {
//                        values1 = new IndexedBigArray<Axis1>(additions.Length);
//                        for (int i = 0; i < additions.Length; i++)
//                            values1[i] = LocateVector(additions[i]).Axis1;
//                        Towel.Algorithms.Sort.Merge(this._compare1, (int i) => { return values1[(ulong)i]; }, (int i, Axis1 value) => { values1[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
//                    };
//
//                    if (allowMultithreading)
//                        result1 = Towel.Parallels.Parallel.Thread(operation);
//                    else
//                        operation();
//                }
//
//
//
//                if (this._subdivisionOverride1 == null && allowMultithreading)
//                    result1.AsyncWaitHandle.WaitOne();
//
//
//                // build the tree
//                Add(new_top, 1, -1, additions.Stepper(), additions.Length, int.MinValue, (int)additions.Length, (int index) => { return values1[index]; }, allowMultithreading);
//                
//                this._top = new_top;
//            }
//        }
//
//        
//        private int Add(Node parent, int depth, int child, Stepper<T> additions, int parent_count, int prevmed1, int initial_count, Get<Axis1> values1, bool allowMultithreading)
//        {
//            Axis1 pointOfDivision1;
//
//            int median_axis1 = -1;
//            if (this._subdivisionOverride1 == null)
//                GetMedianIndexes(initial_count, child, depth, prevmed1, out median_axis1);
//
//            if (this._subdivisionOverride1 != null)
//                pointOfDivision1 = this._subdivisionOverride1(parent.Bounds, additions);
//            else
//                pointOfDivision1 = values1(median_axis1);
//
//            parent.PointOfDivision = new Omnitree.Vector<Axis1>(pointOfDivision1);
//
//            // divide the values along the medians
//            IMap<IAddable<T>, int> collection_map = new MapHashLinked<IAddable<T>, int>();
//            additions((T value) => 
//            {
//                int index = DetermineChildIndex(parent.PointOfDivision.Value, LocateVector(value));
//                IAddable<T> list = null;
//                if (collection_map.TryGet(index, out list))
//                {
//                    list.Add(value);
//                }
//                else
//                {
//                    if (parent_count < 100000)
//                        list = new AddableArray<T>();
//                    else
//                        list = new AddableLinked<T>();
//                    collection_map.Add(index, list);
//                    list.Add(value);
//                }
//            });
//
//            if (depth == 1 && allowMultithreading)
//            {
//                // NOTE: Must assign placeholders before multithreading so that the threads do not overwrite each other
//                collection_map.Keys((int key) => { parent[key] = new Node(Omnitree.Bounds<Axis1>.None, parent, key); });
//                IAsyncResult[] handles = new IAsyncResult[Environment.ProcessorCount];
//                for (int i = 0; i < handles.Length; i++)
//                {
//                    int multiTheadSafe_i = i; // used as catpure variable below making it multithread-safe
//                    handles[i] = Towel.Parallels.Parallel.Thread(() =>
//                    {
//                        Step.EveryNth<Link<IAddable<T>, int>>(collection_map.Pairs, multiTheadSafe_i + 1)(
//                        (Link<IAddable<T>, int> link) =>
//                            {
//                                ReversedChildBuilding(parent, link._2, depth, link._1.Stepper, link._1.Count, median_axis1, initial_count, values1, allowMultithreading);
//                            });
//                    });
//                }
//                
//                foreach (IAsyncResult handle in handles)
//                {
//                    handle.AsyncWaitHandle.WaitOne();
//                }
//            }
//            else
//            {
//                collection_map.Pairs((Link<IAddable<T>, int> link) =>
//                { 
//                    ReversedChildBuilding(parent, link._2, depth, link._1.Stepper, link._1.Count, median_axis1, initial_count, values1, allowMultithreading);
//                });
//            }
//
//            int count = 0;
//            foreach (Node node in parent.Children)
//                count += node.Count;
//            return count;
//        }
//
//        int ReversedChildBuilding(Node parent, int child_index, int depth, Stepper<T> additions, int count, int prevmed1, int initial_count, Get<Axis1> values1, bool allowMultithreading)
//        {
//            Omnitree.Bounds<Axis1> child_bounds = DetermineChildBounds(parent, child_index);
//            if (depth >= _load || count <= _load)
//            {
//                Node new_leaf = new Node(child_bounds, parent, child_index);
//                additions((T value) => { new_leaf.Add(value); });
//                parent[new_leaf.Index] = new_leaf;
//                return new_leaf.Count;
//            }
//            else
//            {
//                Node new_branch = new Node(Omnitree.Vector<Axis1>.Default, child_bounds, parent, child_index);
//                parent[new_branch.Index] = new_branch;
//                new_branch.Count = Add(new_branch, depth + 1, child_index, additions, count, prevmed1, count, values1, allowMultithreading);
//                return new_branch.Count;
//            }
//        }
//
//        /// <summary>Gets the indeces of the median values at the given position during bulk additions.</summary>
//        private void GetMedianIndexes(int count, int child_index, int depth, int previous1, out int index1)
//        {
//            if (depth == 1)
//            {
//                index1 = (count - 1) / 2;
//                return;
//            }
//
//            int splits = Compute.Power(2, depth);
//            int mid_child_range = count / splits;
//
//            if (child_index >= 1)
//            {
//                index1 = previous1 + mid_child_range;
//                child_index -= 1;
//            }
//            else
//            {
//                index1 = previous1 - mid_child_range;
//            }
//
//        }

		

        #endregion

        #region single

        /// <summary>Adds an item to the tree.</summary>
        /// <param name="addition">The item to be added.</param>
        public void Add(T addition)
        {
            if (this._top.Count == int.MaxValue)
                throw new System.InvalidOperationException("(Count == int.MaxValue) max Omnitree size reached (change ints to longs if you need to).");

            // dynamic tree sizes
            Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);

            Omnitree.Bounds<Axis1> bounds = GetBoundings(addition);

            // grow the first branch of the tree
            if (!this._top.PointOfDivision.HasValue && this._top.Count >= _load)
            {
                Node top = this._top;

                // create the new branch from the median values
                this._top = new Node(DetermineMedians(top), Omnitree.Bounds<Axis1>.None, null, -1);

                // iterate through the elements and add them to the appropriate children
                for (Node.ValueNode list = top.Head; list != null; list = list.Next)
                    Add(list.Value, this._top, GetBoundings(list.Value), 0);
            }

            this.Add(addition, this._top, bounds, 0);
        }
        
        /// <summary>Recursive version of the add function.</summary>
        /// <param name="addition">The item to be added.</param>
        /// <param name="node">The current node for tree trversal.</param>
        /// <param name="ms">The location of the addition.</param>
        /// <param name="depth">The current depth of iteration.</param>
        private void Add(T addition, Node node, Omnitree.Bounds<Axis1> bounds, int depth)
        {
            if (!node.PointOfDivision.HasValue)
            {
                //Leaf leaf = node as Leaf;
                if (depth >= _load || !(node.Count >= _load))
                {
                    node.Add(addition);
                    return;
                }
                else
                {
                    //Node parent = node.Parent;
                    //int child_index = this.DetermineChildIndex(parent.PointOfDivision, location);
                    //Node growth = new Node(DetermineMedians(leaf), leaf.Bounds, parent, child_index);
                    //parent[child_index] = growth;

					Node growth = new Node(DetermineMedians(node), node.Bounds, node.Parent, node.Index);
                    node.Parent[node.Index] = growth;

                    for (Node.ValueNode list = node.Head; list != null; list = list.Next)
                    {
                        Omnitree.Bounds<Axis1> temp_bounds = GetBoundings(list.Value);
                        if (EncapsulationCheck(growth.Bounds, temp_bounds))
                            Add(list.Value, growth, temp_bounds, depth);
                        else
                        {
                            ReduceParentCounts(node.Parent, 1);
                            Add(list.Value, this._top, temp_bounds, depth);
                        }
                    }

                    Add(addition, growth, bounds, depth);
                    return;
                }
            }
            else
            {
                //Node branch = node as Node;
                int child_index = this.DetermineChildIndex(node.PointOfDivision.Value, bounds); // determine the child "index" (0 through 2^Dimensions) the addition belongs in
                
				// if -1, then the bounds of the addition straddle the point of division (keep it in current node)
				if (child_index == -1)
				{
					node.Add(addition);
                    return;
				}
				
				Node child_node = node[child_index];

                // null children in branches are just empty leaves
                if (child_node == null)
                {
                    Node new_node = new Node(DetermineChildBounds(node, child_index), node, child_index);
                    node[child_index] = new_node;
                    new_node.Add(addition);
                }
                else
                    // child exists already, continue adding
                    Add(addition, child_node, bounds, depth + 1);

                node.Count++;
                return;
            }
        }

        /// <summary>Determins the dimensions of the child at the given index.</summary>
        /// <param name="leaf">The parent of the node to compute dimensions for.</param>
        /// <param name="child">The index of the child to compute dimensions for.</param>
        /// <param name="median1">The computed minimum dimensions of the child node along the 1D axis.</param>
        /// <param name="median2">The computed minimum dimensions of the child node along the 2D axis.</param>
        /// <param name="median3">The computed minimum dimensions of the child node along the 3D axis.</param>
        private Omnitree.Vector<Axis1> DetermineMedians(Node node)
        {
            try
            {
                // extract the values
                Omnitree.Bound<Axis1>[] values1 = new Omnitree.Bound<Axis1>[node.Count * 2];
                Node.ValueNode for_current = node.Head; // used in for loop
                for (int i = 0; i < node.Count; i++, for_current = for_current.Next)
                    this._getBounds(for_current.Value, 
					out values1[i * 2], out values1[i * 2 + 1]);
                return new Omnitree.Vector<Axis1>(
					Omnitree.SubDivide(values1, this._defaultCompare1 ? Compare.Default : this._compare1));
            }
            catch
            {
                // extract the values
                IndexedBigArray<Omnitree.Bound<Axis1>> values1 = new IndexedBigArray<Omnitree.Bound<Axis1>>(node.Count * 2);
                Node.ValueNode for_current = node.Head; // used in for loop
                for (int i = 0; i < node.Count; i++, for_current = for_current.Next)
                {
                    Omnitree.Bound<Axis1> min1; Omnitree.Bound<Axis1> max1;
                    this._getBounds(for_current.Value,
						out min1, out max1);
                    values1[i * 2] = min1; values1[i * 2 + 1] = max1;
                }
				return new Omnitree.Vector<Axis1>(
					Omnitree.SubDivide(values1, this._defaultCompare1 ? Compare.Default : this._compare1));
            }
        }

        #endregion

        #region Add Helpers

        private Omnitree.Bounds<Axis1> DetermineChildBounds(Node node, int child_index)
        {
			// the node parameter should always have a point of division value for this function
			Omnitree.Vector<Axis1> pointOfDivision = node.PointOfDivision.Value;

            Omnitree.Bound<Axis1> min1, max1;
            if (child_index >= 1)
            {
                min1 = pointOfDivision.Axis1;
                max1 = node.Bounds.Max1;
                child_index -= 1;
            }
            else
            {
                min1 = node.Bounds.Min1;
                max1 = pointOfDivision.Axis1;
            }

            return new Omnitree.Bounds<Axis1>(min1, max1);
        }

        #endregion

        #endregion

        #region Clear

        /// <summary>Returns the tree to an empty state.</summary>
        public void Clear()
        {
            this._top = new Node(Omnitree.Bounds<Axis1>.None, null, -1);
            Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
        }

        #endregion

        #region Clone

        /// <summary>Creates a shallow clone of this data structure.</summary>
        /// <returns>A shallow clone of this data structure.</returns>
        public OmnitreeBoundsLinked<T, Axis1> Clone()
        {
            return new OmnitreeBoundsLinked<T, Axis1>(this);
        }

        #endregion

        #region Count

        /// <summary>Counts the number of items encapsulated by a sub space.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
        /// <returns>The number of items in the provided sub space.</returns>
        public int CountSubSpaceEncapsulated(Axis1 min1, Axis1 max1)
        {
            return CountSubSpaceEncapsulated(_top, new Omnitree.Bounds<Axis1>(min1, max1));
        }
        /// <summary>Counts the number of items encapsulated by a sub space.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
        /// <returns>The number of items in the provided sub space.</returns>
        public int CountSubSpaceEncapsulated(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1)
        {
            return CountSubSpaceEncapsulated(_top, new Omnitree.Bounds<Axis1>(min1, max1));
        }
        /// <summary>Counts the number of items encapsulated by a sub space.</summary>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
        /// <returns>The number of items in the provided sub space.</returns>
        public int CountSubSpaceEncapsulated(Axis1 axis1)
        {
            return CountSubSpaceEncapsulated(_top, new Omnitree.Bounds<Axis1>(axis1, axis1));
        }
        /// <summary>Counts the number of items encapsulated by a sub space.</summary>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
        /// <returns>The number of items in the provided sub space.</returns>
        public int CountSubSpaceEncapsulated(Omnitree.Bound<Axis1> axis1)
        {
            return CountSubSpaceEncapsulated(_top, new Omnitree.Bounds<Axis1>(axis1, axis1));
        }

        /// <summary>Counts the number of items overlapped by a sub space.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
        /// <returns>The number of items in the provided sub space.</returns>
        public int CountSubSpaceOverlapped(Axis1 min1, Axis1 max1)
        {
            return CountSubSpaceOverlapped(_top, new Omnitree.Bounds<Axis1>(min1, max1));
        }
        /// <summary>Counts the number of items overlapped by a sub space.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
        /// <returns>The number of items in the provided sub space.</returns>
        public int CountSubSpaceOverlapped(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1)
        {
            return CountSubSpaceOverlapped(_top, new Omnitree.Bounds<Axis1>(min1, max1));
        }
        /// <summary>Counts the number of items overlapped by a sub space.</summary>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
        /// <returns>The number of items in the provided sub space.</returns>
        public int CountSubSpaceOverlapped(Axis1 axis1)
        {
            return CountSubSpaceOverlapped(_top, new Omnitree.Bounds<Axis1>(axis1, axis1));
        }
        /// <summary>Counts the number of items overlapped by a sub space.</summary>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
        /// <returns>The number of items in the provided sub space.</returns>
        public int CountSubSpaceOverlapped(Omnitree.Bound<Axis1> axis1)
        {
            return CountSubSpaceOverlapped(_top, new Omnitree.Bounds<Axis1>(axis1, axis1));
        }

		private int CountSubSpaceEncapsulated(Node node, Omnitree.Bounds<Axis1> bounds)
		{
			return CountSubSpaceBase(_top, bounds, (a, b) => EncapsulationCheck(a, b));
		}

		private int CountSubSpaceOverlapped(Node node, Omnitree.Bounds<Axis1> bounds)
		{
			return CountSubSpaceBase(_top, bounds, (a, b) => InclusionCheck(a, b));
		}

		private int CountSubSpaceBase(
			Node node,
			Omnitree.Bounds<Axis1> bounds,
			Omnitree.SpatialCheck<Omnitree.Bounds<Axis1>, Omnitree.Bounds<Axis1>> spatialCheck)
        {
            // adjust min/max values
            int count = 0;
            if (EncapsulationCheck(bounds, node.Bounds))
                count += node.Count;
            else if (!node.PointOfDivision.HasValue)
            {
                for (Node.ValueNode list = node.Head; list != null; list = list.Next)
                    if (spatialCheck(bounds, GetBoundings(list.Value)))
                        count++;
            }
            else
            {
                Node branch = node as Node;
                if (!StraddlesLines(branch.Bounds, branch.PointOfDivision.Value))
                {
                    int child_index = DetermineChildIndex(branch.PointOfDivision.Value, bounds);
                    Node child = branch[child_index];
                    if (child != null)
                      count += this.CountSubSpaceBase(child, bounds, spatialCheck);
                }
                else
                {
                    foreach (Node child in node.Children)
                        count += this.CountSubSpaceBase(child, bounds, spatialCheck);
                }
            }
            return count;
        }

        #endregion

        #region Update

        /// <summary>Iterates through the entire tree and ensures each item is in the proper leaf.</summary>
        public void Update()
        {
            this.Update(this._top, 0);
        }

        /// <summary>Recursive version of the Update method.</summary>
        /// <param name="node">The current node of iteration.</param>
        /// <param name="depth">The current depth of iteration.</param>
        private int Update(Node node, int depth)
        {
			// I messed up this function in the conversion
			throw new System.NotImplementedException();

            int removals = 0;

            if (!node.PointOfDivision.HasValue)
            {
                Node.ValueNode current = node.Head;
                Node.ValueNode previous = null;
                while (current != null)
                {
                    Omnitree.Bounds<Axis1> bounds = GetBoundings(current.Value);
                    if (!this.EncapsulationCheck(node.Bounds, bounds))
                    {
                        removals++;
                        T updated = current.Value;
                        if (previous == null)
                        {
                            node.Head = current.Next;
                            goto HeadRemoved;
                        }
                        else
                            previous.Next = current.Next;

                        Node whereToAdd = GetEncapsulationParent(node.Parent, bounds);

                        if (whereToAdd == null)
                            throw new System.Exception("an item was updated outside the range of the omnitree");

                        this.Add(updated, whereToAdd, bounds, whereToAdd.Depth);
                    }
                    previous = current;
                HeadRemoved:
                    current = current.Next;
                }
                node.Count -= removals;
                return removals;
            }
            else
            {
                Node branch = node as Node;
                int skipped = 0;
                for (int i = 0; i + skipped < branch.Children.Length; )
                {
                    removals += this.Update(branch.Children[i], depth + 1);
                    if (branch.Children[i].Count == 0)
                        branch.Children[i] = branch.Children[branch.Children.Length - skipped++ - 1];
                    else
                        i++;
                }
                Node[] newArray = new Node[branch.Children.Length - skipped];
                Array.Copy(branch.Children, newArray, newArray.Length);
                branch.Children = newArray;

                branch.Count -= removals;

                if (branch.Count < _load && branch.Count != 0)
                    ShrinkChild(branch.Parent, branch.Index);
            }

            return removals;
        }

        /// <summary>Iterates through the provided dimensions and ensures each item is in the proper leaf.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
        public void Update(Axis1 min1, Axis1 max1)
        {
            this.Update(new Omnitree.Bounds<Axis1>(min1, max1), this._top, 0);
        }
        /// <summary>Iterates through the provided dimensions and ensures each item is in the proper leaf.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
        public void Update(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1)
        {
            this.Update(new Omnitree.Bounds<Axis1>(min1, max1), this._top, 0);
        }
        /// <summary>Iterates through the provided dimensions and ensures each item is in the proper leaf.</summary>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
        public void Update(Axis1 axis1)
        {
            this.Update(new Omnitree.Bounds<Axis1>(axis1, axis1), this._top, 0);
        }
        /// <summary>Iterates through the provided dimensions and ensures each item is in the proper leaf.</summary>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
        public void Update(Omnitree.Bound<Axis1> axis1)
        {
            this.Update(new Omnitree.Bounds<Axis1>(axis1, axis1), this._top, 0);
        }
        private int Update(Omnitree.Bounds<Axis1> bounds, Node node, int depth)
        {
			// I messed up this function in the conversion
			throw new System.NotImplementedException();

            if (!InclusionCheck(bounds, node.Bounds))
                return 0;

            int removals = 0;

            if (!node.PointOfDivision.HasValue)
            {
                Node.ValueNode current = node.Head;
                Node.ValueNode previous = null;
                while (current != null)
                {
                    Omnitree.Bounds<Axis1> item_bounds = GetBoundings(current.Value);
                    if (!this.EncapsulationCheck(node.Bounds, item_bounds))
                    {
                        removals++;
                        T updated = current.Value;
                        if (previous == null)
                        {
                            node.Head = current.Next;
                            goto HeadRemoved;
                        }
                        else
                            previous.Next = current.Next;
                        Node whereToAdd = GetEncapsulationParent(node.Parent, item_bounds);
                        if (whereToAdd == null)
                            throw new System.Exception("an item was updates outside the range of the omnitree");
                        this.Add(updated, whereToAdd, item_bounds, whereToAdd.Depth);
                    }
                    previous = current;
                HeadRemoved:
                    current = current.Next;
                }
                node.Count -= removals;
                return removals;
            }
            else
            {
                Node branch = node as Node;
                int skipped = 0;
                for (int i = 0; i + skipped < branch.Children.Length; )
                {
                    removals += this.Update(branch.Children[i], depth + 1);
                    if (branch.Children[i].Count == 0)
                        branch.Children[i] = branch.Children[branch.Children.Length - skipped++ - 1];
                    else
                        i++;
                }
                Node[] newArray = new Node[branch.Children.Length - skipped];
                Array.Copy(branch.Children, newArray, newArray.Length);
                branch.Children = newArray;

                branch.Count -= removals;

                if (branch.Count < _load && branch.Count != 0)
                    ShrinkChild(branch.Parent, branch.Index);
            }

            return removals;
        }

        #endregion

        #region Remove

        /// <summary>Removes all the items qualified by the delegate.</summary>
        /// <param name="where">The predicate to qualify removals.</param>
        public void Remove(Predicate<T> where)
        {
            this.Remove(this._top, where);
            Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
        }

        /// <summary>Recursive version of the remove method.</summary>
        /// <param name="node">The current node of traversal.</param>
        /// <param name="where">The predicate to qualify removals.</param>
        private int Remove(Node node, Predicate<T> where)
        {
            int removals = 0;

			// items
            while (node.Head != null && where(node.Head.Value))
            {
                node.Head = node.Head.Next;
                removals++;
            }
            if (node.Head != null)
            {
                Node.ValueNode list = node.Head;
                while (list.Next != null)
                {
                    if (where(list.Next.Value))
                    {
                        list.Next = list.Next.Next;
                        removals++;
                    }
                }
            }
            node.Count -= removals;
            
			// children
			if (node.Children != null)
			{
				int skipped = 0;
				for (int i = 0; i + skipped < node.Children.Length; )
				{
				    removals += this.Remove(node.Children[i], where);
				    if (node.Children[i].Count == 0)
				        node.Children[i] = node.Children[node.Children.Length - skipped++ - 1];
				    else
				        i++;
				}
				Node[] newArray = new Node[node.Children.Length - skipped];
				Array.Copy(node.Children, newArray, newArray.Length);
				node.Children = newArray;

				node.Count -= removals;

				if (node.Count < _load && node.Count != 0)
				    ShrinkChild(node.Parent, node.Index);
			}
            return removals;
        }

        /// <summary>Removes all the items encapsulated in a given space.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
        /// <returns>The number of items that were removed.</returns>
        public void RemoveEncapsulated(Axis1 min1, Axis1 max1)
        {
            this.RemoveEncapsulated(this._top, new Omnitree.Bounds<Axis1>(min1, max1));
        }
        /// <summary>Removes all the items encapsulated in a given space.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
        /// <returns>The number of items that were removed.</returns>
        public void RemoveEncapsulated(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1)
        {
            this.RemoveEncapsulated(this._top, new Omnitree.Bounds<Axis1>(min1, max1));
        }
        /// <summary>Removes all the items encapsulated in a given space.</summary>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
        public void RemoveEncapsulated(Omnitree.Bound<Axis1> axis1)
        {
            this.RemoveEncapsulated(this._top, new Omnitree.Bounds<Axis1>(axis1, axis1));
        }
        private int RemoveEncapsulated(Node node, Omnitree.Bounds<Axis1> bounds)
        {
            int removals = this.RemoveBase(node, bounds, (a, b) => this.EncapsulationCheck(a, b));
			Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
			return removals;
        }

		/// <summary>Removes all the items overlapping a given space.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
        /// <returns>The number of items that were removed.</returns>
        public void RemoveOverlapped(Axis1 min1, Axis1 max1)
        {
            this.RemoveOverlapped(this._top, new Omnitree.Bounds<Axis1>(min1, max1));
        }
        /// <summary>Removes all the items overlapping a given space.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
        /// <returns>The number of items that were removed.</returns>
        public void RemoveOverlapped(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1)
        {
            this.RemoveOverlapped(this._top, new Omnitree.Bounds<Axis1>(min1, max1));
        }
        private int RemoveOverlapped(Node node, Omnitree.Bounds<Axis1> bounds)
        {
            int removals = this.RemoveBase(node, bounds, (a, b) => this.InclusionCheck(a, b));
			Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
			return removals;
        }

		private int RemoveBase(
			Node node,
			Omnitree.Bounds<Axis1> bounds,
			Omnitree.SpatialCheck<Omnitree.Bounds<Axis1>, Omnitree.Bounds<Axis1>> spatialCheck)
        {
            int removals = 0;
            if (InclusionCheck(bounds, node.Bounds))
            {
				// items
                Node.ValueNode current_node = node.Head;
                Node.ValueNode previous_node = null;
                while (current_node != null)
                {
                    Node.ValueNode temp_previous = current_node;
                    if (spatialCheck(bounds, GetBoundings(current_node.Value)))
                    {
                        removals++;
                        if (current_node == node.Head)
                            node.Head = node.Head.Next;
                        else
                        {
                            previous_node.Next = current_node.Next;
                            temp_previous = previous_node;
                        }
                    }
                    previous_node = temp_previous;
                    current_node = current_node.Next;
                }
                node.Count -= removals;
                
				// children
				if (node.Children != null)
				{
					int skipped = 0;
					for (int i = 0; i + skipped < node.Children.Length; )
					{
					    removals += this.RemoveBase(node.Children[i], bounds, spatialCheck);
					    if (node.Children[i].Count == 0)
					        node.Children[i] = node.Children[node.Children.Length - skipped++ - 1];
					    else
					        i++;
					}
					Node[] newArray = new Node[node.Children.Length - skipped];
					Array.Copy(node.Children, newArray, newArray.Length);
					node.Children = newArray;

					node.Count -= removals;
					// convert this branch back into a leaf
					// Note: if count is zero, it will be chopped off
					if (node.Count < _load && node.Count > 0)
					    ShrinkChild(node.Parent, node.Index);
				}
            }
			
            return removals;
        }

		/// <summary>Removes all the items in a given space validated by a predicate.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
        /// <param name="where">The equality constraint of the removal.</param>
        public void RemoveEncapsulated(Axis1 min1, Axis1 max1, Predicate<T> where)
        {
            this.RemoveEncapsulated(this._top, new Omnitree.Bounds<Axis1>(min1, max1), where);
        }
        /// <summary>Removes all the items in a given space validated by a predicate.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
        /// <param name="where">The equality constraint of the removal.</param>
        public void RemoveEncapsulated(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Predicate<T> where)
        {
            this.RemoveEncapsulated(this._top, new Omnitree.Bounds<Axis1>(min1, max1), where);
        }
        private int RemoveEncapsulated(Node node, Omnitree.Bounds<Axis1> bounds, Predicate<T> where)
        {
            int removals = RemoveBase(node, bounds, where, (a, b) => this.EncapsulationCheck(a, b));
			Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
			return removals;
        }

        /// <summary>Removes all the items in a given space validated by a predicate.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
        /// <param name="where">The equality constraint of the removal.</param>
        public void RemoveOverlapped(Axis1 min1, Axis1 max1, Predicate<T> where)
        {
            this.RemoveOverlapped(this._top, new Omnitree.Bounds<Axis1>(min1, max1), where);
        }
        /// <summary>Removes all the items in a given space validated by a predicate.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
        /// <param name="where">The equality constraint of the removal.</param>
        public void RemoveOverlapped(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Predicate<T> where)
        {
            this.RemoveOverlapped(this._top, new Omnitree.Bounds<Axis1>(min1, max1), where);
        }
        private int RemoveOverlapped(Node node, Omnitree.Bounds<Axis1> bounds, Predicate<T> where)
        {
            int removals = RemoveBase(node, bounds, where, (a, b) => this.InclusionCheck(a, b));
			Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
			return removals;
        }

		private int RemoveBase(
			Node node,
			Omnitree.Bounds<Axis1> bounds,
			Predicate<T> where,
			Omnitree.SpatialCheck<Omnitree.Bounds<Axis1>, Omnitree.Bounds<Axis1>> spatialCheck)
        {
            if (!InclusionCheck(node.Bounds, bounds))
                return 0;
            int removals = 0;
            
			// items
            Node.ValueNode current = node.Head;
            Node.ValueNode previous = null;
            while (current != null)
            {
                if (spatialCheck(bounds, GetBoundings(current.Value)) && where(current.Value))
                {
                    removals++;
                    if (previous == null)
                    {
                        node.Head = current.Next;
                        goto HeadRemoved;
                    }
                    else
                        previous.Next = current.Next;
                }
                previous = current;
            HeadRemoved:
                current = current.Next;
            }
            node.Count -= removals;

            // children
			if (node.Children != null)
			{
				int skipped = 0;
				for (int i = 0; i + skipped < node.Children.Length; )
				{
				    removals += this.RemoveBase(node.Children[i], bounds, where, spatialCheck);
				    if (node.Children[i].Count == 0)
				        node.Children[i] = node.Children[node.Children.Length - skipped++ - 1];
				    else
				        i++;
				}
				Node[] newArray = new Node[node.Children.Length - skipped];
				Array.Copy(node.Children, newArray, newArray.Length);
				node.Children = newArray;

				node.Count -= removals;

				if (node.Count < _load && node.Count != 0)
				    ShrinkChild(node.Parent, node.Index);
			}
            return removals;
        }

        /// <summary>Removes all instances of a given value.</summary>
        public void Remove(T removal)
        {
            Omnitree.Bound<Axis1> min1; Omnitree.Bound<Axis1> max1;
            this._getBounds(removal, out min1, out max1);
            this.RemoveOverlapped(this._top, new Omnitree.Bounds<Axis1>(min1, max1), item => this._equate(item, removal));
        }
        /// <summary>Removes all the items in a given space.</summary>
        /// <param name="axis1">The axis of the removal along the  1D axis.</param>
        /// <returns>The number of items that were removed.</returns>
        public void RemoveOverlapped(Axis1 axis1)
        {
            this.RemoveOverlapped(axis1, axis1);
            Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
        }
        
        /// <summary>Removes all the items in a given space validated by a predicate.</summary>
        /// <param name="axis1">The axis of the removal along the  1D axis.</param>
        /// <param name="where">The equality constraint of the removal.</param>
        public void RemoveOverlapped(Axis1 axis1, Predicate<T> where)
        {
			this.RemoveOverlapped(axis1, axis1, where);
            Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
        }

        #endregion

        #region Stepper And IEnumerable

        /// <summary>Traverses every item in the tree and performs the delegate in them.</summary>
        /// <param name="function">The delegate to perform on every item in the tree.</param>
        public void Stepper(Step<T> function)
        {
            this.Stepper(function, this._top);
        }
        private void Stepper(Step<T> function, Node node)
        {
            Node.ValueNode list = node.Head;
            while (list != null)
            {
                function(list.Value);
                list = list.Next;
            }
			if (node.Children != null)
				foreach (Node child in node.Children)
				    this.Stepper(function, child);
        }

        /// <summary>Traverses every item in the tree and performs the delegate in them.</summary>
        /// <param name="function">The delegate to perform on every item in the tree.</param>
        public StepStatus Stepper(StepBreak<T> function)
        {
            return Stepper(function, _top);
        }
        private StepStatus Stepper(StepBreak<T> function, Node node)
        {
            StepStatus status = StepStatus.Continue;
            
            for (Node.ValueNode list = node.Head; list != null; list = list.Next)
                if ((status = function(list._value)) != StepStatus.Continue)
                    break;
            
			if (node.Children != null)
				foreach (Node child in node.Children)
				    if ((status = Stepper(function, child)) != StepStatus.Continue)
				        break;
            
            return status;
        }

        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="function">The delegate to perform on all items in the tree within the given bounds.</param>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
        public void StepperEncapsulated(Step<T> function, Axis1 min1, Axis1 max1)
        {
            StepperEncapsulated(function, _top, new Omnitree.Bounds<Axis1>(min1, max1));
        }
        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="function">The delegate to perform on all items in the tree within the given bounds.</param>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
        public void StepperEncapsulated(Step<T> function, Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1)
        {
            StepperEncapsulated(function, _top, new Omnitree.Bounds<Axis1>(min1, max1));
        }
        private void StepperEncapsulated(Step<T> function, Node node, Omnitree.Bounds<Axis1> bounds)
        {
            StepperBase(function, node, bounds, (a, b) => this.EncapsulationCheck(a, b));
        }

		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="function">The delegate to perform on all items in the tree within the given bounds.</param>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
        public void StepperOverlapped(Step<T> function, Axis1 min1, Axis1 max1)
        {
            StepperOverlapped(function, _top, new Omnitree.Bounds<Axis1>(min1, max1));
        }
        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="function">The delegate to perform on all items in the tree within the given bounds.</param>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
        public void StepperOverlapped(Step<T> function, Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1)
        {
            StepperOverlapped(function, _top, new Omnitree.Bounds<Axis1>(min1, max1));
        }
        private void StepperOverlapped(Step<T> function, Node node, Omnitree.Bounds<Axis1> bounds)
        {
            StepperBase(function, node, bounds, (a, b) => this.InclusionCheck(a, b));
        }

		private void StepperBase(
			Step<T> function,
			Node node,
			Omnitree.Bounds<Axis1> bounds,
			Omnitree.SpatialCheck<Omnitree.Bounds<Axis1>, Omnitree.Bounds<Axis1>> spatialCheck)
        {
            for (Node.ValueNode list = node.Head; list != null; list = list.Next)
                if (spatialCheck(bounds, GetBoundings(list.Value)))
                    function(list.Value);

			if (node.Children != null)
			{
				foreach (Node child in node.Children)
				    // optimization: stop bounds checking if space encapsulates node
				    if (EncapsulationCheck(bounds, child.Bounds))
				        this.Stepper(function, child);
				    else if (InclusionCheck(child.Bounds, bounds))
				        this.StepperBase(function, child, bounds, spatialCheck);
			}
        }

        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
        public StepStatus StepperEncapsulated(StepBreak<T> function, Axis1 min1, Axis1 max1)
        {
            return StepperEncapsulated(function, _top, new Omnitree.Bounds<Axis1>(min1, max1));
        }
        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
        public StepStatus StepperEncapsulated(StepBreak<T> function, Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1)
        {
			return StepperEncapsulated(function, _top, new Omnitree.Bounds<Axis1>(min1, max1));
        }
        private StepStatus StepperEncapsulated(StepBreak<T> function, Node node, Omnitree.Bounds<Axis1> bounds)
        {
            return StepperBase(function, node, bounds, (a, b) => this.EncapsulationCheck(a, b));
        }

		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
        public StepStatus StepperOverlapped(StepBreak<T> function, Axis1 min1, Axis1 max1)
        {
            return StepperOverlapped(function, _top, new Omnitree.Bounds<Axis1>(min1, max1));
        }
        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
        public StepStatus StepperOverlapped(StepBreak<T> function, Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1)
        {
			return StepperOverlapped(function, _top, new Omnitree.Bounds<Axis1>(min1, max1));
        }
        private StepStatus StepperOverlapped(StepBreak<T> function, Node node, Omnitree.Bounds<Axis1> bounds)
        {
            return StepperBase(function, node, bounds, (a, b) => this.InclusionCheck(a, b));
        }

		private StepStatus StepperBase(
			StepBreak<T> function,
			Node node,
			Omnitree.Bounds<Axis1> bounds,
			Omnitree.SpatialCheck<Omnitree.Bounds<Axis1>, Omnitree.Bounds<Axis1>> spatialCheck)
        {
            StepStatus status = StepStatus.Continue;

            for (Node.ValueNode list = node.Head; list != null; list = list.Next)
                if (spatialCheck(bounds, GetBoundings(list.Value)) &&
                    (status = function(list.Value)) != StepStatus.Continue)
                    break;

			if (node.Children != null)
			{
				foreach (Node child in node.Children)
				    // optimization: stop bounds checking if space encapsulates node
				    if (EncapsulationCheck(bounds, child.Bounds) &&
				        (status = this.Stepper(function, child)) != StepStatus.Continue)
				        break;
				    else if (!InclusionCheck(child.Bounds, bounds) &&
				        (status = this.StepperBase(function, child, bounds, spatialCheck)) != StepStatus.Continue)
				        break;
			}

            return status;
        }

        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="axis1">The axis of the removal along the  1D axis.</param>
        public void StepperOverlapped(Step<T> function, Axis1 axis1)
        {
            StepperOverlapped(function, this._top, new Omnitree.Bounds<Axis1>(axis1, axis1));
        }

        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="function">The delegate to perform on all items in the tree within the given bounds.</param>
        /// <param name="axis1">The axis of the removal along the  1D axis.</param>
        public StepStatus StepperOverlapped(StepBreak<T> function, Axis1 axis1)
        {
			return StepperOverlapped(function, this._top, new Omnitree.Bounds<Axis1>(axis1, axis1));
        }

        /// <summary>FOR COMPATIBILITY ONLY. AVOID IF POSSIBLE.</summary>
        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
        {
            throw new System.NotImplementedException();
            //return (this.ToArray() as System.Collections.Generic.IEnumerable<T>).GetEnumerator();
        }

        /// <summary>FOR COMPATIBILITY ONLY. AVOID IF POSSIBLE.</summary>
        System.Collections.Generic.IEnumerator<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator()
        {
            throw new System.NotImplementedException();
            //return (this.ToArray() as System.Collections.Generic.IEnumerable<T>).GetEnumerator();
        }

        #endregion

        #region Helpers

        private bool StraddlesLines(Omnitree.Bounds<Axis1> bounds, Omnitree.Vector<Axis1> vector)
        {
			if ((!bounds.Min1.Exists || (this._compare1(bounds.Min1.Value, vector.Axis1) != Comparison.Greater)) &&
				(!bounds.Max1.Exists || (this._compare1(bounds.Max1.Value, vector.Axis1) != Comparison.Less)))
				return true;
            return false;
        }

        /// <summary>Computes the child index that contains the desired dimensions.</summary>
        /// <param name="node">The branch .</param>
        /// <param name="vector">The dimensions to determine the child index.</param>
        /// <returns>The computed child index based on the coordinates relative to the center of the node.</returns>
        private int DetermineChildIndex(Omnitree.Vector<Axis1> pointOfDivision, Omnitree.Bounds<Axis1> bounds)
        {
			// make sure a child encapsulates the bounds (otherwise the bounds cannot move down the tree)
			if (StraddlesLines(bounds, pointOfDivision))
				return -1;

            int child = 0;
            if (!bounds.Min1.Exists || !(this._compare1(bounds.Min1.Value, pointOfDivision.Axis1) == Comparison.Less))
                child += 1 << 0;
            return child;
        }

        /// <summary>Converts a branch back into a leaf when the count is reduced.</summary>
        /// <param name="parent">The parent to shrink a child of.</param>
        /// <param name="child">The index of the child to shrink.</param>
        private void ShrinkChild(Node parent, int child_index)
        {
            Node leaf;
            Node removal = null;
            if (parent == null) // top of tree
            {
                removal = this._top;
                leaf = new Node(Omnitree.Bounds<Axis1>.None, null, -1);
                this._top = leaf;
            }
            else // non-top branch
            {
                removal = parent[child_index];
                leaf = new Node(removal.Bounds, removal.Parent, removal.Index);
                parent[child_index] = leaf;
            }

            this.Stepper((T step) => { leaf.Add(step); }, removal);
        }

        /// <summary>Reduces the counts of all the parents of a given node by a given amount.</summary>
        /// <param name="parent">The starting parent of the reduction.</param>
        /// <param name="reduction">The amount to reduce the parent counts by.</param>
        private void ReduceParentCounts(Node parent, int reduction)
        {
            IncreaseParentCounts(parent, -reduction);
        }

        /// <summary>Increases the counts of all the parents of a given node by a given amount.</summary>
        /// <param name="parent">The starting parent of the increase.</param>
        /// <param name="increase">The amount to increase the parent counts by.</param>
        private void IncreaseParentCounts(Node parent, int increase)
        {
            Node looper = parent;
            while (looper != null)
            {
                looper.Count += increase;
                looper = looper.Parent;
            }
        }

        /// <summary>Checks a node for inclusion (overlap) between two bounds.</summary>
        /// <returns>True if the spaces overlap; False if not.</returns>
        private bool InclusionCheck(Omnitree.Bounds<Axis1> a, Omnitree.Bounds<Axis1> b)
        {

            if (a.Max1.Exists && b.Min1.Exists && this._compare1(a.Max1.Value, b.Min1.Value) == Comparison.Less)
                return false;
            else if (a.Min1.Exists && b.Max1.Exists && this._compare1(a.Min1.Value, b.Max1.Value) == Comparison.Greater)
                return false;

            return true;
        }

        /// <summary>Checks if a space encapsulates a point.</summary>
        /// <returns>True if the space encapsulates the point; False if not.</returns>
        private bool EncapsulationCheck(Omnitree.Bounds<Axis1> bounds, Omnitree.Vector<Axis1> vector)
        {
            // if the location is not outside the bounds, it must be inside

            if (bounds.Min1.Exists && this._compare1(vector.Axis1, bounds.Min1.Value) == Comparison.Less)
                return false;
            else if (bounds.Max1.Exists && this._compare1(vector.Axis1, bounds.Max1.Value) == Comparison.Greater)
                return false;

            return true;
        }

        /// <summary>Checks if a space (left) encapsulates another space (right).</summary>
        /// <returns>True if the left space encapsulates the right; False if not.</returns>
        private bool EncapsulationCheck(Omnitree.Bounds<Axis1> a, Omnitree.Bounds<Axis1> b)
        {
            if ((a.Min1.Exists && !b.Min1.Exists))
                return false;
			if ((a.Max1.Exists && !b.Max1.Exists))
                return false;

            if (b.Min1.Exists && a.Min1.Exists && this._compare1(a.Min1.Value, b.Min1.Value) != Comparison.Less)
                return false;
            if (b.Max1.Exists && a.Max1.Exists && this._compare1(a.Max1.Value, b.Max1.Value) != Comparison.Greater)
                return false;

            return true;
        }

        /// <summary>Checks for equality between two locations.</summary>
        /// <returns>True if equal; False if not;</returns>
        private bool EqualsCheck(Omnitree.Vector<Axis1> a, Omnitree.Vector<Axis1> b)
        {

            if (!this._equate1(a.Axis1, b.Axis1))
                return false;

            return true;
        }

        /// <summary>Gets the nearest parent that encapsulates a location.</summary>
        /// <param name="node">The starting node to find the encapsulating parent of the location.</param>
        /// <param name="bounds">The bounds to get the encapsulating parent from.</param>
        /// <returns>The nearest node that encapsulates the given location.</returns>
        private Node GetEncapsulationParent(Node node, Omnitree.Bounds<Axis1> bounds)
        {
            while (node != null && !EncapsulationCheck(node.Bounds, bounds))
                node = node.Parent;
            return node;
        }

        private Omnitree.Bounds<Axis1> GetBoundings(T value)
        {
            Omnitree.Bound<Axis1> min1; Omnitree.Bound<Axis1> max1;
            this._getBounds(value,
				out min1, out max1);
            return new Omnitree.Bounds<Axis1>(
				min1, max1);
        }

        #endregion

        #endregion
    }

    #endregion

    #region 2 Dimensional

    public interface IOmnitreeBounds<T, Axis1, Axis2> : IDataStructure<T>,
            DataStructure.ICountable,
            DataStructure.IAddable<T>,
            DataStructure.IClearable,
            DataStructure.IRemovable<T>,
            DataStructure.IEquating<T>
    {
        #region Properties

        /// <summary>The number of dimensions in this tree.</summary>
        int Dimensions { get; }

        #endregion

        #region Methods

        /// <summary>Counts the number of items encapsulated by a sub space.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
        /// <returns>The number of items in the provided sub space.</returns>
        int CountSubSpaceEncapsulated(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2);

		/// <summary>Counts the number of items overlapped by a sub space.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
        /// <returns>The number of items in the provided sub space.</returns>
        int CountSubSpaceOverlapped(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2);

        /// <summary>Iterates through the entire tree and ensures each item is in the proper leaf.</summary>
        void Update();
        /// <summary>Iterates through the provided dimensions and ensures each item is in the proper leaf.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
        void Update(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2);

        /// <summary>Removes all the items in a given space.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
        void RemoveEncapsulated(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2);
        /// <summary>Removes all the items in a given space where predicate is met.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
        /// <param name="where">The predicate constraint of the removal.</param>
        void RemoveEncapsulated(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Predicate<T> where);

		/// <summary>Removes all the items in a given space.</summary>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
        void RemoveOverlapped(Axis1 axis1, Axis2 axis2);
        /// <summary>Removes all the items in a given space.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
        void RemoveOverlapped(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2);
        /// <summary>Removes all the items in a given space where equality is met.</summary>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
        /// <param name="where">The equality constraint of the removal.</param>
        void RemoveOverlapped(Axis1 axis1, Axis2 axis2, Predicate<T> where);
        /// <summary>Removes all the items in a given space where predicate is met.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
        /// <param name="where">The predicate constraint of the removal.</param>
        void RemoveOverlapped(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Predicate<T> where);

        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="step">The step function to perform on all items in the tree within the given bounds.</param>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
        void StepperEncapsulated(Step<T> step, Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2);
        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="step">The step function to perform on all items in the tree within the given bounds.</param>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
        StepStatus StepperEncapsulated(StepBreak<T> step, Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2);
        
		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="step">The step function to perform on all items in the tree within the given bounds.</param>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
        void StepperOverlapped(Step<T> step, Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2);
        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="step">The step function to perform on all items in the tree within the given bounds.</param>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
        StepStatus StepperOverlapped(StepBreak<T> step, Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2);

		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="step">The step function to perform on all items in the tree within the given bounds.</param>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
        void StepperOverlapped(Step<T> step, Axis1 axis1, Axis2 axis2);
        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="step">The step function to perform on all items in the tree within the given bounds.</param>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
        StepStatus StepperOverlapped(StepBreak<T> function, Axis1 axis1, Axis2 axis2);

        #endregion
    }

    public class OmnitreeBoundsLinked<T, Axis1, Axis2> : IOmnitreeBounds<T, Axis1, Axis2>
    {
        private const int _dimensions = 2;
        internal static int _children_per_node = (int)BigInteger.Pow(2, 2);

        private Node _top;

		private int _naturalLogLower = 1; // caching the next time to calculate loads (lower count)
		private int _naturalLogUpper = -1; // caching the next time to calculate loads (upper count)
        private int _load; // ln(count); min = _defaultLoad
        private Omnitree.GetBounds<T, Axis1, Axis2> _getBounds;

        private bool _defaultEquate;
        private Equate<T> _equate;


        private bool _defaultEquate1;
        private Equate<Axis1> _equate1;

        private bool _defaultEquate2;
        private Equate<Axis2> _equate2;



        private bool _defaultCompare1;
        private Compare<Axis1> _compare1;

        private bool _defaultCompare2;
        private Compare<Axis2> _compare2;


        // allows median overriding for custom optimizations (USE AT YOUR OWN RISK)
        private Omnitree.SubdivisionOverride<T, Axis1, Omnitree.Bounds<Axis1, Axis2>> _subdivisionOverride1;
        private Omnitree.SubdivisionOverride<T, Axis2, Omnitree.Bounds<Axis1, Axis2>> _subdivisionOverride2;

        #region Nested Types

        /// <summary>Can be a leaf or a branch.</summary>
        internal class Node
        {
            public class ValueNode
            {
                internal T _value;
                internal ValueNode _next;

                public T Value { get { return _value; } set { _value = value; } }
                public ValueNode Next { get { return _next; } set { _next = value; } }

                public ValueNode(T value, ValueNode next)
                {
                    _value = value;
                    _next = next;
                }
            }

            internal Omnitree.Bounds<Axis1, Axis2> _bounds;
            internal Node _parent;
            internal int _index;
            internal int _count;
            internal ValueNode _head;
            private Node[] _children;
            private Omnitree.Vector<Axis1, Axis2>? _pointOfDivision;

            /// <summary>The parent of this node.</summary>
            public Omnitree.Bounds<Axis1, Axis2> Bounds { get { return this._bounds; } }
            /// <summary>The parent of this node.</summary>
            public Node Parent { get { return this._parent; } }
            /// <summary>The computed child index of this node (see the "Notes" region in "Omnitree.cs" for the algorithm.</summary>
            public int Index { get { return this._index; } }
            /// <summary>The number of elements stored in this node and its children.</summary>
            public int Count { get { return this._count; } set { this._count = value; } }
            /// <summary>The first object stored in this node.</summary>
            public ValueNode Head { get { return this._head; } set { this._head = value; } }
            public Node[] Children { get { return this._children; } set { this._children = value; } }
            public Omnitree.Vector<Axis1, Axis2>? PointOfDivision { get { return this._pointOfDivision; } internal set { this._pointOfDivision = value; } }

            /// <summary>Gets child by index.</summary>
            /// <param name="child_index">The index of the child to get.</param>
            /// <returns>The child of the given index or null if non-existent.</returns>
            public Node this[int child_index]
            {
                get
                {
                    if (this._children == null)
                        return null;
                    if (this._children.Length == OmnitreePointsLinked<T, Axis1, Axis2>._children_per_node)
                        return this._children[(int)child_index];
                    foreach (Node node in this._children)
                        if (node.Index == child_index)
                            return node;
                    return null;
                }
                set
                {
                    // This error check should be unnecessary... but fuck it... might as well
                    if (value.Index != child_index)
                        throw new System.Exception("Bug in Omnitree (index/property mis-match when setting a child on a branch)");

                    // no children yet
                    if (this._children == null)
                    {
                        this._children = new Node[] { value };
                        return;
                    }
                    // max children overwrite
                    else if (this._children.Length == OmnitreePointsLinked<T, Axis1, Axis2>._children_per_node)
                    {
                        this._children[(int)child_index] = value;
                        return;
                    }
                    // non-max child overwrite
                    for (int i = 0; i < this._children.Length; i++)
                        if (this._children[i].Index == child_index)
                        {
                            this._children[i] = value;
                            return;
                        }
                    // new child
                    Node[] newArray = new Node[this._children.Length + 1];
                    if (newArray.Length == OmnitreePointsLinked<T, Axis1, Axis2>._children_per_node)
                    {
                        // new child resulting in a max children branch (sorting required)
                        for (int i = 0; i < this._children.Length; i++)
                        {
                            newArray[(int)this._children[i]._index] = this._children[i];
                        }
                        newArray[(int)value._index] = value;
                    }
                    else
                    {
                        // new child resulting in a non-max children branch
                        Array.Copy(this._children, newArray, this._children.Length);
                        newArray[newArray.Length - 1] = value;
                    }
                    this._children = newArray;
                }
            }

            /// <summary>The depth this node is located in the Omnitree.</summary>
            public int Depth
            {
                get
                {
                    int depth = -1;
                    for (Node looper = this; looper != null; looper = looper.Parent)
                        depth++;
                    return depth;
                }
            }

            /// <summary>Constructs a node.</summary>
            /// <param name="bounds">The bounds of this node.</param>
            /// <param name="parent">The parent of this node.</param>
            /// <param name="index">The number of elements stored in this node and its children.</param>
            public Node(Omnitree.Bounds<Axis1, Axis2> bounds, Node parent, int index)
            {
                this._bounds = bounds;
                this._parent = parent;
                this._index = index;
            }

            public Node(Omnitree.Vector<Axis1, Axis2> pointOfDivision, Omnitree.Bounds<Axis1, Axis2> bounds, Node parent, int index)
                : this(bounds, parent, index)
            {
                this._pointOfDivision = pointOfDivision;
            }

            internal Node(Node nodeToClone)
            {
                this._bounds = nodeToClone._bounds;
                this._parent = nodeToClone._parent;
                this._index = nodeToClone._index;
                this._count = nodeToClone._count;

                this._children = nodeToClone._children.Clone() as Node[];
                this._pointOfDivision = nodeToClone._pointOfDivision;

                ValueNode this_looper = this._head;
                ValueNode other_looper = nodeToClone._head;

                while (other_looper != null)
                {
                    this_looper.Next = new ValueNode(other_looper.Next.Value, null);
                    this_looper = this_looper.Next;
                    other_looper = other_looper.Next;
                }
            }

            public void Add(T addition)
            {
                this._head = new ValueNode(addition, this._head);
                this.Count++;
            }

            internal Node Clone()
            {
                return new Node(this);
            }
        }
        
        #endregion

        #region Constructors

        /// <summary>This constructor is for cloning purposes</summary>
        private OmnitreeBoundsLinked(OmnitreeBoundsLinked<T, Axis1, Axis2> omnitree)
        {
            this._top = omnitree._top.Clone();
            this._load = omnitree._load;
            this._getBounds = omnitree._getBounds;
            this._defaultEquate = omnitree._defaultEquate;
            this._equate = omnitree._equate;

            this._defaultEquate1 = omnitree._defaultEquate1;
            this._equate1 = omnitree._equate1;
            this._defaultEquate2 = omnitree._defaultEquate2;
            this._equate2 = omnitree._equate2;

            this._defaultCompare1 = omnitree._defaultCompare1;
            this._compare1 = omnitree._compare1;
            this._defaultCompare2 = omnitree._defaultCompare2;
            this._compare2 = omnitree._compare2;

            this._subdivisionOverride1 = omnitree._subdivisionOverride1;
            this._subdivisionOverride2 = omnitree._subdivisionOverride2;
        }

        private OmnitreeBoundsLinked(
            Omnitree.GetBounds<T, Axis1, Axis2> getBounds,

            bool defaultEquate,
            Equate<T> equate,

            bool defaultEquate1,
            Equate<Axis1> equateAxis1,
            bool defaultEquate2,
            Equate<Axis2> equateAxis2,

            bool defaultCompare1,
            Compare<Axis1> compare1,
            bool defaultCompare2,
            Compare<Axis2> compare2,

            Omnitree.SubdivisionOverride<T, Axis1, Omnitree.Bounds<Axis1, Axis2>> subdivisionOverride1,
            Omnitree.SubdivisionOverride<T, Axis2, Omnitree.Bounds<Axis1, Axis2>> subdivisionOverride2)
        {
			if (getBounds == null)
			{
				throw new ArgumentNullException(nameof(getBounds));
			}
			if (equate == null)
			{
				throw new ArgumentNullException(nameof(equate));
			}

			if (equateAxis1 == null)
			{
				throw new ArgumentNullException(nameof(equateAxis1));
			}
			if (equateAxis2 == null)
			{
				throw new ArgumentNullException(nameof(equateAxis2));
			}

			if (compare1 == null)
			{
				throw new ArgumentNullException(nameof(compare1));
			}
			if (compare2 == null)
			{
				throw new ArgumentNullException(nameof(compare2));
			}

            this._getBounds = getBounds;
            this._defaultEquate = defaultEquate;
            this._equate = equate;

            this._defaultEquate1 = defaultEquate1;
            this._equate1 = equateAxis1;
            this._defaultEquate2 = defaultEquate2;
            this._equate2 = equateAxis2;

            this._defaultCompare1 = defaultCompare1;
            this._compare1 = compare1;
            this._defaultCompare2 = defaultCompare2;
            this._compare2 = compare2;

            this._subdivisionOverride1 = subdivisionOverride1;
            this._subdivisionOverride2 = subdivisionOverride2;

            this._top = new Node(Omnitree.Bounds<Axis1, Axis2>.None, null, -1);
            Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
        }

        private OmnitreeBoundsLinked(
            Omnitree.GetBounds<T, Axis1, Axis2> getBounds,
            Equate<T> equate,

            Equate<Axis1> equateAxis1,
            Equate<Axis2> equateAxis2,

            Compare<Axis1> compare1,
            Compare<Axis2> compare2,

            Omnitree.SubdivisionOverride<T, Axis1, Omnitree.Bounds<Axis1, Axis2>> subdivisionOverride1,
            Omnitree.SubdivisionOverride<T, Axis2, Omnitree.Bounds<Axis1, Axis2>> subdivisionOverride2)
            : this(
            getBounds,

            false,
            equate,

            false,
            equateAxis1,
            false,
            equateAxis2,

            false,
            compare1,
            false,
            compare2,

            subdivisionOverride1,
            subdivisionOverride2)
        { }

        public OmnitreeBoundsLinked(
            Omnitree.GetBounds<T, Axis1, Axis2> getBounds,

            Equate<T> equate,

            Equate<Axis1> equateAxis1,
            Equate<Axis2> equateAxis2,

            Compare<Axis1> compare1,
            Compare<Axis2> compare2)
            : this(
                getBounds,

                false,
                equate,

                false,
                equateAxis1,
                false,
                equateAxis2,

                false,
                compare1,
                false,
                compare2,

                null,
                null)
        { }



        public OmnitreeBoundsLinked(
            Omnitree.GetBounds<T, Axis1, Axis2> getBounds,

            Equate<T> equate,

            Compare<Axis1> compare1,
            Compare<Axis2> compare2)
            : this(
                getBounds,
                false,
                equate,

                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,

                false,
                compare1,
                false,
                compare2,

                null,
                null)
        { }

        public OmnitreeBoundsLinked(
            Omnitree.GetBounds<T, Axis1, Axis2> getBounds,
            Equate<T> equate,

            Compare<Axis1> compare1,
            Compare<Axis2> compare2,

            Omnitree.SubdivisionOverride<T, Axis1, Omnitree.Bounds<Axis1, Axis2>> subdivisionOverride1,
            Omnitree.SubdivisionOverride<T, Axis2, Omnitree.Bounds<Axis1, Axis2>> subdivisionOverride2)
            : this(
                getBounds,

                false,
                equate,

                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,

                false,
                compare1,
                false,
                compare2,

                subdivisionOverride1,
                subdivisionOverride2)
        { }

        public OmnitreeBoundsLinked(
            Omnitree.GetBounds<T, Axis1, Axis2> getBounds,

            Compare<Axis1> compare1,
            Compare<Axis2> compare2)
            : this(
                getBounds,
                true,
                Towel.Equate.Default,

                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,

                false,
                compare1,
                false,
                compare2,

                null,
                null)
        { }

        public OmnitreeBoundsLinked(
            Omnitree.GetBounds<T, Axis1, Axis2> getBounds,

            Compare<Axis1> compare1,
            Compare<Axis2> compare2,

            Omnitree.SubdivisionOverride<T, Axis1, Omnitree.Bounds<Axis1, Axis2>> subdivisionOverride1,
            Omnitree.SubdivisionOverride<T, Axis2, Omnitree.Bounds<Axis1, Axis2>> subdivisionOverride2)
            : this(
                getBounds,

                true,
                Towel.Equate.Default,

                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,

                false,
                compare1,
                false,
                compare2,

                subdivisionOverride1,
                subdivisionOverride2)
        { }

        public OmnitreeBoundsLinked(
            Omnitree.GetBounds<T, Axis1, Axis2> getBounds,
            Equate<T> equate)
            : this(
                getBounds,

                false,
                equate,

                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,

                true,
                Compare.Default,
                true,
                Compare.Default,

                null,
                null)
        { }

        public OmnitreeBoundsLinked(
            Omnitree.GetBounds<T, Axis1, Axis2> getBounds,
            Equate<T> equate,
            Omnitree.SubdivisionOverride<T, Axis1, Omnitree.Bounds<Axis1, Axis2>> subdivisionOverride1,
            Omnitree.SubdivisionOverride<T, Axis2, Omnitree.Bounds<Axis1, Axis2>> subdivisionOverride2)
            : this(
                getBounds,

                false,
                equate,

                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,

                true,
                Compare.Default,
                true,
                Compare.Default,

                subdivisionOverride1,
                subdivisionOverride2)
        { }

        public OmnitreeBoundsLinked(
            Omnitree.GetBounds<T, Axis1, Axis2> getBounds)
            : this(
                getBounds,

                true,
                Towel.Equate.Default,

                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,

                true,
                Compare.Default,
                true,
                Compare.Default,

                null,
                null)
        { }

		public OmnitreeBoundsLinked(
            Omnitree.GetBoundings<T, Axis1, Axis2> getBoundings)
            : this(
                Omnitree.ConvertToGetBounds(getBoundings),

                true,
                Towel.Equate.Default,

                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,

                true,
                Compare.Default,
                true,
                Compare.Default,

                null,
                null)
        { }

        public OmnitreeBoundsLinked(
            Omnitree.GetBounds<T, Axis1, Axis2> getBounds,
            Omnitree.SubdivisionOverride<T, Axis1, Omnitree.Bounds<Axis1, Axis2>> subdivisionOverride1,
            Omnitree.SubdivisionOverride<T, Axis2, Omnitree.Bounds<Axis1, Axis2>> subdivisionOverride2)
            : this(
                getBounds,

                true,
                Towel.Equate.Default,

                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,

                true,
                Compare.Default,
                true,
                Compare.Default,

                subdivisionOverride1,
                subdivisionOverride2)
        { }

        #endregion

        #region Properties

        /// <summary>The number of dimensions in this tree.</summary>
        public int Dimensions { get { return _dimensions; } }

        /// <summary>The function for equating keys in this table.</summary>
        public Equate<T> Equate { get { return this._equate; } }

        /// <summary>The location function the Omnitree is using.</summary>
        public Omnitree.GetBounds<T, Axis1, Axis2> GetBounds { get { return this._getBounds; } }

        /// <summary>The comparison function the Omnitree is using along the 1D axis.</summary>
        public Compare<Axis1> Compare1 { get { return this._compare1; } }
        /// <summary>The comparison function the Omnitree is using along the 2D axis.</summary>
        public Compare<Axis2> Compare2 { get { return this._compare2; } }

        /// <summary>The function for equating values along the 1D axis.</summary>
        public Equate<Axis1> EquateAxis1 { get { return this._equate1; } }
        /// <summary>The function for equating values along the 2D axis.</summary>
        public Equate<Axis2> EquateAxis2 { get { return this._equate2; } }

        /// <summary>The current number of items in the tree.</summary>
        public int Count { get { return this._top.Count; } }

        private delegate void MaxDepthFinder(Node node, int current_depth, ref int max_depth);
        /// <summary>Finds the current maximum depth of the tree. NOT AN O(1) OPERATION. Intended for educational purposes only.</summary>
        public int MaxDepth
        {
            get
            {
                MaxDepthFinder maxDepthFinder = null;
                maxDepthFinder =
                        (Node node, int current_depth, ref int max_depth) =>
                        {
                            if (current_depth > max_depth)
                                max_depth = current_depth;
                            foreach (Node child in node.Children)
                                maxDepthFinder(child, current_depth + 1, ref max_depth);
                        };
                int _max_depth = -1;
                maxDepthFinder(this._top, 0, ref _max_depth);
                return _max_depth;
            }
        }

        private delegate void NodeCountFinder(Node node, ref int current_count);
        /// <summary>Counts the current number of nodes in the tree. NOT AN O(1) OPERATION. Intended for educational purposes only.</summary>
        public int NodeCount
        {
            get
            {
                NodeCountFinder nodeCountFinder = null;
                nodeCountFinder =
                        (Node node, ref int current_count) =>
                        {
                            current_count++;
                            foreach (Node child in node.Children)
                                nodeCountFinder(child, ref current_count);
                        };

                int _current_count = 0;
                nodeCountFinder(this._top, ref _current_count);
                return _current_count;
            }
        }

        #endregion

        #region Methods

        #region Add

        #region Bulk

		// not yet implemented

//        public void Add(IndexedBigArray<T> additions, bool allowMultithreading)
//        {
//            if (additions.Length > int.MaxValue)
//                throw new System.Exception("The maximum size of the Omnitree was exceeded during bulk addition.");
//
//            if (this._top.Count != 0 || (int)additions.Length <= _load)
//            {
//                for (ulong i = 0; i < additions.Length; i++)
//                    this.Add(additions[i]);
//            }
//            else
//            {
//                // adjust the loads prior to additions
//                ComputeLoads((int)additions.Length);
//
//                Node new_top = new Node(Omnitree.Bounds<Axis1, Axis2>.None, null, -1);
//                new_top.Count = (int)additions.Length;
//
//
//                // prepare data for median computations
//                IndexedBigArray<Axis1> values1;
//                IAsyncResult result1 = null;
//                if (this._subdivisionOverride1 != null)
//                    values1 = null;
//                else
//                {
//                    values1 = null;
//                    Towel.Parallels.Parallel.Operation operation = () =>
//                    {
//                        values1 = new IndexedBigArray<Axis1>(additions.Length * 2);
//                        for (ulong i = 0; i < additions.Length; i++)
//						{
//							Omnitree.Bounds<Axis1, Axis2> bounds = GetBoundings(additions[i]);
//                            values1[i * 2] = bounds.Min1;
//							values1[i * 2 + 1] = bounds.Max1;
//						}
//
//                        Towel.Algorithms.Sort.Merge(this._compare1, (int i) => { return values1[(ulong)i]; }, (int i, Axis1 value) => { values1[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
//                    };
//
//                    if (allowMultithreading)
//                        result1 = Towel.Parallels.Parallel.Thread(operation);
//                    else
//                        operation();
//                }
//
//                // prepare data for median computations
//                IndexedBigArray<Axis2> values2;
//                IAsyncResult result2 = null;
//                if (this._subdivisionOverride2 != null)
//                    values2 = null;
//                else
//                {
//                    values2 = null;
//                    Towel.Parallels.Parallel.Operation operation = () =>
//                    {
//                        values2 = new IndexedBigArray<Axis2>(additions.Length * 2);
//                        for (ulong i = 0; i < additions.Length; i++)
//						{
//							Omnitree.Bounds<Axis1, Axis2> bounds = GetBoundings(additions[i]);
//                            values2[i * 2] = bounds.Min1;
//							values2[i * 2 + 1] = bounds.Max1;
//						}
//
//                        Towel.Algorithms.Sort.Merge(this._compare2, (int i) => { return values2[(ulong)i]; }, (int i, Axis2 value) => { values2[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
//                    };
//
//                    if (allowMultithreading)
//                        result2 = Towel.Parallels.Parallel.Thread(operation);
//                    else
//                        operation();
//                }
//
//
//
//                if (this._subdivisionOverride1 == null && allowMultithreading)
//                    result1.AsyncWaitHandle.WaitOne();
//                if (this._subdivisionOverride2 == null && allowMultithreading)
//                    result2.AsyncWaitHandle.WaitOne();
//
//                // build the tree
//                Add(new_top, 1, -1, additions.Stepper(), (int)additions.Length, int.MinValue, int.MinValue, (int)additions.Length, (int index) => { return values1[index]; }, (int index) => { return values2[index]; }, allowMultithreading);
//                
//                this._top = new_top;
//            }
//        }
//
//        public void Add(bool allowMultithreading, params T[] additions)
//        {
//            if (additions.Length > int.MaxValue)
//                throw new System.Exception("The maximum size of the Omnitree was exceeded during bulk addition.");
//
//            if (this._top.Count != 0 || (int)additions.Length <= _load)
//            {
//                for (int i = 0; i < additions.Length; i++)
//                    this.Add(additions[i]);
//            }
//            else
//            {
//                // adjust the loads prior to additions
//                ComputeLoads((int)additions.Length);
//
//                Node new_top = new Node(Omnitree.Bounds<Axis1, Axis2>.None, null, -1);
//                new_top.Count = (int)additions.Length;
//
//
//                // prepare data for median computations
//                IndexedBigArray<Axis1> values1;
//                IAsyncResult result1 = null;
//                if (this._subdivisionOverride1 != null)
//                    values1 = null;
//                else
//                {
//                    values1 = null;
//                    Towel.Parallels.Parallel.Operation operation = () =>
//                    {
//                        values1 = new IndexedBigArray<Axis1>(additions.Length);
//                        for (int i = 0; i < additions.Length; i++)
//                            values1[i] = LocateVector(additions[i]).Axis1;
//                        Towel.Algorithms.Sort.Merge(this._compare1, (int i) => { return values1[(ulong)i]; }, (int i, Axis1 value) => { values1[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
//                    };
//
//                    if (allowMultithreading)
//                        result1 = Towel.Parallels.Parallel.Thread(operation);
//                    else
//                        operation();
//                }
//
//                // prepare data for median computations
//                IndexedBigArray<Axis2> values2;
//                IAsyncResult result2 = null;
//                if (this._subdivisionOverride2 != null)
//                    values2 = null;
//                else
//                {
//                    values2 = null;
//                    Towel.Parallels.Parallel.Operation operation = () =>
//                    {
//                        values2 = new IndexedBigArray<Axis2>(additions.Length);
//                        for (int i = 0; i < additions.Length; i++)
//                            values2[i] = LocateVector(additions[i]).Axis2;
//                        Towel.Algorithms.Sort.Merge(this._compare2, (int i) => { return values2[(ulong)i]; }, (int i, Axis2 value) => { values2[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
//                    };
//
//                    if (allowMultithreading)
//                        result2 = Towel.Parallels.Parallel.Thread(operation);
//                    else
//                        operation();
//                }
//
//
//
//                if (this._subdivisionOverride1 == null && allowMultithreading)
//                    result1.AsyncWaitHandle.WaitOne();
//
//                if (this._subdivisionOverride2 == null && allowMultithreading)
//                    result2.AsyncWaitHandle.WaitOne();
//
//
//                // build the tree
//                Add(new_top, 1, -1, additions.Stepper(), additions.Length, int.MinValue, int.MinValue, (int)additions.Length, (int index) => { return values1[index]; }, (int index) => { return values2[index]; }, allowMultithreading);
//                
//                this._top = new_top;
//            }
//        }
//
//        
//        private int Add(Node parent, int depth, int child, Stepper<T> additions, int parent_count, int prevmed1, int prevmed2, int initial_count, Get<Axis1> values1, Get<Axis2> values2, bool allowMultithreading)
//        {
//            Axis1 pointOfDivision1;
//            Axis2 pointOfDivision2;
//
//            int median_axis1 = -1;
//            int median_axis2 = -1;
//            if (this._subdivisionOverride1 == null || this._subdivisionOverride2 == null)
//                GetMedianIndexes(initial_count, child, depth, prevmed1, prevmed2, out median_axis1, out median_axis2);
//
//            if (this._subdivisionOverride1 != null)
//                pointOfDivision1 = this._subdivisionOverride1(parent.Bounds, additions);
//            else
//                pointOfDivision1 = values1(median_axis1);
//
//            if (this._subdivisionOverride2 != null)
//                pointOfDivision2 = this._subdivisionOverride2(parent.Bounds, additions);
//            else
//                pointOfDivision2 = values2(median_axis2);
//
//            parent.PointOfDivision = new Omnitree.Vector<Axis1, Axis2>(pointOfDivision1, pointOfDivision2);
//
//            // divide the values along the medians
//            IMap<IAddable<T>, int> collection_map = new MapHashLinked<IAddable<T>, int>();
//            additions((T value) => 
//            {
//                int index = DetermineChildIndex(parent.PointOfDivision.Value, LocateVector(value));
//                IAddable<T> list = null;
//                if (collection_map.TryGet(index, out list))
//                {
//                    list.Add(value);
//                }
//                else
//                {
//                    if (parent_count < 100000)
//                        list = new AddableArray<T>();
//                    else
//                        list = new AddableLinked<T>();
//                    collection_map.Add(index, list);
//                    list.Add(value);
//                }
//            });
//
//            if (depth == 1 && allowMultithreading)
//            {
//                // NOTE: Must assign placeholders before multithreading so that the threads do not overwrite each other
//                collection_map.Keys((int key) => { parent[key] = new Node(Omnitree.Bounds<Axis1, Axis2>.None, parent, key); });
//                IAsyncResult[] handles = new IAsyncResult[Environment.ProcessorCount];
//                for (int i = 0; i < handles.Length; i++)
//                {
//                    int multiTheadSafe_i = i; // used as catpure variable below making it multithread-safe
//                    handles[i] = Towel.Parallels.Parallel.Thread(() =>
//                    {
//                        Step.EveryNth<Link<IAddable<T>, int>>(collection_map.Pairs, multiTheadSafe_i + 1)(
//                        (Link<IAddable<T>, int> link) =>
//                            {
//                                ReversedChildBuilding(parent, link._2, depth, link._1.Stepper, link._1.Count, median_axis1, median_axis2, initial_count, values1, values2, allowMultithreading);
//                            });
//                    });
//                }
//                
//                foreach (IAsyncResult handle in handles)
//                {
//                    handle.AsyncWaitHandle.WaitOne();
//                }
//            }
//            else
//            {
//                collection_map.Pairs((Link<IAddable<T>, int> link) =>
//                { 
//                    ReversedChildBuilding(parent, link._2, depth, link._1.Stepper, link._1.Count, median_axis1, median_axis2, initial_count, values1, values2, allowMultithreading);
//                });
//            }
//
//            int count = 0;
//            foreach (Node node in parent.Children)
//                count += node.Count;
//            return count;
//        }
//
//        int ReversedChildBuilding(Node parent, int child_index, int depth, Stepper<T> additions, int count, int prevmed1, int prevmed2, int initial_count, Get<Axis1> values1, Get<Axis2> values2, bool allowMultithreading)
//        {
//            Omnitree.Bounds<Axis1, Axis2> child_bounds = DetermineChildBounds(parent, child_index);
//            if (depth >= _load || count <= _load)
//            {
//                Node new_leaf = new Node(child_bounds, parent, child_index);
//                additions((T value) => { new_leaf.Add(value); });
//                parent[new_leaf.Index] = new_leaf;
//                return new_leaf.Count;
//            }
//            else
//            {
//                Node new_branch = new Node(Omnitree.Vector<Axis1, Axis2>.Default, child_bounds, parent, child_index);
//                parent[new_branch.Index] = new_branch;
//                new_branch.Count = Add(new_branch, depth + 1, child_index, additions, count, prevmed1, prevmed2, count, values1, values2, allowMultithreading);
//                return new_branch.Count;
//            }
//        }
//
//        /// <summary>Gets the indeces of the median values at the given position during bulk additions.</summary>
//        private void GetMedianIndexes(int count, int child_index, int depth, int previous1, int previous2, out int index1, out int index2)
//        {
//            if (depth == 1)
//            {
//                index1 = (count - 1) / 2;
//                index2 = (count - 1) / 2;
//                return;
//            }
//
//            int splits = Compute.Power(2, depth);
//            int mid_child_range = count / splits;
//
//            if (child_index >= 2)
//            {
//                index2 = previous2 + mid_child_range;
//                child_index -= 2;
//            }
//            else
//            {
//                index2 = previous2 - mid_child_range;
//            }
//
//            if (child_index >= 1)
//            {
//                index1 = previous1 + mid_child_range;
//                child_index -= 1;
//            }
//            else
//            {
//                index1 = previous1 - mid_child_range;
//            }
//
//        }

		

        #endregion

        #region single

        /// <summary>Adds an item to the tree.</summary>
        /// <param name="addition">The item to be added.</param>
        public void Add(T addition)
        {
            if (this._top.Count == int.MaxValue)
                throw new System.InvalidOperationException("(Count == int.MaxValue) max Omnitree size reached (change ints to longs if you need to).");

            // dynamic tree sizes
            Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);

            Omnitree.Bounds<Axis1, Axis2> bounds = GetBoundings(addition);

            // grow the first branch of the tree
            if (!this._top.PointOfDivision.HasValue && this._top.Count >= _load)
            {
                Node top = this._top;

                // create the new branch from the median values
                this._top = new Node(DetermineMedians(top), Omnitree.Bounds<Axis1, Axis2>.None, null, -1);

                // iterate through the elements and add them to the appropriate children
                for (Node.ValueNode list = top.Head; list != null; list = list.Next)
                    Add(list.Value, this._top, GetBoundings(list.Value), 0);
            }

            this.Add(addition, this._top, bounds, 0);
        }
        
        /// <summary>Recursive version of the add function.</summary>
        /// <param name="addition">The item to be added.</param>
        /// <param name="node">The current node for tree trversal.</param>
        /// <param name="ms">The location of the addition.</param>
        /// <param name="depth">The current depth of iteration.</param>
        private void Add(T addition, Node node, Omnitree.Bounds<Axis1, Axis2> bounds, int depth)
        {
            if (!node.PointOfDivision.HasValue)
            {
                //Leaf leaf = node as Leaf;
                if (depth >= _load || !(node.Count >= _load))
                {
                    node.Add(addition);
                    return;
                }
                else
                {
                    //Node parent = node.Parent;
                    //int child_index = this.DetermineChildIndex(parent.PointOfDivision, location);
                    //Node growth = new Node(DetermineMedians(leaf), leaf.Bounds, parent, child_index);
                    //parent[child_index] = growth;

					Node growth = new Node(DetermineMedians(node), node.Bounds, node.Parent, node.Index);
                    node.Parent[node.Index] = growth;

                    for (Node.ValueNode list = node.Head; list != null; list = list.Next)
                    {
                        Omnitree.Bounds<Axis1, Axis2> temp_bounds = GetBoundings(list.Value);
                        if (EncapsulationCheck(growth.Bounds, temp_bounds))
                            Add(list.Value, growth, temp_bounds, depth);
                        else
                        {
                            ReduceParentCounts(node.Parent, 1);
                            Add(list.Value, this._top, temp_bounds, depth);
                        }
                    }

                    Add(addition, growth, bounds, depth);
                    return;
                }
            }
            else
            {
                //Node branch = node as Node;
                int child_index = this.DetermineChildIndex(node.PointOfDivision.Value, bounds); // determine the child "index" (0 through 2^Dimensions) the addition belongs in
                
				// if -1, then the bounds of the addition straddle the point of division (keep it in current node)
				if (child_index == -1)
				{
					node.Add(addition);
                    return;
				}
				
				Node child_node = node[child_index];

                // null children in branches are just empty leaves
                if (child_node == null)
                {
                    Node new_node = new Node(DetermineChildBounds(node, child_index), node, child_index);
                    node[child_index] = new_node;
                    new_node.Add(addition);
                }
                else
                    // child exists already, continue adding
                    Add(addition, child_node, bounds, depth + 1);

                node.Count++;
                return;
            }
        }

        /// <summary>Determins the dimensions of the child at the given index.</summary>
        /// <param name="leaf">The parent of the node to compute dimensions for.</param>
        /// <param name="child">The index of the child to compute dimensions for.</param>
        /// <param name="median1">The computed minimum dimensions of the child node along the 1D axis.</param>
        /// <param name="median2">The computed minimum dimensions of the child node along the 2D axis.</param>
        /// <param name="median3">The computed minimum dimensions of the child node along the 3D axis.</param>
        private Omnitree.Vector<Axis1, Axis2> DetermineMedians(Node node)
        {
            try
            {
                // extract the values
                Omnitree.Bound<Axis1>[] values1 = new Omnitree.Bound<Axis1>[node.Count * 2];
                Omnitree.Bound<Axis2>[] values2 = new Omnitree.Bound<Axis2>[node.Count * 2];
                Node.ValueNode for_current = node.Head; // used in for loop
                for (int i = 0; i < node.Count; i++, for_current = for_current.Next)
                    this._getBounds(for_current.Value, 
					out values1[i * 2], out values1[i * 2 + 1], 
					out values2[i * 2], out values2[i * 2 + 1]);
                return new Omnitree.Vector<Axis1, Axis2>(
					Omnitree.SubDivide(values1, this._defaultCompare1 ? Compare.Default : this._compare1), 
					Omnitree.SubDivide(values2, this._defaultCompare2 ? Compare.Default : this._compare2));
            }
            catch
            {
                // extract the values
                IndexedBigArray<Omnitree.Bound<Axis1>> values1 = new IndexedBigArray<Omnitree.Bound<Axis1>>(node.Count * 2);
                IndexedBigArray<Omnitree.Bound<Axis2>> values2 = new IndexedBigArray<Omnitree.Bound<Axis2>>(node.Count * 2);
                Node.ValueNode for_current = node.Head; // used in for loop
                for (int i = 0; i < node.Count; i++, for_current = for_current.Next)
                {
                    Omnitree.Bound<Axis1> min1; Omnitree.Bound<Axis1> max1;
                    Omnitree.Bound<Axis2> min2; Omnitree.Bound<Axis2> max2;
                    this._getBounds(for_current.Value,
						out min1, out max1,
						out min2, out max2);
                    values1[i * 2] = min1; values1[i * 2 + 1] = max1;
                    values2[i * 2] = min2; values2[i * 2 + 1] = max2;
                }
				return new Omnitree.Vector<Axis1, Axis2>(
					Omnitree.SubDivide(values1, this._defaultCompare1 ? Compare.Default : this._compare1), 
					Omnitree.SubDivide(values2, this._defaultCompare2 ? Compare.Default : this._compare2));
            }
        }

        #endregion

        #region Add Helpers

        private Omnitree.Bounds<Axis1, Axis2> DetermineChildBounds(Node node, int child_index)
        {
			// the node parameter should always have a point of division value for this function
			Omnitree.Vector<Axis1, Axis2> pointOfDivision = node.PointOfDivision.Value;

            Omnitree.Bound<Axis2> min2, max2;
            if (child_index >= 2)
            {
                min2 = pointOfDivision.Axis2;
                max2 = node.Bounds.Max2;
                child_index -= 2;
            }
            else
            {
                min2 = node.Bounds.Min2;
                max2 = pointOfDivision.Axis2;
            }

            Omnitree.Bound<Axis1> min1, max1;
            if (child_index >= 1)
            {
                min1 = pointOfDivision.Axis1;
                max1 = node.Bounds.Max1;
                child_index -= 1;
            }
            else
            {
                min1 = node.Bounds.Min1;
                max1 = pointOfDivision.Axis1;
            }

            return new Omnitree.Bounds<Axis1, Axis2>(min1, max1, min2, max2);
        }

        #endregion

        #endregion

        #region Clear

        /// <summary>Returns the tree to an empty state.</summary>
        public void Clear()
        {
            this._top = new Node(Omnitree.Bounds<Axis1, Axis2>.None, null, -1);
            Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
        }

        #endregion

        #region Clone

        /// <summary>Creates a shallow clone of this data structure.</summary>
        /// <returns>A shallow clone of this data structure.</returns>
        public OmnitreeBoundsLinked<T, Axis1, Axis2> Clone()
        {
            return new OmnitreeBoundsLinked<T, Axis1, Axis2>(this);
        }

        #endregion

        #region Count

        /// <summary>Counts the number of items encapsulated by a sub space.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
        /// <returns>The number of items in the provided sub space.</returns>
        public int CountSubSpaceEncapsulated(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2)
        {
            return CountSubSpaceEncapsulated(_top, new Omnitree.Bounds<Axis1, Axis2>(min1, max1, min2, max2));
        }
        /// <summary>Counts the number of items encapsulated by a sub space.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
        /// <returns>The number of items in the provided sub space.</returns>
        public int CountSubSpaceEncapsulated(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2)
        {
            return CountSubSpaceEncapsulated(_top, new Omnitree.Bounds<Axis1, Axis2>(min1, max1, min2, max2));
        }
        /// <summary>Counts the number of items encapsulated by a sub space.</summary>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
        /// <returns>The number of items in the provided sub space.</returns>
        public int CountSubSpaceEncapsulated(Axis1 axis1, Axis2 axis2)
        {
            return CountSubSpaceEncapsulated(_top, new Omnitree.Bounds<Axis1, Axis2>(axis1, axis1, axis2, axis2));
        }
        /// <summary>Counts the number of items encapsulated by a sub space.</summary>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
        /// <returns>The number of items in the provided sub space.</returns>
        public int CountSubSpaceEncapsulated(Omnitree.Bound<Axis1> axis1, Omnitree.Bound<Axis2> axis2)
        {
            return CountSubSpaceEncapsulated(_top, new Omnitree.Bounds<Axis1, Axis2>(axis1, axis1, axis2, axis2));
        }

        /// <summary>Counts the number of items overlapped by a sub space.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
        /// <returns>The number of items in the provided sub space.</returns>
        public int CountSubSpaceOverlapped(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2)
        {
            return CountSubSpaceOverlapped(_top, new Omnitree.Bounds<Axis1, Axis2>(min1, max1, min2, max2));
        }
        /// <summary>Counts the number of items overlapped by a sub space.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
        /// <returns>The number of items in the provided sub space.</returns>
        public int CountSubSpaceOverlapped(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2)
        {
            return CountSubSpaceOverlapped(_top, new Omnitree.Bounds<Axis1, Axis2>(min1, max1, min2, max2));
        }
        /// <summary>Counts the number of items overlapped by a sub space.</summary>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
        /// <returns>The number of items in the provided sub space.</returns>
        public int CountSubSpaceOverlapped(Axis1 axis1, Axis2 axis2)
        {
            return CountSubSpaceOverlapped(_top, new Omnitree.Bounds<Axis1, Axis2>(axis1, axis1, axis2, axis2));
        }
        /// <summary>Counts the number of items overlapped by a sub space.</summary>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
        /// <returns>The number of items in the provided sub space.</returns>
        public int CountSubSpaceOverlapped(Omnitree.Bound<Axis1> axis1, Omnitree.Bound<Axis2> axis2)
        {
            return CountSubSpaceOverlapped(_top, new Omnitree.Bounds<Axis1, Axis2>(axis1, axis1, axis2, axis2));
        }

		private int CountSubSpaceEncapsulated(Node node, Omnitree.Bounds<Axis1, Axis2> bounds)
		{
			return CountSubSpaceBase(_top, bounds, (a, b) => EncapsulationCheck(a, b));
		}

		private int CountSubSpaceOverlapped(Node node, Omnitree.Bounds<Axis1, Axis2> bounds)
		{
			return CountSubSpaceBase(_top, bounds, (a, b) => InclusionCheck(a, b));
		}

		private int CountSubSpaceBase(
			Node node,
			Omnitree.Bounds<Axis1, Axis2> bounds,
			Omnitree.SpatialCheck<Omnitree.Bounds<Axis1, Axis2>, Omnitree.Bounds<Axis1, Axis2>> spatialCheck)
        {
            // adjust min/max values
            int count = 0;
            if (EncapsulationCheck(bounds, node.Bounds))
                count += node.Count;
            else if (!node.PointOfDivision.HasValue)
            {
                for (Node.ValueNode list = node.Head; list != null; list = list.Next)
                    if (spatialCheck(bounds, GetBoundings(list.Value)))
                        count++;
            }
            else
            {
                Node branch = node as Node;
                if (!StraddlesLines(branch.Bounds, branch.PointOfDivision.Value))
                {
                    int child_index = DetermineChildIndex(branch.PointOfDivision.Value, bounds);
                    Node child = branch[child_index];
                    if (child != null)
                      count += this.CountSubSpaceBase(child, bounds, spatialCheck);
                }
                else
                {
                    foreach (Node child in node.Children)
                        count += this.CountSubSpaceBase(child, bounds, spatialCheck);
                }
            }
            return count;
        }

        #endregion

        #region Update

        /// <summary>Iterates through the entire tree and ensures each item is in the proper leaf.</summary>
        public void Update()
        {
            this.Update(this._top, 0);
        }

        /// <summary>Recursive version of the Update method.</summary>
        /// <param name="node">The current node of iteration.</param>
        /// <param name="depth">The current depth of iteration.</param>
        private int Update(Node node, int depth)
        {
			// I messed up this function in the conversion
			throw new System.NotImplementedException();

            int removals = 0;

            if (!node.PointOfDivision.HasValue)
            {
                Node.ValueNode current = node.Head;
                Node.ValueNode previous = null;
                while (current != null)
                {
                    Omnitree.Bounds<Axis1, Axis2> bounds = GetBoundings(current.Value);
                    if (!this.EncapsulationCheck(node.Bounds, bounds))
                    {
                        removals++;
                        T updated = current.Value;
                        if (previous == null)
                        {
                            node.Head = current.Next;
                            goto HeadRemoved;
                        }
                        else
                            previous.Next = current.Next;

                        Node whereToAdd = GetEncapsulationParent(node.Parent, bounds);

                        if (whereToAdd == null)
                            throw new System.Exception("an item was updated outside the range of the omnitree");

                        this.Add(updated, whereToAdd, bounds, whereToAdd.Depth);
                    }
                    previous = current;
                HeadRemoved:
                    current = current.Next;
                }
                node.Count -= removals;
                return removals;
            }
            else
            {
                Node branch = node as Node;
                int skipped = 0;
                for (int i = 0; i + skipped < branch.Children.Length; )
                {
                    removals += this.Update(branch.Children[i], depth + 1);
                    if (branch.Children[i].Count == 0)
                        branch.Children[i] = branch.Children[branch.Children.Length - skipped++ - 1];
                    else
                        i++;
                }
                Node[] newArray = new Node[branch.Children.Length - skipped];
                Array.Copy(branch.Children, newArray, newArray.Length);
                branch.Children = newArray;

                branch.Count -= removals;

                if (branch.Count < _load && branch.Count != 0)
                    ShrinkChild(branch.Parent, branch.Index);
            }

            return removals;
        }

        /// <summary>Iterates through the provided dimensions and ensures each item is in the proper leaf.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
        public void Update(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2)
        {
            this.Update(new Omnitree.Bounds<Axis1, Axis2>(min1, max1, min2, max2), this._top, 0);
        }
        /// <summary>Iterates through the provided dimensions and ensures each item is in the proper leaf.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
        public void Update(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2)
        {
            this.Update(new Omnitree.Bounds<Axis1, Axis2>(min1, max1, min2, max2), this._top, 0);
        }
        /// <summary>Iterates through the provided dimensions and ensures each item is in the proper leaf.</summary>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
        public void Update(Axis1 axis1, Axis2 axis2)
        {
            this.Update(new Omnitree.Bounds<Axis1, Axis2>(axis1, axis1, axis2, axis2), this._top, 0);
        }
        /// <summary>Iterates through the provided dimensions and ensures each item is in the proper leaf.</summary>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
        public void Update(Omnitree.Bound<Axis1> axis1, Omnitree.Bound<Axis2> axis2)
        {
            this.Update(new Omnitree.Bounds<Axis1, Axis2>(axis1, axis1, axis2, axis2), this._top, 0);
        }
        private int Update(Omnitree.Bounds<Axis1, Axis2> bounds, Node node, int depth)
        {
			// I messed up this function in the conversion
			throw new System.NotImplementedException();

            if (!InclusionCheck(bounds, node.Bounds))
                return 0;

            int removals = 0;

            if (!node.PointOfDivision.HasValue)
            {
                Node.ValueNode current = node.Head;
                Node.ValueNode previous = null;
                while (current != null)
                {
                    Omnitree.Bounds<Axis1, Axis2> item_bounds = GetBoundings(current.Value);
                    if (!this.EncapsulationCheck(node.Bounds, item_bounds))
                    {
                        removals++;
                        T updated = current.Value;
                        if (previous == null)
                        {
                            node.Head = current.Next;
                            goto HeadRemoved;
                        }
                        else
                            previous.Next = current.Next;
                        Node whereToAdd = GetEncapsulationParent(node.Parent, item_bounds);
                        if (whereToAdd == null)
                            throw new System.Exception("an item was updates outside the range of the omnitree");
                        this.Add(updated, whereToAdd, item_bounds, whereToAdd.Depth);
                    }
                    previous = current;
                HeadRemoved:
                    current = current.Next;
                }
                node.Count -= removals;
                return removals;
            }
            else
            {
                Node branch = node as Node;
                int skipped = 0;
                for (int i = 0; i + skipped < branch.Children.Length; )
                {
                    removals += this.Update(branch.Children[i], depth + 1);
                    if (branch.Children[i].Count == 0)
                        branch.Children[i] = branch.Children[branch.Children.Length - skipped++ - 1];
                    else
                        i++;
                }
                Node[] newArray = new Node[branch.Children.Length - skipped];
                Array.Copy(branch.Children, newArray, newArray.Length);
                branch.Children = newArray;

                branch.Count -= removals;

                if (branch.Count < _load && branch.Count != 0)
                    ShrinkChild(branch.Parent, branch.Index);
            }

            return removals;
        }

        #endregion

        #region Remove

        /// <summary>Removes all the items qualified by the delegate.</summary>
        /// <param name="where">The predicate to qualify removals.</param>
        public void Remove(Predicate<T> where)
        {
            this.Remove(this._top, where);
            Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
        }

        /// <summary>Recursive version of the remove method.</summary>
        /// <param name="node">The current node of traversal.</param>
        /// <param name="where">The predicate to qualify removals.</param>
        private int Remove(Node node, Predicate<T> where)
        {
            int removals = 0;

			// items
            while (node.Head != null && where(node.Head.Value))
            {
                node.Head = node.Head.Next;
                removals++;
            }
            if (node.Head != null)
            {
                Node.ValueNode list = node.Head;
                while (list.Next != null)
                {
                    if (where(list.Next.Value))
                    {
                        list.Next = list.Next.Next;
                        removals++;
                    }
                }
            }
            node.Count -= removals;
            
			// children
			if (node.Children != null)
			{
				int skipped = 0;
				for (int i = 0; i + skipped < node.Children.Length; )
				{
				    removals += this.Remove(node.Children[i], where);
				    if (node.Children[i].Count == 0)
				        node.Children[i] = node.Children[node.Children.Length - skipped++ - 1];
				    else
				        i++;
				}
				Node[] newArray = new Node[node.Children.Length - skipped];
				Array.Copy(node.Children, newArray, newArray.Length);
				node.Children = newArray;

				node.Count -= removals;

				if (node.Count < _load && node.Count != 0)
				    ShrinkChild(node.Parent, node.Index);
			}
            return removals;
        }

        /// <summary>Removes all the items encapsulated in a given space.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
        /// <returns>The number of items that were removed.</returns>
        public void RemoveEncapsulated(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2)
        {
            this.RemoveEncapsulated(this._top, new Omnitree.Bounds<Axis1, Axis2>(min1, max1, min2, max2));
        }
        /// <summary>Removes all the items encapsulated in a given space.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
        /// <returns>The number of items that were removed.</returns>
        public void RemoveEncapsulated(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2)
        {
            this.RemoveEncapsulated(this._top, new Omnitree.Bounds<Axis1, Axis2>(min1, max1, min2, max2));
        }
        /// <summary>Removes all the items encapsulated in a given space.</summary>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
        public void RemoveEncapsulated(Omnitree.Bound<Axis1> axis1, Omnitree.Bound<Axis2> axis2)
        {
            this.RemoveEncapsulated(this._top, new Omnitree.Bounds<Axis1, Axis2>(axis1, axis1, axis2, axis2));
        }
        private int RemoveEncapsulated(Node node, Omnitree.Bounds<Axis1, Axis2> bounds)
        {
            int removals = this.RemoveBase(node, bounds, (a, b) => this.EncapsulationCheck(a, b));
			Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
			return removals;
        }

		/// <summary>Removes all the items overlapping a given space.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
        /// <returns>The number of items that were removed.</returns>
        public void RemoveOverlapped(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2)
        {
            this.RemoveOverlapped(this._top, new Omnitree.Bounds<Axis1, Axis2>(min1, max1, min2, max2));
        }
        /// <summary>Removes all the items overlapping a given space.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
        /// <returns>The number of items that were removed.</returns>
        public void RemoveOverlapped(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2)
        {
            this.RemoveOverlapped(this._top, new Omnitree.Bounds<Axis1, Axis2>(min1, max1, min2, max2));
        }
        private int RemoveOverlapped(Node node, Omnitree.Bounds<Axis1, Axis2> bounds)
        {
            int removals = this.RemoveBase(node, bounds, (a, b) => this.InclusionCheck(a, b));
			Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
			return removals;
        }

		private int RemoveBase(
			Node node,
			Omnitree.Bounds<Axis1, Axis2> bounds,
			Omnitree.SpatialCheck<Omnitree.Bounds<Axis1, Axis2>, Omnitree.Bounds<Axis1, Axis2>> spatialCheck)
        {
            int removals = 0;
            if (InclusionCheck(bounds, node.Bounds))
            {
				// items
                Node.ValueNode current_node = node.Head;
                Node.ValueNode previous_node = null;
                while (current_node != null)
                {
                    Node.ValueNode temp_previous = current_node;
                    if (spatialCheck(bounds, GetBoundings(current_node.Value)))
                    {
                        removals++;
                        if (current_node == node.Head)
                            node.Head = node.Head.Next;
                        else
                        {
                            previous_node.Next = current_node.Next;
                            temp_previous = previous_node;
                        }
                    }
                    previous_node = temp_previous;
                    current_node = current_node.Next;
                }
                node.Count -= removals;
                
				// children
				if (node.Children != null)
				{
					int skipped = 0;
					for (int i = 0; i + skipped < node.Children.Length; )
					{
					    removals += this.RemoveBase(node.Children[i], bounds, spatialCheck);
					    if (node.Children[i].Count == 0)
					        node.Children[i] = node.Children[node.Children.Length - skipped++ - 1];
					    else
					        i++;
					}
					Node[] newArray = new Node[node.Children.Length - skipped];
					Array.Copy(node.Children, newArray, newArray.Length);
					node.Children = newArray;

					node.Count -= removals;
					// convert this branch back into a leaf
					// Note: if count is zero, it will be chopped off
					if (node.Count < _load && node.Count > 0)
					    ShrinkChild(node.Parent, node.Index);
				}
            }
			
            return removals;
        }

		/// <summary>Removes all the items in a given space validated by a predicate.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
        /// <param name="where">The equality constraint of the removal.</param>
        public void RemoveEncapsulated(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Predicate<T> where)
        {
            this.RemoveEncapsulated(this._top, new Omnitree.Bounds<Axis1, Axis2>(min1, max1, min2, max2), where);
        }
        /// <summary>Removes all the items in a given space validated by a predicate.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
        /// <param name="where">The equality constraint of the removal.</param>
        public void RemoveEncapsulated(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Predicate<T> where)
        {
            this.RemoveEncapsulated(this._top, new Omnitree.Bounds<Axis1, Axis2>(min1, max1, min2, max2), where);
        }
        private int RemoveEncapsulated(Node node, Omnitree.Bounds<Axis1, Axis2> bounds, Predicate<T> where)
        {
            int removals = RemoveBase(node, bounds, where, (a, b) => this.EncapsulationCheck(a, b));
			Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
			return removals;
        }

        /// <summary>Removes all the items in a given space validated by a predicate.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
        /// <param name="where">The equality constraint of the removal.</param>
        public void RemoveOverlapped(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Predicate<T> where)
        {
            this.RemoveOverlapped(this._top, new Omnitree.Bounds<Axis1, Axis2>(min1, max1, min2, max2), where);
        }
        /// <summary>Removes all the items in a given space validated by a predicate.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
        /// <param name="where">The equality constraint of the removal.</param>
        public void RemoveOverlapped(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Predicate<T> where)
        {
            this.RemoveOverlapped(this._top, new Omnitree.Bounds<Axis1, Axis2>(min1, max1, min2, max2), where);
        }
        private int RemoveOverlapped(Node node, Omnitree.Bounds<Axis1, Axis2> bounds, Predicate<T> where)
        {
            int removals = RemoveBase(node, bounds, where, (a, b) => this.InclusionCheck(a, b));
			Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
			return removals;
        }

		private int RemoveBase(
			Node node,
			Omnitree.Bounds<Axis1, Axis2> bounds,
			Predicate<T> where,
			Omnitree.SpatialCheck<Omnitree.Bounds<Axis1, Axis2>, Omnitree.Bounds<Axis1, Axis2>> spatialCheck)
        {
            if (!InclusionCheck(node.Bounds, bounds))
                return 0;
            int removals = 0;
            
			// items
            Node.ValueNode current = node.Head;
            Node.ValueNode previous = null;
            while (current != null)
            {
                if (spatialCheck(bounds, GetBoundings(current.Value)) && where(current.Value))
                {
                    removals++;
                    if (previous == null)
                    {
                        node.Head = current.Next;
                        goto HeadRemoved;
                    }
                    else
                        previous.Next = current.Next;
                }
                previous = current;
            HeadRemoved:
                current = current.Next;
            }
            node.Count -= removals;

            // children
			if (node.Children != null)
			{
				int skipped = 0;
				for (int i = 0; i + skipped < node.Children.Length; )
				{
				    removals += this.RemoveBase(node.Children[i], bounds, where, spatialCheck);
				    if (node.Children[i].Count == 0)
				        node.Children[i] = node.Children[node.Children.Length - skipped++ - 1];
				    else
				        i++;
				}
				Node[] newArray = new Node[node.Children.Length - skipped];
				Array.Copy(node.Children, newArray, newArray.Length);
				node.Children = newArray;

				node.Count -= removals;

				if (node.Count < _load && node.Count != 0)
				    ShrinkChild(node.Parent, node.Index);
			}
            return removals;
        }

        /// <summary>Removes all instances of a given value.</summary>
        public void Remove(T removal)
        {
            Omnitree.Bound<Axis1> min1; Omnitree.Bound<Axis1> max1;
            Omnitree.Bound<Axis2> min2; Omnitree.Bound<Axis2> max2;
            this._getBounds(removal, out min1, out max1, out min2, out max2);
            this.RemoveOverlapped(this._top, new Omnitree.Bounds<Axis1, Axis2>(min1, max1, min2, max2), item => this._equate(item, removal));
        }
        /// <summary>Removes all the items in a given space.</summary>
        /// <param name="axis1">The axis of the removal along the  1D axis.</param>
		/// <param name="axis2">The axis of the removal along the  2D axis.</param>
        /// <returns>The number of items that were removed.</returns>
        public void RemoveOverlapped(Axis1 axis1, Axis2 axis2)
        {
            this.RemoveOverlapped(axis1, axis1, axis2, axis2);
            Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
        }
        
        /// <summary>Removes all the items in a given space validated by a predicate.</summary>
        /// <param name="axis1">The axis of the removal along the  1D axis.</param>
		/// <param name="axis2">The axis of the removal along the  2D axis.</param>
        /// <param name="where">The equality constraint of the removal.</param>
        public void RemoveOverlapped(Axis1 axis1, Axis2 axis2, Predicate<T> where)
        {
			this.RemoveOverlapped(axis1, axis1, axis2, axis2, where);
            Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
        }

        #endregion

        #region Stepper And IEnumerable

        /// <summary>Traverses every item in the tree and performs the delegate in them.</summary>
        /// <param name="function">The delegate to perform on every item in the tree.</param>
        public void Stepper(Step<T> function)
        {
            this.Stepper(function, this._top);
        }
        private void Stepper(Step<T> function, Node node)
        {
            Node.ValueNode list = node.Head;
            while (list != null)
            {
                function(list.Value);
                list = list.Next;
            }
			if (node.Children != null)
				foreach (Node child in node.Children)
				    this.Stepper(function, child);
        }

        /// <summary>Traverses every item in the tree and performs the delegate in them.</summary>
        /// <param name="function">The delegate to perform on every item in the tree.</param>
        public StepStatus Stepper(StepBreak<T> function)
        {
            return Stepper(function, _top);
        }
        private StepStatus Stepper(StepBreak<T> function, Node node)
        {
            StepStatus status = StepStatus.Continue;
            
            for (Node.ValueNode list = node.Head; list != null; list = list.Next)
                if ((status = function(list._value)) != StepStatus.Continue)
                    break;
            
			if (node.Children != null)
				foreach (Node child in node.Children)
				    if ((status = Stepper(function, child)) != StepStatus.Continue)
				        break;
            
            return status;
        }

        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="function">The delegate to perform on all items in the tree within the given bounds.</param>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
        public void StepperEncapsulated(Step<T> function, Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2)
        {
            StepperEncapsulated(function, _top, new Omnitree.Bounds<Axis1, Axis2>(min1, max1, min2, max2));
        }
        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="function">The delegate to perform on all items in the tree within the given bounds.</param>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
        public void StepperEncapsulated(Step<T> function, Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2)
        {
            StepperEncapsulated(function, _top, new Omnitree.Bounds<Axis1, Axis2>(min1, max1, min2, max2));
        }
        private void StepperEncapsulated(Step<T> function, Node node, Omnitree.Bounds<Axis1, Axis2> bounds)
        {
            StepperBase(function, node, bounds, (a, b) => this.EncapsulationCheck(a, b));
        }

		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="function">The delegate to perform on all items in the tree within the given bounds.</param>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
        public void StepperOverlapped(Step<T> function, Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2)
        {
            StepperOverlapped(function, _top, new Omnitree.Bounds<Axis1, Axis2>(min1, max1, min2, max2));
        }
        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="function">The delegate to perform on all items in the tree within the given bounds.</param>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
        public void StepperOverlapped(Step<T> function, Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2)
        {
            StepperOverlapped(function, _top, new Omnitree.Bounds<Axis1, Axis2>(min1, max1, min2, max2));
        }
        private void StepperOverlapped(Step<T> function, Node node, Omnitree.Bounds<Axis1, Axis2> bounds)
        {
            StepperBase(function, node, bounds, (a, b) => this.InclusionCheck(a, b));
        }

		private void StepperBase(
			Step<T> function,
			Node node,
			Omnitree.Bounds<Axis1, Axis2> bounds,
			Omnitree.SpatialCheck<Omnitree.Bounds<Axis1, Axis2>, Omnitree.Bounds<Axis1, Axis2>> spatialCheck)
        {
            for (Node.ValueNode list = node.Head; list != null; list = list.Next)
                if (spatialCheck(bounds, GetBoundings(list.Value)))
                    function(list.Value);

			if (node.Children != null)
			{
				foreach (Node child in node.Children)
				    // optimization: stop bounds checking if space encapsulates node
				    if (EncapsulationCheck(bounds, child.Bounds))
				        this.Stepper(function, child);
				    else if (InclusionCheck(child.Bounds, bounds))
				        this.StepperBase(function, child, bounds, spatialCheck);
			}
        }

        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
        public StepStatus StepperEncapsulated(StepBreak<T> function, Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2)
        {
            return StepperEncapsulated(function, _top, new Omnitree.Bounds<Axis1, Axis2>(min1, max1, min2, max2));
        }
        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
        public StepStatus StepperEncapsulated(StepBreak<T> function, Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2)
        {
			return StepperEncapsulated(function, _top, new Omnitree.Bounds<Axis1, Axis2>(min1, max1, min2, max2));
        }
        private StepStatus StepperEncapsulated(StepBreak<T> function, Node node, Omnitree.Bounds<Axis1, Axis2> bounds)
        {
            return StepperBase(function, node, bounds, (a, b) => this.EncapsulationCheck(a, b));
        }

		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
        public StepStatus StepperOverlapped(StepBreak<T> function, Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2)
        {
            return StepperOverlapped(function, _top, new Omnitree.Bounds<Axis1, Axis2>(min1, max1, min2, max2));
        }
        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
        public StepStatus StepperOverlapped(StepBreak<T> function, Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2)
        {
			return StepperOverlapped(function, _top, new Omnitree.Bounds<Axis1, Axis2>(min1, max1, min2, max2));
        }
        private StepStatus StepperOverlapped(StepBreak<T> function, Node node, Omnitree.Bounds<Axis1, Axis2> bounds)
        {
            return StepperBase(function, node, bounds, (a, b) => this.InclusionCheck(a, b));
        }

		private StepStatus StepperBase(
			StepBreak<T> function,
			Node node,
			Omnitree.Bounds<Axis1, Axis2> bounds,
			Omnitree.SpatialCheck<Omnitree.Bounds<Axis1, Axis2>, Omnitree.Bounds<Axis1, Axis2>> spatialCheck)
        {
            StepStatus status = StepStatus.Continue;

            for (Node.ValueNode list = node.Head; list != null; list = list.Next)
                if (spatialCheck(bounds, GetBoundings(list.Value)) &&
                    (status = function(list.Value)) != StepStatus.Continue)
                    break;

			if (node.Children != null)
			{
				foreach (Node child in node.Children)
				    // optimization: stop bounds checking if space encapsulates node
				    if (EncapsulationCheck(bounds, child.Bounds) &&
				        (status = this.Stepper(function, child)) != StepStatus.Continue)
				        break;
				    else if (!InclusionCheck(child.Bounds, bounds) &&
				        (status = this.StepperBase(function, child, bounds, spatialCheck)) != StepStatus.Continue)
				        break;
			}

            return status;
        }

        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="axis1">The axis of the removal along the  1D axis.</param>
		/// <param name="axis2">The axis of the removal along the  2D axis.</param>
        public void StepperOverlapped(Step<T> function, Axis1 axis1, Axis2 axis2)
        {
            StepperOverlapped(function, this._top, new Omnitree.Bounds<Axis1, Axis2>(axis1, axis1, axis2, axis2));
        }

        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="function">The delegate to perform on all items in the tree within the given bounds.</param>
        /// <param name="axis1">The axis of the removal along the  1D axis.</param>
		/// <param name="axis2">The axis of the removal along the  2D axis.</param>
        public StepStatus StepperOverlapped(StepBreak<T> function, Axis1 axis1, Axis2 axis2)
        {
			return StepperOverlapped(function, this._top, new Omnitree.Bounds<Axis1, Axis2>(axis1, axis1, axis2, axis2));
        }

        /// <summary>FOR COMPATIBILITY ONLY. AVOID IF POSSIBLE.</summary>
        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
        {
            throw new System.NotImplementedException();
            //return (this.ToArray() as System.Collections.Generic.IEnumerable<T>).GetEnumerator();
        }

        /// <summary>FOR COMPATIBILITY ONLY. AVOID IF POSSIBLE.</summary>
        System.Collections.Generic.IEnumerator<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator()
        {
            throw new System.NotImplementedException();
            //return (this.ToArray() as System.Collections.Generic.IEnumerable<T>).GetEnumerator();
        }

        #endregion

        #region Helpers

        private bool StraddlesLines(Omnitree.Bounds<Axis1, Axis2> bounds, Omnitree.Vector<Axis1, Axis2> vector)
        {
			if ((!bounds.Min1.Exists || (this._compare1(bounds.Min1.Value, vector.Axis1) != Comparison.Greater)) &&
				(!bounds.Max1.Exists || (this._compare1(bounds.Max1.Value, vector.Axis1) != Comparison.Less)))
				return true;
			if ((!bounds.Min2.Exists || (this._compare2(bounds.Min2.Value, vector.Axis2) != Comparison.Greater)) &&
				(!bounds.Max2.Exists || (this._compare2(bounds.Max2.Value, vector.Axis2) != Comparison.Less)))
				return true;
            return false;
        }

        /// <summary>Computes the child index that contains the desired dimensions.</summary>
        /// <param name="node">The branch .</param>
        /// <param name="vector">The dimensions to determine the child index.</param>
        /// <returns>The computed child index based on the coordinates relative to the center of the node.</returns>
        private int DetermineChildIndex(Omnitree.Vector<Axis1, Axis2> pointOfDivision, Omnitree.Bounds<Axis1, Axis2> bounds)
        {
			// make sure a child encapsulates the bounds (otherwise the bounds cannot move down the tree)
			if (StraddlesLines(bounds, pointOfDivision))
				return -1;

            int child = 0;
            if (!bounds.Min1.Exists || !(this._compare1(bounds.Min1.Value, pointOfDivision.Axis1) == Comparison.Less))
                child += 1 << 0;
            if (!bounds.Min2.Exists || !(this._compare2(bounds.Min2.Value, pointOfDivision.Axis2) == Comparison.Less))
                child += 1 << 1;
            return child;
        }

        /// <summary>Converts a branch back into a leaf when the count is reduced.</summary>
        /// <param name="parent">The parent to shrink a child of.</param>
        /// <param name="child">The index of the child to shrink.</param>
        private void ShrinkChild(Node parent, int child_index)
        {
            Node leaf;
            Node removal = null;
            if (parent == null) // top of tree
            {
                removal = this._top;
                leaf = new Node(Omnitree.Bounds<Axis1, Axis2>.None, null, -1);
                this._top = leaf;
            }
            else // non-top branch
            {
                removal = parent[child_index];
                leaf = new Node(removal.Bounds, removal.Parent, removal.Index);
                parent[child_index] = leaf;
            }

            this.Stepper((T step) => { leaf.Add(step); }, removal);
        }

        /// <summary>Reduces the counts of all the parents of a given node by a given amount.</summary>
        /// <param name="parent">The starting parent of the reduction.</param>
        /// <param name="reduction">The amount to reduce the parent counts by.</param>
        private void ReduceParentCounts(Node parent, int reduction)
        {
            IncreaseParentCounts(parent, -reduction);
        }

        /// <summary>Increases the counts of all the parents of a given node by a given amount.</summary>
        /// <param name="parent">The starting parent of the increase.</param>
        /// <param name="increase">The amount to increase the parent counts by.</param>
        private void IncreaseParentCounts(Node parent, int increase)
        {
            Node looper = parent;
            while (looper != null)
            {
                looper.Count += increase;
                looper = looper.Parent;
            }
        }

        /// <summary>Checks a node for inclusion (overlap) between two bounds.</summary>
        /// <returns>True if the spaces overlap; False if not.</returns>
        private bool InclusionCheck(Omnitree.Bounds<Axis1, Axis2> a, Omnitree.Bounds<Axis1, Axis2> b)
        {

            if (a.Max1.Exists && b.Min1.Exists && this._compare1(a.Max1.Value, b.Min1.Value) == Comparison.Less)
                return false;
            else if (a.Min1.Exists && b.Max1.Exists && this._compare1(a.Min1.Value, b.Max1.Value) == Comparison.Greater)
                return false;

            if (a.Max2.Exists && b.Min2.Exists && this._compare2(a.Max2.Value, b.Min2.Value) == Comparison.Less)
                return false;
            else if (a.Min2.Exists && b.Max2.Exists && this._compare2(a.Min2.Value, b.Max2.Value) == Comparison.Greater)
                return false;

            return true;
        }

        /// <summary>Checks if a space encapsulates a point.</summary>
        /// <returns>True if the space encapsulates the point; False if not.</returns>
        private bool EncapsulationCheck(Omnitree.Bounds<Axis1, Axis2> bounds, Omnitree.Vector<Axis1, Axis2> vector)
        {
            // if the location is not outside the bounds, it must be inside

            if (bounds.Min1.Exists && this._compare1(vector.Axis1, bounds.Min1.Value) == Comparison.Less)
                return false;
            else if (bounds.Max1.Exists && this._compare1(vector.Axis1, bounds.Max1.Value) == Comparison.Greater)
                return false;

            if (bounds.Min2.Exists && this._compare2(vector.Axis2, bounds.Min2.Value) == Comparison.Less)
                return false;
            else if (bounds.Max2.Exists && this._compare2(vector.Axis2, bounds.Max2.Value) == Comparison.Greater)
                return false;

            return true;
        }

        /// <summary>Checks if a space (left) encapsulates another space (right).</summary>
        /// <returns>True if the left space encapsulates the right; False if not.</returns>
        private bool EncapsulationCheck(Omnitree.Bounds<Axis1, Axis2> a, Omnitree.Bounds<Axis1, Axis2> b)
        {
            if ((a.Min1.Exists && !b.Min1.Exists) || (a.Min2.Exists && !b.Min2.Exists))
                return false;
			if ((a.Max1.Exists && !b.Max1.Exists) || (a.Max2.Exists && !b.Max2.Exists))
                return false;

            if (b.Min1.Exists && a.Min1.Exists && this._compare1(a.Min1.Value, b.Min1.Value) != Comparison.Less)
                return false;
            if (b.Max1.Exists && a.Max1.Exists && this._compare1(a.Max1.Value, b.Max1.Value) != Comparison.Greater)
                return false;

            if (b.Min2.Exists && a.Min2.Exists && this._compare2(a.Min2.Value, b.Min2.Value) != Comparison.Less)
                return false;
            if (b.Max2.Exists && a.Max2.Exists && this._compare2(a.Max2.Value, b.Max2.Value) != Comparison.Greater)
                return false;

            return true;
        }

        /// <summary>Checks for equality between two locations.</summary>
        /// <returns>True if equal; False if not;</returns>
        private bool EqualsCheck(Omnitree.Vector<Axis1, Axis2> a, Omnitree.Vector<Axis1, Axis2> b)
        {

            if (!this._equate1(a.Axis1, b.Axis1))
                return false;

            if (!this._equate2(a.Axis2, b.Axis2))
                return false;

            return true;
        }

        /// <summary>Gets the nearest parent that encapsulates a location.</summary>
        /// <param name="node">The starting node to find the encapsulating parent of the location.</param>
        /// <param name="bounds">The bounds to get the encapsulating parent from.</param>
        /// <returns>The nearest node that encapsulates the given location.</returns>
        private Node GetEncapsulationParent(Node node, Omnitree.Bounds<Axis1, Axis2> bounds)
        {
            while (node != null && !EncapsulationCheck(node.Bounds, bounds))
                node = node.Parent;
            return node;
        }

        private Omnitree.Bounds<Axis1, Axis2> GetBoundings(T value)
        {
            Omnitree.Bound<Axis1> min1; Omnitree.Bound<Axis1> max1;
            Omnitree.Bound<Axis2> min2; Omnitree.Bound<Axis2> max2;
            this._getBounds(value,
				out min1, out max1,
				out min2, out max2);
            return new Omnitree.Bounds<Axis1, Axis2>(
				min1, max1,
				min2, max2);
        }

        #endregion

        #endregion
    }

    #endregion

    #region 3 Dimensional

    public interface IOmnitreeBounds<T, Axis1, Axis2, Axis3> : IDataStructure<T>,
            DataStructure.ICountable,
            DataStructure.IAddable<T>,
            DataStructure.IClearable,
            DataStructure.IRemovable<T>,
            DataStructure.IEquating<T>
    {
        #region Properties

        /// <summary>The number of dimensions in this tree.</summary>
        int Dimensions { get; }

        #endregion

        #region Methods

        /// <summary>Counts the number of items encapsulated by a sub space.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
        /// <returns>The number of items in the provided sub space.</returns>
        int CountSubSpaceEncapsulated(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3);

		/// <summary>Counts the number of items overlapped by a sub space.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
        /// <returns>The number of items in the provided sub space.</returns>
        int CountSubSpaceOverlapped(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3);

        /// <summary>Iterates through the entire tree and ensures each item is in the proper leaf.</summary>
        void Update();
        /// <summary>Iterates through the provided dimensions and ensures each item is in the proper leaf.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
        void Update(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3);

        /// <summary>Removes all the items in a given space.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
        void RemoveEncapsulated(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3);
        /// <summary>Removes all the items in a given space where predicate is met.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
        /// <param name="where">The predicate constraint of the removal.</param>
        void RemoveEncapsulated(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Predicate<T> where);

		/// <summary>Removes all the items in a given space.</summary>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
        void RemoveOverlapped(Axis1 axis1, Axis2 axis2, Axis3 axis3);
        /// <summary>Removes all the items in a given space.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
        void RemoveOverlapped(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3);
        /// <summary>Removes all the items in a given space where equality is met.</summary>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
        /// <param name="where">The equality constraint of the removal.</param>
        void RemoveOverlapped(Axis1 axis1, Axis2 axis2, Axis3 axis3, Predicate<T> where);
        /// <summary>Removes all the items in a given space where predicate is met.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
        /// <param name="where">The predicate constraint of the removal.</param>
        void RemoveOverlapped(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Predicate<T> where);

        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="step">The step function to perform on all items in the tree within the given bounds.</param>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
        void StepperEncapsulated(Step<T> step, Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3);
        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="step">The step function to perform on all items in the tree within the given bounds.</param>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
        StepStatus StepperEncapsulated(StepBreak<T> step, Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3);
        
		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="step">The step function to perform on all items in the tree within the given bounds.</param>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
        void StepperOverlapped(Step<T> step, Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3);
        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="step">The step function to perform on all items in the tree within the given bounds.</param>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
        StepStatus StepperOverlapped(StepBreak<T> step, Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3);

		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="step">The step function to perform on all items in the tree within the given bounds.</param>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
        void StepperOverlapped(Step<T> step, Axis1 axis1, Axis2 axis2, Axis3 axis3);
        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="step">The step function to perform on all items in the tree within the given bounds.</param>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
        StepStatus StepperOverlapped(StepBreak<T> function, Axis1 axis1, Axis2 axis2, Axis3 axis3);

        #endregion
    }

    public class OmnitreeBoundsLinked<T, Axis1, Axis2, Axis3> : IOmnitreeBounds<T, Axis1, Axis2, Axis3>
    {
        private const int _dimensions = 3;
        internal static int _children_per_node = (int)BigInteger.Pow(2, 3);

        private Node _top;

		private int _naturalLogLower = 1; // caching the next time to calculate loads (lower count)
		private int _naturalLogUpper = -1; // caching the next time to calculate loads (upper count)
        private int _load; // ln(count); min = _defaultLoad
        private Omnitree.GetBounds<T, Axis1, Axis2, Axis3> _getBounds;

        private bool _defaultEquate;
        private Equate<T> _equate;


        private bool _defaultEquate1;
        private Equate<Axis1> _equate1;

        private bool _defaultEquate2;
        private Equate<Axis2> _equate2;

        private bool _defaultEquate3;
        private Equate<Axis3> _equate3;



        private bool _defaultCompare1;
        private Compare<Axis1> _compare1;

        private bool _defaultCompare2;
        private Compare<Axis2> _compare2;

        private bool _defaultCompare3;
        private Compare<Axis3> _compare3;


        // allows median overriding for custom optimizations (USE AT YOUR OWN RISK)
        private Omnitree.SubdivisionOverride<T, Axis1, Omnitree.Bounds<Axis1, Axis2, Axis3>> _subdivisionOverride1;
        private Omnitree.SubdivisionOverride<T, Axis2, Omnitree.Bounds<Axis1, Axis2, Axis3>> _subdivisionOverride2;
        private Omnitree.SubdivisionOverride<T, Axis3, Omnitree.Bounds<Axis1, Axis2, Axis3>> _subdivisionOverride3;

        #region Nested Types

        /// <summary>Can be a leaf or a branch.</summary>
        internal class Node
        {
            public class ValueNode
            {
                internal T _value;
                internal ValueNode _next;

                public T Value { get { return _value; } set { _value = value; } }
                public ValueNode Next { get { return _next; } set { _next = value; } }

                public ValueNode(T value, ValueNode next)
                {
                    _value = value;
                    _next = next;
                }
            }

            internal Omnitree.Bounds<Axis1, Axis2, Axis3> _bounds;
            internal Node _parent;
            internal int _index;
            internal int _count;
            internal ValueNode _head;
            private Node[] _children;
            private Omnitree.Vector<Axis1, Axis2, Axis3>? _pointOfDivision;

            /// <summary>The parent of this node.</summary>
            public Omnitree.Bounds<Axis1, Axis2, Axis3> Bounds { get { return this._bounds; } }
            /// <summary>The parent of this node.</summary>
            public Node Parent { get { return this._parent; } }
            /// <summary>The computed child index of this node (see the "Notes" region in "Omnitree.cs" for the algorithm.</summary>
            public int Index { get { return this._index; } }
            /// <summary>The number of elements stored in this node and its children.</summary>
            public int Count { get { return this._count; } set { this._count = value; } }
            /// <summary>The first object stored in this node.</summary>
            public ValueNode Head { get { return this._head; } set { this._head = value; } }
            public Node[] Children { get { return this._children; } set { this._children = value; } }
            public Omnitree.Vector<Axis1, Axis2, Axis3>? PointOfDivision { get { return this._pointOfDivision; } internal set { this._pointOfDivision = value; } }

            /// <summary>Gets child by index.</summary>
            /// <param name="child_index">The index of the child to get.</param>
            /// <returns>The child of the given index or null if non-existent.</returns>
            public Node this[int child_index]
            {
                get
                {
                    if (this._children == null)
                        return null;
                    if (this._children.Length == OmnitreePointsLinked<T, Axis1, Axis2, Axis3>._children_per_node)
                        return this._children[(int)child_index];
                    foreach (Node node in this._children)
                        if (node.Index == child_index)
                            return node;
                    return null;
                }
                set
                {
                    // This error check should be unnecessary... but fuck it... might as well
                    if (value.Index != child_index)
                        throw new System.Exception("Bug in Omnitree (index/property mis-match when setting a child on a branch)");

                    // no children yet
                    if (this._children == null)
                    {
                        this._children = new Node[] { value };
                        return;
                    }
                    // max children overwrite
                    else if (this._children.Length == OmnitreePointsLinked<T, Axis1, Axis2, Axis3>._children_per_node)
                    {
                        this._children[(int)child_index] = value;
                        return;
                    }
                    // non-max child overwrite
                    for (int i = 0; i < this._children.Length; i++)
                        if (this._children[i].Index == child_index)
                        {
                            this._children[i] = value;
                            return;
                        }
                    // new child
                    Node[] newArray = new Node[this._children.Length + 1];
                    if (newArray.Length == OmnitreePointsLinked<T, Axis1, Axis2, Axis3>._children_per_node)
                    {
                        // new child resulting in a max children branch (sorting required)
                        for (int i = 0; i < this._children.Length; i++)
                        {
                            newArray[(int)this._children[i]._index] = this._children[i];
                        }
                        newArray[(int)value._index] = value;
                    }
                    else
                    {
                        // new child resulting in a non-max children branch
                        Array.Copy(this._children, newArray, this._children.Length);
                        newArray[newArray.Length - 1] = value;
                    }
                    this._children = newArray;
                }
            }

            /// <summary>The depth this node is located in the Omnitree.</summary>
            public int Depth
            {
                get
                {
                    int depth = -1;
                    for (Node looper = this; looper != null; looper = looper.Parent)
                        depth++;
                    return depth;
                }
            }

            /// <summary>Constructs a node.</summary>
            /// <param name="bounds">The bounds of this node.</param>
            /// <param name="parent">The parent of this node.</param>
            /// <param name="index">The number of elements stored in this node and its children.</param>
            public Node(Omnitree.Bounds<Axis1, Axis2, Axis3> bounds, Node parent, int index)
            {
                this._bounds = bounds;
                this._parent = parent;
                this._index = index;
            }

            public Node(Omnitree.Vector<Axis1, Axis2, Axis3> pointOfDivision, Omnitree.Bounds<Axis1, Axis2, Axis3> bounds, Node parent, int index)
                : this(bounds, parent, index)
            {
                this._pointOfDivision = pointOfDivision;
            }

            internal Node(Node nodeToClone)
            {
                this._bounds = nodeToClone._bounds;
                this._parent = nodeToClone._parent;
                this._index = nodeToClone._index;
                this._count = nodeToClone._count;

                this._children = nodeToClone._children.Clone() as Node[];
                this._pointOfDivision = nodeToClone._pointOfDivision;

                ValueNode this_looper = this._head;
                ValueNode other_looper = nodeToClone._head;

                while (other_looper != null)
                {
                    this_looper.Next = new ValueNode(other_looper.Next.Value, null);
                    this_looper = this_looper.Next;
                    other_looper = other_looper.Next;
                }
            }

            public void Add(T addition)
            {
                this._head = new ValueNode(addition, this._head);
                this.Count++;
            }

            internal Node Clone()
            {
                return new Node(this);
            }
        }
        
        #endregion

        #region Constructors

        /// <summary>This constructor is for cloning purposes</summary>
        private OmnitreeBoundsLinked(OmnitreeBoundsLinked<T, Axis1, Axis2, Axis3> omnitree)
        {
            this._top = omnitree._top.Clone();
            this._load = omnitree._load;
            this._getBounds = omnitree._getBounds;
            this._defaultEquate = omnitree._defaultEquate;
            this._equate = omnitree._equate;

            this._defaultEquate1 = omnitree._defaultEquate1;
            this._equate1 = omnitree._equate1;
            this._defaultEquate2 = omnitree._defaultEquate2;
            this._equate2 = omnitree._equate2;
            this._defaultEquate3 = omnitree._defaultEquate3;
            this._equate3 = omnitree._equate3;

            this._defaultCompare1 = omnitree._defaultCompare1;
            this._compare1 = omnitree._compare1;
            this._defaultCompare2 = omnitree._defaultCompare2;
            this._compare2 = omnitree._compare2;
            this._defaultCompare3 = omnitree._defaultCompare3;
            this._compare3 = omnitree._compare3;

            this._subdivisionOverride1 = omnitree._subdivisionOverride1;
            this._subdivisionOverride2 = omnitree._subdivisionOverride2;
            this._subdivisionOverride3 = omnitree._subdivisionOverride3;
        }

        private OmnitreeBoundsLinked(
            Omnitree.GetBounds<T, Axis1, Axis2, Axis3> getBounds,

            bool defaultEquate,
            Equate<T> equate,

            bool defaultEquate1,
            Equate<Axis1> equateAxis1,
            bool defaultEquate2,
            Equate<Axis2> equateAxis2,
            bool defaultEquate3,
            Equate<Axis3> equateAxis3,

            bool defaultCompare1,
            Compare<Axis1> compare1,
            bool defaultCompare2,
            Compare<Axis2> compare2,
            bool defaultCompare3,
            Compare<Axis3> compare3,

            Omnitree.SubdivisionOverride<T, Axis1, Omnitree.Bounds<Axis1, Axis2, Axis3>> subdivisionOverride1,
            Omnitree.SubdivisionOverride<T, Axis2, Omnitree.Bounds<Axis1, Axis2, Axis3>> subdivisionOverride2,
            Omnitree.SubdivisionOverride<T, Axis3, Omnitree.Bounds<Axis1, Axis2, Axis3>> subdivisionOverride3)
        {
			if (getBounds == null)
			{
				throw new ArgumentNullException(nameof(getBounds));
			}
			if (equate == null)
			{
				throw new ArgumentNullException(nameof(equate));
			}

			if (equateAxis1 == null)
			{
				throw new ArgumentNullException(nameof(equateAxis1));
			}
			if (equateAxis2 == null)
			{
				throw new ArgumentNullException(nameof(equateAxis2));
			}
			if (equateAxis3 == null)
			{
				throw new ArgumentNullException(nameof(equateAxis3));
			}

			if (compare1 == null)
			{
				throw new ArgumentNullException(nameof(compare1));
			}
			if (compare2 == null)
			{
				throw new ArgumentNullException(nameof(compare2));
			}
			if (compare3 == null)
			{
				throw new ArgumentNullException(nameof(compare3));
			}

            this._getBounds = getBounds;
            this._defaultEquate = defaultEquate;
            this._equate = equate;

            this._defaultEquate1 = defaultEquate1;
            this._equate1 = equateAxis1;
            this._defaultEquate2 = defaultEquate2;
            this._equate2 = equateAxis2;
            this._defaultEquate3 = defaultEquate3;
            this._equate3 = equateAxis3;

            this._defaultCompare1 = defaultCompare1;
            this._compare1 = compare1;
            this._defaultCompare2 = defaultCompare2;
            this._compare2 = compare2;
            this._defaultCompare3 = defaultCompare3;
            this._compare3 = compare3;

            this._subdivisionOverride1 = subdivisionOverride1;
            this._subdivisionOverride2 = subdivisionOverride2;
            this._subdivisionOverride3 = subdivisionOverride3;

            this._top = new Node(Omnitree.Bounds<Axis1, Axis2, Axis3>.None, null, -1);
            Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
        }

        private OmnitreeBoundsLinked(
            Omnitree.GetBounds<T, Axis1, Axis2, Axis3> getBounds,
            Equate<T> equate,

            Equate<Axis1> equateAxis1,
            Equate<Axis2> equateAxis2,
            Equate<Axis3> equateAxis3,

            Compare<Axis1> compare1,
            Compare<Axis2> compare2,
            Compare<Axis3> compare3,

            Omnitree.SubdivisionOverride<T, Axis1, Omnitree.Bounds<Axis1, Axis2, Axis3>> subdivisionOverride1,
            Omnitree.SubdivisionOverride<T, Axis2, Omnitree.Bounds<Axis1, Axis2, Axis3>> subdivisionOverride2,
            Omnitree.SubdivisionOverride<T, Axis3, Omnitree.Bounds<Axis1, Axis2, Axis3>> subdivisionOverride3)
            : this(
            getBounds,

            false,
            equate,

            false,
            equateAxis1,
            false,
            equateAxis2,
            false,
            equateAxis3,

            false,
            compare1,
            false,
            compare2,
            false,
            compare3,

            subdivisionOverride1,
            subdivisionOverride2,
            subdivisionOverride3)
        { }

        public OmnitreeBoundsLinked(
            Omnitree.GetBounds<T, Axis1, Axis2, Axis3> getBounds,

            Equate<T> equate,

            Equate<Axis1> equateAxis1,
            Equate<Axis2> equateAxis2,
            Equate<Axis3> equateAxis3,

            Compare<Axis1> compare1,
            Compare<Axis2> compare2,
            Compare<Axis3> compare3)
            : this(
                getBounds,

                false,
                equate,

                false,
                equateAxis1,
                false,
                equateAxis2,
                false,
                equateAxis3,

                false,
                compare1,
                false,
                compare2,
                false,
                compare3,

                null,
                null,
                null)
        { }



        public OmnitreeBoundsLinked(
            Omnitree.GetBounds<T, Axis1, Axis2, Axis3> getBounds,

            Equate<T> equate,

            Compare<Axis1> compare1,
            Compare<Axis2> compare2,
            Compare<Axis3> compare3)
            : this(
                getBounds,
                false,
                equate,

                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,

                false,
                compare1,
                false,
                compare2,
                false,
                compare3,

                null,
                null,
                null)
        { }

        public OmnitreeBoundsLinked(
            Omnitree.GetBounds<T, Axis1, Axis2, Axis3> getBounds,
            Equate<T> equate,

            Compare<Axis1> compare1,
            Compare<Axis2> compare2,
            Compare<Axis3> compare3,

            Omnitree.SubdivisionOverride<T, Axis1, Omnitree.Bounds<Axis1, Axis2, Axis3>> subdivisionOverride1,
            Omnitree.SubdivisionOverride<T, Axis2, Omnitree.Bounds<Axis1, Axis2, Axis3>> subdivisionOverride2,
            Omnitree.SubdivisionOverride<T, Axis3, Omnitree.Bounds<Axis1, Axis2, Axis3>> subdivisionOverride3)
            : this(
                getBounds,

                false,
                equate,

                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,

                false,
                compare1,
                false,
                compare2,
                false,
                compare3,

                subdivisionOverride1,
                subdivisionOverride2,
                subdivisionOverride3)
        { }

        public OmnitreeBoundsLinked(
            Omnitree.GetBounds<T, Axis1, Axis2, Axis3> getBounds,

            Compare<Axis1> compare1,
            Compare<Axis2> compare2,
            Compare<Axis3> compare3)
            : this(
                getBounds,
                true,
                Towel.Equate.Default,

                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,

                false,
                compare1,
                false,
                compare2,
                false,
                compare3,

                null,
                null,
                null)
        { }

        public OmnitreeBoundsLinked(
            Omnitree.GetBounds<T, Axis1, Axis2, Axis3> getBounds,

            Compare<Axis1> compare1,
            Compare<Axis2> compare2,
            Compare<Axis3> compare3,

            Omnitree.SubdivisionOverride<T, Axis1, Omnitree.Bounds<Axis1, Axis2, Axis3>> subdivisionOverride1,
            Omnitree.SubdivisionOverride<T, Axis2, Omnitree.Bounds<Axis1, Axis2, Axis3>> subdivisionOverride2,
            Omnitree.SubdivisionOverride<T, Axis3, Omnitree.Bounds<Axis1, Axis2, Axis3>> subdivisionOverride3)
            : this(
                getBounds,

                true,
                Towel.Equate.Default,

                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,

                false,
                compare1,
                false,
                compare2,
                false,
                compare3,

                subdivisionOverride1,
                subdivisionOverride2,
                subdivisionOverride3)
        { }

        public OmnitreeBoundsLinked(
            Omnitree.GetBounds<T, Axis1, Axis2, Axis3> getBounds,
            Equate<T> equate)
            : this(
                getBounds,

                false,
                equate,

                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,

                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,

                null,
                null,
                null)
        { }

        public OmnitreeBoundsLinked(
            Omnitree.GetBounds<T, Axis1, Axis2, Axis3> getBounds,
            Equate<T> equate,
            Omnitree.SubdivisionOverride<T, Axis1, Omnitree.Bounds<Axis1, Axis2, Axis3>> subdivisionOverride1,
            Omnitree.SubdivisionOverride<T, Axis2, Omnitree.Bounds<Axis1, Axis2, Axis3>> subdivisionOverride2,
            Omnitree.SubdivisionOverride<T, Axis3, Omnitree.Bounds<Axis1, Axis2, Axis3>> subdivisionOverride3)
            : this(
                getBounds,

                false,
                equate,

                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,

                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,

                subdivisionOverride1,
                subdivisionOverride2,
                subdivisionOverride3)
        { }

        public OmnitreeBoundsLinked(
            Omnitree.GetBounds<T, Axis1, Axis2, Axis3> getBounds)
            : this(
                getBounds,

                true,
                Towel.Equate.Default,

                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,

                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,

                null,
                null,
                null)
        { }

		public OmnitreeBoundsLinked(
            Omnitree.GetBoundings<T, Axis1, Axis2, Axis3> getBoundings)
            : this(
                Omnitree.ConvertToGetBounds(getBoundings),

                true,
                Towel.Equate.Default,

                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,

                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,

                null,
                null,
                null)
        { }

        public OmnitreeBoundsLinked(
            Omnitree.GetBounds<T, Axis1, Axis2, Axis3> getBounds,
            Omnitree.SubdivisionOverride<T, Axis1, Omnitree.Bounds<Axis1, Axis2, Axis3>> subdivisionOverride1,
            Omnitree.SubdivisionOverride<T, Axis2, Omnitree.Bounds<Axis1, Axis2, Axis3>> subdivisionOverride2,
            Omnitree.SubdivisionOverride<T, Axis3, Omnitree.Bounds<Axis1, Axis2, Axis3>> subdivisionOverride3)
            : this(
                getBounds,

                true,
                Towel.Equate.Default,

                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,

                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,

                subdivisionOverride1,
                subdivisionOverride2,
                subdivisionOverride3)
        { }

        #endregion

        #region Properties

        /// <summary>The number of dimensions in this tree.</summary>
        public int Dimensions { get { return _dimensions; } }

        /// <summary>The function for equating keys in this table.</summary>
        public Equate<T> Equate { get { return this._equate; } }

        /// <summary>The location function the Omnitree is using.</summary>
        public Omnitree.GetBounds<T, Axis1, Axis2, Axis3> GetBounds { get { return this._getBounds; } }

        /// <summary>The comparison function the Omnitree is using along the 1D axis.</summary>
        public Compare<Axis1> Compare1 { get { return this._compare1; } }
        /// <summary>The comparison function the Omnitree is using along the 2D axis.</summary>
        public Compare<Axis2> Compare2 { get { return this._compare2; } }
        /// <summary>The comparison function the Omnitree is using along the 3D axis.</summary>
        public Compare<Axis3> Compare3 { get { return this._compare3; } }

        /// <summary>The function for equating values along the 1D axis.</summary>
        public Equate<Axis1> EquateAxis1 { get { return this._equate1; } }
        /// <summary>The function for equating values along the 2D axis.</summary>
        public Equate<Axis2> EquateAxis2 { get { return this._equate2; } }
        /// <summary>The function for equating values along the 3D axis.</summary>
        public Equate<Axis3> EquateAxis3 { get { return this._equate3; } }

        /// <summary>The current number of items in the tree.</summary>
        public int Count { get { return this._top.Count; } }

        private delegate void MaxDepthFinder(Node node, int current_depth, ref int max_depth);
        /// <summary>Finds the current maximum depth of the tree. NOT AN O(1) OPERATION. Intended for educational purposes only.</summary>
        public int MaxDepth
        {
            get
            {
                MaxDepthFinder maxDepthFinder = null;
                maxDepthFinder =
                        (Node node, int current_depth, ref int max_depth) =>
                        {
                            if (current_depth > max_depth)
                                max_depth = current_depth;
                            foreach (Node child in node.Children)
                                maxDepthFinder(child, current_depth + 1, ref max_depth);
                        };
                int _max_depth = -1;
                maxDepthFinder(this._top, 0, ref _max_depth);
                return _max_depth;
            }
        }

        private delegate void NodeCountFinder(Node node, ref int current_count);
        /// <summary>Counts the current number of nodes in the tree. NOT AN O(1) OPERATION. Intended for educational purposes only.</summary>
        public int NodeCount
        {
            get
            {
                NodeCountFinder nodeCountFinder = null;
                nodeCountFinder =
                        (Node node, ref int current_count) =>
                        {
                            current_count++;
                            foreach (Node child in node.Children)
                                nodeCountFinder(child, ref current_count);
                        };

                int _current_count = 0;
                nodeCountFinder(this._top, ref _current_count);
                return _current_count;
            }
        }

        #endregion

        #region Methods

        #region Add

        #region Bulk

		// not yet implemented

//        public void Add(IndexedBigArray<T> additions, bool allowMultithreading)
//        {
//            if (additions.Length > int.MaxValue)
//                throw new System.Exception("The maximum size of the Omnitree was exceeded during bulk addition.");
//
//            if (this._top.Count != 0 || (int)additions.Length <= _load)
//            {
//                for (ulong i = 0; i < additions.Length; i++)
//                    this.Add(additions[i]);
//            }
//            else
//            {
//                // adjust the loads prior to additions
//                ComputeLoads((int)additions.Length);
//
//                Node new_top = new Node(Omnitree.Bounds<Axis1, Axis2, Axis3>.None, null, -1);
//                new_top.Count = (int)additions.Length;
//
//
//                // prepare data for median computations
//                IndexedBigArray<Axis1> values1;
//                IAsyncResult result1 = null;
//                if (this._subdivisionOverride1 != null)
//                    values1 = null;
//                else
//                {
//                    values1 = null;
//                    Towel.Parallels.Parallel.Operation operation = () =>
//                    {
//                        values1 = new IndexedBigArray<Axis1>(additions.Length * 2);
//                        for (ulong i = 0; i < additions.Length; i++)
//						{
//							Omnitree.Bounds<Axis1, Axis2, Axis3> bounds = GetBoundings(additions[i]);
//                            values1[i * 2] = bounds.Min1;
//							values1[i * 2 + 1] = bounds.Max1;
//						}
//
//                        Towel.Algorithms.Sort.Merge(this._compare1, (int i) => { return values1[(ulong)i]; }, (int i, Axis1 value) => { values1[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
//                    };
//
//                    if (allowMultithreading)
//                        result1 = Towel.Parallels.Parallel.Thread(operation);
//                    else
//                        operation();
//                }
//
//                // prepare data for median computations
//                IndexedBigArray<Axis2> values2;
//                IAsyncResult result2 = null;
//                if (this._subdivisionOverride2 != null)
//                    values2 = null;
//                else
//                {
//                    values2 = null;
//                    Towel.Parallels.Parallel.Operation operation = () =>
//                    {
//                        values2 = new IndexedBigArray<Axis2>(additions.Length * 2);
//                        for (ulong i = 0; i < additions.Length; i++)
//						{
//							Omnitree.Bounds<Axis1, Axis2, Axis3> bounds = GetBoundings(additions[i]);
//                            values2[i * 2] = bounds.Min1;
//							values2[i * 2 + 1] = bounds.Max1;
//						}
//
//                        Towel.Algorithms.Sort.Merge(this._compare2, (int i) => { return values2[(ulong)i]; }, (int i, Axis2 value) => { values2[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
//                    };
//
//                    if (allowMultithreading)
//                        result2 = Towel.Parallels.Parallel.Thread(operation);
//                    else
//                        operation();
//                }
//
//                // prepare data for median computations
//                IndexedBigArray<Axis3> values3;
//                IAsyncResult result3 = null;
//                if (this._subdivisionOverride3 != null)
//                    values3 = null;
//                else
//                {
//                    values3 = null;
//                    Towel.Parallels.Parallel.Operation operation = () =>
//                    {
//                        values3 = new IndexedBigArray<Axis3>(additions.Length * 2);
//                        for (ulong i = 0; i < additions.Length; i++)
//						{
//							Omnitree.Bounds<Axis1, Axis2, Axis3> bounds = GetBoundings(additions[i]);
//                            values3[i * 2] = bounds.Min1;
//							values3[i * 2 + 1] = bounds.Max1;
//						}
//
//                        Towel.Algorithms.Sort.Merge(this._compare3, (int i) => { return values3[(ulong)i]; }, (int i, Axis3 value) => { values3[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
//                    };
//
//                    if (allowMultithreading)
//                        result3 = Towel.Parallels.Parallel.Thread(operation);
//                    else
//                        operation();
//                }
//
//
//
//                if (this._subdivisionOverride1 == null && allowMultithreading)
//                    result1.AsyncWaitHandle.WaitOne();
//                if (this._subdivisionOverride2 == null && allowMultithreading)
//                    result2.AsyncWaitHandle.WaitOne();
//                if (this._subdivisionOverride3 == null && allowMultithreading)
//                    result3.AsyncWaitHandle.WaitOne();
//
//                // build the tree
//                Add(new_top, 1, -1, additions.Stepper(), (int)additions.Length, int.MinValue, int.MinValue, int.MinValue, (int)additions.Length, (int index) => { return values1[index]; }, (int index) => { return values2[index]; }, (int index) => { return values3[index]; }, allowMultithreading);
//                
//                this._top = new_top;
//            }
//        }
//
//        public void Add(bool allowMultithreading, params T[] additions)
//        {
//            if (additions.Length > int.MaxValue)
//                throw new System.Exception("The maximum size of the Omnitree was exceeded during bulk addition.");
//
//            if (this._top.Count != 0 || (int)additions.Length <= _load)
//            {
//                for (int i = 0; i < additions.Length; i++)
//                    this.Add(additions[i]);
//            }
//            else
//            {
//                // adjust the loads prior to additions
//                ComputeLoads((int)additions.Length);
//
//                Node new_top = new Node(Omnitree.Bounds<Axis1, Axis2, Axis3>.None, null, -1);
//                new_top.Count = (int)additions.Length;
//
//
//                // prepare data for median computations
//                IndexedBigArray<Axis1> values1;
//                IAsyncResult result1 = null;
//                if (this._subdivisionOverride1 != null)
//                    values1 = null;
//                else
//                {
//                    values1 = null;
//                    Towel.Parallels.Parallel.Operation operation = () =>
//                    {
//                        values1 = new IndexedBigArray<Axis1>(additions.Length);
//                        for (int i = 0; i < additions.Length; i++)
//                            values1[i] = LocateVector(additions[i]).Axis1;
//                        Towel.Algorithms.Sort.Merge(this._compare1, (int i) => { return values1[(ulong)i]; }, (int i, Axis1 value) => { values1[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
//                    };
//
//                    if (allowMultithreading)
//                        result1 = Towel.Parallels.Parallel.Thread(operation);
//                    else
//                        operation();
//                }
//
//                // prepare data for median computations
//                IndexedBigArray<Axis2> values2;
//                IAsyncResult result2 = null;
//                if (this._subdivisionOverride2 != null)
//                    values2 = null;
//                else
//                {
//                    values2 = null;
//                    Towel.Parallels.Parallel.Operation operation = () =>
//                    {
//                        values2 = new IndexedBigArray<Axis2>(additions.Length);
//                        for (int i = 0; i < additions.Length; i++)
//                            values2[i] = LocateVector(additions[i]).Axis2;
//                        Towel.Algorithms.Sort.Merge(this._compare2, (int i) => { return values2[(ulong)i]; }, (int i, Axis2 value) => { values2[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
//                    };
//
//                    if (allowMultithreading)
//                        result2 = Towel.Parallels.Parallel.Thread(operation);
//                    else
//                        operation();
//                }
//
//                // prepare data for median computations
//                IndexedBigArray<Axis3> values3;
//                IAsyncResult result3 = null;
//                if (this._subdivisionOverride3 != null)
//                    values3 = null;
//                else
//                {
//                    values3 = null;
//                    Towel.Parallels.Parallel.Operation operation = () =>
//                    {
//                        values3 = new IndexedBigArray<Axis3>(additions.Length);
//                        for (int i = 0; i < additions.Length; i++)
//                            values3[i] = LocateVector(additions[i]).Axis3;
//                        Towel.Algorithms.Sort.Merge(this._compare3, (int i) => { return values3[(ulong)i]; }, (int i, Axis3 value) => { values3[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
//                    };
//
//                    if (allowMultithreading)
//                        result3 = Towel.Parallels.Parallel.Thread(operation);
//                    else
//                        operation();
//                }
//
//
//
//                if (this._subdivisionOverride1 == null && allowMultithreading)
//                    result1.AsyncWaitHandle.WaitOne();
//
//                if (this._subdivisionOverride2 == null && allowMultithreading)
//                    result2.AsyncWaitHandle.WaitOne();
//
//                if (this._subdivisionOverride3 == null && allowMultithreading)
//                    result3.AsyncWaitHandle.WaitOne();
//
//
//                // build the tree
//                Add(new_top, 1, -1, additions.Stepper(), additions.Length, int.MinValue, int.MinValue, int.MinValue, (int)additions.Length, (int index) => { return values1[index]; }, (int index) => { return values2[index]; }, (int index) => { return values3[index]; }, allowMultithreading);
//                
//                this._top = new_top;
//            }
//        }
//
//        
//        private int Add(Node parent, int depth, int child, Stepper<T> additions, int parent_count, int prevmed1, int prevmed2, int prevmed3, int initial_count, Get<Axis1> values1, Get<Axis2> values2, Get<Axis3> values3, bool allowMultithreading)
//        {
//            Axis1 pointOfDivision1;
//            Axis2 pointOfDivision2;
//            Axis3 pointOfDivision3;
//
//            int median_axis1 = -1;
//            int median_axis2 = -1;
//            int median_axis3 = -1;
//            if (this._subdivisionOverride1 == null || this._subdivisionOverride2 == null || this._subdivisionOverride3 == null)
//                GetMedianIndexes(initial_count, child, depth, prevmed1, prevmed2, prevmed3, out median_axis1, out median_axis2, out median_axis3);
//
//            if (this._subdivisionOverride1 != null)
//                pointOfDivision1 = this._subdivisionOverride1(parent.Bounds, additions);
//            else
//                pointOfDivision1 = values1(median_axis1);
//
//            if (this._subdivisionOverride2 != null)
//                pointOfDivision2 = this._subdivisionOverride2(parent.Bounds, additions);
//            else
//                pointOfDivision2 = values2(median_axis2);
//
//            if (this._subdivisionOverride3 != null)
//                pointOfDivision3 = this._subdivisionOverride3(parent.Bounds, additions);
//            else
//                pointOfDivision3 = values3(median_axis3);
//
//            parent.PointOfDivision = new Omnitree.Vector<Axis1, Axis2, Axis3>(pointOfDivision1, pointOfDivision2, pointOfDivision3);
//
//            // divide the values along the medians
//            IMap<IAddable<T>, int> collection_map = new MapHashLinked<IAddable<T>, int>();
//            additions((T value) => 
//            {
//                int index = DetermineChildIndex(parent.PointOfDivision.Value, LocateVector(value));
//                IAddable<T> list = null;
//                if (collection_map.TryGet(index, out list))
//                {
//                    list.Add(value);
//                }
//                else
//                {
//                    if (parent_count < 100000)
//                        list = new AddableArray<T>();
//                    else
//                        list = new AddableLinked<T>();
//                    collection_map.Add(index, list);
//                    list.Add(value);
//                }
//            });
//
//            if (depth == 1 && allowMultithreading)
//            {
//                // NOTE: Must assign placeholders before multithreading so that the threads do not overwrite each other
//                collection_map.Keys((int key) => { parent[key] = new Node(Omnitree.Bounds<Axis1, Axis2, Axis3>.None, parent, key); });
//                IAsyncResult[] handles = new IAsyncResult[Environment.ProcessorCount];
//                for (int i = 0; i < handles.Length; i++)
//                {
//                    int multiTheadSafe_i = i; // used as catpure variable below making it multithread-safe
//                    handles[i] = Towel.Parallels.Parallel.Thread(() =>
//                    {
//                        Step.EveryNth<Link<IAddable<T>, int>>(collection_map.Pairs, multiTheadSafe_i + 1)(
//                        (Link<IAddable<T>, int> link) =>
//                            {
//                                ReversedChildBuilding(parent, link._2, depth, link._1.Stepper, link._1.Count, median_axis1, median_axis2, median_axis3, initial_count, values1, values2, values3, allowMultithreading);
//                            });
//                    });
//                }
//                
//                foreach (IAsyncResult handle in handles)
//                {
//                    handle.AsyncWaitHandle.WaitOne();
//                }
//            }
//            else
//            {
//                collection_map.Pairs((Link<IAddable<T>, int> link) =>
//                { 
//                    ReversedChildBuilding(parent, link._2, depth, link._1.Stepper, link._1.Count, median_axis1, median_axis2, median_axis3, initial_count, values1, values2, values3, allowMultithreading);
//                });
//            }
//
//            int count = 0;
//            foreach (Node node in parent.Children)
//                count += node.Count;
//            return count;
//        }
//
//        int ReversedChildBuilding(Node parent, int child_index, int depth, Stepper<T> additions, int count, int prevmed1, int prevmed2, int prevmed3, int initial_count, Get<Axis1> values1, Get<Axis2> values2, Get<Axis3> values3, bool allowMultithreading)
//        {
//            Omnitree.Bounds<Axis1, Axis2, Axis3> child_bounds = DetermineChildBounds(parent, child_index);
//            if (depth >= _load || count <= _load)
//            {
//                Node new_leaf = new Node(child_bounds, parent, child_index);
//                additions((T value) => { new_leaf.Add(value); });
//                parent[new_leaf.Index] = new_leaf;
//                return new_leaf.Count;
//            }
//            else
//            {
//                Node new_branch = new Node(Omnitree.Vector<Axis1, Axis2, Axis3>.Default, child_bounds, parent, child_index);
//                parent[new_branch.Index] = new_branch;
//                new_branch.Count = Add(new_branch, depth + 1, child_index, additions, count, prevmed1, prevmed2, prevmed3, count, values1, values2, values3, allowMultithreading);
//                return new_branch.Count;
//            }
//        }
//
//        /// <summary>Gets the indeces of the median values at the given position during bulk additions.</summary>
//        private void GetMedianIndexes(int count, int child_index, int depth, int previous1, int previous2, int previous3, out int index1, out int index2, out int index3)
//        {
//            if (depth == 1)
//            {
//                index1 = (count - 1) / 2;
//                index2 = (count - 1) / 2;
//                index3 = (count - 1) / 2;
//                return;
//            }
//
//            int splits = Compute.Power(2, depth);
//            int mid_child_range = count / splits;
//
//            if (child_index >= 4)
//            {
//                index3 = previous3 + mid_child_range;
//                child_index -= 4;
//            }
//            else
//            {
//                index3 = previous3 - mid_child_range;
//            }
//
//            if (child_index >= 2)
//            {
//                index2 = previous2 + mid_child_range;
//                child_index -= 2;
//            }
//            else
//            {
//                index2 = previous2 - mid_child_range;
//            }
//
//            if (child_index >= 1)
//            {
//                index1 = previous1 + mid_child_range;
//                child_index -= 1;
//            }
//            else
//            {
//                index1 = previous1 - mid_child_range;
//            }
//
//        }

		

        #endregion

        #region single

        /// <summary>Adds an item to the tree.</summary>
        /// <param name="addition">The item to be added.</param>
        public void Add(T addition)
        {
            if (this._top.Count == int.MaxValue)
                throw new System.InvalidOperationException("(Count == int.MaxValue) max Omnitree size reached (change ints to longs if you need to).");

            // dynamic tree sizes
            Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);

            Omnitree.Bounds<Axis1, Axis2, Axis3> bounds = GetBoundings(addition);

            // grow the first branch of the tree
            if (!this._top.PointOfDivision.HasValue && this._top.Count >= _load)
            {
                Node top = this._top;

                // create the new branch from the median values
                this._top = new Node(DetermineMedians(top), Omnitree.Bounds<Axis1, Axis2, Axis3>.None, null, -1);

                // iterate through the elements and add them to the appropriate children
                for (Node.ValueNode list = top.Head; list != null; list = list.Next)
                    Add(list.Value, this._top, GetBoundings(list.Value), 0);
            }

            this.Add(addition, this._top, bounds, 0);
        }
        
        /// <summary>Recursive version of the add function.</summary>
        /// <param name="addition">The item to be added.</param>
        /// <param name="node">The current node for tree trversal.</param>
        /// <param name="ms">The location of the addition.</param>
        /// <param name="depth">The current depth of iteration.</param>
        private void Add(T addition, Node node, Omnitree.Bounds<Axis1, Axis2, Axis3> bounds, int depth)
        {
            if (!node.PointOfDivision.HasValue)
            {
                //Leaf leaf = node as Leaf;
                if (depth >= _load || !(node.Count >= _load))
                {
                    node.Add(addition);
                    return;
                }
                else
                {
                    //Node parent = node.Parent;
                    //int child_index = this.DetermineChildIndex(parent.PointOfDivision, location);
                    //Node growth = new Node(DetermineMedians(leaf), leaf.Bounds, parent, child_index);
                    //parent[child_index] = growth;

					Node growth = new Node(DetermineMedians(node), node.Bounds, node.Parent, node.Index);
                    node.Parent[node.Index] = growth;

                    for (Node.ValueNode list = node.Head; list != null; list = list.Next)
                    {
                        Omnitree.Bounds<Axis1, Axis2, Axis3> temp_bounds = GetBoundings(list.Value);
                        if (EncapsulationCheck(growth.Bounds, temp_bounds))
                            Add(list.Value, growth, temp_bounds, depth);
                        else
                        {
                            ReduceParentCounts(node.Parent, 1);
                            Add(list.Value, this._top, temp_bounds, depth);
                        }
                    }

                    Add(addition, growth, bounds, depth);
                    return;
                }
            }
            else
            {
                //Node branch = node as Node;
                int child_index = this.DetermineChildIndex(node.PointOfDivision.Value, bounds); // determine the child "index" (0 through 2^Dimensions) the addition belongs in
                
				// if -1, then the bounds of the addition straddle the point of division (keep it in current node)
				if (child_index == -1)
				{
					node.Add(addition);
                    return;
				}
				
				Node child_node = node[child_index];

                // null children in branches are just empty leaves
                if (child_node == null)
                {
                    Node new_node = new Node(DetermineChildBounds(node, child_index), node, child_index);
                    node[child_index] = new_node;
                    new_node.Add(addition);
                }
                else
                    // child exists already, continue adding
                    Add(addition, child_node, bounds, depth + 1);

                node.Count++;
                return;
            }
        }

        /// <summary>Determins the dimensions of the child at the given index.</summary>
        /// <param name="leaf">The parent of the node to compute dimensions for.</param>
        /// <param name="child">The index of the child to compute dimensions for.</param>
        /// <param name="median1">The computed minimum dimensions of the child node along the 1D axis.</param>
        /// <param name="median2">The computed minimum dimensions of the child node along the 2D axis.</param>
        /// <param name="median3">The computed minimum dimensions of the child node along the 3D axis.</param>
        private Omnitree.Vector<Axis1, Axis2, Axis3> DetermineMedians(Node node)
        {
            try
            {
                // extract the values
                Omnitree.Bound<Axis1>[] values1 = new Omnitree.Bound<Axis1>[node.Count * 2];
                Omnitree.Bound<Axis2>[] values2 = new Omnitree.Bound<Axis2>[node.Count * 2];
                Omnitree.Bound<Axis3>[] values3 = new Omnitree.Bound<Axis3>[node.Count * 2];
                Node.ValueNode for_current = node.Head; // used in for loop
                for (int i = 0; i < node.Count; i++, for_current = for_current.Next)
                    this._getBounds(for_current.Value, 
					out values1[i * 2], out values1[i * 2 + 1], 
					out values2[i * 2], out values2[i * 2 + 1], 
					out values3[i * 2], out values3[i * 2 + 1]);
                return new Omnitree.Vector<Axis1, Axis2, Axis3>(
					Omnitree.SubDivide(values1, this._defaultCompare1 ? Compare.Default : this._compare1), 
					Omnitree.SubDivide(values2, this._defaultCompare2 ? Compare.Default : this._compare2), 
					Omnitree.SubDivide(values3, this._defaultCompare3 ? Compare.Default : this._compare3));
            }
            catch
            {
                // extract the values
                IndexedBigArray<Omnitree.Bound<Axis1>> values1 = new IndexedBigArray<Omnitree.Bound<Axis1>>(node.Count * 2);
                IndexedBigArray<Omnitree.Bound<Axis2>> values2 = new IndexedBigArray<Omnitree.Bound<Axis2>>(node.Count * 2);
                IndexedBigArray<Omnitree.Bound<Axis3>> values3 = new IndexedBigArray<Omnitree.Bound<Axis3>>(node.Count * 2);
                Node.ValueNode for_current = node.Head; // used in for loop
                for (int i = 0; i < node.Count; i++, for_current = for_current.Next)
                {
                    Omnitree.Bound<Axis1> min1; Omnitree.Bound<Axis1> max1;
                    Omnitree.Bound<Axis2> min2; Omnitree.Bound<Axis2> max2;
                    Omnitree.Bound<Axis3> min3; Omnitree.Bound<Axis3> max3;
                    this._getBounds(for_current.Value,
						out min1, out max1,
						out min2, out max2,
						out min3, out max3);
                    values1[i * 2] = min1; values1[i * 2 + 1] = max1;
                    values2[i * 2] = min2; values2[i * 2 + 1] = max2;
                    values3[i * 2] = min3; values3[i * 2 + 1] = max3;
                }
				return new Omnitree.Vector<Axis1, Axis2, Axis3>(
					Omnitree.SubDivide(values1, this._defaultCompare1 ? Compare.Default : this._compare1), 
					Omnitree.SubDivide(values2, this._defaultCompare2 ? Compare.Default : this._compare2), 
					Omnitree.SubDivide(values3, this._defaultCompare3 ? Compare.Default : this._compare3));
            }
        }

        #endregion

        #region Add Helpers

        private Omnitree.Bounds<Axis1, Axis2, Axis3> DetermineChildBounds(Node node, int child_index)
        {
			// the node parameter should always have a point of division value for this function
			Omnitree.Vector<Axis1, Axis2, Axis3> pointOfDivision = node.PointOfDivision.Value;

            Omnitree.Bound<Axis3> min3, max3;
            if (child_index >= 4)
            {
                min3 = pointOfDivision.Axis3;
                max3 = node.Bounds.Max3;
                child_index -= 4;
            }
            else
            {
                min3 = node.Bounds.Min3;
                max3 = pointOfDivision.Axis3;
            }

            Omnitree.Bound<Axis2> min2, max2;
            if (child_index >= 2)
            {
                min2 = pointOfDivision.Axis2;
                max2 = node.Bounds.Max2;
                child_index -= 2;
            }
            else
            {
                min2 = node.Bounds.Min2;
                max2 = pointOfDivision.Axis2;
            }

            Omnitree.Bound<Axis1> min1, max1;
            if (child_index >= 1)
            {
                min1 = pointOfDivision.Axis1;
                max1 = node.Bounds.Max1;
                child_index -= 1;
            }
            else
            {
                min1 = node.Bounds.Min1;
                max1 = pointOfDivision.Axis1;
            }

            return new Omnitree.Bounds<Axis1, Axis2, Axis3>(min1, max1, min2, max2, min3, max3);
        }

        #endregion

        #endregion

        #region Clear

        /// <summary>Returns the tree to an empty state.</summary>
        public void Clear()
        {
            this._top = new Node(Omnitree.Bounds<Axis1, Axis2, Axis3>.None, null, -1);
            Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
        }

        #endregion

        #region Clone

        /// <summary>Creates a shallow clone of this data structure.</summary>
        /// <returns>A shallow clone of this data structure.</returns>
        public OmnitreeBoundsLinked<T, Axis1, Axis2, Axis3> Clone()
        {
            return new OmnitreeBoundsLinked<T, Axis1, Axis2, Axis3>(this);
        }

        #endregion

        #region Count

        /// <summary>Counts the number of items encapsulated by a sub space.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
        /// <returns>The number of items in the provided sub space.</returns>
        public int CountSubSpaceEncapsulated(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3)
        {
            return CountSubSpaceEncapsulated(_top, new Omnitree.Bounds<Axis1, Axis2, Axis3>(min1, max1, min2, max2, min3, max3));
        }
        /// <summary>Counts the number of items encapsulated by a sub space.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
        /// <returns>The number of items in the provided sub space.</returns>
        public int CountSubSpaceEncapsulated(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3)
        {
            return CountSubSpaceEncapsulated(_top, new Omnitree.Bounds<Axis1, Axis2, Axis3>(min1, max1, min2, max2, min3, max3));
        }
        /// <summary>Counts the number of items encapsulated by a sub space.</summary>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
        /// <returns>The number of items in the provided sub space.</returns>
        public int CountSubSpaceEncapsulated(Axis1 axis1, Axis2 axis2, Axis3 axis3)
        {
            return CountSubSpaceEncapsulated(_top, new Omnitree.Bounds<Axis1, Axis2, Axis3>(axis1, axis1, axis2, axis2, axis3, axis3));
        }
        /// <summary>Counts the number of items encapsulated by a sub space.</summary>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
        /// <returns>The number of items in the provided sub space.</returns>
        public int CountSubSpaceEncapsulated(Omnitree.Bound<Axis1> axis1, Omnitree.Bound<Axis2> axis2, Omnitree.Bound<Axis3> axis3)
        {
            return CountSubSpaceEncapsulated(_top, new Omnitree.Bounds<Axis1, Axis2, Axis3>(axis1, axis1, axis2, axis2, axis3, axis3));
        }

        /// <summary>Counts the number of items overlapped by a sub space.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
        /// <returns>The number of items in the provided sub space.</returns>
        public int CountSubSpaceOverlapped(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3)
        {
            return CountSubSpaceOverlapped(_top, new Omnitree.Bounds<Axis1, Axis2, Axis3>(min1, max1, min2, max2, min3, max3));
        }
        /// <summary>Counts the number of items overlapped by a sub space.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
        /// <returns>The number of items in the provided sub space.</returns>
        public int CountSubSpaceOverlapped(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3)
        {
            return CountSubSpaceOverlapped(_top, new Omnitree.Bounds<Axis1, Axis2, Axis3>(min1, max1, min2, max2, min3, max3));
        }
        /// <summary>Counts the number of items overlapped by a sub space.</summary>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
        /// <returns>The number of items in the provided sub space.</returns>
        public int CountSubSpaceOverlapped(Axis1 axis1, Axis2 axis2, Axis3 axis3)
        {
            return CountSubSpaceOverlapped(_top, new Omnitree.Bounds<Axis1, Axis2, Axis3>(axis1, axis1, axis2, axis2, axis3, axis3));
        }
        /// <summary>Counts the number of items overlapped by a sub space.</summary>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
        /// <returns>The number of items in the provided sub space.</returns>
        public int CountSubSpaceOverlapped(Omnitree.Bound<Axis1> axis1, Omnitree.Bound<Axis2> axis2, Omnitree.Bound<Axis3> axis3)
        {
            return CountSubSpaceOverlapped(_top, new Omnitree.Bounds<Axis1, Axis2, Axis3>(axis1, axis1, axis2, axis2, axis3, axis3));
        }

		private int CountSubSpaceEncapsulated(Node node, Omnitree.Bounds<Axis1, Axis2, Axis3> bounds)
		{
			return CountSubSpaceBase(_top, bounds, (a, b) => EncapsulationCheck(a, b));
		}

		private int CountSubSpaceOverlapped(Node node, Omnitree.Bounds<Axis1, Axis2, Axis3> bounds)
		{
			return CountSubSpaceBase(_top, bounds, (a, b) => InclusionCheck(a, b));
		}

		private int CountSubSpaceBase(
			Node node,
			Omnitree.Bounds<Axis1, Axis2, Axis3> bounds,
			Omnitree.SpatialCheck<Omnitree.Bounds<Axis1, Axis2, Axis3>, Omnitree.Bounds<Axis1, Axis2, Axis3>> spatialCheck)
        {
            // adjust min/max values
            int count = 0;
            if (EncapsulationCheck(bounds, node.Bounds))
                count += node.Count;
            else if (!node.PointOfDivision.HasValue)
            {
                for (Node.ValueNode list = node.Head; list != null; list = list.Next)
                    if (spatialCheck(bounds, GetBoundings(list.Value)))
                        count++;
            }
            else
            {
                Node branch = node as Node;
                if (!StraddlesLines(branch.Bounds, branch.PointOfDivision.Value))
                {
                    int child_index = DetermineChildIndex(branch.PointOfDivision.Value, bounds);
                    Node child = branch[child_index];
                    if (child != null)
                      count += this.CountSubSpaceBase(child, bounds, spatialCheck);
                }
                else
                {
                    foreach (Node child in node.Children)
                        count += this.CountSubSpaceBase(child, bounds, spatialCheck);
                }
            }
            return count;
        }

        #endregion

        #region Update

        /// <summary>Iterates through the entire tree and ensures each item is in the proper leaf.</summary>
        public void Update()
        {
            this.Update(this._top, 0);
        }

        /// <summary>Recursive version of the Update method.</summary>
        /// <param name="node">The current node of iteration.</param>
        /// <param name="depth">The current depth of iteration.</param>
        private int Update(Node node, int depth)
        {
			// I messed up this function in the conversion
			throw new System.NotImplementedException();

            int removals = 0;

            if (!node.PointOfDivision.HasValue)
            {
                Node.ValueNode current = node.Head;
                Node.ValueNode previous = null;
                while (current != null)
                {
                    Omnitree.Bounds<Axis1, Axis2, Axis3> bounds = GetBoundings(current.Value);
                    if (!this.EncapsulationCheck(node.Bounds, bounds))
                    {
                        removals++;
                        T updated = current.Value;
                        if (previous == null)
                        {
                            node.Head = current.Next;
                            goto HeadRemoved;
                        }
                        else
                            previous.Next = current.Next;

                        Node whereToAdd = GetEncapsulationParent(node.Parent, bounds);

                        if (whereToAdd == null)
                            throw new System.Exception("an item was updated outside the range of the omnitree");

                        this.Add(updated, whereToAdd, bounds, whereToAdd.Depth);
                    }
                    previous = current;
                HeadRemoved:
                    current = current.Next;
                }
                node.Count -= removals;
                return removals;
            }
            else
            {
                Node branch = node as Node;
                int skipped = 0;
                for (int i = 0; i + skipped < branch.Children.Length; )
                {
                    removals += this.Update(branch.Children[i], depth + 1);
                    if (branch.Children[i].Count == 0)
                        branch.Children[i] = branch.Children[branch.Children.Length - skipped++ - 1];
                    else
                        i++;
                }
                Node[] newArray = new Node[branch.Children.Length - skipped];
                Array.Copy(branch.Children, newArray, newArray.Length);
                branch.Children = newArray;

                branch.Count -= removals;

                if (branch.Count < _load && branch.Count != 0)
                    ShrinkChild(branch.Parent, branch.Index);
            }

            return removals;
        }

        /// <summary>Iterates through the provided dimensions and ensures each item is in the proper leaf.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
        public void Update(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3)
        {
            this.Update(new Omnitree.Bounds<Axis1, Axis2, Axis3>(min1, max1, min2, max2, min3, max3), this._top, 0);
        }
        /// <summary>Iterates through the provided dimensions and ensures each item is in the proper leaf.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
        public void Update(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3)
        {
            this.Update(new Omnitree.Bounds<Axis1, Axis2, Axis3>(min1, max1, min2, max2, min3, max3), this._top, 0);
        }
        /// <summary>Iterates through the provided dimensions and ensures each item is in the proper leaf.</summary>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
        public void Update(Axis1 axis1, Axis2 axis2, Axis3 axis3)
        {
            this.Update(new Omnitree.Bounds<Axis1, Axis2, Axis3>(axis1, axis1, axis2, axis2, axis3, axis3), this._top, 0);
        }
        /// <summary>Iterates through the provided dimensions and ensures each item is in the proper leaf.</summary>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
        public void Update(Omnitree.Bound<Axis1> axis1, Omnitree.Bound<Axis2> axis2, Omnitree.Bound<Axis3> axis3)
        {
            this.Update(new Omnitree.Bounds<Axis1, Axis2, Axis3>(axis1, axis1, axis2, axis2, axis3, axis3), this._top, 0);
        }
        private int Update(Omnitree.Bounds<Axis1, Axis2, Axis3> bounds, Node node, int depth)
        {
			// I messed up this function in the conversion
			throw new System.NotImplementedException();

            if (!InclusionCheck(bounds, node.Bounds))
                return 0;

            int removals = 0;

            if (!node.PointOfDivision.HasValue)
            {
                Node.ValueNode current = node.Head;
                Node.ValueNode previous = null;
                while (current != null)
                {
                    Omnitree.Bounds<Axis1, Axis2, Axis3> item_bounds = GetBoundings(current.Value);
                    if (!this.EncapsulationCheck(node.Bounds, item_bounds))
                    {
                        removals++;
                        T updated = current.Value;
                        if (previous == null)
                        {
                            node.Head = current.Next;
                            goto HeadRemoved;
                        }
                        else
                            previous.Next = current.Next;
                        Node whereToAdd = GetEncapsulationParent(node.Parent, item_bounds);
                        if (whereToAdd == null)
                            throw new System.Exception("an item was updates outside the range of the omnitree");
                        this.Add(updated, whereToAdd, item_bounds, whereToAdd.Depth);
                    }
                    previous = current;
                HeadRemoved:
                    current = current.Next;
                }
                node.Count -= removals;
                return removals;
            }
            else
            {
                Node branch = node as Node;
                int skipped = 0;
                for (int i = 0; i + skipped < branch.Children.Length; )
                {
                    removals += this.Update(branch.Children[i], depth + 1);
                    if (branch.Children[i].Count == 0)
                        branch.Children[i] = branch.Children[branch.Children.Length - skipped++ - 1];
                    else
                        i++;
                }
                Node[] newArray = new Node[branch.Children.Length - skipped];
                Array.Copy(branch.Children, newArray, newArray.Length);
                branch.Children = newArray;

                branch.Count -= removals;

                if (branch.Count < _load && branch.Count != 0)
                    ShrinkChild(branch.Parent, branch.Index);
            }

            return removals;
        }

        #endregion

        #region Remove

        /// <summary>Removes all the items qualified by the delegate.</summary>
        /// <param name="where">The predicate to qualify removals.</param>
        public void Remove(Predicate<T> where)
        {
            this.Remove(this._top, where);
            Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
        }

        /// <summary>Recursive version of the remove method.</summary>
        /// <param name="node">The current node of traversal.</param>
        /// <param name="where">The predicate to qualify removals.</param>
        private int Remove(Node node, Predicate<T> where)
        {
            int removals = 0;

			// items
            while (node.Head != null && where(node.Head.Value))
            {
                node.Head = node.Head.Next;
                removals++;
            }
            if (node.Head != null)
            {
                Node.ValueNode list = node.Head;
                while (list.Next != null)
                {
                    if (where(list.Next.Value))
                    {
                        list.Next = list.Next.Next;
                        removals++;
                    }
                }
            }
            node.Count -= removals;
            
			// children
			if (node.Children != null)
			{
				int skipped = 0;
				for (int i = 0; i + skipped < node.Children.Length; )
				{
				    removals += this.Remove(node.Children[i], where);
				    if (node.Children[i].Count == 0)
				        node.Children[i] = node.Children[node.Children.Length - skipped++ - 1];
				    else
				        i++;
				}
				Node[] newArray = new Node[node.Children.Length - skipped];
				Array.Copy(node.Children, newArray, newArray.Length);
				node.Children = newArray;

				node.Count -= removals;

				if (node.Count < _load && node.Count != 0)
				    ShrinkChild(node.Parent, node.Index);
			}
            return removals;
        }

        /// <summary>Removes all the items encapsulated in a given space.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
        /// <returns>The number of items that were removed.</returns>
        public void RemoveEncapsulated(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3)
        {
            this.RemoveEncapsulated(this._top, new Omnitree.Bounds<Axis1, Axis2, Axis3>(min1, max1, min2, max2, min3, max3));
        }
        /// <summary>Removes all the items encapsulated in a given space.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
        /// <returns>The number of items that were removed.</returns>
        public void RemoveEncapsulated(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3)
        {
            this.RemoveEncapsulated(this._top, new Omnitree.Bounds<Axis1, Axis2, Axis3>(min1, max1, min2, max2, min3, max3));
        }
        /// <summary>Removes all the items encapsulated in a given space.</summary>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
        public void RemoveEncapsulated(Omnitree.Bound<Axis1> axis1, Omnitree.Bound<Axis2> axis2, Omnitree.Bound<Axis3> axis3)
        {
            this.RemoveEncapsulated(this._top, new Omnitree.Bounds<Axis1, Axis2, Axis3>(axis1, axis1, axis2, axis2, axis3, axis3));
        }
        private int RemoveEncapsulated(Node node, Omnitree.Bounds<Axis1, Axis2, Axis3> bounds)
        {
            int removals = this.RemoveBase(node, bounds, (a, b) => this.EncapsulationCheck(a, b));
			Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
			return removals;
        }

		/// <summary>Removes all the items overlapping a given space.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
        /// <returns>The number of items that were removed.</returns>
        public void RemoveOverlapped(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3)
        {
            this.RemoveOverlapped(this._top, new Omnitree.Bounds<Axis1, Axis2, Axis3>(min1, max1, min2, max2, min3, max3));
        }
        /// <summary>Removes all the items overlapping a given space.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
        /// <returns>The number of items that were removed.</returns>
        public void RemoveOverlapped(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3)
        {
            this.RemoveOverlapped(this._top, new Omnitree.Bounds<Axis1, Axis2, Axis3>(min1, max1, min2, max2, min3, max3));
        }
        private int RemoveOverlapped(Node node, Omnitree.Bounds<Axis1, Axis2, Axis3> bounds)
        {
            int removals = this.RemoveBase(node, bounds, (a, b) => this.InclusionCheck(a, b));
			Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
			return removals;
        }

		private int RemoveBase(
			Node node,
			Omnitree.Bounds<Axis1, Axis2, Axis3> bounds,
			Omnitree.SpatialCheck<Omnitree.Bounds<Axis1, Axis2, Axis3>, Omnitree.Bounds<Axis1, Axis2, Axis3>> spatialCheck)
        {
            int removals = 0;
            if (InclusionCheck(bounds, node.Bounds))
            {
				// items
                Node.ValueNode current_node = node.Head;
                Node.ValueNode previous_node = null;
                while (current_node != null)
                {
                    Node.ValueNode temp_previous = current_node;
                    if (spatialCheck(bounds, GetBoundings(current_node.Value)))
                    {
                        removals++;
                        if (current_node == node.Head)
                            node.Head = node.Head.Next;
                        else
                        {
                            previous_node.Next = current_node.Next;
                            temp_previous = previous_node;
                        }
                    }
                    previous_node = temp_previous;
                    current_node = current_node.Next;
                }
                node.Count -= removals;
                
				// children
				if (node.Children != null)
				{
					int skipped = 0;
					for (int i = 0; i + skipped < node.Children.Length; )
					{
					    removals += this.RemoveBase(node.Children[i], bounds, spatialCheck);
					    if (node.Children[i].Count == 0)
					        node.Children[i] = node.Children[node.Children.Length - skipped++ - 1];
					    else
					        i++;
					}
					Node[] newArray = new Node[node.Children.Length - skipped];
					Array.Copy(node.Children, newArray, newArray.Length);
					node.Children = newArray;

					node.Count -= removals;
					// convert this branch back into a leaf
					// Note: if count is zero, it will be chopped off
					if (node.Count < _load && node.Count > 0)
					    ShrinkChild(node.Parent, node.Index);
				}
            }
			
            return removals;
        }

		/// <summary>Removes all the items in a given space validated by a predicate.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
        /// <param name="where">The equality constraint of the removal.</param>
        public void RemoveEncapsulated(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Predicate<T> where)
        {
            this.RemoveEncapsulated(this._top, new Omnitree.Bounds<Axis1, Axis2, Axis3>(min1, max1, min2, max2, min3, max3), where);
        }
        /// <summary>Removes all the items in a given space validated by a predicate.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
        /// <param name="where">The equality constraint of the removal.</param>
        public void RemoveEncapsulated(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Predicate<T> where)
        {
            this.RemoveEncapsulated(this._top, new Omnitree.Bounds<Axis1, Axis2, Axis3>(min1, max1, min2, max2, min3, max3), where);
        }
        private int RemoveEncapsulated(Node node, Omnitree.Bounds<Axis1, Axis2, Axis3> bounds, Predicate<T> where)
        {
            int removals = RemoveBase(node, bounds, where, (a, b) => this.EncapsulationCheck(a, b));
			Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
			return removals;
        }

        /// <summary>Removes all the items in a given space validated by a predicate.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
        /// <param name="where">The equality constraint of the removal.</param>
        public void RemoveOverlapped(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Predicate<T> where)
        {
            this.RemoveOverlapped(this._top, new Omnitree.Bounds<Axis1, Axis2, Axis3>(min1, max1, min2, max2, min3, max3), where);
        }
        /// <summary>Removes all the items in a given space validated by a predicate.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
        /// <param name="where">The equality constraint of the removal.</param>
        public void RemoveOverlapped(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Predicate<T> where)
        {
            this.RemoveOverlapped(this._top, new Omnitree.Bounds<Axis1, Axis2, Axis3>(min1, max1, min2, max2, min3, max3), where);
        }
        private int RemoveOverlapped(Node node, Omnitree.Bounds<Axis1, Axis2, Axis3> bounds, Predicate<T> where)
        {
            int removals = RemoveBase(node, bounds, where, (a, b) => this.InclusionCheck(a, b));
			Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
			return removals;
        }

		private int RemoveBase(
			Node node,
			Omnitree.Bounds<Axis1, Axis2, Axis3> bounds,
			Predicate<T> where,
			Omnitree.SpatialCheck<Omnitree.Bounds<Axis1, Axis2, Axis3>, Omnitree.Bounds<Axis1, Axis2, Axis3>> spatialCheck)
        {
            if (!InclusionCheck(node.Bounds, bounds))
                return 0;
            int removals = 0;
            
			// items
            Node.ValueNode current = node.Head;
            Node.ValueNode previous = null;
            while (current != null)
            {
                if (spatialCheck(bounds, GetBoundings(current.Value)) && where(current.Value))
                {
                    removals++;
                    if (previous == null)
                    {
                        node.Head = current.Next;
                        goto HeadRemoved;
                    }
                    else
                        previous.Next = current.Next;
                }
                previous = current;
            HeadRemoved:
                current = current.Next;
            }
            node.Count -= removals;

            // children
			if (node.Children != null)
			{
				int skipped = 0;
				for (int i = 0; i + skipped < node.Children.Length; )
				{
				    removals += this.RemoveBase(node.Children[i], bounds, where, spatialCheck);
				    if (node.Children[i].Count == 0)
				        node.Children[i] = node.Children[node.Children.Length - skipped++ - 1];
				    else
				        i++;
				}
				Node[] newArray = new Node[node.Children.Length - skipped];
				Array.Copy(node.Children, newArray, newArray.Length);
				node.Children = newArray;

				node.Count -= removals;

				if (node.Count < _load && node.Count != 0)
				    ShrinkChild(node.Parent, node.Index);
			}
            return removals;
        }

        /// <summary>Removes all instances of a given value.</summary>
        public void Remove(T removal)
        {
            Omnitree.Bound<Axis1> min1; Omnitree.Bound<Axis1> max1;
            Omnitree.Bound<Axis2> min2; Omnitree.Bound<Axis2> max2;
            Omnitree.Bound<Axis3> min3; Omnitree.Bound<Axis3> max3;
            this._getBounds(removal, out min1, out max1, out min2, out max2, out min3, out max3);
            this.RemoveOverlapped(this._top, new Omnitree.Bounds<Axis1, Axis2, Axis3>(min1, max1, min2, max2, min3, max3), item => this._equate(item, removal));
        }
        /// <summary>Removes all the items in a given space.</summary>
        /// <param name="axis1">The axis of the removal along the  1D axis.</param>
		/// <param name="axis2">The axis of the removal along the  2D axis.</param>
		/// <param name="axis3">The axis of the removal along the  3D axis.</param>
        /// <returns>The number of items that were removed.</returns>
        public void RemoveOverlapped(Axis1 axis1, Axis2 axis2, Axis3 axis3)
        {
            this.RemoveOverlapped(axis1, axis1, axis2, axis2, axis3, axis3);
            Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
        }
        
        /// <summary>Removes all the items in a given space validated by a predicate.</summary>
        /// <param name="axis1">The axis of the removal along the  1D axis.</param>
		/// <param name="axis2">The axis of the removal along the  2D axis.</param>
		/// <param name="axis3">The axis of the removal along the  3D axis.</param>
        /// <param name="where">The equality constraint of the removal.</param>
        public void RemoveOverlapped(Axis1 axis1, Axis2 axis2, Axis3 axis3, Predicate<T> where)
        {
			this.RemoveOverlapped(axis1, axis1, axis2, axis2, axis3, axis3, where);
            Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
        }

        #endregion

        #region Stepper And IEnumerable

        /// <summary>Traverses every item in the tree and performs the delegate in them.</summary>
        /// <param name="function">The delegate to perform on every item in the tree.</param>
        public void Stepper(Step<T> function)
        {
            this.Stepper(function, this._top);
        }
        private void Stepper(Step<T> function, Node node)
        {
            Node.ValueNode list = node.Head;
            while (list != null)
            {
                function(list.Value);
                list = list.Next;
            }
			if (node.Children != null)
				foreach (Node child in node.Children)
				    this.Stepper(function, child);
        }

        /// <summary>Traverses every item in the tree and performs the delegate in them.</summary>
        /// <param name="function">The delegate to perform on every item in the tree.</param>
        public StepStatus Stepper(StepBreak<T> function)
        {
            return Stepper(function, _top);
        }
        private StepStatus Stepper(StepBreak<T> function, Node node)
        {
            StepStatus status = StepStatus.Continue;
            
            for (Node.ValueNode list = node.Head; list != null; list = list.Next)
                if ((status = function(list._value)) != StepStatus.Continue)
                    break;
            
			if (node.Children != null)
				foreach (Node child in node.Children)
				    if ((status = Stepper(function, child)) != StepStatus.Continue)
				        break;
            
            return status;
        }

        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="function">The delegate to perform on all items in the tree within the given bounds.</param>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
        public void StepperEncapsulated(Step<T> function, Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3)
        {
            StepperEncapsulated(function, _top, new Omnitree.Bounds<Axis1, Axis2, Axis3>(min1, max1, min2, max2, min3, max3));
        }
        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="function">The delegate to perform on all items in the tree within the given bounds.</param>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
        public void StepperEncapsulated(Step<T> function, Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3)
        {
            StepperEncapsulated(function, _top, new Omnitree.Bounds<Axis1, Axis2, Axis3>(min1, max1, min2, max2, min3, max3));
        }
        private void StepperEncapsulated(Step<T> function, Node node, Omnitree.Bounds<Axis1, Axis2, Axis3> bounds)
        {
            StepperBase(function, node, bounds, (a, b) => this.EncapsulationCheck(a, b));
        }

		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="function">The delegate to perform on all items in the tree within the given bounds.</param>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
        public void StepperOverlapped(Step<T> function, Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3)
        {
            StepperOverlapped(function, _top, new Omnitree.Bounds<Axis1, Axis2, Axis3>(min1, max1, min2, max2, min3, max3));
        }
        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="function">The delegate to perform on all items in the tree within the given bounds.</param>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
        public void StepperOverlapped(Step<T> function, Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3)
        {
            StepperOverlapped(function, _top, new Omnitree.Bounds<Axis1, Axis2, Axis3>(min1, max1, min2, max2, min3, max3));
        }
        private void StepperOverlapped(Step<T> function, Node node, Omnitree.Bounds<Axis1, Axis2, Axis3> bounds)
        {
            StepperBase(function, node, bounds, (a, b) => this.InclusionCheck(a, b));
        }

		private void StepperBase(
			Step<T> function,
			Node node,
			Omnitree.Bounds<Axis1, Axis2, Axis3> bounds,
			Omnitree.SpatialCheck<Omnitree.Bounds<Axis1, Axis2, Axis3>, Omnitree.Bounds<Axis1, Axis2, Axis3>> spatialCheck)
        {
            for (Node.ValueNode list = node.Head; list != null; list = list.Next)
                if (spatialCheck(bounds, GetBoundings(list.Value)))
                    function(list.Value);

			if (node.Children != null)
			{
				foreach (Node child in node.Children)
				    // optimization: stop bounds checking if space encapsulates node
				    if (EncapsulationCheck(bounds, child.Bounds))
				        this.Stepper(function, child);
				    else if (InclusionCheck(child.Bounds, bounds))
				        this.StepperBase(function, child, bounds, spatialCheck);
			}
        }

        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
        public StepStatus StepperEncapsulated(StepBreak<T> function, Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3)
        {
            return StepperEncapsulated(function, _top, new Omnitree.Bounds<Axis1, Axis2, Axis3>(min1, max1, min2, max2, min3, max3));
        }
        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
        public StepStatus StepperEncapsulated(StepBreak<T> function, Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3)
        {
			return StepperEncapsulated(function, _top, new Omnitree.Bounds<Axis1, Axis2, Axis3>(min1, max1, min2, max2, min3, max3));
        }
        private StepStatus StepperEncapsulated(StepBreak<T> function, Node node, Omnitree.Bounds<Axis1, Axis2, Axis3> bounds)
        {
            return StepperBase(function, node, bounds, (a, b) => this.EncapsulationCheck(a, b));
        }

		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
        public StepStatus StepperOverlapped(StepBreak<T> function, Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3)
        {
            return StepperOverlapped(function, _top, new Omnitree.Bounds<Axis1, Axis2, Axis3>(min1, max1, min2, max2, min3, max3));
        }
        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
        public StepStatus StepperOverlapped(StepBreak<T> function, Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3)
        {
			return StepperOverlapped(function, _top, new Omnitree.Bounds<Axis1, Axis2, Axis3>(min1, max1, min2, max2, min3, max3));
        }
        private StepStatus StepperOverlapped(StepBreak<T> function, Node node, Omnitree.Bounds<Axis1, Axis2, Axis3> bounds)
        {
            return StepperBase(function, node, bounds, (a, b) => this.InclusionCheck(a, b));
        }

		private StepStatus StepperBase(
			StepBreak<T> function,
			Node node,
			Omnitree.Bounds<Axis1, Axis2, Axis3> bounds,
			Omnitree.SpatialCheck<Omnitree.Bounds<Axis1, Axis2, Axis3>, Omnitree.Bounds<Axis1, Axis2, Axis3>> spatialCheck)
        {
            StepStatus status = StepStatus.Continue;

            for (Node.ValueNode list = node.Head; list != null; list = list.Next)
                if (spatialCheck(bounds, GetBoundings(list.Value)) &&
                    (status = function(list.Value)) != StepStatus.Continue)
                    break;

			if (node.Children != null)
			{
				foreach (Node child in node.Children)
				    // optimization: stop bounds checking if space encapsulates node
				    if (EncapsulationCheck(bounds, child.Bounds) &&
				        (status = this.Stepper(function, child)) != StepStatus.Continue)
				        break;
				    else if (!InclusionCheck(child.Bounds, bounds) &&
				        (status = this.StepperBase(function, child, bounds, spatialCheck)) != StepStatus.Continue)
				        break;
			}

            return status;
        }

        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="axis1">The axis of the removal along the  1D axis.</param>
		/// <param name="axis2">The axis of the removal along the  2D axis.</param>
		/// <param name="axis3">The axis of the removal along the  3D axis.</param>
        public void StepperOverlapped(Step<T> function, Axis1 axis1, Axis2 axis2, Axis3 axis3)
        {
            StepperOverlapped(function, this._top, new Omnitree.Bounds<Axis1, Axis2, Axis3>(axis1, axis1, axis2, axis2, axis3, axis3));
        }

        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="function">The delegate to perform on all items in the tree within the given bounds.</param>
        /// <param name="axis1">The axis of the removal along the  1D axis.</param>
		/// <param name="axis2">The axis of the removal along the  2D axis.</param>
		/// <param name="axis3">The axis of the removal along the  3D axis.</param>
        public StepStatus StepperOverlapped(StepBreak<T> function, Axis1 axis1, Axis2 axis2, Axis3 axis3)
        {
			return StepperOverlapped(function, this._top, new Omnitree.Bounds<Axis1, Axis2, Axis3>(axis1, axis1, axis2, axis2, axis3, axis3));
        }

        /// <summary>FOR COMPATIBILITY ONLY. AVOID IF POSSIBLE.</summary>
        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
        {
            throw new System.NotImplementedException();
            //return (this.ToArray() as System.Collections.Generic.IEnumerable<T>).GetEnumerator();
        }

        /// <summary>FOR COMPATIBILITY ONLY. AVOID IF POSSIBLE.</summary>
        System.Collections.Generic.IEnumerator<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator()
        {
            throw new System.NotImplementedException();
            //return (this.ToArray() as System.Collections.Generic.IEnumerable<T>).GetEnumerator();
        }

        #endregion

        #region Helpers

        private bool StraddlesLines(Omnitree.Bounds<Axis1, Axis2, Axis3> bounds, Omnitree.Vector<Axis1, Axis2, Axis3> vector)
        {
			if ((!bounds.Min1.Exists || (this._compare1(bounds.Min1.Value, vector.Axis1) != Comparison.Greater)) &&
				(!bounds.Max1.Exists || (this._compare1(bounds.Max1.Value, vector.Axis1) != Comparison.Less)))
				return true;
			if ((!bounds.Min2.Exists || (this._compare2(bounds.Min2.Value, vector.Axis2) != Comparison.Greater)) &&
				(!bounds.Max2.Exists || (this._compare2(bounds.Max2.Value, vector.Axis2) != Comparison.Less)))
				return true;
			if ((!bounds.Min3.Exists || (this._compare3(bounds.Min3.Value, vector.Axis3) != Comparison.Greater)) &&
				(!bounds.Max3.Exists || (this._compare3(bounds.Max3.Value, vector.Axis3) != Comparison.Less)))
				return true;
            return false;
        }

        /// <summary>Computes the child index that contains the desired dimensions.</summary>
        /// <param name="node">The branch .</param>
        /// <param name="vector">The dimensions to determine the child index.</param>
        /// <returns>The computed child index based on the coordinates relative to the center of the node.</returns>
        private int DetermineChildIndex(Omnitree.Vector<Axis1, Axis2, Axis3> pointOfDivision, Omnitree.Bounds<Axis1, Axis2, Axis3> bounds)
        {
			// make sure a child encapsulates the bounds (otherwise the bounds cannot move down the tree)
			if (StraddlesLines(bounds, pointOfDivision))
				return -1;

            int child = 0;
            if (!bounds.Min1.Exists || !(this._compare1(bounds.Min1.Value, pointOfDivision.Axis1) == Comparison.Less))
                child += 1 << 0;
            if (!bounds.Min2.Exists || !(this._compare2(bounds.Min2.Value, pointOfDivision.Axis2) == Comparison.Less))
                child += 1 << 1;
            if (!bounds.Min3.Exists || !(this._compare3(bounds.Min3.Value, pointOfDivision.Axis3) == Comparison.Less))
                child += 1 << 2;
            return child;
        }

        /// <summary>Converts a branch back into a leaf when the count is reduced.</summary>
        /// <param name="parent">The parent to shrink a child of.</param>
        /// <param name="child">The index of the child to shrink.</param>
        private void ShrinkChild(Node parent, int child_index)
        {
            Node leaf;
            Node removal = null;
            if (parent == null) // top of tree
            {
                removal = this._top;
                leaf = new Node(Omnitree.Bounds<Axis1, Axis2, Axis3>.None, null, -1);
                this._top = leaf;
            }
            else // non-top branch
            {
                removal = parent[child_index];
                leaf = new Node(removal.Bounds, removal.Parent, removal.Index);
                parent[child_index] = leaf;
            }

            this.Stepper((T step) => { leaf.Add(step); }, removal);
        }

        /// <summary>Reduces the counts of all the parents of a given node by a given amount.</summary>
        /// <param name="parent">The starting parent of the reduction.</param>
        /// <param name="reduction">The amount to reduce the parent counts by.</param>
        private void ReduceParentCounts(Node parent, int reduction)
        {
            IncreaseParentCounts(parent, -reduction);
        }

        /// <summary>Increases the counts of all the parents of a given node by a given amount.</summary>
        /// <param name="parent">The starting parent of the increase.</param>
        /// <param name="increase">The amount to increase the parent counts by.</param>
        private void IncreaseParentCounts(Node parent, int increase)
        {
            Node looper = parent;
            while (looper != null)
            {
                looper.Count += increase;
                looper = looper.Parent;
            }
        }

        /// <summary>Checks a node for inclusion (overlap) between two bounds.</summary>
        /// <returns>True if the spaces overlap; False if not.</returns>
        private bool InclusionCheck(Omnitree.Bounds<Axis1, Axis2, Axis3> a, Omnitree.Bounds<Axis1, Axis2, Axis3> b)
        {

            if (a.Max1.Exists && b.Min1.Exists && this._compare1(a.Max1.Value, b.Min1.Value) == Comparison.Less)
                return false;
            else if (a.Min1.Exists && b.Max1.Exists && this._compare1(a.Min1.Value, b.Max1.Value) == Comparison.Greater)
                return false;

            if (a.Max2.Exists && b.Min2.Exists && this._compare2(a.Max2.Value, b.Min2.Value) == Comparison.Less)
                return false;
            else if (a.Min2.Exists && b.Max2.Exists && this._compare2(a.Min2.Value, b.Max2.Value) == Comparison.Greater)
                return false;

            if (a.Max3.Exists && b.Min3.Exists && this._compare3(a.Max3.Value, b.Min3.Value) == Comparison.Less)
                return false;
            else if (a.Min3.Exists && b.Max3.Exists && this._compare3(a.Min3.Value, b.Max3.Value) == Comparison.Greater)
                return false;

            return true;
        }

        /// <summary>Checks if a space encapsulates a point.</summary>
        /// <returns>True if the space encapsulates the point; False if not.</returns>
        private bool EncapsulationCheck(Omnitree.Bounds<Axis1, Axis2, Axis3> bounds, Omnitree.Vector<Axis1, Axis2, Axis3> vector)
        {
            // if the location is not outside the bounds, it must be inside

            if (bounds.Min1.Exists && this._compare1(vector.Axis1, bounds.Min1.Value) == Comparison.Less)
                return false;
            else if (bounds.Max1.Exists && this._compare1(vector.Axis1, bounds.Max1.Value) == Comparison.Greater)
                return false;

            if (bounds.Min2.Exists && this._compare2(vector.Axis2, bounds.Min2.Value) == Comparison.Less)
                return false;
            else if (bounds.Max2.Exists && this._compare2(vector.Axis2, bounds.Max2.Value) == Comparison.Greater)
                return false;

            if (bounds.Min3.Exists && this._compare3(vector.Axis3, bounds.Min3.Value) == Comparison.Less)
                return false;
            else if (bounds.Max3.Exists && this._compare3(vector.Axis3, bounds.Max3.Value) == Comparison.Greater)
                return false;

            return true;
        }

        /// <summary>Checks if a space (left) encapsulates another space (right).</summary>
        /// <returns>True if the left space encapsulates the right; False if not.</returns>
        private bool EncapsulationCheck(Omnitree.Bounds<Axis1, Axis2, Axis3> a, Omnitree.Bounds<Axis1, Axis2, Axis3> b)
        {
            if ((a.Min1.Exists && !b.Min1.Exists) || (a.Min2.Exists && !b.Min2.Exists) || (a.Min3.Exists && !b.Min3.Exists))
                return false;
			if ((a.Max1.Exists && !b.Max1.Exists) || (a.Max2.Exists && !b.Max2.Exists) || (a.Max3.Exists && !b.Max3.Exists))
                return false;

            if (b.Min1.Exists && a.Min1.Exists && this._compare1(a.Min1.Value, b.Min1.Value) != Comparison.Less)
                return false;
            if (b.Max1.Exists && a.Max1.Exists && this._compare1(a.Max1.Value, b.Max1.Value) != Comparison.Greater)
                return false;

            if (b.Min2.Exists && a.Min2.Exists && this._compare2(a.Min2.Value, b.Min2.Value) != Comparison.Less)
                return false;
            if (b.Max2.Exists && a.Max2.Exists && this._compare2(a.Max2.Value, b.Max2.Value) != Comparison.Greater)
                return false;

            if (b.Min3.Exists && a.Min3.Exists && this._compare3(a.Min3.Value, b.Min3.Value) != Comparison.Less)
                return false;
            if (b.Max3.Exists && a.Max3.Exists && this._compare3(a.Max3.Value, b.Max3.Value) != Comparison.Greater)
                return false;

            return true;
        }

        /// <summary>Checks for equality between two locations.</summary>
        /// <returns>True if equal; False if not;</returns>
        private bool EqualsCheck(Omnitree.Vector<Axis1, Axis2, Axis3> a, Omnitree.Vector<Axis1, Axis2, Axis3> b)
        {

            if (!this._equate1(a.Axis1, b.Axis1))
                return false;

            if (!this._equate2(a.Axis2, b.Axis2))
                return false;

            if (!this._equate3(a.Axis3, b.Axis3))
                return false;

            return true;
        }

        /// <summary>Gets the nearest parent that encapsulates a location.</summary>
        /// <param name="node">The starting node to find the encapsulating parent of the location.</param>
        /// <param name="bounds">The bounds to get the encapsulating parent from.</param>
        /// <returns>The nearest node that encapsulates the given location.</returns>
        private Node GetEncapsulationParent(Node node, Omnitree.Bounds<Axis1, Axis2, Axis3> bounds)
        {
            while (node != null && !EncapsulationCheck(node.Bounds, bounds))
                node = node.Parent;
            return node;
        }

        private Omnitree.Bounds<Axis1, Axis2, Axis3> GetBoundings(T value)
        {
            Omnitree.Bound<Axis1> min1; Omnitree.Bound<Axis1> max1;
            Omnitree.Bound<Axis2> min2; Omnitree.Bound<Axis2> max2;
            Omnitree.Bound<Axis3> min3; Omnitree.Bound<Axis3> max3;
            this._getBounds(value,
				out min1, out max1,
				out min2, out max2,
				out min3, out max3);
            return new Omnitree.Bounds<Axis1, Axis2, Axis3>(
				min1, max1,
				min2, max2,
				min3, max3);
        }

        #endregion

        #endregion
    }

    #endregion

    #region 4 Dimensional

    public interface IOmnitreeBounds<T, Axis1, Axis2, Axis3, Axis4> : IDataStructure<T>,
            DataStructure.ICountable,
            DataStructure.IAddable<T>,
            DataStructure.IClearable,
            DataStructure.IRemovable<T>,
            DataStructure.IEquating<T>
    {
        #region Properties

        /// <summary>The number of dimensions in this tree.</summary>
        int Dimensions { get; }

        #endregion

        #region Methods

        /// <summary>Counts the number of items encapsulated by a sub space.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
        /// <returns>The number of items in the provided sub space.</returns>
        int CountSubSpaceEncapsulated(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4);

		/// <summary>Counts the number of items overlapped by a sub space.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
        /// <returns>The number of items in the provided sub space.</returns>
        int CountSubSpaceOverlapped(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4);

        /// <summary>Iterates through the entire tree and ensures each item is in the proper leaf.</summary>
        void Update();
        /// <summary>Iterates through the provided dimensions and ensures each item is in the proper leaf.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
        void Update(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4);

        /// <summary>Removes all the items in a given space.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
        void RemoveEncapsulated(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4);
        /// <summary>Removes all the items in a given space where predicate is met.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
        /// <param name="where">The predicate constraint of the removal.</param>
        void RemoveEncapsulated(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Predicate<T> where);

		/// <summary>Removes all the items in a given space.</summary>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
        void RemoveOverlapped(Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4);
        /// <summary>Removes all the items in a given space.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
        void RemoveOverlapped(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4);
        /// <summary>Removes all the items in a given space where equality is met.</summary>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
        /// <param name="where">The equality constraint of the removal.</param>
        void RemoveOverlapped(Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Predicate<T> where);
        /// <summary>Removes all the items in a given space where predicate is met.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
        /// <param name="where">The predicate constraint of the removal.</param>
        void RemoveOverlapped(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Predicate<T> where);

        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="step">The step function to perform on all items in the tree within the given bounds.</param>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
        void StepperEncapsulated(Step<T> step, Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4);
        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="step">The step function to perform on all items in the tree within the given bounds.</param>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
        StepStatus StepperEncapsulated(StepBreak<T> step, Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4);
        
		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="step">The step function to perform on all items in the tree within the given bounds.</param>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
        void StepperOverlapped(Step<T> step, Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4);
        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="step">The step function to perform on all items in the tree within the given bounds.</param>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
        StepStatus StepperOverlapped(StepBreak<T> step, Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4);

		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="step">The step function to perform on all items in the tree within the given bounds.</param>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
        void StepperOverlapped(Step<T> step, Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4);
        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="step">The step function to perform on all items in the tree within the given bounds.</param>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
        StepStatus StepperOverlapped(StepBreak<T> function, Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4);

        #endregion
    }

    public class OmnitreeBoundsLinked<T, Axis1, Axis2, Axis3, Axis4> : IOmnitreeBounds<T, Axis1, Axis2, Axis3, Axis4>
    {
        private const int _dimensions = 4;
        internal static int _children_per_node = (int)BigInteger.Pow(2, 4);

        private Node _top;

		private int _naturalLogLower = 1; // caching the next time to calculate loads (lower count)
		private int _naturalLogUpper = -1; // caching the next time to calculate loads (upper count)
        private int _load; // ln(count); min = _defaultLoad
        private Omnitree.GetBounds<T, Axis1, Axis2, Axis3, Axis4> _getBounds;

        private bool _defaultEquate;
        private Equate<T> _equate;


        private bool _defaultEquate1;
        private Equate<Axis1> _equate1;

        private bool _defaultEquate2;
        private Equate<Axis2> _equate2;

        private bool _defaultEquate3;
        private Equate<Axis3> _equate3;

        private bool _defaultEquate4;
        private Equate<Axis4> _equate4;



        private bool _defaultCompare1;
        private Compare<Axis1> _compare1;

        private bool _defaultCompare2;
        private Compare<Axis2> _compare2;

        private bool _defaultCompare3;
        private Compare<Axis3> _compare3;

        private bool _defaultCompare4;
        private Compare<Axis4> _compare4;


        // allows median overriding for custom optimizations (USE AT YOUR OWN RISK)
        private Omnitree.SubdivisionOverride<T, Axis1, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>> _subdivisionOverride1;
        private Omnitree.SubdivisionOverride<T, Axis2, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>> _subdivisionOverride2;
        private Omnitree.SubdivisionOverride<T, Axis3, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>> _subdivisionOverride3;
        private Omnitree.SubdivisionOverride<T, Axis4, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>> _subdivisionOverride4;

        #region Nested Types

        /// <summary>Can be a leaf or a branch.</summary>
        internal class Node
        {
            public class ValueNode
            {
                internal T _value;
                internal ValueNode _next;

                public T Value { get { return _value; } set { _value = value; } }
                public ValueNode Next { get { return _next; } set { _next = value; } }

                public ValueNode(T value, ValueNode next)
                {
                    _value = value;
                    _next = next;
                }
            }

            internal Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4> _bounds;
            internal Node _parent;
            internal int _index;
            internal int _count;
            internal ValueNode _head;
            private Node[] _children;
            private Omnitree.Vector<Axis1, Axis2, Axis3, Axis4>? _pointOfDivision;

            /// <summary>The parent of this node.</summary>
            public Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4> Bounds { get { return this._bounds; } }
            /// <summary>The parent of this node.</summary>
            public Node Parent { get { return this._parent; } }
            /// <summary>The computed child index of this node (see the "Notes" region in "Omnitree.cs" for the algorithm.</summary>
            public int Index { get { return this._index; } }
            /// <summary>The number of elements stored in this node and its children.</summary>
            public int Count { get { return this._count; } set { this._count = value; } }
            /// <summary>The first object stored in this node.</summary>
            public ValueNode Head { get { return this._head; } set { this._head = value; } }
            public Node[] Children { get { return this._children; } set { this._children = value; } }
            public Omnitree.Vector<Axis1, Axis2, Axis3, Axis4>? PointOfDivision { get { return this._pointOfDivision; } internal set { this._pointOfDivision = value; } }

            /// <summary>Gets child by index.</summary>
            /// <param name="child_index">The index of the child to get.</param>
            /// <returns>The child of the given index or null if non-existent.</returns>
            public Node this[int child_index]
            {
                get
                {
                    if (this._children == null)
                        return null;
                    if (this._children.Length == OmnitreePointsLinked<T, Axis1, Axis2, Axis3, Axis4>._children_per_node)
                        return this._children[(int)child_index];
                    foreach (Node node in this._children)
                        if (node.Index == child_index)
                            return node;
                    return null;
                }
                set
                {
                    // This error check should be unnecessary... but fuck it... might as well
                    if (value.Index != child_index)
                        throw new System.Exception("Bug in Omnitree (index/property mis-match when setting a child on a branch)");

                    // no children yet
                    if (this._children == null)
                    {
                        this._children = new Node[] { value };
                        return;
                    }
                    // max children overwrite
                    else if (this._children.Length == OmnitreePointsLinked<T, Axis1, Axis2, Axis3, Axis4>._children_per_node)
                    {
                        this._children[(int)child_index] = value;
                        return;
                    }
                    // non-max child overwrite
                    for (int i = 0; i < this._children.Length; i++)
                        if (this._children[i].Index == child_index)
                        {
                            this._children[i] = value;
                            return;
                        }
                    // new child
                    Node[] newArray = new Node[this._children.Length + 1];
                    if (newArray.Length == OmnitreePointsLinked<T, Axis1, Axis2, Axis3, Axis4>._children_per_node)
                    {
                        // new child resulting in a max children branch (sorting required)
                        for (int i = 0; i < this._children.Length; i++)
                        {
                            newArray[(int)this._children[i]._index] = this._children[i];
                        }
                        newArray[(int)value._index] = value;
                    }
                    else
                    {
                        // new child resulting in a non-max children branch
                        Array.Copy(this._children, newArray, this._children.Length);
                        newArray[newArray.Length - 1] = value;
                    }
                    this._children = newArray;
                }
            }

            /// <summary>The depth this node is located in the Omnitree.</summary>
            public int Depth
            {
                get
                {
                    int depth = -1;
                    for (Node looper = this; looper != null; looper = looper.Parent)
                        depth++;
                    return depth;
                }
            }

            /// <summary>Constructs a node.</summary>
            /// <param name="bounds">The bounds of this node.</param>
            /// <param name="parent">The parent of this node.</param>
            /// <param name="index">The number of elements stored in this node and its children.</param>
            public Node(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4> bounds, Node parent, int index)
            {
                this._bounds = bounds;
                this._parent = parent;
                this._index = index;
            }

            public Node(Omnitree.Vector<Axis1, Axis2, Axis3, Axis4> pointOfDivision, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4> bounds, Node parent, int index)
                : this(bounds, parent, index)
            {
                this._pointOfDivision = pointOfDivision;
            }

            internal Node(Node nodeToClone)
            {
                this._bounds = nodeToClone._bounds;
                this._parent = nodeToClone._parent;
                this._index = nodeToClone._index;
                this._count = nodeToClone._count;

                this._children = nodeToClone._children.Clone() as Node[];
                this._pointOfDivision = nodeToClone._pointOfDivision;

                ValueNode this_looper = this._head;
                ValueNode other_looper = nodeToClone._head;

                while (other_looper != null)
                {
                    this_looper.Next = new ValueNode(other_looper.Next.Value, null);
                    this_looper = this_looper.Next;
                    other_looper = other_looper.Next;
                }
            }

            public void Add(T addition)
            {
                this._head = new ValueNode(addition, this._head);
                this.Count++;
            }

            internal Node Clone()
            {
                return new Node(this);
            }
        }
        
        #endregion

        #region Constructors

        /// <summary>This constructor is for cloning purposes</summary>
        private OmnitreeBoundsLinked(OmnitreeBoundsLinked<T, Axis1, Axis2, Axis3, Axis4> omnitree)
        {
            this._top = omnitree._top.Clone();
            this._load = omnitree._load;
            this._getBounds = omnitree._getBounds;
            this._defaultEquate = omnitree._defaultEquate;
            this._equate = omnitree._equate;

            this._defaultEquate1 = omnitree._defaultEquate1;
            this._equate1 = omnitree._equate1;
            this._defaultEquate2 = omnitree._defaultEquate2;
            this._equate2 = omnitree._equate2;
            this._defaultEquate3 = omnitree._defaultEquate3;
            this._equate3 = omnitree._equate3;
            this._defaultEquate4 = omnitree._defaultEquate4;
            this._equate4 = omnitree._equate4;

            this._defaultCompare1 = omnitree._defaultCompare1;
            this._compare1 = omnitree._compare1;
            this._defaultCompare2 = omnitree._defaultCompare2;
            this._compare2 = omnitree._compare2;
            this._defaultCompare3 = omnitree._defaultCompare3;
            this._compare3 = omnitree._compare3;
            this._defaultCompare4 = omnitree._defaultCompare4;
            this._compare4 = omnitree._compare4;

            this._subdivisionOverride1 = omnitree._subdivisionOverride1;
            this._subdivisionOverride2 = omnitree._subdivisionOverride2;
            this._subdivisionOverride3 = omnitree._subdivisionOverride3;
            this._subdivisionOverride4 = omnitree._subdivisionOverride4;
        }

        private OmnitreeBoundsLinked(
            Omnitree.GetBounds<T, Axis1, Axis2, Axis3, Axis4> getBounds,

            bool defaultEquate,
            Equate<T> equate,

            bool defaultEquate1,
            Equate<Axis1> equateAxis1,
            bool defaultEquate2,
            Equate<Axis2> equateAxis2,
            bool defaultEquate3,
            Equate<Axis3> equateAxis3,
            bool defaultEquate4,
            Equate<Axis4> equateAxis4,

            bool defaultCompare1,
            Compare<Axis1> compare1,
            bool defaultCompare2,
            Compare<Axis2> compare2,
            bool defaultCompare3,
            Compare<Axis3> compare3,
            bool defaultCompare4,
            Compare<Axis4> compare4,

            Omnitree.SubdivisionOverride<T, Axis1, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>> subdivisionOverride1,
            Omnitree.SubdivisionOverride<T, Axis2, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>> subdivisionOverride2,
            Omnitree.SubdivisionOverride<T, Axis3, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>> subdivisionOverride3,
            Omnitree.SubdivisionOverride<T, Axis4, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>> subdivisionOverride4)
        {
			if (getBounds == null)
			{
				throw new ArgumentNullException(nameof(getBounds));
			}
			if (equate == null)
			{
				throw new ArgumentNullException(nameof(equate));
			}

			if (equateAxis1 == null)
			{
				throw new ArgumentNullException(nameof(equateAxis1));
			}
			if (equateAxis2 == null)
			{
				throw new ArgumentNullException(nameof(equateAxis2));
			}
			if (equateAxis3 == null)
			{
				throw new ArgumentNullException(nameof(equateAxis3));
			}
			if (equateAxis4 == null)
			{
				throw new ArgumentNullException(nameof(equateAxis4));
			}

			if (compare1 == null)
			{
				throw new ArgumentNullException(nameof(compare1));
			}
			if (compare2 == null)
			{
				throw new ArgumentNullException(nameof(compare2));
			}
			if (compare3 == null)
			{
				throw new ArgumentNullException(nameof(compare3));
			}
			if (compare4 == null)
			{
				throw new ArgumentNullException(nameof(compare4));
			}

            this._getBounds = getBounds;
            this._defaultEquate = defaultEquate;
            this._equate = equate;

            this._defaultEquate1 = defaultEquate1;
            this._equate1 = equateAxis1;
            this._defaultEquate2 = defaultEquate2;
            this._equate2 = equateAxis2;
            this._defaultEquate3 = defaultEquate3;
            this._equate3 = equateAxis3;
            this._defaultEquate4 = defaultEquate4;
            this._equate4 = equateAxis4;

            this._defaultCompare1 = defaultCompare1;
            this._compare1 = compare1;
            this._defaultCompare2 = defaultCompare2;
            this._compare2 = compare2;
            this._defaultCompare3 = defaultCompare3;
            this._compare3 = compare3;
            this._defaultCompare4 = defaultCompare4;
            this._compare4 = compare4;

            this._subdivisionOverride1 = subdivisionOverride1;
            this._subdivisionOverride2 = subdivisionOverride2;
            this._subdivisionOverride3 = subdivisionOverride3;
            this._subdivisionOverride4 = subdivisionOverride4;

            this._top = new Node(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>.None, null, -1);
            Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
        }

        private OmnitreeBoundsLinked(
            Omnitree.GetBounds<T, Axis1, Axis2, Axis3, Axis4> getBounds,
            Equate<T> equate,

            Equate<Axis1> equateAxis1,
            Equate<Axis2> equateAxis2,
            Equate<Axis3> equateAxis3,
            Equate<Axis4> equateAxis4,

            Compare<Axis1> compare1,
            Compare<Axis2> compare2,
            Compare<Axis3> compare3,
            Compare<Axis4> compare4,

            Omnitree.SubdivisionOverride<T, Axis1, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>> subdivisionOverride1,
            Omnitree.SubdivisionOverride<T, Axis2, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>> subdivisionOverride2,
            Omnitree.SubdivisionOverride<T, Axis3, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>> subdivisionOverride3,
            Omnitree.SubdivisionOverride<T, Axis4, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>> subdivisionOverride4)
            : this(
            getBounds,

            false,
            equate,

            false,
            equateAxis1,
            false,
            equateAxis2,
            false,
            equateAxis3,
            false,
            equateAxis4,

            false,
            compare1,
            false,
            compare2,
            false,
            compare3,
            false,
            compare4,

            subdivisionOverride1,
            subdivisionOverride2,
            subdivisionOverride3,
            subdivisionOverride4)
        { }

        public OmnitreeBoundsLinked(
            Omnitree.GetBounds<T, Axis1, Axis2, Axis3, Axis4> getBounds,

            Equate<T> equate,

            Equate<Axis1> equateAxis1,
            Equate<Axis2> equateAxis2,
            Equate<Axis3> equateAxis3,
            Equate<Axis4> equateAxis4,

            Compare<Axis1> compare1,
            Compare<Axis2> compare2,
            Compare<Axis3> compare3,
            Compare<Axis4> compare4)
            : this(
                getBounds,

                false,
                equate,

                false,
                equateAxis1,
                false,
                equateAxis2,
                false,
                equateAxis3,
                false,
                equateAxis4,

                false,
                compare1,
                false,
                compare2,
                false,
                compare3,
                false,
                compare4,

                null,
                null,
                null,
                null)
        { }



        public OmnitreeBoundsLinked(
            Omnitree.GetBounds<T, Axis1, Axis2, Axis3, Axis4> getBounds,

            Equate<T> equate,

            Compare<Axis1> compare1,
            Compare<Axis2> compare2,
            Compare<Axis3> compare3,
            Compare<Axis4> compare4)
            : this(
                getBounds,
                false,
                equate,

                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,

                false,
                compare1,
                false,
                compare2,
                false,
                compare3,
                false,
                compare4,

                null,
                null,
                null,
                null)
        { }

        public OmnitreeBoundsLinked(
            Omnitree.GetBounds<T, Axis1, Axis2, Axis3, Axis4> getBounds,
            Equate<T> equate,

            Compare<Axis1> compare1,
            Compare<Axis2> compare2,
            Compare<Axis3> compare3,
            Compare<Axis4> compare4,

            Omnitree.SubdivisionOverride<T, Axis1, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>> subdivisionOverride1,
            Omnitree.SubdivisionOverride<T, Axis2, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>> subdivisionOverride2,
            Omnitree.SubdivisionOverride<T, Axis3, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>> subdivisionOverride3,
            Omnitree.SubdivisionOverride<T, Axis4, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>> subdivisionOverride4)
            : this(
                getBounds,

                false,
                equate,

                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,

                false,
                compare1,
                false,
                compare2,
                false,
                compare3,
                false,
                compare4,

                subdivisionOverride1,
                subdivisionOverride2,
                subdivisionOverride3,
                subdivisionOverride4)
        { }

        public OmnitreeBoundsLinked(
            Omnitree.GetBounds<T, Axis1, Axis2, Axis3, Axis4> getBounds,

            Compare<Axis1> compare1,
            Compare<Axis2> compare2,
            Compare<Axis3> compare3,
            Compare<Axis4> compare4)
            : this(
                getBounds,
                true,
                Towel.Equate.Default,

                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,

                false,
                compare1,
                false,
                compare2,
                false,
                compare3,
                false,
                compare4,

                null,
                null,
                null,
                null)
        { }

        public OmnitreeBoundsLinked(
            Omnitree.GetBounds<T, Axis1, Axis2, Axis3, Axis4> getBounds,

            Compare<Axis1> compare1,
            Compare<Axis2> compare2,
            Compare<Axis3> compare3,
            Compare<Axis4> compare4,

            Omnitree.SubdivisionOverride<T, Axis1, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>> subdivisionOverride1,
            Omnitree.SubdivisionOverride<T, Axis2, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>> subdivisionOverride2,
            Omnitree.SubdivisionOverride<T, Axis3, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>> subdivisionOverride3,
            Omnitree.SubdivisionOverride<T, Axis4, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>> subdivisionOverride4)
            : this(
                getBounds,

                true,
                Towel.Equate.Default,

                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,

                false,
                compare1,
                false,
                compare2,
                false,
                compare3,
                false,
                compare4,

                subdivisionOverride1,
                subdivisionOverride2,
                subdivisionOverride3,
                subdivisionOverride4)
        { }

        public OmnitreeBoundsLinked(
            Omnitree.GetBounds<T, Axis1, Axis2, Axis3, Axis4> getBounds,
            Equate<T> equate)
            : this(
                getBounds,

                false,
                equate,

                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,

                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,

                null,
                null,
                null,
                null)
        { }

        public OmnitreeBoundsLinked(
            Omnitree.GetBounds<T, Axis1, Axis2, Axis3, Axis4> getBounds,
            Equate<T> equate,
            Omnitree.SubdivisionOverride<T, Axis1, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>> subdivisionOverride1,
            Omnitree.SubdivisionOverride<T, Axis2, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>> subdivisionOverride2,
            Omnitree.SubdivisionOverride<T, Axis3, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>> subdivisionOverride3,
            Omnitree.SubdivisionOverride<T, Axis4, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>> subdivisionOverride4)
            : this(
                getBounds,

                false,
                equate,

                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,

                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,

                subdivisionOverride1,
                subdivisionOverride2,
                subdivisionOverride3,
                subdivisionOverride4)
        { }

        public OmnitreeBoundsLinked(
            Omnitree.GetBounds<T, Axis1, Axis2, Axis3, Axis4> getBounds)
            : this(
                getBounds,

                true,
                Towel.Equate.Default,

                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,

                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,

                null,
                null,
                null,
                null)
        { }

		public OmnitreeBoundsLinked(
            Omnitree.GetBoundings<T, Axis1, Axis2, Axis3, Axis4> getBoundings)
            : this(
                Omnitree.ConvertToGetBounds(getBoundings),

                true,
                Towel.Equate.Default,

                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,

                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,

                null,
                null,
                null,
                null)
        { }

        public OmnitreeBoundsLinked(
            Omnitree.GetBounds<T, Axis1, Axis2, Axis3, Axis4> getBounds,
            Omnitree.SubdivisionOverride<T, Axis1, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>> subdivisionOverride1,
            Omnitree.SubdivisionOverride<T, Axis2, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>> subdivisionOverride2,
            Omnitree.SubdivisionOverride<T, Axis3, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>> subdivisionOverride3,
            Omnitree.SubdivisionOverride<T, Axis4, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>> subdivisionOverride4)
            : this(
                getBounds,

                true,
                Towel.Equate.Default,

                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,

                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,

                subdivisionOverride1,
                subdivisionOverride2,
                subdivisionOverride3,
                subdivisionOverride4)
        { }

        #endregion

        #region Properties

        /// <summary>The number of dimensions in this tree.</summary>
        public int Dimensions { get { return _dimensions; } }

        /// <summary>The function for equating keys in this table.</summary>
        public Equate<T> Equate { get { return this._equate; } }

        /// <summary>The location function the Omnitree is using.</summary>
        public Omnitree.GetBounds<T, Axis1, Axis2, Axis3, Axis4> GetBounds { get { return this._getBounds; } }

        /// <summary>The comparison function the Omnitree is using along the 1D axis.</summary>
        public Compare<Axis1> Compare1 { get { return this._compare1; } }
        /// <summary>The comparison function the Omnitree is using along the 2D axis.</summary>
        public Compare<Axis2> Compare2 { get { return this._compare2; } }
        /// <summary>The comparison function the Omnitree is using along the 3D axis.</summary>
        public Compare<Axis3> Compare3 { get { return this._compare3; } }
        /// <summary>The comparison function the Omnitree is using along the 4D axis.</summary>
        public Compare<Axis4> Compare4 { get { return this._compare4; } }

        /// <summary>The function for equating values along the 1D axis.</summary>
        public Equate<Axis1> EquateAxis1 { get { return this._equate1; } }
        /// <summary>The function for equating values along the 2D axis.</summary>
        public Equate<Axis2> EquateAxis2 { get { return this._equate2; } }
        /// <summary>The function for equating values along the 3D axis.</summary>
        public Equate<Axis3> EquateAxis3 { get { return this._equate3; } }
        /// <summary>The function for equating values along the 4D axis.</summary>
        public Equate<Axis4> EquateAxis4 { get { return this._equate4; } }

        /// <summary>The current number of items in the tree.</summary>
        public int Count { get { return this._top.Count; } }

        private delegate void MaxDepthFinder(Node node, int current_depth, ref int max_depth);
        /// <summary>Finds the current maximum depth of the tree. NOT AN O(1) OPERATION. Intended for educational purposes only.</summary>
        public int MaxDepth
        {
            get
            {
                MaxDepthFinder maxDepthFinder = null;
                maxDepthFinder =
                        (Node node, int current_depth, ref int max_depth) =>
                        {
                            if (current_depth > max_depth)
                                max_depth = current_depth;
                            foreach (Node child in node.Children)
                                maxDepthFinder(child, current_depth + 1, ref max_depth);
                        };
                int _max_depth = -1;
                maxDepthFinder(this._top, 0, ref _max_depth);
                return _max_depth;
            }
        }

        private delegate void NodeCountFinder(Node node, ref int current_count);
        /// <summary>Counts the current number of nodes in the tree. NOT AN O(1) OPERATION. Intended for educational purposes only.</summary>
        public int NodeCount
        {
            get
            {
                NodeCountFinder nodeCountFinder = null;
                nodeCountFinder =
                        (Node node, ref int current_count) =>
                        {
                            current_count++;
                            foreach (Node child in node.Children)
                                nodeCountFinder(child, ref current_count);
                        };

                int _current_count = 0;
                nodeCountFinder(this._top, ref _current_count);
                return _current_count;
            }
        }

        #endregion

        #region Methods

        #region Add

        #region Bulk

		// not yet implemented

//        public void Add(IndexedBigArray<T> additions, bool allowMultithreading)
//        {
//            if (additions.Length > int.MaxValue)
//                throw new System.Exception("The maximum size of the Omnitree was exceeded during bulk addition.");
//
//            if (this._top.Count != 0 || (int)additions.Length <= _load)
//            {
//                for (ulong i = 0; i < additions.Length; i++)
//                    this.Add(additions[i]);
//            }
//            else
//            {
//                // adjust the loads prior to additions
//                ComputeLoads((int)additions.Length);
//
//                Node new_top = new Node(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>.None, null, -1);
//                new_top.Count = (int)additions.Length;
//
//
//                // prepare data for median computations
//                IndexedBigArray<Axis1> values1;
//                IAsyncResult result1 = null;
//                if (this._subdivisionOverride1 != null)
//                    values1 = null;
//                else
//                {
//                    values1 = null;
//                    Towel.Parallels.Parallel.Operation operation = () =>
//                    {
//                        values1 = new IndexedBigArray<Axis1>(additions.Length * 2);
//                        for (ulong i = 0; i < additions.Length; i++)
//						{
//							Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4> bounds = GetBoundings(additions[i]);
//                            values1[i * 2] = bounds.Min1;
//							values1[i * 2 + 1] = bounds.Max1;
//						}
//
//                        Towel.Algorithms.Sort.Merge(this._compare1, (int i) => { return values1[(ulong)i]; }, (int i, Axis1 value) => { values1[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
//                    };
//
//                    if (allowMultithreading)
//                        result1 = Towel.Parallels.Parallel.Thread(operation);
//                    else
//                        operation();
//                }
//
//                // prepare data for median computations
//                IndexedBigArray<Axis2> values2;
//                IAsyncResult result2 = null;
//                if (this._subdivisionOverride2 != null)
//                    values2 = null;
//                else
//                {
//                    values2 = null;
//                    Towel.Parallels.Parallel.Operation operation = () =>
//                    {
//                        values2 = new IndexedBigArray<Axis2>(additions.Length * 2);
//                        for (ulong i = 0; i < additions.Length; i++)
//						{
//							Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4> bounds = GetBoundings(additions[i]);
//                            values2[i * 2] = bounds.Min1;
//							values2[i * 2 + 1] = bounds.Max1;
//						}
//
//                        Towel.Algorithms.Sort.Merge(this._compare2, (int i) => { return values2[(ulong)i]; }, (int i, Axis2 value) => { values2[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
//                    };
//
//                    if (allowMultithreading)
//                        result2 = Towel.Parallels.Parallel.Thread(operation);
//                    else
//                        operation();
//                }
//
//                // prepare data for median computations
//                IndexedBigArray<Axis3> values3;
//                IAsyncResult result3 = null;
//                if (this._subdivisionOverride3 != null)
//                    values3 = null;
//                else
//                {
//                    values3 = null;
//                    Towel.Parallels.Parallel.Operation operation = () =>
//                    {
//                        values3 = new IndexedBigArray<Axis3>(additions.Length * 2);
//                        for (ulong i = 0; i < additions.Length; i++)
//						{
//							Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4> bounds = GetBoundings(additions[i]);
//                            values3[i * 2] = bounds.Min1;
//							values3[i * 2 + 1] = bounds.Max1;
//						}
//
//                        Towel.Algorithms.Sort.Merge(this._compare3, (int i) => { return values3[(ulong)i]; }, (int i, Axis3 value) => { values3[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
//                    };
//
//                    if (allowMultithreading)
//                        result3 = Towel.Parallels.Parallel.Thread(operation);
//                    else
//                        operation();
//                }
//
//                // prepare data for median computations
//                IndexedBigArray<Axis4> values4;
//                IAsyncResult result4 = null;
//                if (this._subdivisionOverride4 != null)
//                    values4 = null;
//                else
//                {
//                    values4 = null;
//                    Towel.Parallels.Parallel.Operation operation = () =>
//                    {
//                        values4 = new IndexedBigArray<Axis4>(additions.Length * 2);
//                        for (ulong i = 0; i < additions.Length; i++)
//						{
//							Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4> bounds = GetBoundings(additions[i]);
//                            values4[i * 2] = bounds.Min1;
//							values4[i * 2 + 1] = bounds.Max1;
//						}
//
//                        Towel.Algorithms.Sort.Merge(this._compare4, (int i) => { return values4[(ulong)i]; }, (int i, Axis4 value) => { values4[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
//                    };
//
//                    if (allowMultithreading)
//                        result4 = Towel.Parallels.Parallel.Thread(operation);
//                    else
//                        operation();
//                }
//
//
//
//                if (this._subdivisionOverride1 == null && allowMultithreading)
//                    result1.AsyncWaitHandle.WaitOne();
//                if (this._subdivisionOverride2 == null && allowMultithreading)
//                    result2.AsyncWaitHandle.WaitOne();
//                if (this._subdivisionOverride3 == null && allowMultithreading)
//                    result3.AsyncWaitHandle.WaitOne();
//                if (this._subdivisionOverride4 == null && allowMultithreading)
//                    result4.AsyncWaitHandle.WaitOne();
//
//                // build the tree
//                Add(new_top, 1, -1, additions.Stepper(), (int)additions.Length, int.MinValue, int.MinValue, int.MinValue, int.MinValue, (int)additions.Length, (int index) => { return values1[index]; }, (int index) => { return values2[index]; }, (int index) => { return values3[index]; }, (int index) => { return values4[index]; }, allowMultithreading);
//                
//                this._top = new_top;
//            }
//        }
//
//        public void Add(bool allowMultithreading, params T[] additions)
//        {
//            if (additions.Length > int.MaxValue)
//                throw new System.Exception("The maximum size of the Omnitree was exceeded during bulk addition.");
//
//            if (this._top.Count != 0 || (int)additions.Length <= _load)
//            {
//                for (int i = 0; i < additions.Length; i++)
//                    this.Add(additions[i]);
//            }
//            else
//            {
//                // adjust the loads prior to additions
//                ComputeLoads((int)additions.Length);
//
//                Node new_top = new Node(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>.None, null, -1);
//                new_top.Count = (int)additions.Length;
//
//
//                // prepare data for median computations
//                IndexedBigArray<Axis1> values1;
//                IAsyncResult result1 = null;
//                if (this._subdivisionOverride1 != null)
//                    values1 = null;
//                else
//                {
//                    values1 = null;
//                    Towel.Parallels.Parallel.Operation operation = () =>
//                    {
//                        values1 = new IndexedBigArray<Axis1>(additions.Length);
//                        for (int i = 0; i < additions.Length; i++)
//                            values1[i] = LocateVector(additions[i]).Axis1;
//                        Towel.Algorithms.Sort.Merge(this._compare1, (int i) => { return values1[(ulong)i]; }, (int i, Axis1 value) => { values1[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
//                    };
//
//                    if (allowMultithreading)
//                        result1 = Towel.Parallels.Parallel.Thread(operation);
//                    else
//                        operation();
//                }
//
//                // prepare data for median computations
//                IndexedBigArray<Axis2> values2;
//                IAsyncResult result2 = null;
//                if (this._subdivisionOverride2 != null)
//                    values2 = null;
//                else
//                {
//                    values2 = null;
//                    Towel.Parallels.Parallel.Operation operation = () =>
//                    {
//                        values2 = new IndexedBigArray<Axis2>(additions.Length);
//                        for (int i = 0; i < additions.Length; i++)
//                            values2[i] = LocateVector(additions[i]).Axis2;
//                        Towel.Algorithms.Sort.Merge(this._compare2, (int i) => { return values2[(ulong)i]; }, (int i, Axis2 value) => { values2[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
//                    };
//
//                    if (allowMultithreading)
//                        result2 = Towel.Parallels.Parallel.Thread(operation);
//                    else
//                        operation();
//                }
//
//                // prepare data for median computations
//                IndexedBigArray<Axis3> values3;
//                IAsyncResult result3 = null;
//                if (this._subdivisionOverride3 != null)
//                    values3 = null;
//                else
//                {
//                    values3 = null;
//                    Towel.Parallels.Parallel.Operation operation = () =>
//                    {
//                        values3 = new IndexedBigArray<Axis3>(additions.Length);
//                        for (int i = 0; i < additions.Length; i++)
//                            values3[i] = LocateVector(additions[i]).Axis3;
//                        Towel.Algorithms.Sort.Merge(this._compare3, (int i) => { return values3[(ulong)i]; }, (int i, Axis3 value) => { values3[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
//                    };
//
//                    if (allowMultithreading)
//                        result3 = Towel.Parallels.Parallel.Thread(operation);
//                    else
//                        operation();
//                }
//
//                // prepare data for median computations
//                IndexedBigArray<Axis4> values4;
//                IAsyncResult result4 = null;
//                if (this._subdivisionOverride4 != null)
//                    values4 = null;
//                else
//                {
//                    values4 = null;
//                    Towel.Parallels.Parallel.Operation operation = () =>
//                    {
//                        values4 = new IndexedBigArray<Axis4>(additions.Length);
//                        for (int i = 0; i < additions.Length; i++)
//                            values4[i] = LocateVector(additions[i]).Axis4;
//                        Towel.Algorithms.Sort.Merge(this._compare4, (int i) => { return values4[(ulong)i]; }, (int i, Axis4 value) => { values4[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
//                    };
//
//                    if (allowMultithreading)
//                        result4 = Towel.Parallels.Parallel.Thread(operation);
//                    else
//                        operation();
//                }
//
//
//
//                if (this._subdivisionOverride1 == null && allowMultithreading)
//                    result1.AsyncWaitHandle.WaitOne();
//
//                if (this._subdivisionOverride2 == null && allowMultithreading)
//                    result2.AsyncWaitHandle.WaitOne();
//
//                if (this._subdivisionOverride3 == null && allowMultithreading)
//                    result3.AsyncWaitHandle.WaitOne();
//
//                if (this._subdivisionOverride4 == null && allowMultithreading)
//                    result4.AsyncWaitHandle.WaitOne();
//
//
//                // build the tree
//                Add(new_top, 1, -1, additions.Stepper(), additions.Length, int.MinValue, int.MinValue, int.MinValue, int.MinValue, (int)additions.Length, (int index) => { return values1[index]; }, (int index) => { return values2[index]; }, (int index) => { return values3[index]; }, (int index) => { return values4[index]; }, allowMultithreading);
//                
//                this._top = new_top;
//            }
//        }
//
//        
//        private int Add(Node parent, int depth, int child, Stepper<T> additions, int parent_count, int prevmed1, int prevmed2, int prevmed3, int prevmed4, int initial_count, Get<Axis1> values1, Get<Axis2> values2, Get<Axis3> values3, Get<Axis4> values4, bool allowMultithreading)
//        {
//            Axis1 pointOfDivision1;
//            Axis2 pointOfDivision2;
//            Axis3 pointOfDivision3;
//            Axis4 pointOfDivision4;
//
//            int median_axis1 = -1;
//            int median_axis2 = -1;
//            int median_axis3 = -1;
//            int median_axis4 = -1;
//            if (this._subdivisionOverride1 == null || this._subdivisionOverride2 == null || this._subdivisionOverride3 == null || this._subdivisionOverride4 == null)
//                GetMedianIndexes(initial_count, child, depth, prevmed1, prevmed2, prevmed3, prevmed4, out median_axis1, out median_axis2, out median_axis3, out median_axis4);
//
//            if (this._subdivisionOverride1 != null)
//                pointOfDivision1 = this._subdivisionOverride1(parent.Bounds, additions);
//            else
//                pointOfDivision1 = values1(median_axis1);
//
//            if (this._subdivisionOverride2 != null)
//                pointOfDivision2 = this._subdivisionOverride2(parent.Bounds, additions);
//            else
//                pointOfDivision2 = values2(median_axis2);
//
//            if (this._subdivisionOverride3 != null)
//                pointOfDivision3 = this._subdivisionOverride3(parent.Bounds, additions);
//            else
//                pointOfDivision3 = values3(median_axis3);
//
//            if (this._subdivisionOverride4 != null)
//                pointOfDivision4 = this._subdivisionOverride4(parent.Bounds, additions);
//            else
//                pointOfDivision4 = values4(median_axis4);
//
//            parent.PointOfDivision = new Omnitree.Vector<Axis1, Axis2, Axis3, Axis4>(pointOfDivision1, pointOfDivision2, pointOfDivision3, pointOfDivision4);
//
//            // divide the values along the medians
//            IMap<IAddable<T>, int> collection_map = new MapHashLinked<IAddable<T>, int>();
//            additions((T value) => 
//            {
//                int index = DetermineChildIndex(parent.PointOfDivision.Value, LocateVector(value));
//                IAddable<T> list = null;
//                if (collection_map.TryGet(index, out list))
//                {
//                    list.Add(value);
//                }
//                else
//                {
//                    if (parent_count < 100000)
//                        list = new AddableArray<T>();
//                    else
//                        list = new AddableLinked<T>();
//                    collection_map.Add(index, list);
//                    list.Add(value);
//                }
//            });
//
//            if (depth == 1 && allowMultithreading)
//            {
//                // NOTE: Must assign placeholders before multithreading so that the threads do not overwrite each other
//                collection_map.Keys((int key) => { parent[key] = new Node(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>.None, parent, key); });
//                IAsyncResult[] handles = new IAsyncResult[Environment.ProcessorCount];
//                for (int i = 0; i < handles.Length; i++)
//                {
//                    int multiTheadSafe_i = i; // used as catpure variable below making it multithread-safe
//                    handles[i] = Towel.Parallels.Parallel.Thread(() =>
//                    {
//                        Step.EveryNth<Link<IAddable<T>, int>>(collection_map.Pairs, multiTheadSafe_i + 1)(
//                        (Link<IAddable<T>, int> link) =>
//                            {
//                                ReversedChildBuilding(parent, link._2, depth, link._1.Stepper, link._1.Count, median_axis1, median_axis2, median_axis3, median_axis4, initial_count, values1, values2, values3, values4, allowMultithreading);
//                            });
//                    });
//                }
//                
//                foreach (IAsyncResult handle in handles)
//                {
//                    handle.AsyncWaitHandle.WaitOne();
//                }
//            }
//            else
//            {
//                collection_map.Pairs((Link<IAddable<T>, int> link) =>
//                { 
//                    ReversedChildBuilding(parent, link._2, depth, link._1.Stepper, link._1.Count, median_axis1, median_axis2, median_axis3, median_axis4, initial_count, values1, values2, values3, values4, allowMultithreading);
//                });
//            }
//
//            int count = 0;
//            foreach (Node node in parent.Children)
//                count += node.Count;
//            return count;
//        }
//
//        int ReversedChildBuilding(Node parent, int child_index, int depth, Stepper<T> additions, int count, int prevmed1, int prevmed2, int prevmed3, int prevmed4, int initial_count, Get<Axis1> values1, Get<Axis2> values2, Get<Axis3> values3, Get<Axis4> values4, bool allowMultithreading)
//        {
//            Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4> child_bounds = DetermineChildBounds(parent, child_index);
//            if (depth >= _load || count <= _load)
//            {
//                Node new_leaf = new Node(child_bounds, parent, child_index);
//                additions((T value) => { new_leaf.Add(value); });
//                parent[new_leaf.Index] = new_leaf;
//                return new_leaf.Count;
//            }
//            else
//            {
//                Node new_branch = new Node(Omnitree.Vector<Axis1, Axis2, Axis3, Axis4>.Default, child_bounds, parent, child_index);
//                parent[new_branch.Index] = new_branch;
//                new_branch.Count = Add(new_branch, depth + 1, child_index, additions, count, prevmed1, prevmed2, prevmed3, prevmed4, count, values1, values2, values3, values4, allowMultithreading);
//                return new_branch.Count;
//            }
//        }
//
//        /// <summary>Gets the indeces of the median values at the given position during bulk additions.</summary>
//        private void GetMedianIndexes(int count, int child_index, int depth, int previous1, int previous2, int previous3, int previous4, out int index1, out int index2, out int index3, out int index4)
//        {
//            if (depth == 1)
//            {
//                index1 = (count - 1) / 2;
//                index2 = (count - 1) / 2;
//                index3 = (count - 1) / 2;
//                index4 = (count - 1) / 2;
//                return;
//            }
//
//            int splits = Compute.Power(2, depth);
//            int mid_child_range = count / splits;
//
//            if (child_index >= 8)
//            {
//                index4 = previous4 + mid_child_range;
//                child_index -= 8;
//            }
//            else
//            {
//                index4 = previous4 - mid_child_range;
//            }
//
//            if (child_index >= 4)
//            {
//                index3 = previous3 + mid_child_range;
//                child_index -= 4;
//            }
//            else
//            {
//                index3 = previous3 - mid_child_range;
//            }
//
//            if (child_index >= 2)
//            {
//                index2 = previous2 + mid_child_range;
//                child_index -= 2;
//            }
//            else
//            {
//                index2 = previous2 - mid_child_range;
//            }
//
//            if (child_index >= 1)
//            {
//                index1 = previous1 + mid_child_range;
//                child_index -= 1;
//            }
//            else
//            {
//                index1 = previous1 - mid_child_range;
//            }
//
//        }

		

        #endregion

        #region single

        /// <summary>Adds an item to the tree.</summary>
        /// <param name="addition">The item to be added.</param>
        public void Add(T addition)
        {
            if (this._top.Count == int.MaxValue)
                throw new System.InvalidOperationException("(Count == int.MaxValue) max Omnitree size reached (change ints to longs if you need to).");

            // dynamic tree sizes
            Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);

            Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4> bounds = GetBoundings(addition);

            // grow the first branch of the tree
            if (!this._top.PointOfDivision.HasValue && this._top.Count >= _load)
            {
                Node top = this._top;

                // create the new branch from the median values
                this._top = new Node(DetermineMedians(top), Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>.None, null, -1);

                // iterate through the elements and add them to the appropriate children
                for (Node.ValueNode list = top.Head; list != null; list = list.Next)
                    Add(list.Value, this._top, GetBoundings(list.Value), 0);
            }

            this.Add(addition, this._top, bounds, 0);
        }
        
        /// <summary>Recursive version of the add function.</summary>
        /// <param name="addition">The item to be added.</param>
        /// <param name="node">The current node for tree trversal.</param>
        /// <param name="ms">The location of the addition.</param>
        /// <param name="depth">The current depth of iteration.</param>
        private void Add(T addition, Node node, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4> bounds, int depth)
        {
            if (!node.PointOfDivision.HasValue)
            {
                //Leaf leaf = node as Leaf;
                if (depth >= _load || !(node.Count >= _load))
                {
                    node.Add(addition);
                    return;
                }
                else
                {
                    //Node parent = node.Parent;
                    //int child_index = this.DetermineChildIndex(parent.PointOfDivision, location);
                    //Node growth = new Node(DetermineMedians(leaf), leaf.Bounds, parent, child_index);
                    //parent[child_index] = growth;

					Node growth = new Node(DetermineMedians(node), node.Bounds, node.Parent, node.Index);
                    node.Parent[node.Index] = growth;

                    for (Node.ValueNode list = node.Head; list != null; list = list.Next)
                    {
                        Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4> temp_bounds = GetBoundings(list.Value);
                        if (EncapsulationCheck(growth.Bounds, temp_bounds))
                            Add(list.Value, growth, temp_bounds, depth);
                        else
                        {
                            ReduceParentCounts(node.Parent, 1);
                            Add(list.Value, this._top, temp_bounds, depth);
                        }
                    }

                    Add(addition, growth, bounds, depth);
                    return;
                }
            }
            else
            {
                //Node branch = node as Node;
                int child_index = this.DetermineChildIndex(node.PointOfDivision.Value, bounds); // determine the child "index" (0 through 2^Dimensions) the addition belongs in
                
				// if -1, then the bounds of the addition straddle the point of division (keep it in current node)
				if (child_index == -1)
				{
					node.Add(addition);
                    return;
				}
				
				Node child_node = node[child_index];

                // null children in branches are just empty leaves
                if (child_node == null)
                {
                    Node new_node = new Node(DetermineChildBounds(node, child_index), node, child_index);
                    node[child_index] = new_node;
                    new_node.Add(addition);
                }
                else
                    // child exists already, continue adding
                    Add(addition, child_node, bounds, depth + 1);

                node.Count++;
                return;
            }
        }

        /// <summary>Determins the dimensions of the child at the given index.</summary>
        /// <param name="leaf">The parent of the node to compute dimensions for.</param>
        /// <param name="child">The index of the child to compute dimensions for.</param>
        /// <param name="median1">The computed minimum dimensions of the child node along the 1D axis.</param>
        /// <param name="median2">The computed minimum dimensions of the child node along the 2D axis.</param>
        /// <param name="median3">The computed minimum dimensions of the child node along the 3D axis.</param>
        private Omnitree.Vector<Axis1, Axis2, Axis3, Axis4> DetermineMedians(Node node)
        {
            try
            {
                // extract the values
                Omnitree.Bound<Axis1>[] values1 = new Omnitree.Bound<Axis1>[node.Count * 2];
                Omnitree.Bound<Axis2>[] values2 = new Omnitree.Bound<Axis2>[node.Count * 2];
                Omnitree.Bound<Axis3>[] values3 = new Omnitree.Bound<Axis3>[node.Count * 2];
                Omnitree.Bound<Axis4>[] values4 = new Omnitree.Bound<Axis4>[node.Count * 2];
                Node.ValueNode for_current = node.Head; // used in for loop
                for (int i = 0; i < node.Count; i++, for_current = for_current.Next)
                    this._getBounds(for_current.Value, 
					out values1[i * 2], out values1[i * 2 + 1], 
					out values2[i * 2], out values2[i * 2 + 1], 
					out values3[i * 2], out values3[i * 2 + 1], 
					out values4[i * 2], out values4[i * 2 + 1]);
                return new Omnitree.Vector<Axis1, Axis2, Axis3, Axis4>(
					Omnitree.SubDivide(values1, this._defaultCompare1 ? Compare.Default : this._compare1), 
					Omnitree.SubDivide(values2, this._defaultCompare2 ? Compare.Default : this._compare2), 
					Omnitree.SubDivide(values3, this._defaultCompare3 ? Compare.Default : this._compare3), 
					Omnitree.SubDivide(values4, this._defaultCompare4 ? Compare.Default : this._compare4));
            }
            catch
            {
                // extract the values
                IndexedBigArray<Omnitree.Bound<Axis1>> values1 = new IndexedBigArray<Omnitree.Bound<Axis1>>(node.Count * 2);
                IndexedBigArray<Omnitree.Bound<Axis2>> values2 = new IndexedBigArray<Omnitree.Bound<Axis2>>(node.Count * 2);
                IndexedBigArray<Omnitree.Bound<Axis3>> values3 = new IndexedBigArray<Omnitree.Bound<Axis3>>(node.Count * 2);
                IndexedBigArray<Omnitree.Bound<Axis4>> values4 = new IndexedBigArray<Omnitree.Bound<Axis4>>(node.Count * 2);
                Node.ValueNode for_current = node.Head; // used in for loop
                for (int i = 0; i < node.Count; i++, for_current = for_current.Next)
                {
                    Omnitree.Bound<Axis1> min1; Omnitree.Bound<Axis1> max1;
                    Omnitree.Bound<Axis2> min2; Omnitree.Bound<Axis2> max2;
                    Omnitree.Bound<Axis3> min3; Omnitree.Bound<Axis3> max3;
                    Omnitree.Bound<Axis4> min4; Omnitree.Bound<Axis4> max4;
                    this._getBounds(for_current.Value,
						out min1, out max1,
						out min2, out max2,
						out min3, out max3,
						out min4, out max4);
                    values1[i * 2] = min1; values1[i * 2 + 1] = max1;
                    values2[i * 2] = min2; values2[i * 2 + 1] = max2;
                    values3[i * 2] = min3; values3[i * 2 + 1] = max3;
                    values4[i * 2] = min4; values4[i * 2 + 1] = max4;
                }
				return new Omnitree.Vector<Axis1, Axis2, Axis3, Axis4>(
					Omnitree.SubDivide(values1, this._defaultCompare1 ? Compare.Default : this._compare1), 
					Omnitree.SubDivide(values2, this._defaultCompare2 ? Compare.Default : this._compare2), 
					Omnitree.SubDivide(values3, this._defaultCompare3 ? Compare.Default : this._compare3), 
					Omnitree.SubDivide(values4, this._defaultCompare4 ? Compare.Default : this._compare4));
            }
        }

        #endregion

        #region Add Helpers

        private Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4> DetermineChildBounds(Node node, int child_index)
        {
			// the node parameter should always have a point of division value for this function
			Omnitree.Vector<Axis1, Axis2, Axis3, Axis4> pointOfDivision = node.PointOfDivision.Value;

            Omnitree.Bound<Axis4> min4, max4;
            if (child_index >= 8)
            {
                min4 = pointOfDivision.Axis4;
                max4 = node.Bounds.Max4;
                child_index -= 8;
            }
            else
            {
                min4 = node.Bounds.Min4;
                max4 = pointOfDivision.Axis4;
            }

            Omnitree.Bound<Axis3> min3, max3;
            if (child_index >= 4)
            {
                min3 = pointOfDivision.Axis3;
                max3 = node.Bounds.Max3;
                child_index -= 4;
            }
            else
            {
                min3 = node.Bounds.Min3;
                max3 = pointOfDivision.Axis3;
            }

            Omnitree.Bound<Axis2> min2, max2;
            if (child_index >= 2)
            {
                min2 = pointOfDivision.Axis2;
                max2 = node.Bounds.Max2;
                child_index -= 2;
            }
            else
            {
                min2 = node.Bounds.Min2;
                max2 = pointOfDivision.Axis2;
            }

            Omnitree.Bound<Axis1> min1, max1;
            if (child_index >= 1)
            {
                min1 = pointOfDivision.Axis1;
                max1 = node.Bounds.Max1;
                child_index -= 1;
            }
            else
            {
                min1 = node.Bounds.Min1;
                max1 = pointOfDivision.Axis1;
            }

            return new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>(min1, max1, min2, max2, min3, max3, min4, max4);
        }

        #endregion

        #endregion

        #region Clear

        /// <summary>Returns the tree to an empty state.</summary>
        public void Clear()
        {
            this._top = new Node(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>.None, null, -1);
            Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
        }

        #endregion

        #region Clone

        /// <summary>Creates a shallow clone of this data structure.</summary>
        /// <returns>A shallow clone of this data structure.</returns>
        public OmnitreeBoundsLinked<T, Axis1, Axis2, Axis3, Axis4> Clone()
        {
            return new OmnitreeBoundsLinked<T, Axis1, Axis2, Axis3, Axis4>(this);
        }

        #endregion

        #region Count

        /// <summary>Counts the number of items encapsulated by a sub space.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
        /// <returns>The number of items in the provided sub space.</returns>
        public int CountSubSpaceEncapsulated(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4)
        {
            return CountSubSpaceEncapsulated(_top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>(min1, max1, min2, max2, min3, max3, min4, max4));
        }
        /// <summary>Counts the number of items encapsulated by a sub space.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
        /// <returns>The number of items in the provided sub space.</returns>
        public int CountSubSpaceEncapsulated(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4)
        {
            return CountSubSpaceEncapsulated(_top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>(min1, max1, min2, max2, min3, max3, min4, max4));
        }
        /// <summary>Counts the number of items encapsulated by a sub space.</summary>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
        /// <returns>The number of items in the provided sub space.</returns>
        public int CountSubSpaceEncapsulated(Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4)
        {
            return CountSubSpaceEncapsulated(_top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>(axis1, axis1, axis2, axis2, axis3, axis3, axis4, axis4));
        }
        /// <summary>Counts the number of items encapsulated by a sub space.</summary>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
        /// <returns>The number of items in the provided sub space.</returns>
        public int CountSubSpaceEncapsulated(Omnitree.Bound<Axis1> axis1, Omnitree.Bound<Axis2> axis2, Omnitree.Bound<Axis3> axis3, Omnitree.Bound<Axis4> axis4)
        {
            return CountSubSpaceEncapsulated(_top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>(axis1, axis1, axis2, axis2, axis3, axis3, axis4, axis4));
        }

        /// <summary>Counts the number of items overlapped by a sub space.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
        /// <returns>The number of items in the provided sub space.</returns>
        public int CountSubSpaceOverlapped(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4)
        {
            return CountSubSpaceOverlapped(_top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>(min1, max1, min2, max2, min3, max3, min4, max4));
        }
        /// <summary>Counts the number of items overlapped by a sub space.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
        /// <returns>The number of items in the provided sub space.</returns>
        public int CountSubSpaceOverlapped(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4)
        {
            return CountSubSpaceOverlapped(_top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>(min1, max1, min2, max2, min3, max3, min4, max4));
        }
        /// <summary>Counts the number of items overlapped by a sub space.</summary>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
        /// <returns>The number of items in the provided sub space.</returns>
        public int CountSubSpaceOverlapped(Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4)
        {
            return CountSubSpaceOverlapped(_top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>(axis1, axis1, axis2, axis2, axis3, axis3, axis4, axis4));
        }
        /// <summary>Counts the number of items overlapped by a sub space.</summary>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
        /// <returns>The number of items in the provided sub space.</returns>
        public int CountSubSpaceOverlapped(Omnitree.Bound<Axis1> axis1, Omnitree.Bound<Axis2> axis2, Omnitree.Bound<Axis3> axis3, Omnitree.Bound<Axis4> axis4)
        {
            return CountSubSpaceOverlapped(_top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>(axis1, axis1, axis2, axis2, axis3, axis3, axis4, axis4));
        }

		private int CountSubSpaceEncapsulated(Node node, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4> bounds)
		{
			return CountSubSpaceBase(_top, bounds, (a, b) => EncapsulationCheck(a, b));
		}

		private int CountSubSpaceOverlapped(Node node, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4> bounds)
		{
			return CountSubSpaceBase(_top, bounds, (a, b) => InclusionCheck(a, b));
		}

		private int CountSubSpaceBase(
			Node node,
			Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4> bounds,
			Omnitree.SpatialCheck<Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>> spatialCheck)
        {
            // adjust min/max values
            int count = 0;
            if (EncapsulationCheck(bounds, node.Bounds))
                count += node.Count;
            else if (!node.PointOfDivision.HasValue)
            {
                for (Node.ValueNode list = node.Head; list != null; list = list.Next)
                    if (spatialCheck(bounds, GetBoundings(list.Value)))
                        count++;
            }
            else
            {
                Node branch = node as Node;
                if (!StraddlesLines(branch.Bounds, branch.PointOfDivision.Value))
                {
                    int child_index = DetermineChildIndex(branch.PointOfDivision.Value, bounds);
                    Node child = branch[child_index];
                    if (child != null)
                      count += this.CountSubSpaceBase(child, bounds, spatialCheck);
                }
                else
                {
                    foreach (Node child in node.Children)
                        count += this.CountSubSpaceBase(child, bounds, spatialCheck);
                }
            }
            return count;
        }

        #endregion

        #region Update

        /// <summary>Iterates through the entire tree and ensures each item is in the proper leaf.</summary>
        public void Update()
        {
            this.Update(this._top, 0);
        }

        /// <summary>Recursive version of the Update method.</summary>
        /// <param name="node">The current node of iteration.</param>
        /// <param name="depth">The current depth of iteration.</param>
        private int Update(Node node, int depth)
        {
			// I messed up this function in the conversion
			throw new System.NotImplementedException();

            int removals = 0;

            if (!node.PointOfDivision.HasValue)
            {
                Node.ValueNode current = node.Head;
                Node.ValueNode previous = null;
                while (current != null)
                {
                    Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4> bounds = GetBoundings(current.Value);
                    if (!this.EncapsulationCheck(node.Bounds, bounds))
                    {
                        removals++;
                        T updated = current.Value;
                        if (previous == null)
                        {
                            node.Head = current.Next;
                            goto HeadRemoved;
                        }
                        else
                            previous.Next = current.Next;

                        Node whereToAdd = GetEncapsulationParent(node.Parent, bounds);

                        if (whereToAdd == null)
                            throw new System.Exception("an item was updated outside the range of the omnitree");

                        this.Add(updated, whereToAdd, bounds, whereToAdd.Depth);
                    }
                    previous = current;
                HeadRemoved:
                    current = current.Next;
                }
                node.Count -= removals;
                return removals;
            }
            else
            {
                Node branch = node as Node;
                int skipped = 0;
                for (int i = 0; i + skipped < branch.Children.Length; )
                {
                    removals += this.Update(branch.Children[i], depth + 1);
                    if (branch.Children[i].Count == 0)
                        branch.Children[i] = branch.Children[branch.Children.Length - skipped++ - 1];
                    else
                        i++;
                }
                Node[] newArray = new Node[branch.Children.Length - skipped];
                Array.Copy(branch.Children, newArray, newArray.Length);
                branch.Children = newArray;

                branch.Count -= removals;

                if (branch.Count < _load && branch.Count != 0)
                    ShrinkChild(branch.Parent, branch.Index);
            }

            return removals;
        }

        /// <summary>Iterates through the provided dimensions and ensures each item is in the proper leaf.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
        public void Update(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4)
        {
            this.Update(new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>(min1, max1, min2, max2, min3, max3, min4, max4), this._top, 0);
        }
        /// <summary>Iterates through the provided dimensions and ensures each item is in the proper leaf.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
        public void Update(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4)
        {
            this.Update(new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>(min1, max1, min2, max2, min3, max3, min4, max4), this._top, 0);
        }
        /// <summary>Iterates through the provided dimensions and ensures each item is in the proper leaf.</summary>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
        public void Update(Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4)
        {
            this.Update(new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>(axis1, axis1, axis2, axis2, axis3, axis3, axis4, axis4), this._top, 0);
        }
        /// <summary>Iterates through the provided dimensions and ensures each item is in the proper leaf.</summary>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
        public void Update(Omnitree.Bound<Axis1> axis1, Omnitree.Bound<Axis2> axis2, Omnitree.Bound<Axis3> axis3, Omnitree.Bound<Axis4> axis4)
        {
            this.Update(new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>(axis1, axis1, axis2, axis2, axis3, axis3, axis4, axis4), this._top, 0);
        }
        private int Update(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4> bounds, Node node, int depth)
        {
			// I messed up this function in the conversion
			throw new System.NotImplementedException();

            if (!InclusionCheck(bounds, node.Bounds))
                return 0;

            int removals = 0;

            if (!node.PointOfDivision.HasValue)
            {
                Node.ValueNode current = node.Head;
                Node.ValueNode previous = null;
                while (current != null)
                {
                    Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4> item_bounds = GetBoundings(current.Value);
                    if (!this.EncapsulationCheck(node.Bounds, item_bounds))
                    {
                        removals++;
                        T updated = current.Value;
                        if (previous == null)
                        {
                            node.Head = current.Next;
                            goto HeadRemoved;
                        }
                        else
                            previous.Next = current.Next;
                        Node whereToAdd = GetEncapsulationParent(node.Parent, item_bounds);
                        if (whereToAdd == null)
                            throw new System.Exception("an item was updates outside the range of the omnitree");
                        this.Add(updated, whereToAdd, item_bounds, whereToAdd.Depth);
                    }
                    previous = current;
                HeadRemoved:
                    current = current.Next;
                }
                node.Count -= removals;
                return removals;
            }
            else
            {
                Node branch = node as Node;
                int skipped = 0;
                for (int i = 0; i + skipped < branch.Children.Length; )
                {
                    removals += this.Update(branch.Children[i], depth + 1);
                    if (branch.Children[i].Count == 0)
                        branch.Children[i] = branch.Children[branch.Children.Length - skipped++ - 1];
                    else
                        i++;
                }
                Node[] newArray = new Node[branch.Children.Length - skipped];
                Array.Copy(branch.Children, newArray, newArray.Length);
                branch.Children = newArray;

                branch.Count -= removals;

                if (branch.Count < _load && branch.Count != 0)
                    ShrinkChild(branch.Parent, branch.Index);
            }

            return removals;
        }

        #endregion

        #region Remove

        /// <summary>Removes all the items qualified by the delegate.</summary>
        /// <param name="where">The predicate to qualify removals.</param>
        public void Remove(Predicate<T> where)
        {
            this.Remove(this._top, where);
            Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
        }

        /// <summary>Recursive version of the remove method.</summary>
        /// <param name="node">The current node of traversal.</param>
        /// <param name="where">The predicate to qualify removals.</param>
        private int Remove(Node node, Predicate<T> where)
        {
            int removals = 0;

			// items
            while (node.Head != null && where(node.Head.Value))
            {
                node.Head = node.Head.Next;
                removals++;
            }
            if (node.Head != null)
            {
                Node.ValueNode list = node.Head;
                while (list.Next != null)
                {
                    if (where(list.Next.Value))
                    {
                        list.Next = list.Next.Next;
                        removals++;
                    }
                }
            }
            node.Count -= removals;
            
			// children
			if (node.Children != null)
			{
				int skipped = 0;
				for (int i = 0; i + skipped < node.Children.Length; )
				{
				    removals += this.Remove(node.Children[i], where);
				    if (node.Children[i].Count == 0)
				        node.Children[i] = node.Children[node.Children.Length - skipped++ - 1];
				    else
				        i++;
				}
				Node[] newArray = new Node[node.Children.Length - skipped];
				Array.Copy(node.Children, newArray, newArray.Length);
				node.Children = newArray;

				node.Count -= removals;

				if (node.Count < _load && node.Count != 0)
				    ShrinkChild(node.Parent, node.Index);
			}
            return removals;
        }

        /// <summary>Removes all the items encapsulated in a given space.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
        /// <returns>The number of items that were removed.</returns>
        public void RemoveEncapsulated(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4)
        {
            this.RemoveEncapsulated(this._top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>(min1, max1, min2, max2, min3, max3, min4, max4));
        }
        /// <summary>Removes all the items encapsulated in a given space.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
        /// <returns>The number of items that were removed.</returns>
        public void RemoveEncapsulated(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4)
        {
            this.RemoveEncapsulated(this._top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>(min1, max1, min2, max2, min3, max3, min4, max4));
        }
        /// <summary>Removes all the items encapsulated in a given space.</summary>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
        public void RemoveEncapsulated(Omnitree.Bound<Axis1> axis1, Omnitree.Bound<Axis2> axis2, Omnitree.Bound<Axis3> axis3, Omnitree.Bound<Axis4> axis4)
        {
            this.RemoveEncapsulated(this._top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>(axis1, axis1, axis2, axis2, axis3, axis3, axis4, axis4));
        }
        private int RemoveEncapsulated(Node node, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4> bounds)
        {
            int removals = this.RemoveBase(node, bounds, (a, b) => this.EncapsulationCheck(a, b));
			Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
			return removals;
        }

		/// <summary>Removes all the items overlapping a given space.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
        /// <returns>The number of items that were removed.</returns>
        public void RemoveOverlapped(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4)
        {
            this.RemoveOverlapped(this._top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>(min1, max1, min2, max2, min3, max3, min4, max4));
        }
        /// <summary>Removes all the items overlapping a given space.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
        /// <returns>The number of items that were removed.</returns>
        public void RemoveOverlapped(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4)
        {
            this.RemoveOverlapped(this._top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>(min1, max1, min2, max2, min3, max3, min4, max4));
        }
        private int RemoveOverlapped(Node node, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4> bounds)
        {
            int removals = this.RemoveBase(node, bounds, (a, b) => this.InclusionCheck(a, b));
			Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
			return removals;
        }

		private int RemoveBase(
			Node node,
			Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4> bounds,
			Omnitree.SpatialCheck<Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>> spatialCheck)
        {
            int removals = 0;
            if (InclusionCheck(bounds, node.Bounds))
            {
				// items
                Node.ValueNode current_node = node.Head;
                Node.ValueNode previous_node = null;
                while (current_node != null)
                {
                    Node.ValueNode temp_previous = current_node;
                    if (spatialCheck(bounds, GetBoundings(current_node.Value)))
                    {
                        removals++;
                        if (current_node == node.Head)
                            node.Head = node.Head.Next;
                        else
                        {
                            previous_node.Next = current_node.Next;
                            temp_previous = previous_node;
                        }
                    }
                    previous_node = temp_previous;
                    current_node = current_node.Next;
                }
                node.Count -= removals;
                
				// children
				if (node.Children != null)
				{
					int skipped = 0;
					for (int i = 0; i + skipped < node.Children.Length; )
					{
					    removals += this.RemoveBase(node.Children[i], bounds, spatialCheck);
					    if (node.Children[i].Count == 0)
					        node.Children[i] = node.Children[node.Children.Length - skipped++ - 1];
					    else
					        i++;
					}
					Node[] newArray = new Node[node.Children.Length - skipped];
					Array.Copy(node.Children, newArray, newArray.Length);
					node.Children = newArray;

					node.Count -= removals;
					// convert this branch back into a leaf
					// Note: if count is zero, it will be chopped off
					if (node.Count < _load && node.Count > 0)
					    ShrinkChild(node.Parent, node.Index);
				}
            }
			
            return removals;
        }

		/// <summary>Removes all the items in a given space validated by a predicate.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
        /// <param name="where">The equality constraint of the removal.</param>
        public void RemoveEncapsulated(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Predicate<T> where)
        {
            this.RemoveEncapsulated(this._top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>(min1, max1, min2, max2, min3, max3, min4, max4), where);
        }
        /// <summary>Removes all the items in a given space validated by a predicate.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
        /// <param name="where">The equality constraint of the removal.</param>
        public void RemoveEncapsulated(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Predicate<T> where)
        {
            this.RemoveEncapsulated(this._top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>(min1, max1, min2, max2, min3, max3, min4, max4), where);
        }
        private int RemoveEncapsulated(Node node, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4> bounds, Predicate<T> where)
        {
            int removals = RemoveBase(node, bounds, where, (a, b) => this.EncapsulationCheck(a, b));
			Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
			return removals;
        }

        /// <summary>Removes all the items in a given space validated by a predicate.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
        /// <param name="where">The equality constraint of the removal.</param>
        public void RemoveOverlapped(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Predicate<T> where)
        {
            this.RemoveOverlapped(this._top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>(min1, max1, min2, max2, min3, max3, min4, max4), where);
        }
        /// <summary>Removes all the items in a given space validated by a predicate.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
        /// <param name="where">The equality constraint of the removal.</param>
        public void RemoveOverlapped(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Predicate<T> where)
        {
            this.RemoveOverlapped(this._top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>(min1, max1, min2, max2, min3, max3, min4, max4), where);
        }
        private int RemoveOverlapped(Node node, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4> bounds, Predicate<T> where)
        {
            int removals = RemoveBase(node, bounds, where, (a, b) => this.InclusionCheck(a, b));
			Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
			return removals;
        }

		private int RemoveBase(
			Node node,
			Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4> bounds,
			Predicate<T> where,
			Omnitree.SpatialCheck<Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>> spatialCheck)
        {
            if (!InclusionCheck(node.Bounds, bounds))
                return 0;
            int removals = 0;
            
			// items
            Node.ValueNode current = node.Head;
            Node.ValueNode previous = null;
            while (current != null)
            {
                if (spatialCheck(bounds, GetBoundings(current.Value)) && where(current.Value))
                {
                    removals++;
                    if (previous == null)
                    {
                        node.Head = current.Next;
                        goto HeadRemoved;
                    }
                    else
                        previous.Next = current.Next;
                }
                previous = current;
            HeadRemoved:
                current = current.Next;
            }
            node.Count -= removals;

            // children
			if (node.Children != null)
			{
				int skipped = 0;
				for (int i = 0; i + skipped < node.Children.Length; )
				{
				    removals += this.RemoveBase(node.Children[i], bounds, where, spatialCheck);
				    if (node.Children[i].Count == 0)
				        node.Children[i] = node.Children[node.Children.Length - skipped++ - 1];
				    else
				        i++;
				}
				Node[] newArray = new Node[node.Children.Length - skipped];
				Array.Copy(node.Children, newArray, newArray.Length);
				node.Children = newArray;

				node.Count -= removals;

				if (node.Count < _load && node.Count != 0)
				    ShrinkChild(node.Parent, node.Index);
			}
            return removals;
        }

        /// <summary>Removes all instances of a given value.</summary>
        public void Remove(T removal)
        {
            Omnitree.Bound<Axis1> min1; Omnitree.Bound<Axis1> max1;
            Omnitree.Bound<Axis2> min2; Omnitree.Bound<Axis2> max2;
            Omnitree.Bound<Axis3> min3; Omnitree.Bound<Axis3> max3;
            Omnitree.Bound<Axis4> min4; Omnitree.Bound<Axis4> max4;
            this._getBounds(removal, out min1, out max1, out min2, out max2, out min3, out max3, out min4, out max4);
            this.RemoveOverlapped(this._top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>(min1, max1, min2, max2, min3, max3, min4, max4), item => this._equate(item, removal));
        }
        /// <summary>Removes all the items in a given space.</summary>
        /// <param name="axis1">The axis of the removal along the  1D axis.</param>
		/// <param name="axis2">The axis of the removal along the  2D axis.</param>
		/// <param name="axis3">The axis of the removal along the  3D axis.</param>
		/// <param name="axis4">The axis of the removal along the  4D axis.</param>
        /// <returns>The number of items that were removed.</returns>
        public void RemoveOverlapped(Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4)
        {
            this.RemoveOverlapped(axis1, axis1, axis2, axis2, axis3, axis3, axis4, axis4);
            Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
        }
        
        /// <summary>Removes all the items in a given space validated by a predicate.</summary>
        /// <param name="axis1">The axis of the removal along the  1D axis.</param>
		/// <param name="axis2">The axis of the removal along the  2D axis.</param>
		/// <param name="axis3">The axis of the removal along the  3D axis.</param>
		/// <param name="axis4">The axis of the removal along the  4D axis.</param>
        /// <param name="where">The equality constraint of the removal.</param>
        public void RemoveOverlapped(Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Predicate<T> where)
        {
			this.RemoveOverlapped(axis1, axis1, axis2, axis2, axis3, axis3, axis4, axis4, where);
            Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
        }

        #endregion

        #region Stepper And IEnumerable

        /// <summary>Traverses every item in the tree and performs the delegate in them.</summary>
        /// <param name="function">The delegate to perform on every item in the tree.</param>
        public void Stepper(Step<T> function)
        {
            this.Stepper(function, this._top);
        }
        private void Stepper(Step<T> function, Node node)
        {
            Node.ValueNode list = node.Head;
            while (list != null)
            {
                function(list.Value);
                list = list.Next;
            }
			if (node.Children != null)
				foreach (Node child in node.Children)
				    this.Stepper(function, child);
        }

        /// <summary>Traverses every item in the tree and performs the delegate in them.</summary>
        /// <param name="function">The delegate to perform on every item in the tree.</param>
        public StepStatus Stepper(StepBreak<T> function)
        {
            return Stepper(function, _top);
        }
        private StepStatus Stepper(StepBreak<T> function, Node node)
        {
            StepStatus status = StepStatus.Continue;
            
            for (Node.ValueNode list = node.Head; list != null; list = list.Next)
                if ((status = function(list._value)) != StepStatus.Continue)
                    break;
            
			if (node.Children != null)
				foreach (Node child in node.Children)
				    if ((status = Stepper(function, child)) != StepStatus.Continue)
				        break;
            
            return status;
        }

        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="function">The delegate to perform on all items in the tree within the given bounds.</param>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
        public void StepperEncapsulated(Step<T> function, Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4)
        {
            StepperEncapsulated(function, _top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>(min1, max1, min2, max2, min3, max3, min4, max4));
        }
        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="function">The delegate to perform on all items in the tree within the given bounds.</param>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
        public void StepperEncapsulated(Step<T> function, Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4)
        {
            StepperEncapsulated(function, _top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>(min1, max1, min2, max2, min3, max3, min4, max4));
        }
        private void StepperEncapsulated(Step<T> function, Node node, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4> bounds)
        {
            StepperBase(function, node, bounds, (a, b) => this.EncapsulationCheck(a, b));
        }

		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="function">The delegate to perform on all items in the tree within the given bounds.</param>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
        public void StepperOverlapped(Step<T> function, Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4)
        {
            StepperOverlapped(function, _top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>(min1, max1, min2, max2, min3, max3, min4, max4));
        }
        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="function">The delegate to perform on all items in the tree within the given bounds.</param>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
        public void StepperOverlapped(Step<T> function, Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4)
        {
            StepperOverlapped(function, _top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>(min1, max1, min2, max2, min3, max3, min4, max4));
        }
        private void StepperOverlapped(Step<T> function, Node node, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4> bounds)
        {
            StepperBase(function, node, bounds, (a, b) => this.InclusionCheck(a, b));
        }

		private void StepperBase(
			Step<T> function,
			Node node,
			Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4> bounds,
			Omnitree.SpatialCheck<Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>> spatialCheck)
        {
            for (Node.ValueNode list = node.Head; list != null; list = list.Next)
                if (spatialCheck(bounds, GetBoundings(list.Value)))
                    function(list.Value);

			if (node.Children != null)
			{
				foreach (Node child in node.Children)
				    // optimization: stop bounds checking if space encapsulates node
				    if (EncapsulationCheck(bounds, child.Bounds))
				        this.Stepper(function, child);
				    else if (InclusionCheck(child.Bounds, bounds))
				        this.StepperBase(function, child, bounds, spatialCheck);
			}
        }

        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
        public StepStatus StepperEncapsulated(StepBreak<T> function, Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4)
        {
            return StepperEncapsulated(function, _top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>(min1, max1, min2, max2, min3, max3, min4, max4));
        }
        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
        public StepStatus StepperEncapsulated(StepBreak<T> function, Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4)
        {
			return StepperEncapsulated(function, _top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>(min1, max1, min2, max2, min3, max3, min4, max4));
        }
        private StepStatus StepperEncapsulated(StepBreak<T> function, Node node, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4> bounds)
        {
            return StepperBase(function, node, bounds, (a, b) => this.EncapsulationCheck(a, b));
        }

		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
        public StepStatus StepperOverlapped(StepBreak<T> function, Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4)
        {
            return StepperOverlapped(function, _top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>(min1, max1, min2, max2, min3, max3, min4, max4));
        }
        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
        public StepStatus StepperOverlapped(StepBreak<T> function, Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4)
        {
			return StepperOverlapped(function, _top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>(min1, max1, min2, max2, min3, max3, min4, max4));
        }
        private StepStatus StepperOverlapped(StepBreak<T> function, Node node, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4> bounds)
        {
            return StepperBase(function, node, bounds, (a, b) => this.InclusionCheck(a, b));
        }

		private StepStatus StepperBase(
			StepBreak<T> function,
			Node node,
			Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4> bounds,
			Omnitree.SpatialCheck<Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>> spatialCheck)
        {
            StepStatus status = StepStatus.Continue;

            for (Node.ValueNode list = node.Head; list != null; list = list.Next)
                if (spatialCheck(bounds, GetBoundings(list.Value)) &&
                    (status = function(list.Value)) != StepStatus.Continue)
                    break;

			if (node.Children != null)
			{
				foreach (Node child in node.Children)
				    // optimization: stop bounds checking if space encapsulates node
				    if (EncapsulationCheck(bounds, child.Bounds) &&
				        (status = this.Stepper(function, child)) != StepStatus.Continue)
				        break;
				    else if (!InclusionCheck(child.Bounds, bounds) &&
				        (status = this.StepperBase(function, child, bounds, spatialCheck)) != StepStatus.Continue)
				        break;
			}

            return status;
        }

        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="axis1">The axis of the removal along the  1D axis.</param>
		/// <param name="axis2">The axis of the removal along the  2D axis.</param>
		/// <param name="axis3">The axis of the removal along the  3D axis.</param>
		/// <param name="axis4">The axis of the removal along the  4D axis.</param>
        public void StepperOverlapped(Step<T> function, Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4)
        {
            StepperOverlapped(function, this._top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>(axis1, axis1, axis2, axis2, axis3, axis3, axis4, axis4));
        }

        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="function">The delegate to perform on all items in the tree within the given bounds.</param>
        /// <param name="axis1">The axis of the removal along the  1D axis.</param>
		/// <param name="axis2">The axis of the removal along the  2D axis.</param>
		/// <param name="axis3">The axis of the removal along the  3D axis.</param>
		/// <param name="axis4">The axis of the removal along the  4D axis.</param>
        public StepStatus StepperOverlapped(StepBreak<T> function, Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4)
        {
			return StepperOverlapped(function, this._top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>(axis1, axis1, axis2, axis2, axis3, axis3, axis4, axis4));
        }

        /// <summary>FOR COMPATIBILITY ONLY. AVOID IF POSSIBLE.</summary>
        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
        {
            throw new System.NotImplementedException();
            //return (this.ToArray() as System.Collections.Generic.IEnumerable<T>).GetEnumerator();
        }

        /// <summary>FOR COMPATIBILITY ONLY. AVOID IF POSSIBLE.</summary>
        System.Collections.Generic.IEnumerator<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator()
        {
            throw new System.NotImplementedException();
            //return (this.ToArray() as System.Collections.Generic.IEnumerable<T>).GetEnumerator();
        }

        #endregion

        #region Helpers

        private bool StraddlesLines(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4> bounds, Omnitree.Vector<Axis1, Axis2, Axis3, Axis4> vector)
        {
			if ((!bounds.Min1.Exists || (this._compare1(bounds.Min1.Value, vector.Axis1) != Comparison.Greater)) &&
				(!bounds.Max1.Exists || (this._compare1(bounds.Max1.Value, vector.Axis1) != Comparison.Less)))
				return true;
			if ((!bounds.Min2.Exists || (this._compare2(bounds.Min2.Value, vector.Axis2) != Comparison.Greater)) &&
				(!bounds.Max2.Exists || (this._compare2(bounds.Max2.Value, vector.Axis2) != Comparison.Less)))
				return true;
			if ((!bounds.Min3.Exists || (this._compare3(bounds.Min3.Value, vector.Axis3) != Comparison.Greater)) &&
				(!bounds.Max3.Exists || (this._compare3(bounds.Max3.Value, vector.Axis3) != Comparison.Less)))
				return true;
			if ((!bounds.Min4.Exists || (this._compare4(bounds.Min4.Value, vector.Axis4) != Comparison.Greater)) &&
				(!bounds.Max4.Exists || (this._compare4(bounds.Max4.Value, vector.Axis4) != Comparison.Less)))
				return true;
            return false;
        }

        /// <summary>Computes the child index that contains the desired dimensions.</summary>
        /// <param name="node">The branch .</param>
        /// <param name="vector">The dimensions to determine the child index.</param>
        /// <returns>The computed child index based on the coordinates relative to the center of the node.</returns>
        private int DetermineChildIndex(Omnitree.Vector<Axis1, Axis2, Axis3, Axis4> pointOfDivision, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4> bounds)
        {
			// make sure a child encapsulates the bounds (otherwise the bounds cannot move down the tree)
			if (StraddlesLines(bounds, pointOfDivision))
				return -1;

            int child = 0;
            if (!bounds.Min1.Exists || !(this._compare1(bounds.Min1.Value, pointOfDivision.Axis1) == Comparison.Less))
                child += 1 << 0;
            if (!bounds.Min2.Exists || !(this._compare2(bounds.Min2.Value, pointOfDivision.Axis2) == Comparison.Less))
                child += 1 << 1;
            if (!bounds.Min3.Exists || !(this._compare3(bounds.Min3.Value, pointOfDivision.Axis3) == Comparison.Less))
                child += 1 << 2;
            if (!bounds.Min4.Exists || !(this._compare4(bounds.Min4.Value, pointOfDivision.Axis4) == Comparison.Less))
                child += 1 << 3;
            return child;
        }

        /// <summary>Converts a branch back into a leaf when the count is reduced.</summary>
        /// <param name="parent">The parent to shrink a child of.</param>
        /// <param name="child">The index of the child to shrink.</param>
        private void ShrinkChild(Node parent, int child_index)
        {
            Node leaf;
            Node removal = null;
            if (parent == null) // top of tree
            {
                removal = this._top;
                leaf = new Node(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>.None, null, -1);
                this._top = leaf;
            }
            else // non-top branch
            {
                removal = parent[child_index];
                leaf = new Node(removal.Bounds, removal.Parent, removal.Index);
                parent[child_index] = leaf;
            }

            this.Stepper((T step) => { leaf.Add(step); }, removal);
        }

        /// <summary>Reduces the counts of all the parents of a given node by a given amount.</summary>
        /// <param name="parent">The starting parent of the reduction.</param>
        /// <param name="reduction">The amount to reduce the parent counts by.</param>
        private void ReduceParentCounts(Node parent, int reduction)
        {
            IncreaseParentCounts(parent, -reduction);
        }

        /// <summary>Increases the counts of all the parents of a given node by a given amount.</summary>
        /// <param name="parent">The starting parent of the increase.</param>
        /// <param name="increase">The amount to increase the parent counts by.</param>
        private void IncreaseParentCounts(Node parent, int increase)
        {
            Node looper = parent;
            while (looper != null)
            {
                looper.Count += increase;
                looper = looper.Parent;
            }
        }

        /// <summary>Checks a node for inclusion (overlap) between two bounds.</summary>
        /// <returns>True if the spaces overlap; False if not.</returns>
        private bool InclusionCheck(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4> a, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4> b)
        {

            if (a.Max1.Exists && b.Min1.Exists && this._compare1(a.Max1.Value, b.Min1.Value) == Comparison.Less)
                return false;
            else if (a.Min1.Exists && b.Max1.Exists && this._compare1(a.Min1.Value, b.Max1.Value) == Comparison.Greater)
                return false;

            if (a.Max2.Exists && b.Min2.Exists && this._compare2(a.Max2.Value, b.Min2.Value) == Comparison.Less)
                return false;
            else if (a.Min2.Exists && b.Max2.Exists && this._compare2(a.Min2.Value, b.Max2.Value) == Comparison.Greater)
                return false;

            if (a.Max3.Exists && b.Min3.Exists && this._compare3(a.Max3.Value, b.Min3.Value) == Comparison.Less)
                return false;
            else if (a.Min3.Exists && b.Max3.Exists && this._compare3(a.Min3.Value, b.Max3.Value) == Comparison.Greater)
                return false;

            if (a.Max4.Exists && b.Min4.Exists && this._compare4(a.Max4.Value, b.Min4.Value) == Comparison.Less)
                return false;
            else if (a.Min4.Exists && b.Max4.Exists && this._compare4(a.Min4.Value, b.Max4.Value) == Comparison.Greater)
                return false;

            return true;
        }

        /// <summary>Checks if a space encapsulates a point.</summary>
        /// <returns>True if the space encapsulates the point; False if not.</returns>
        private bool EncapsulationCheck(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4> bounds, Omnitree.Vector<Axis1, Axis2, Axis3, Axis4> vector)
        {
            // if the location is not outside the bounds, it must be inside

            if (bounds.Min1.Exists && this._compare1(vector.Axis1, bounds.Min1.Value) == Comparison.Less)
                return false;
            else if (bounds.Max1.Exists && this._compare1(vector.Axis1, bounds.Max1.Value) == Comparison.Greater)
                return false;

            if (bounds.Min2.Exists && this._compare2(vector.Axis2, bounds.Min2.Value) == Comparison.Less)
                return false;
            else if (bounds.Max2.Exists && this._compare2(vector.Axis2, bounds.Max2.Value) == Comparison.Greater)
                return false;

            if (bounds.Min3.Exists && this._compare3(vector.Axis3, bounds.Min3.Value) == Comparison.Less)
                return false;
            else if (bounds.Max3.Exists && this._compare3(vector.Axis3, bounds.Max3.Value) == Comparison.Greater)
                return false;

            if (bounds.Min4.Exists && this._compare4(vector.Axis4, bounds.Min4.Value) == Comparison.Less)
                return false;
            else if (bounds.Max4.Exists && this._compare4(vector.Axis4, bounds.Max4.Value) == Comparison.Greater)
                return false;

            return true;
        }

        /// <summary>Checks if a space (left) encapsulates another space (right).</summary>
        /// <returns>True if the left space encapsulates the right; False if not.</returns>
        private bool EncapsulationCheck(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4> a, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4> b)
        {
            if ((a.Min1.Exists && !b.Min1.Exists) || (a.Min2.Exists && !b.Min2.Exists) || (a.Min3.Exists && !b.Min3.Exists) || (a.Min4.Exists && !b.Min4.Exists))
                return false;
			if ((a.Max1.Exists && !b.Max1.Exists) || (a.Max2.Exists && !b.Max2.Exists) || (a.Max3.Exists && !b.Max3.Exists) || (a.Max4.Exists && !b.Max4.Exists))
                return false;

            if (b.Min1.Exists && a.Min1.Exists && this._compare1(a.Min1.Value, b.Min1.Value) != Comparison.Less)
                return false;
            if (b.Max1.Exists && a.Max1.Exists && this._compare1(a.Max1.Value, b.Max1.Value) != Comparison.Greater)
                return false;

            if (b.Min2.Exists && a.Min2.Exists && this._compare2(a.Min2.Value, b.Min2.Value) != Comparison.Less)
                return false;
            if (b.Max2.Exists && a.Max2.Exists && this._compare2(a.Max2.Value, b.Max2.Value) != Comparison.Greater)
                return false;

            if (b.Min3.Exists && a.Min3.Exists && this._compare3(a.Min3.Value, b.Min3.Value) != Comparison.Less)
                return false;
            if (b.Max3.Exists && a.Max3.Exists && this._compare3(a.Max3.Value, b.Max3.Value) != Comparison.Greater)
                return false;

            if (b.Min4.Exists && a.Min4.Exists && this._compare4(a.Min4.Value, b.Min4.Value) != Comparison.Less)
                return false;
            if (b.Max4.Exists && a.Max4.Exists && this._compare4(a.Max4.Value, b.Max4.Value) != Comparison.Greater)
                return false;

            return true;
        }

        /// <summary>Checks for equality between two locations.</summary>
        /// <returns>True if equal; False if not;</returns>
        private bool EqualsCheck(Omnitree.Vector<Axis1, Axis2, Axis3, Axis4> a, Omnitree.Vector<Axis1, Axis2, Axis3, Axis4> b)
        {

            if (!this._equate1(a.Axis1, b.Axis1))
                return false;

            if (!this._equate2(a.Axis2, b.Axis2))
                return false;

            if (!this._equate3(a.Axis3, b.Axis3))
                return false;

            if (!this._equate4(a.Axis4, b.Axis4))
                return false;

            return true;
        }

        /// <summary>Gets the nearest parent that encapsulates a location.</summary>
        /// <param name="node">The starting node to find the encapsulating parent of the location.</param>
        /// <param name="bounds">The bounds to get the encapsulating parent from.</param>
        /// <returns>The nearest node that encapsulates the given location.</returns>
        private Node GetEncapsulationParent(Node node, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4> bounds)
        {
            while (node != null && !EncapsulationCheck(node.Bounds, bounds))
                node = node.Parent;
            return node;
        }

        private Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4> GetBoundings(T value)
        {
            Omnitree.Bound<Axis1> min1; Omnitree.Bound<Axis1> max1;
            Omnitree.Bound<Axis2> min2; Omnitree.Bound<Axis2> max2;
            Omnitree.Bound<Axis3> min3; Omnitree.Bound<Axis3> max3;
            Omnitree.Bound<Axis4> min4; Omnitree.Bound<Axis4> max4;
            this._getBounds(value,
				out min1, out max1,
				out min2, out max2,
				out min3, out max3,
				out min4, out max4);
            return new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>(
				min1, max1,
				min2, max2,
				min3, max3,
				min4, max4);
        }

        #endregion

        #endregion
    }

    #endregion

    #region 5 Dimensional

    public interface IOmnitreeBounds<T, Axis1, Axis2, Axis3, Axis4, Axis5> : IDataStructure<T>,
            DataStructure.ICountable,
            DataStructure.IAddable<T>,
            DataStructure.IClearable,
            DataStructure.IRemovable<T>,
            DataStructure.IEquating<T>
    {
        #region Properties

        /// <summary>The number of dimensions in this tree.</summary>
        int Dimensions { get; }

        #endregion

        #region Methods

        /// <summary>Counts the number of items encapsulated by a sub space.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
        /// <returns>The number of items in the provided sub space.</returns>
        int CountSubSpaceEncapsulated(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5);

		/// <summary>Counts the number of items overlapped by a sub space.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
        /// <returns>The number of items in the provided sub space.</returns>
        int CountSubSpaceOverlapped(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5);

        /// <summary>Iterates through the entire tree and ensures each item is in the proper leaf.</summary>
        void Update();
        /// <summary>Iterates through the provided dimensions and ensures each item is in the proper leaf.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
        void Update(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5);

        /// <summary>Removes all the items in a given space.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
        void RemoveEncapsulated(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5);
        /// <summary>Removes all the items in a given space where predicate is met.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
        /// <param name="where">The predicate constraint of the removal.</param>
        void RemoveEncapsulated(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5, Predicate<T> where);

		/// <summary>Removes all the items in a given space.</summary>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
		/// <param name="axis5">The coordinate along the 5D axis.</param>
        void RemoveOverlapped(Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Axis5 axis5);
        /// <summary>Removes all the items in a given space.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
        void RemoveOverlapped(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5);
        /// <summary>Removes all the items in a given space where equality is met.</summary>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
		/// <param name="axis5">The coordinate along the 5D axis.</param>
        /// <param name="where">The equality constraint of the removal.</param>
        void RemoveOverlapped(Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Axis5 axis5, Predicate<T> where);
        /// <summary>Removes all the items in a given space where predicate is met.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
        /// <param name="where">The predicate constraint of the removal.</param>
        void RemoveOverlapped(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5, Predicate<T> where);

        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="step">The step function to perform on all items in the tree within the given bounds.</param>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
        void StepperEncapsulated(Step<T> step, Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5);
        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="step">The step function to perform on all items in the tree within the given bounds.</param>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
        StepStatus StepperEncapsulated(StepBreak<T> step, Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5);
        
		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="step">The step function to perform on all items in the tree within the given bounds.</param>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
        void StepperOverlapped(Step<T> step, Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5);
        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="step">The step function to perform on all items in the tree within the given bounds.</param>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
        StepStatus StepperOverlapped(StepBreak<T> step, Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5);

		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="step">The step function to perform on all items in the tree within the given bounds.</param>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
		/// <param name="axis5">The coordinate along the 5D axis.</param>
        void StepperOverlapped(Step<T> step, Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Axis5 axis5);
        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="step">The step function to perform on all items in the tree within the given bounds.</param>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
		/// <param name="axis5">The coordinate along the 5D axis.</param>
        StepStatus StepperOverlapped(StepBreak<T> function, Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Axis5 axis5);

        #endregion
    }

    public class OmnitreeBoundsLinked<T, Axis1, Axis2, Axis3, Axis4, Axis5> : IOmnitreeBounds<T, Axis1, Axis2, Axis3, Axis4, Axis5>
    {
        private const int _dimensions = 5;
        internal static int _children_per_node = (int)BigInteger.Pow(2, 5);

        private Node _top;

		private int _naturalLogLower = 1; // caching the next time to calculate loads (lower count)
		private int _naturalLogUpper = -1; // caching the next time to calculate loads (upper count)
        private int _load; // ln(count); min = _defaultLoad
        private Omnitree.GetBounds<T, Axis1, Axis2, Axis3, Axis4, Axis5> _getBounds;

        private bool _defaultEquate;
        private Equate<T> _equate;


        private bool _defaultEquate1;
        private Equate<Axis1> _equate1;

        private bool _defaultEquate2;
        private Equate<Axis2> _equate2;

        private bool _defaultEquate3;
        private Equate<Axis3> _equate3;

        private bool _defaultEquate4;
        private Equate<Axis4> _equate4;

        private bool _defaultEquate5;
        private Equate<Axis5> _equate5;



        private bool _defaultCompare1;
        private Compare<Axis1> _compare1;

        private bool _defaultCompare2;
        private Compare<Axis2> _compare2;

        private bool _defaultCompare3;
        private Compare<Axis3> _compare3;

        private bool _defaultCompare4;
        private Compare<Axis4> _compare4;

        private bool _defaultCompare5;
        private Compare<Axis5> _compare5;


        // allows median overriding for custom optimizations (USE AT YOUR OWN RISK)
        private Omnitree.SubdivisionOverride<T, Axis1, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>> _subdivisionOverride1;
        private Omnitree.SubdivisionOverride<T, Axis2, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>> _subdivisionOverride2;
        private Omnitree.SubdivisionOverride<T, Axis3, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>> _subdivisionOverride3;
        private Omnitree.SubdivisionOverride<T, Axis4, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>> _subdivisionOverride4;
        private Omnitree.SubdivisionOverride<T, Axis5, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>> _subdivisionOverride5;

        #region Nested Types

        /// <summary>Can be a leaf or a branch.</summary>
        internal class Node
        {
            public class ValueNode
            {
                internal T _value;
                internal ValueNode _next;

                public T Value { get { return _value; } set { _value = value; } }
                public ValueNode Next { get { return _next; } set { _next = value; } }

                public ValueNode(T value, ValueNode next)
                {
                    _value = value;
                    _next = next;
                }
            }

            internal Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5> _bounds;
            internal Node _parent;
            internal int _index;
            internal int _count;
            internal ValueNode _head;
            private Node[] _children;
            private Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5>? _pointOfDivision;

            /// <summary>The parent of this node.</summary>
            public Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5> Bounds { get { return this._bounds; } }
            /// <summary>The parent of this node.</summary>
            public Node Parent { get { return this._parent; } }
            /// <summary>The computed child index of this node (see the "Notes" region in "Omnitree.cs" for the algorithm.</summary>
            public int Index { get { return this._index; } }
            /// <summary>The number of elements stored in this node and its children.</summary>
            public int Count { get { return this._count; } set { this._count = value; } }
            /// <summary>The first object stored in this node.</summary>
            public ValueNode Head { get { return this._head; } set { this._head = value; } }
            public Node[] Children { get { return this._children; } set { this._children = value; } }
            public Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5>? PointOfDivision { get { return this._pointOfDivision; } internal set { this._pointOfDivision = value; } }

            /// <summary>Gets child by index.</summary>
            /// <param name="child_index">The index of the child to get.</param>
            /// <returns>The child of the given index or null if non-existent.</returns>
            public Node this[int child_index]
            {
                get
                {
                    if (this._children == null)
                        return null;
                    if (this._children.Length == OmnitreePointsLinked<T, Axis1, Axis2, Axis3, Axis4, Axis5>._children_per_node)
                        return this._children[(int)child_index];
                    foreach (Node node in this._children)
                        if (node.Index == child_index)
                            return node;
                    return null;
                }
                set
                {
                    // This error check should be unnecessary... but fuck it... might as well
                    if (value.Index != child_index)
                        throw new System.Exception("Bug in Omnitree (index/property mis-match when setting a child on a branch)");

                    // no children yet
                    if (this._children == null)
                    {
                        this._children = new Node[] { value };
                        return;
                    }
                    // max children overwrite
                    else if (this._children.Length == OmnitreePointsLinked<T, Axis1, Axis2, Axis3, Axis4, Axis5>._children_per_node)
                    {
                        this._children[(int)child_index] = value;
                        return;
                    }
                    // non-max child overwrite
                    for (int i = 0; i < this._children.Length; i++)
                        if (this._children[i].Index == child_index)
                        {
                            this._children[i] = value;
                            return;
                        }
                    // new child
                    Node[] newArray = new Node[this._children.Length + 1];
                    if (newArray.Length == OmnitreePointsLinked<T, Axis1, Axis2, Axis3, Axis4, Axis5>._children_per_node)
                    {
                        // new child resulting in a max children branch (sorting required)
                        for (int i = 0; i < this._children.Length; i++)
                        {
                            newArray[(int)this._children[i]._index] = this._children[i];
                        }
                        newArray[(int)value._index] = value;
                    }
                    else
                    {
                        // new child resulting in a non-max children branch
                        Array.Copy(this._children, newArray, this._children.Length);
                        newArray[newArray.Length - 1] = value;
                    }
                    this._children = newArray;
                }
            }

            /// <summary>The depth this node is located in the Omnitree.</summary>
            public int Depth
            {
                get
                {
                    int depth = -1;
                    for (Node looper = this; looper != null; looper = looper.Parent)
                        depth++;
                    return depth;
                }
            }

            /// <summary>Constructs a node.</summary>
            /// <param name="bounds">The bounds of this node.</param>
            /// <param name="parent">The parent of this node.</param>
            /// <param name="index">The number of elements stored in this node and its children.</param>
            public Node(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5> bounds, Node parent, int index)
            {
                this._bounds = bounds;
                this._parent = parent;
                this._index = index;
            }

            public Node(Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5> pointOfDivision, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5> bounds, Node parent, int index)
                : this(bounds, parent, index)
            {
                this._pointOfDivision = pointOfDivision;
            }

            internal Node(Node nodeToClone)
            {
                this._bounds = nodeToClone._bounds;
                this._parent = nodeToClone._parent;
                this._index = nodeToClone._index;
                this._count = nodeToClone._count;

                this._children = nodeToClone._children.Clone() as Node[];
                this._pointOfDivision = nodeToClone._pointOfDivision;

                ValueNode this_looper = this._head;
                ValueNode other_looper = nodeToClone._head;

                while (other_looper != null)
                {
                    this_looper.Next = new ValueNode(other_looper.Next.Value, null);
                    this_looper = this_looper.Next;
                    other_looper = other_looper.Next;
                }
            }

            public void Add(T addition)
            {
                this._head = new ValueNode(addition, this._head);
                this.Count++;
            }

            internal Node Clone()
            {
                return new Node(this);
            }
        }
        
        #endregion

        #region Constructors

        /// <summary>This constructor is for cloning purposes</summary>
        private OmnitreeBoundsLinked(OmnitreeBoundsLinked<T, Axis1, Axis2, Axis3, Axis4, Axis5> omnitree)
        {
            this._top = omnitree._top.Clone();
            this._load = omnitree._load;
            this._getBounds = omnitree._getBounds;
            this._defaultEquate = omnitree._defaultEquate;
            this._equate = omnitree._equate;

            this._defaultEquate1 = omnitree._defaultEquate1;
            this._equate1 = omnitree._equate1;
            this._defaultEquate2 = omnitree._defaultEquate2;
            this._equate2 = omnitree._equate2;
            this._defaultEquate3 = omnitree._defaultEquate3;
            this._equate3 = omnitree._equate3;
            this._defaultEquate4 = omnitree._defaultEquate4;
            this._equate4 = omnitree._equate4;
            this._defaultEquate5 = omnitree._defaultEquate5;
            this._equate5 = omnitree._equate5;

            this._defaultCompare1 = omnitree._defaultCompare1;
            this._compare1 = omnitree._compare1;
            this._defaultCompare2 = omnitree._defaultCompare2;
            this._compare2 = omnitree._compare2;
            this._defaultCompare3 = omnitree._defaultCompare3;
            this._compare3 = omnitree._compare3;
            this._defaultCompare4 = omnitree._defaultCompare4;
            this._compare4 = omnitree._compare4;
            this._defaultCompare5 = omnitree._defaultCompare5;
            this._compare5 = omnitree._compare5;

            this._subdivisionOverride1 = omnitree._subdivisionOverride1;
            this._subdivisionOverride2 = omnitree._subdivisionOverride2;
            this._subdivisionOverride3 = omnitree._subdivisionOverride3;
            this._subdivisionOverride4 = omnitree._subdivisionOverride4;
            this._subdivisionOverride5 = omnitree._subdivisionOverride5;
        }

        private OmnitreeBoundsLinked(
            Omnitree.GetBounds<T, Axis1, Axis2, Axis3, Axis4, Axis5> getBounds,

            bool defaultEquate,
            Equate<T> equate,

            bool defaultEquate1,
            Equate<Axis1> equateAxis1,
            bool defaultEquate2,
            Equate<Axis2> equateAxis2,
            bool defaultEquate3,
            Equate<Axis3> equateAxis3,
            bool defaultEquate4,
            Equate<Axis4> equateAxis4,
            bool defaultEquate5,
            Equate<Axis5> equateAxis5,

            bool defaultCompare1,
            Compare<Axis1> compare1,
            bool defaultCompare2,
            Compare<Axis2> compare2,
            bool defaultCompare3,
            Compare<Axis3> compare3,
            bool defaultCompare4,
            Compare<Axis4> compare4,
            bool defaultCompare5,
            Compare<Axis5> compare5,

            Omnitree.SubdivisionOverride<T, Axis1, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>> subdivisionOverride1,
            Omnitree.SubdivisionOverride<T, Axis2, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>> subdivisionOverride2,
            Omnitree.SubdivisionOverride<T, Axis3, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>> subdivisionOverride3,
            Omnitree.SubdivisionOverride<T, Axis4, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>> subdivisionOverride4,
            Omnitree.SubdivisionOverride<T, Axis5, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>> subdivisionOverride5)
        {
			if (getBounds == null)
			{
				throw new ArgumentNullException(nameof(getBounds));
			}
			if (equate == null)
			{
				throw new ArgumentNullException(nameof(equate));
			}

			if (equateAxis1 == null)
			{
				throw new ArgumentNullException(nameof(equateAxis1));
			}
			if (equateAxis2 == null)
			{
				throw new ArgumentNullException(nameof(equateAxis2));
			}
			if (equateAxis3 == null)
			{
				throw new ArgumentNullException(nameof(equateAxis3));
			}
			if (equateAxis4 == null)
			{
				throw new ArgumentNullException(nameof(equateAxis4));
			}
			if (equateAxis5 == null)
			{
				throw new ArgumentNullException(nameof(equateAxis5));
			}

			if (compare1 == null)
			{
				throw new ArgumentNullException(nameof(compare1));
			}
			if (compare2 == null)
			{
				throw new ArgumentNullException(nameof(compare2));
			}
			if (compare3 == null)
			{
				throw new ArgumentNullException(nameof(compare3));
			}
			if (compare4 == null)
			{
				throw new ArgumentNullException(nameof(compare4));
			}
			if (compare5 == null)
			{
				throw new ArgumentNullException(nameof(compare5));
			}

            this._getBounds = getBounds;
            this._defaultEquate = defaultEquate;
            this._equate = equate;

            this._defaultEquate1 = defaultEquate1;
            this._equate1 = equateAxis1;
            this._defaultEquate2 = defaultEquate2;
            this._equate2 = equateAxis2;
            this._defaultEquate3 = defaultEquate3;
            this._equate3 = equateAxis3;
            this._defaultEquate4 = defaultEquate4;
            this._equate4 = equateAxis4;
            this._defaultEquate5 = defaultEquate5;
            this._equate5 = equateAxis5;

            this._defaultCompare1 = defaultCompare1;
            this._compare1 = compare1;
            this._defaultCompare2 = defaultCompare2;
            this._compare2 = compare2;
            this._defaultCompare3 = defaultCompare3;
            this._compare3 = compare3;
            this._defaultCompare4 = defaultCompare4;
            this._compare4 = compare4;
            this._defaultCompare5 = defaultCompare5;
            this._compare5 = compare5;

            this._subdivisionOverride1 = subdivisionOverride1;
            this._subdivisionOverride2 = subdivisionOverride2;
            this._subdivisionOverride3 = subdivisionOverride3;
            this._subdivisionOverride4 = subdivisionOverride4;
            this._subdivisionOverride5 = subdivisionOverride5;

            this._top = new Node(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>.None, null, -1);
            Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
        }

        private OmnitreeBoundsLinked(
            Omnitree.GetBounds<T, Axis1, Axis2, Axis3, Axis4, Axis5> getBounds,
            Equate<T> equate,

            Equate<Axis1> equateAxis1,
            Equate<Axis2> equateAxis2,
            Equate<Axis3> equateAxis3,
            Equate<Axis4> equateAxis4,
            Equate<Axis5> equateAxis5,

            Compare<Axis1> compare1,
            Compare<Axis2> compare2,
            Compare<Axis3> compare3,
            Compare<Axis4> compare4,
            Compare<Axis5> compare5,

            Omnitree.SubdivisionOverride<T, Axis1, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>> subdivisionOverride1,
            Omnitree.SubdivisionOverride<T, Axis2, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>> subdivisionOverride2,
            Omnitree.SubdivisionOverride<T, Axis3, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>> subdivisionOverride3,
            Omnitree.SubdivisionOverride<T, Axis4, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>> subdivisionOverride4,
            Omnitree.SubdivisionOverride<T, Axis5, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>> subdivisionOverride5)
            : this(
            getBounds,

            false,
            equate,

            false,
            equateAxis1,
            false,
            equateAxis2,
            false,
            equateAxis3,
            false,
            equateAxis4,
            false,
            equateAxis5,

            false,
            compare1,
            false,
            compare2,
            false,
            compare3,
            false,
            compare4,
            false,
            compare5,

            subdivisionOverride1,
            subdivisionOverride2,
            subdivisionOverride3,
            subdivisionOverride4,
            subdivisionOverride5)
        { }

        public OmnitreeBoundsLinked(
            Omnitree.GetBounds<T, Axis1, Axis2, Axis3, Axis4, Axis5> getBounds,

            Equate<T> equate,

            Equate<Axis1> equateAxis1,
            Equate<Axis2> equateAxis2,
            Equate<Axis3> equateAxis3,
            Equate<Axis4> equateAxis4,
            Equate<Axis5> equateAxis5,

            Compare<Axis1> compare1,
            Compare<Axis2> compare2,
            Compare<Axis3> compare3,
            Compare<Axis4> compare4,
            Compare<Axis5> compare5)
            : this(
                getBounds,

                false,
                equate,

                false,
                equateAxis1,
                false,
                equateAxis2,
                false,
                equateAxis3,
                false,
                equateAxis4,
                false,
                equateAxis5,

                false,
                compare1,
                false,
                compare2,
                false,
                compare3,
                false,
                compare4,
                false,
                compare5,

                null,
                null,
                null,
                null,
                null)
        { }



        public OmnitreeBoundsLinked(
            Omnitree.GetBounds<T, Axis1, Axis2, Axis3, Axis4, Axis5> getBounds,

            Equate<T> equate,

            Compare<Axis1> compare1,
            Compare<Axis2> compare2,
            Compare<Axis3> compare3,
            Compare<Axis4> compare4,
            Compare<Axis5> compare5)
            : this(
                getBounds,
                false,
                equate,

                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,

                false,
                compare1,
                false,
                compare2,
                false,
                compare3,
                false,
                compare4,
                false,
                compare5,

                null,
                null,
                null,
                null,
                null)
        { }

        public OmnitreeBoundsLinked(
            Omnitree.GetBounds<T, Axis1, Axis2, Axis3, Axis4, Axis5> getBounds,
            Equate<T> equate,

            Compare<Axis1> compare1,
            Compare<Axis2> compare2,
            Compare<Axis3> compare3,
            Compare<Axis4> compare4,
            Compare<Axis5> compare5,

            Omnitree.SubdivisionOverride<T, Axis1, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>> subdivisionOverride1,
            Omnitree.SubdivisionOverride<T, Axis2, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>> subdivisionOverride2,
            Omnitree.SubdivisionOverride<T, Axis3, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>> subdivisionOverride3,
            Omnitree.SubdivisionOverride<T, Axis4, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>> subdivisionOverride4,
            Omnitree.SubdivisionOverride<T, Axis5, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>> subdivisionOverride5)
            : this(
                getBounds,

                false,
                equate,

                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,

                false,
                compare1,
                false,
                compare2,
                false,
                compare3,
                false,
                compare4,
                false,
                compare5,

                subdivisionOverride1,
                subdivisionOverride2,
                subdivisionOverride3,
                subdivisionOverride4,
                subdivisionOverride5)
        { }

        public OmnitreeBoundsLinked(
            Omnitree.GetBounds<T, Axis1, Axis2, Axis3, Axis4, Axis5> getBounds,

            Compare<Axis1> compare1,
            Compare<Axis2> compare2,
            Compare<Axis3> compare3,
            Compare<Axis4> compare4,
            Compare<Axis5> compare5)
            : this(
                getBounds,
                true,
                Towel.Equate.Default,

                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,

                false,
                compare1,
                false,
                compare2,
                false,
                compare3,
                false,
                compare4,
                false,
                compare5,

                null,
                null,
                null,
                null,
                null)
        { }

        public OmnitreeBoundsLinked(
            Omnitree.GetBounds<T, Axis1, Axis2, Axis3, Axis4, Axis5> getBounds,

            Compare<Axis1> compare1,
            Compare<Axis2> compare2,
            Compare<Axis3> compare3,
            Compare<Axis4> compare4,
            Compare<Axis5> compare5,

            Omnitree.SubdivisionOverride<T, Axis1, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>> subdivisionOverride1,
            Omnitree.SubdivisionOverride<T, Axis2, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>> subdivisionOverride2,
            Omnitree.SubdivisionOverride<T, Axis3, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>> subdivisionOverride3,
            Omnitree.SubdivisionOverride<T, Axis4, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>> subdivisionOverride4,
            Omnitree.SubdivisionOverride<T, Axis5, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>> subdivisionOverride5)
            : this(
                getBounds,

                true,
                Towel.Equate.Default,

                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,

                false,
                compare1,
                false,
                compare2,
                false,
                compare3,
                false,
                compare4,
                false,
                compare5,

                subdivisionOverride1,
                subdivisionOverride2,
                subdivisionOverride3,
                subdivisionOverride4,
                subdivisionOverride5)
        { }

        public OmnitreeBoundsLinked(
            Omnitree.GetBounds<T, Axis1, Axis2, Axis3, Axis4, Axis5> getBounds,
            Equate<T> equate)
            : this(
                getBounds,

                false,
                equate,

                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,

                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,

                null,
                null,
                null,
                null,
                null)
        { }

        public OmnitreeBoundsLinked(
            Omnitree.GetBounds<T, Axis1, Axis2, Axis3, Axis4, Axis5> getBounds,
            Equate<T> equate,
            Omnitree.SubdivisionOverride<T, Axis1, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>> subdivisionOverride1,
            Omnitree.SubdivisionOverride<T, Axis2, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>> subdivisionOverride2,
            Omnitree.SubdivisionOverride<T, Axis3, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>> subdivisionOverride3,
            Omnitree.SubdivisionOverride<T, Axis4, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>> subdivisionOverride4,
            Omnitree.SubdivisionOverride<T, Axis5, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>> subdivisionOverride5)
            : this(
                getBounds,

                false,
                equate,

                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,

                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,

                subdivisionOverride1,
                subdivisionOverride2,
                subdivisionOverride3,
                subdivisionOverride4,
                subdivisionOverride5)
        { }

        public OmnitreeBoundsLinked(
            Omnitree.GetBounds<T, Axis1, Axis2, Axis3, Axis4, Axis5> getBounds)
            : this(
                getBounds,

                true,
                Towel.Equate.Default,

                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,

                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,

                null,
                null,
                null,
                null,
                null)
        { }

		public OmnitreeBoundsLinked(
            Omnitree.GetBoundings<T, Axis1, Axis2, Axis3, Axis4, Axis5> getBoundings)
            : this(
                Omnitree.ConvertToGetBounds(getBoundings),

                true,
                Towel.Equate.Default,

                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,

                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,

                null,
                null,
                null,
                null,
                null)
        { }

        public OmnitreeBoundsLinked(
            Omnitree.GetBounds<T, Axis1, Axis2, Axis3, Axis4, Axis5> getBounds,
            Omnitree.SubdivisionOverride<T, Axis1, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>> subdivisionOverride1,
            Omnitree.SubdivisionOverride<T, Axis2, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>> subdivisionOverride2,
            Omnitree.SubdivisionOverride<T, Axis3, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>> subdivisionOverride3,
            Omnitree.SubdivisionOverride<T, Axis4, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>> subdivisionOverride4,
            Omnitree.SubdivisionOverride<T, Axis5, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>> subdivisionOverride5)
            : this(
                getBounds,

                true,
                Towel.Equate.Default,

                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,

                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,

                subdivisionOverride1,
                subdivisionOverride2,
                subdivisionOverride3,
                subdivisionOverride4,
                subdivisionOverride5)
        { }

        #endregion

        #region Properties

        /// <summary>The number of dimensions in this tree.</summary>
        public int Dimensions { get { return _dimensions; } }

        /// <summary>The function for equating keys in this table.</summary>
        public Equate<T> Equate { get { return this._equate; } }

        /// <summary>The location function the Omnitree is using.</summary>
        public Omnitree.GetBounds<T, Axis1, Axis2, Axis3, Axis4, Axis5> GetBounds { get { return this._getBounds; } }

        /// <summary>The comparison function the Omnitree is using along the 1D axis.</summary>
        public Compare<Axis1> Compare1 { get { return this._compare1; } }
        /// <summary>The comparison function the Omnitree is using along the 2D axis.</summary>
        public Compare<Axis2> Compare2 { get { return this._compare2; } }
        /// <summary>The comparison function the Omnitree is using along the 3D axis.</summary>
        public Compare<Axis3> Compare3 { get { return this._compare3; } }
        /// <summary>The comparison function the Omnitree is using along the 4D axis.</summary>
        public Compare<Axis4> Compare4 { get { return this._compare4; } }
        /// <summary>The comparison function the Omnitree is using along the 5D axis.</summary>
        public Compare<Axis5> Compare5 { get { return this._compare5; } }

        /// <summary>The function for equating values along the 1D axis.</summary>
        public Equate<Axis1> EquateAxis1 { get { return this._equate1; } }
        /// <summary>The function for equating values along the 2D axis.</summary>
        public Equate<Axis2> EquateAxis2 { get { return this._equate2; } }
        /// <summary>The function for equating values along the 3D axis.</summary>
        public Equate<Axis3> EquateAxis3 { get { return this._equate3; } }
        /// <summary>The function for equating values along the 4D axis.</summary>
        public Equate<Axis4> EquateAxis4 { get { return this._equate4; } }
        /// <summary>The function for equating values along the 5D axis.</summary>
        public Equate<Axis5> EquateAxis5 { get { return this._equate5; } }

        /// <summary>The current number of items in the tree.</summary>
        public int Count { get { return this._top.Count; } }

        private delegate void MaxDepthFinder(Node node, int current_depth, ref int max_depth);
        /// <summary>Finds the current maximum depth of the tree. NOT AN O(1) OPERATION. Intended for educational purposes only.</summary>
        public int MaxDepth
        {
            get
            {
                MaxDepthFinder maxDepthFinder = null;
                maxDepthFinder =
                        (Node node, int current_depth, ref int max_depth) =>
                        {
                            if (current_depth > max_depth)
                                max_depth = current_depth;
                            foreach (Node child in node.Children)
                                maxDepthFinder(child, current_depth + 1, ref max_depth);
                        };
                int _max_depth = -1;
                maxDepthFinder(this._top, 0, ref _max_depth);
                return _max_depth;
            }
        }

        private delegate void NodeCountFinder(Node node, ref int current_count);
        /// <summary>Counts the current number of nodes in the tree. NOT AN O(1) OPERATION. Intended for educational purposes only.</summary>
        public int NodeCount
        {
            get
            {
                NodeCountFinder nodeCountFinder = null;
                nodeCountFinder =
                        (Node node, ref int current_count) =>
                        {
                            current_count++;
                            foreach (Node child in node.Children)
                                nodeCountFinder(child, ref current_count);
                        };

                int _current_count = 0;
                nodeCountFinder(this._top, ref _current_count);
                return _current_count;
            }
        }

        #endregion

        #region Methods

        #region Add

        #region Bulk

		// not yet implemented

//        public void Add(IndexedBigArray<T> additions, bool allowMultithreading)
//        {
//            if (additions.Length > int.MaxValue)
//                throw new System.Exception("The maximum size of the Omnitree was exceeded during bulk addition.");
//
//            if (this._top.Count != 0 || (int)additions.Length <= _load)
//            {
//                for (ulong i = 0; i < additions.Length; i++)
//                    this.Add(additions[i]);
//            }
//            else
//            {
//                // adjust the loads prior to additions
//                ComputeLoads((int)additions.Length);
//
//                Node new_top = new Node(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>.None, null, -1);
//                new_top.Count = (int)additions.Length;
//
//
//                // prepare data for median computations
//                IndexedBigArray<Axis1> values1;
//                IAsyncResult result1 = null;
//                if (this._subdivisionOverride1 != null)
//                    values1 = null;
//                else
//                {
//                    values1 = null;
//                    Towel.Parallels.Parallel.Operation operation = () =>
//                    {
//                        values1 = new IndexedBigArray<Axis1>(additions.Length * 2);
//                        for (ulong i = 0; i < additions.Length; i++)
//						{
//							Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5> bounds = GetBoundings(additions[i]);
//                            values1[i * 2] = bounds.Min1;
//							values1[i * 2 + 1] = bounds.Max1;
//						}
//
//                        Towel.Algorithms.Sort.Merge(this._compare1, (int i) => { return values1[(ulong)i]; }, (int i, Axis1 value) => { values1[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
//                    };
//
//                    if (allowMultithreading)
//                        result1 = Towel.Parallels.Parallel.Thread(operation);
//                    else
//                        operation();
//                }
//
//                // prepare data for median computations
//                IndexedBigArray<Axis2> values2;
//                IAsyncResult result2 = null;
//                if (this._subdivisionOverride2 != null)
//                    values2 = null;
//                else
//                {
//                    values2 = null;
//                    Towel.Parallels.Parallel.Operation operation = () =>
//                    {
//                        values2 = new IndexedBigArray<Axis2>(additions.Length * 2);
//                        for (ulong i = 0; i < additions.Length; i++)
//						{
//							Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5> bounds = GetBoundings(additions[i]);
//                            values2[i * 2] = bounds.Min1;
//							values2[i * 2 + 1] = bounds.Max1;
//						}
//
//                        Towel.Algorithms.Sort.Merge(this._compare2, (int i) => { return values2[(ulong)i]; }, (int i, Axis2 value) => { values2[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
//                    };
//
//                    if (allowMultithreading)
//                        result2 = Towel.Parallels.Parallel.Thread(operation);
//                    else
//                        operation();
//                }
//
//                // prepare data for median computations
//                IndexedBigArray<Axis3> values3;
//                IAsyncResult result3 = null;
//                if (this._subdivisionOverride3 != null)
//                    values3 = null;
//                else
//                {
//                    values3 = null;
//                    Towel.Parallels.Parallel.Operation operation = () =>
//                    {
//                        values3 = new IndexedBigArray<Axis3>(additions.Length * 2);
//                        for (ulong i = 0; i < additions.Length; i++)
//						{
//							Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5> bounds = GetBoundings(additions[i]);
//                            values3[i * 2] = bounds.Min1;
//							values3[i * 2 + 1] = bounds.Max1;
//						}
//
//                        Towel.Algorithms.Sort.Merge(this._compare3, (int i) => { return values3[(ulong)i]; }, (int i, Axis3 value) => { values3[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
//                    };
//
//                    if (allowMultithreading)
//                        result3 = Towel.Parallels.Parallel.Thread(operation);
//                    else
//                        operation();
//                }
//
//                // prepare data for median computations
//                IndexedBigArray<Axis4> values4;
//                IAsyncResult result4 = null;
//                if (this._subdivisionOverride4 != null)
//                    values4 = null;
//                else
//                {
//                    values4 = null;
//                    Towel.Parallels.Parallel.Operation operation = () =>
//                    {
//                        values4 = new IndexedBigArray<Axis4>(additions.Length * 2);
//                        for (ulong i = 0; i < additions.Length; i++)
//						{
//							Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5> bounds = GetBoundings(additions[i]);
//                            values4[i * 2] = bounds.Min1;
//							values4[i * 2 + 1] = bounds.Max1;
//						}
//
//                        Towel.Algorithms.Sort.Merge(this._compare4, (int i) => { return values4[(ulong)i]; }, (int i, Axis4 value) => { values4[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
//                    };
//
//                    if (allowMultithreading)
//                        result4 = Towel.Parallels.Parallel.Thread(operation);
//                    else
//                        operation();
//                }
//
//                // prepare data for median computations
//                IndexedBigArray<Axis5> values5;
//                IAsyncResult result5 = null;
//                if (this._subdivisionOverride5 != null)
//                    values5 = null;
//                else
//                {
//                    values5 = null;
//                    Towel.Parallels.Parallel.Operation operation = () =>
//                    {
//                        values5 = new IndexedBigArray<Axis5>(additions.Length * 2);
//                        for (ulong i = 0; i < additions.Length; i++)
//						{
//							Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5> bounds = GetBoundings(additions[i]);
//                            values5[i * 2] = bounds.Min1;
//							values5[i * 2 + 1] = bounds.Max1;
//						}
//
//                        Towel.Algorithms.Sort.Merge(this._compare5, (int i) => { return values5[(ulong)i]; }, (int i, Axis5 value) => { values5[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
//                    };
//
//                    if (allowMultithreading)
//                        result5 = Towel.Parallels.Parallel.Thread(operation);
//                    else
//                        operation();
//                }
//
//
//
//                if (this._subdivisionOverride1 == null && allowMultithreading)
//                    result1.AsyncWaitHandle.WaitOne();
//                if (this._subdivisionOverride2 == null && allowMultithreading)
//                    result2.AsyncWaitHandle.WaitOne();
//                if (this._subdivisionOverride3 == null && allowMultithreading)
//                    result3.AsyncWaitHandle.WaitOne();
//                if (this._subdivisionOverride4 == null && allowMultithreading)
//                    result4.AsyncWaitHandle.WaitOne();
//                if (this._subdivisionOverride5 == null && allowMultithreading)
//                    result5.AsyncWaitHandle.WaitOne();
//
//                // build the tree
//                Add(new_top, 1, -1, additions.Stepper(), (int)additions.Length, int.MinValue, int.MinValue, int.MinValue, int.MinValue, int.MinValue, (int)additions.Length, (int index) => { return values1[index]; }, (int index) => { return values2[index]; }, (int index) => { return values3[index]; }, (int index) => { return values4[index]; }, (int index) => { return values5[index]; }, allowMultithreading);
//                
//                this._top = new_top;
//            }
//        }
//
//        public void Add(bool allowMultithreading, params T[] additions)
//        {
//            if (additions.Length > int.MaxValue)
//                throw new System.Exception("The maximum size of the Omnitree was exceeded during bulk addition.");
//
//            if (this._top.Count != 0 || (int)additions.Length <= _load)
//            {
//                for (int i = 0; i < additions.Length; i++)
//                    this.Add(additions[i]);
//            }
//            else
//            {
//                // adjust the loads prior to additions
//                ComputeLoads((int)additions.Length);
//
//                Node new_top = new Node(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>.None, null, -1);
//                new_top.Count = (int)additions.Length;
//
//
//                // prepare data for median computations
//                IndexedBigArray<Axis1> values1;
//                IAsyncResult result1 = null;
//                if (this._subdivisionOverride1 != null)
//                    values1 = null;
//                else
//                {
//                    values1 = null;
//                    Towel.Parallels.Parallel.Operation operation = () =>
//                    {
//                        values1 = new IndexedBigArray<Axis1>(additions.Length);
//                        for (int i = 0; i < additions.Length; i++)
//                            values1[i] = LocateVector(additions[i]).Axis1;
//                        Towel.Algorithms.Sort.Merge(this._compare1, (int i) => { return values1[(ulong)i]; }, (int i, Axis1 value) => { values1[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
//                    };
//
//                    if (allowMultithreading)
//                        result1 = Towel.Parallels.Parallel.Thread(operation);
//                    else
//                        operation();
//                }
//
//                // prepare data for median computations
//                IndexedBigArray<Axis2> values2;
//                IAsyncResult result2 = null;
//                if (this._subdivisionOverride2 != null)
//                    values2 = null;
//                else
//                {
//                    values2 = null;
//                    Towel.Parallels.Parallel.Operation operation = () =>
//                    {
//                        values2 = new IndexedBigArray<Axis2>(additions.Length);
//                        for (int i = 0; i < additions.Length; i++)
//                            values2[i] = LocateVector(additions[i]).Axis2;
//                        Towel.Algorithms.Sort.Merge(this._compare2, (int i) => { return values2[(ulong)i]; }, (int i, Axis2 value) => { values2[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
//                    };
//
//                    if (allowMultithreading)
//                        result2 = Towel.Parallels.Parallel.Thread(operation);
//                    else
//                        operation();
//                }
//
//                // prepare data for median computations
//                IndexedBigArray<Axis3> values3;
//                IAsyncResult result3 = null;
//                if (this._subdivisionOverride3 != null)
//                    values3 = null;
//                else
//                {
//                    values3 = null;
//                    Towel.Parallels.Parallel.Operation operation = () =>
//                    {
//                        values3 = new IndexedBigArray<Axis3>(additions.Length);
//                        for (int i = 0; i < additions.Length; i++)
//                            values3[i] = LocateVector(additions[i]).Axis3;
//                        Towel.Algorithms.Sort.Merge(this._compare3, (int i) => { return values3[(ulong)i]; }, (int i, Axis3 value) => { values3[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
//                    };
//
//                    if (allowMultithreading)
//                        result3 = Towel.Parallels.Parallel.Thread(operation);
//                    else
//                        operation();
//                }
//
//                // prepare data for median computations
//                IndexedBigArray<Axis4> values4;
//                IAsyncResult result4 = null;
//                if (this._subdivisionOverride4 != null)
//                    values4 = null;
//                else
//                {
//                    values4 = null;
//                    Towel.Parallels.Parallel.Operation operation = () =>
//                    {
//                        values4 = new IndexedBigArray<Axis4>(additions.Length);
//                        for (int i = 0; i < additions.Length; i++)
//                            values4[i] = LocateVector(additions[i]).Axis4;
//                        Towel.Algorithms.Sort.Merge(this._compare4, (int i) => { return values4[(ulong)i]; }, (int i, Axis4 value) => { values4[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
//                    };
//
//                    if (allowMultithreading)
//                        result4 = Towel.Parallels.Parallel.Thread(operation);
//                    else
//                        operation();
//                }
//
//                // prepare data for median computations
//                IndexedBigArray<Axis5> values5;
//                IAsyncResult result5 = null;
//                if (this._subdivisionOverride5 != null)
//                    values5 = null;
//                else
//                {
//                    values5 = null;
//                    Towel.Parallels.Parallel.Operation operation = () =>
//                    {
//                        values5 = new IndexedBigArray<Axis5>(additions.Length);
//                        for (int i = 0; i < additions.Length; i++)
//                            values5[i] = LocateVector(additions[i]).Axis5;
//                        Towel.Algorithms.Sort.Merge(this._compare5, (int i) => { return values5[(ulong)i]; }, (int i, Axis5 value) => { values5[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
//                    };
//
//                    if (allowMultithreading)
//                        result5 = Towel.Parallels.Parallel.Thread(operation);
//                    else
//                        operation();
//                }
//
//
//
//                if (this._subdivisionOverride1 == null && allowMultithreading)
//                    result1.AsyncWaitHandle.WaitOne();
//
//                if (this._subdivisionOverride2 == null && allowMultithreading)
//                    result2.AsyncWaitHandle.WaitOne();
//
//                if (this._subdivisionOverride3 == null && allowMultithreading)
//                    result3.AsyncWaitHandle.WaitOne();
//
//                if (this._subdivisionOverride4 == null && allowMultithreading)
//                    result4.AsyncWaitHandle.WaitOne();
//
//                if (this._subdivisionOverride5 == null && allowMultithreading)
//                    result5.AsyncWaitHandle.WaitOne();
//
//
//                // build the tree
//                Add(new_top, 1, -1, additions.Stepper(), additions.Length, int.MinValue, int.MinValue, int.MinValue, int.MinValue, int.MinValue, (int)additions.Length, (int index) => { return values1[index]; }, (int index) => { return values2[index]; }, (int index) => { return values3[index]; }, (int index) => { return values4[index]; }, (int index) => { return values5[index]; }, allowMultithreading);
//                
//                this._top = new_top;
//            }
//        }
//
//        
//        private int Add(Node parent, int depth, int child, Stepper<T> additions, int parent_count, int prevmed1, int prevmed2, int prevmed3, int prevmed4, int prevmed5, int initial_count, Get<Axis1> values1, Get<Axis2> values2, Get<Axis3> values3, Get<Axis4> values4, Get<Axis5> values5, bool allowMultithreading)
//        {
//            Axis1 pointOfDivision1;
//            Axis2 pointOfDivision2;
//            Axis3 pointOfDivision3;
//            Axis4 pointOfDivision4;
//            Axis5 pointOfDivision5;
//
//            int median_axis1 = -1;
//            int median_axis2 = -1;
//            int median_axis3 = -1;
//            int median_axis4 = -1;
//            int median_axis5 = -1;
//            if (this._subdivisionOverride1 == null || this._subdivisionOverride2 == null || this._subdivisionOverride3 == null || this._subdivisionOverride4 == null || this._subdivisionOverride5 == null)
//                GetMedianIndexes(initial_count, child, depth, prevmed1, prevmed2, prevmed3, prevmed4, prevmed5, out median_axis1, out median_axis2, out median_axis3, out median_axis4, out median_axis5);
//
//            if (this._subdivisionOverride1 != null)
//                pointOfDivision1 = this._subdivisionOverride1(parent.Bounds, additions);
//            else
//                pointOfDivision1 = values1(median_axis1);
//
//            if (this._subdivisionOverride2 != null)
//                pointOfDivision2 = this._subdivisionOverride2(parent.Bounds, additions);
//            else
//                pointOfDivision2 = values2(median_axis2);
//
//            if (this._subdivisionOverride3 != null)
//                pointOfDivision3 = this._subdivisionOverride3(parent.Bounds, additions);
//            else
//                pointOfDivision3 = values3(median_axis3);
//
//            if (this._subdivisionOverride4 != null)
//                pointOfDivision4 = this._subdivisionOverride4(parent.Bounds, additions);
//            else
//                pointOfDivision4 = values4(median_axis4);
//
//            if (this._subdivisionOverride5 != null)
//                pointOfDivision5 = this._subdivisionOverride5(parent.Bounds, additions);
//            else
//                pointOfDivision5 = values5(median_axis5);
//
//            parent.PointOfDivision = new Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5>(pointOfDivision1, pointOfDivision2, pointOfDivision3, pointOfDivision4, pointOfDivision5);
//
//            // divide the values along the medians
//            IMap<IAddable<T>, int> collection_map = new MapHashLinked<IAddable<T>, int>();
//            additions((T value) => 
//            {
//                int index = DetermineChildIndex(parent.PointOfDivision.Value, LocateVector(value));
//                IAddable<T> list = null;
//                if (collection_map.TryGet(index, out list))
//                {
//                    list.Add(value);
//                }
//                else
//                {
//                    if (parent_count < 100000)
//                        list = new AddableArray<T>();
//                    else
//                        list = new AddableLinked<T>();
//                    collection_map.Add(index, list);
//                    list.Add(value);
//                }
//            });
//
//            if (depth == 1 && allowMultithreading)
//            {
//                // NOTE: Must assign placeholders before multithreading so that the threads do not overwrite each other
//                collection_map.Keys((int key) => { parent[key] = new Node(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>.None, parent, key); });
//                IAsyncResult[] handles = new IAsyncResult[Environment.ProcessorCount];
//                for (int i = 0; i < handles.Length; i++)
//                {
//                    int multiTheadSafe_i = i; // used as catpure variable below making it multithread-safe
//                    handles[i] = Towel.Parallels.Parallel.Thread(() =>
//                    {
//                        Step.EveryNth<Link<IAddable<T>, int>>(collection_map.Pairs, multiTheadSafe_i + 1)(
//                        (Link<IAddable<T>, int> link) =>
//                            {
//                                ReversedChildBuilding(parent, link._2, depth, link._1.Stepper, link._1.Count, median_axis1, median_axis2, median_axis3, median_axis4, median_axis5, initial_count, values1, values2, values3, values4, values5, allowMultithreading);
//                            });
//                    });
//                }
//                
//                foreach (IAsyncResult handle in handles)
//                {
//                    handle.AsyncWaitHandle.WaitOne();
//                }
//            }
//            else
//            {
//                collection_map.Pairs((Link<IAddable<T>, int> link) =>
//                { 
//                    ReversedChildBuilding(parent, link._2, depth, link._1.Stepper, link._1.Count, median_axis1, median_axis2, median_axis3, median_axis4, median_axis5, initial_count, values1, values2, values3, values4, values5, allowMultithreading);
//                });
//            }
//
//            int count = 0;
//            foreach (Node node in parent.Children)
//                count += node.Count;
//            return count;
//        }
//
//        int ReversedChildBuilding(Node parent, int child_index, int depth, Stepper<T> additions, int count, int prevmed1, int prevmed2, int prevmed3, int prevmed4, int prevmed5, int initial_count, Get<Axis1> values1, Get<Axis2> values2, Get<Axis3> values3, Get<Axis4> values4, Get<Axis5> values5, bool allowMultithreading)
//        {
//            Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5> child_bounds = DetermineChildBounds(parent, child_index);
//            if (depth >= _load || count <= _load)
//            {
//                Node new_leaf = new Node(child_bounds, parent, child_index);
//                additions((T value) => { new_leaf.Add(value); });
//                parent[new_leaf.Index] = new_leaf;
//                return new_leaf.Count;
//            }
//            else
//            {
//                Node new_branch = new Node(Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5>.Default, child_bounds, parent, child_index);
//                parent[new_branch.Index] = new_branch;
//                new_branch.Count = Add(new_branch, depth + 1, child_index, additions, count, prevmed1, prevmed2, prevmed3, prevmed4, prevmed5, count, values1, values2, values3, values4, values5, allowMultithreading);
//                return new_branch.Count;
//            }
//        }
//
//        /// <summary>Gets the indeces of the median values at the given position during bulk additions.</summary>
//        private void GetMedianIndexes(int count, int child_index, int depth, int previous1, int previous2, int previous3, int previous4, int previous5, out int index1, out int index2, out int index3, out int index4, out int index5)
//        {
//            if (depth == 1)
//            {
//                index1 = (count - 1) / 2;
//                index2 = (count - 1) / 2;
//                index3 = (count - 1) / 2;
//                index4 = (count - 1) / 2;
//                index5 = (count - 1) / 2;
//                return;
//            }
//
//            int splits = Compute.Power(2, depth);
//            int mid_child_range = count / splits;
//
//            if (child_index >= 16)
//            {
//                index5 = previous5 + mid_child_range;
//                child_index -= 16;
//            }
//            else
//            {
//                index5 = previous5 - mid_child_range;
//            }
//
//            if (child_index >= 8)
//            {
//                index4 = previous4 + mid_child_range;
//                child_index -= 8;
//            }
//            else
//            {
//                index4 = previous4 - mid_child_range;
//            }
//
//            if (child_index >= 4)
//            {
//                index3 = previous3 + mid_child_range;
//                child_index -= 4;
//            }
//            else
//            {
//                index3 = previous3 - mid_child_range;
//            }
//
//            if (child_index >= 2)
//            {
//                index2 = previous2 + mid_child_range;
//                child_index -= 2;
//            }
//            else
//            {
//                index2 = previous2 - mid_child_range;
//            }
//
//            if (child_index >= 1)
//            {
//                index1 = previous1 + mid_child_range;
//                child_index -= 1;
//            }
//            else
//            {
//                index1 = previous1 - mid_child_range;
//            }
//
//        }

		

        #endregion

        #region single

        /// <summary>Adds an item to the tree.</summary>
        /// <param name="addition">The item to be added.</param>
        public void Add(T addition)
        {
            if (this._top.Count == int.MaxValue)
                throw new System.InvalidOperationException("(Count == int.MaxValue) max Omnitree size reached (change ints to longs if you need to).");

            // dynamic tree sizes
            Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);

            Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5> bounds = GetBoundings(addition);

            // grow the first branch of the tree
            if (!this._top.PointOfDivision.HasValue && this._top.Count >= _load)
            {
                Node top = this._top;

                // create the new branch from the median values
                this._top = new Node(DetermineMedians(top), Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>.None, null, -1);

                // iterate through the elements and add them to the appropriate children
                for (Node.ValueNode list = top.Head; list != null; list = list.Next)
                    Add(list.Value, this._top, GetBoundings(list.Value), 0);
            }

            this.Add(addition, this._top, bounds, 0);
        }
        
        /// <summary>Recursive version of the add function.</summary>
        /// <param name="addition">The item to be added.</param>
        /// <param name="node">The current node for tree trversal.</param>
        /// <param name="ms">The location of the addition.</param>
        /// <param name="depth">The current depth of iteration.</param>
        private void Add(T addition, Node node, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5> bounds, int depth)
        {
            if (!node.PointOfDivision.HasValue)
            {
                //Leaf leaf = node as Leaf;
                if (depth >= _load || !(node.Count >= _load))
                {
                    node.Add(addition);
                    return;
                }
                else
                {
                    //Node parent = node.Parent;
                    //int child_index = this.DetermineChildIndex(parent.PointOfDivision, location);
                    //Node growth = new Node(DetermineMedians(leaf), leaf.Bounds, parent, child_index);
                    //parent[child_index] = growth;

					Node growth = new Node(DetermineMedians(node), node.Bounds, node.Parent, node.Index);
                    node.Parent[node.Index] = growth;

                    for (Node.ValueNode list = node.Head; list != null; list = list.Next)
                    {
                        Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5> temp_bounds = GetBoundings(list.Value);
                        if (EncapsulationCheck(growth.Bounds, temp_bounds))
                            Add(list.Value, growth, temp_bounds, depth);
                        else
                        {
                            ReduceParentCounts(node.Parent, 1);
                            Add(list.Value, this._top, temp_bounds, depth);
                        }
                    }

                    Add(addition, growth, bounds, depth);
                    return;
                }
            }
            else
            {
                //Node branch = node as Node;
                int child_index = this.DetermineChildIndex(node.PointOfDivision.Value, bounds); // determine the child "index" (0 through 2^Dimensions) the addition belongs in
                
				// if -1, then the bounds of the addition straddle the point of division (keep it in current node)
				if (child_index == -1)
				{
					node.Add(addition);
                    return;
				}
				
				Node child_node = node[child_index];

                // null children in branches are just empty leaves
                if (child_node == null)
                {
                    Node new_node = new Node(DetermineChildBounds(node, child_index), node, child_index);
                    node[child_index] = new_node;
                    new_node.Add(addition);
                }
                else
                    // child exists already, continue adding
                    Add(addition, child_node, bounds, depth + 1);

                node.Count++;
                return;
            }
        }

        /// <summary>Determins the dimensions of the child at the given index.</summary>
        /// <param name="leaf">The parent of the node to compute dimensions for.</param>
        /// <param name="child">The index of the child to compute dimensions for.</param>
        /// <param name="median1">The computed minimum dimensions of the child node along the 1D axis.</param>
        /// <param name="median2">The computed minimum dimensions of the child node along the 2D axis.</param>
        /// <param name="median3">The computed minimum dimensions of the child node along the 3D axis.</param>
        private Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5> DetermineMedians(Node node)
        {
            try
            {
                // extract the values
                Omnitree.Bound<Axis1>[] values1 = new Omnitree.Bound<Axis1>[node.Count * 2];
                Omnitree.Bound<Axis2>[] values2 = new Omnitree.Bound<Axis2>[node.Count * 2];
                Omnitree.Bound<Axis3>[] values3 = new Omnitree.Bound<Axis3>[node.Count * 2];
                Omnitree.Bound<Axis4>[] values4 = new Omnitree.Bound<Axis4>[node.Count * 2];
                Omnitree.Bound<Axis5>[] values5 = new Omnitree.Bound<Axis5>[node.Count * 2];
                Node.ValueNode for_current = node.Head; // used in for loop
                for (int i = 0; i < node.Count; i++, for_current = for_current.Next)
                    this._getBounds(for_current.Value, 
					out values1[i * 2], out values1[i * 2 + 1], 
					out values2[i * 2], out values2[i * 2 + 1], 
					out values3[i * 2], out values3[i * 2 + 1], 
					out values4[i * 2], out values4[i * 2 + 1], 
					out values5[i * 2], out values5[i * 2 + 1]);
                return new Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5>(
					Omnitree.SubDivide(values1, this._defaultCompare1 ? Compare.Default : this._compare1), 
					Omnitree.SubDivide(values2, this._defaultCompare2 ? Compare.Default : this._compare2), 
					Omnitree.SubDivide(values3, this._defaultCompare3 ? Compare.Default : this._compare3), 
					Omnitree.SubDivide(values4, this._defaultCompare4 ? Compare.Default : this._compare4), 
					Omnitree.SubDivide(values5, this._defaultCompare5 ? Compare.Default : this._compare5));
            }
            catch
            {
                // extract the values
                IndexedBigArray<Omnitree.Bound<Axis1>> values1 = new IndexedBigArray<Omnitree.Bound<Axis1>>(node.Count * 2);
                IndexedBigArray<Omnitree.Bound<Axis2>> values2 = new IndexedBigArray<Omnitree.Bound<Axis2>>(node.Count * 2);
                IndexedBigArray<Omnitree.Bound<Axis3>> values3 = new IndexedBigArray<Omnitree.Bound<Axis3>>(node.Count * 2);
                IndexedBigArray<Omnitree.Bound<Axis4>> values4 = new IndexedBigArray<Omnitree.Bound<Axis4>>(node.Count * 2);
                IndexedBigArray<Omnitree.Bound<Axis5>> values5 = new IndexedBigArray<Omnitree.Bound<Axis5>>(node.Count * 2);
                Node.ValueNode for_current = node.Head; // used in for loop
                for (int i = 0; i < node.Count; i++, for_current = for_current.Next)
                {
                    Omnitree.Bound<Axis1> min1; Omnitree.Bound<Axis1> max1;
                    Omnitree.Bound<Axis2> min2; Omnitree.Bound<Axis2> max2;
                    Omnitree.Bound<Axis3> min3; Omnitree.Bound<Axis3> max3;
                    Omnitree.Bound<Axis4> min4; Omnitree.Bound<Axis4> max4;
                    Omnitree.Bound<Axis5> min5; Omnitree.Bound<Axis5> max5;
                    this._getBounds(for_current.Value,
						out min1, out max1,
						out min2, out max2,
						out min3, out max3,
						out min4, out max4,
						out min5, out max5);
                    values1[i * 2] = min1; values1[i * 2 + 1] = max1;
                    values2[i * 2] = min2; values2[i * 2 + 1] = max2;
                    values3[i * 2] = min3; values3[i * 2 + 1] = max3;
                    values4[i * 2] = min4; values4[i * 2 + 1] = max4;
                    values5[i * 2] = min5; values5[i * 2 + 1] = max5;
                }
				return new Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5>(
					Omnitree.SubDivide(values1, this._defaultCompare1 ? Compare.Default : this._compare1), 
					Omnitree.SubDivide(values2, this._defaultCompare2 ? Compare.Default : this._compare2), 
					Omnitree.SubDivide(values3, this._defaultCompare3 ? Compare.Default : this._compare3), 
					Omnitree.SubDivide(values4, this._defaultCompare4 ? Compare.Default : this._compare4), 
					Omnitree.SubDivide(values5, this._defaultCompare5 ? Compare.Default : this._compare5));
            }
        }

        #endregion

        #region Add Helpers

        private Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5> DetermineChildBounds(Node node, int child_index)
        {
			// the node parameter should always have a point of division value for this function
			Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5> pointOfDivision = node.PointOfDivision.Value;

            Omnitree.Bound<Axis5> min5, max5;
            if (child_index >= 16)
            {
                min5 = pointOfDivision.Axis5;
                max5 = node.Bounds.Max5;
                child_index -= 16;
            }
            else
            {
                min5 = node.Bounds.Min5;
                max5 = pointOfDivision.Axis5;
            }

            Omnitree.Bound<Axis4> min4, max4;
            if (child_index >= 8)
            {
                min4 = pointOfDivision.Axis4;
                max4 = node.Bounds.Max4;
                child_index -= 8;
            }
            else
            {
                min4 = node.Bounds.Min4;
                max4 = pointOfDivision.Axis4;
            }

            Omnitree.Bound<Axis3> min3, max3;
            if (child_index >= 4)
            {
                min3 = pointOfDivision.Axis3;
                max3 = node.Bounds.Max3;
                child_index -= 4;
            }
            else
            {
                min3 = node.Bounds.Min3;
                max3 = pointOfDivision.Axis3;
            }

            Omnitree.Bound<Axis2> min2, max2;
            if (child_index >= 2)
            {
                min2 = pointOfDivision.Axis2;
                max2 = node.Bounds.Max2;
                child_index -= 2;
            }
            else
            {
                min2 = node.Bounds.Min2;
                max2 = pointOfDivision.Axis2;
            }

            Omnitree.Bound<Axis1> min1, max1;
            if (child_index >= 1)
            {
                min1 = pointOfDivision.Axis1;
                max1 = node.Bounds.Max1;
                child_index -= 1;
            }
            else
            {
                min1 = node.Bounds.Min1;
                max1 = pointOfDivision.Axis1;
            }

            return new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5);
        }

        #endregion

        #endregion

        #region Clear

        /// <summary>Returns the tree to an empty state.</summary>
        public void Clear()
        {
            this._top = new Node(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>.None, null, -1);
            Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
        }

        #endregion

        #region Clone

        /// <summary>Creates a shallow clone of this data structure.</summary>
        /// <returns>A shallow clone of this data structure.</returns>
        public OmnitreeBoundsLinked<T, Axis1, Axis2, Axis3, Axis4, Axis5> Clone()
        {
            return new OmnitreeBoundsLinked<T, Axis1, Axis2, Axis3, Axis4, Axis5>(this);
        }

        #endregion

        #region Count

        /// <summary>Counts the number of items encapsulated by a sub space.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
        /// <returns>The number of items in the provided sub space.</returns>
        public int CountSubSpaceEncapsulated(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5)
        {
            return CountSubSpaceEncapsulated(_top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5));
        }
        /// <summary>Counts the number of items encapsulated by a sub space.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
        /// <returns>The number of items in the provided sub space.</returns>
        public int CountSubSpaceEncapsulated(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5)
        {
            return CountSubSpaceEncapsulated(_top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5));
        }
        /// <summary>Counts the number of items encapsulated by a sub space.</summary>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
		/// <param name="axis5">The coordinate along the 5D axis.</param>
        /// <returns>The number of items in the provided sub space.</returns>
        public int CountSubSpaceEncapsulated(Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Axis5 axis5)
        {
            return CountSubSpaceEncapsulated(_top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>(axis1, axis1, axis2, axis2, axis3, axis3, axis4, axis4, axis5, axis5));
        }
        /// <summary>Counts the number of items encapsulated by a sub space.</summary>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
		/// <param name="axis5">The coordinate along the 5D axis.</param>
        /// <returns>The number of items in the provided sub space.</returns>
        public int CountSubSpaceEncapsulated(Omnitree.Bound<Axis1> axis1, Omnitree.Bound<Axis2> axis2, Omnitree.Bound<Axis3> axis3, Omnitree.Bound<Axis4> axis4, Omnitree.Bound<Axis5> axis5)
        {
            return CountSubSpaceEncapsulated(_top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>(axis1, axis1, axis2, axis2, axis3, axis3, axis4, axis4, axis5, axis5));
        }

        /// <summary>Counts the number of items overlapped by a sub space.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
        /// <returns>The number of items in the provided sub space.</returns>
        public int CountSubSpaceOverlapped(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5)
        {
            return CountSubSpaceOverlapped(_top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5));
        }
        /// <summary>Counts the number of items overlapped by a sub space.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
        /// <returns>The number of items in the provided sub space.</returns>
        public int CountSubSpaceOverlapped(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5)
        {
            return CountSubSpaceOverlapped(_top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5));
        }
        /// <summary>Counts the number of items overlapped by a sub space.</summary>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
		/// <param name="axis5">The coordinate along the 5D axis.</param>
        /// <returns>The number of items in the provided sub space.</returns>
        public int CountSubSpaceOverlapped(Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Axis5 axis5)
        {
            return CountSubSpaceOverlapped(_top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>(axis1, axis1, axis2, axis2, axis3, axis3, axis4, axis4, axis5, axis5));
        }
        /// <summary>Counts the number of items overlapped by a sub space.</summary>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
		/// <param name="axis5">The coordinate along the 5D axis.</param>
        /// <returns>The number of items in the provided sub space.</returns>
        public int CountSubSpaceOverlapped(Omnitree.Bound<Axis1> axis1, Omnitree.Bound<Axis2> axis2, Omnitree.Bound<Axis3> axis3, Omnitree.Bound<Axis4> axis4, Omnitree.Bound<Axis5> axis5)
        {
            return CountSubSpaceOverlapped(_top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>(axis1, axis1, axis2, axis2, axis3, axis3, axis4, axis4, axis5, axis5));
        }

		private int CountSubSpaceEncapsulated(Node node, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5> bounds)
		{
			return CountSubSpaceBase(_top, bounds, (a, b) => EncapsulationCheck(a, b));
		}

		private int CountSubSpaceOverlapped(Node node, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5> bounds)
		{
			return CountSubSpaceBase(_top, bounds, (a, b) => InclusionCheck(a, b));
		}

		private int CountSubSpaceBase(
			Node node,
			Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5> bounds,
			Omnitree.SpatialCheck<Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>> spatialCheck)
        {
            // adjust min/max values
            int count = 0;
            if (EncapsulationCheck(bounds, node.Bounds))
                count += node.Count;
            else if (!node.PointOfDivision.HasValue)
            {
                for (Node.ValueNode list = node.Head; list != null; list = list.Next)
                    if (spatialCheck(bounds, GetBoundings(list.Value)))
                        count++;
            }
            else
            {
                Node branch = node as Node;
                if (!StraddlesLines(branch.Bounds, branch.PointOfDivision.Value))
                {
                    int child_index = DetermineChildIndex(branch.PointOfDivision.Value, bounds);
                    Node child = branch[child_index];
                    if (child != null)
                      count += this.CountSubSpaceBase(child, bounds, spatialCheck);
                }
                else
                {
                    foreach (Node child in node.Children)
                        count += this.CountSubSpaceBase(child, bounds, spatialCheck);
                }
            }
            return count;
        }

        #endregion

        #region Update

        /// <summary>Iterates through the entire tree and ensures each item is in the proper leaf.</summary>
        public void Update()
        {
            this.Update(this._top, 0);
        }

        /// <summary>Recursive version of the Update method.</summary>
        /// <param name="node">The current node of iteration.</param>
        /// <param name="depth">The current depth of iteration.</param>
        private int Update(Node node, int depth)
        {
			// I messed up this function in the conversion
			throw new System.NotImplementedException();

            int removals = 0;

            if (!node.PointOfDivision.HasValue)
            {
                Node.ValueNode current = node.Head;
                Node.ValueNode previous = null;
                while (current != null)
                {
                    Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5> bounds = GetBoundings(current.Value);
                    if (!this.EncapsulationCheck(node.Bounds, bounds))
                    {
                        removals++;
                        T updated = current.Value;
                        if (previous == null)
                        {
                            node.Head = current.Next;
                            goto HeadRemoved;
                        }
                        else
                            previous.Next = current.Next;

                        Node whereToAdd = GetEncapsulationParent(node.Parent, bounds);

                        if (whereToAdd == null)
                            throw new System.Exception("an item was updated outside the range of the omnitree");

                        this.Add(updated, whereToAdd, bounds, whereToAdd.Depth);
                    }
                    previous = current;
                HeadRemoved:
                    current = current.Next;
                }
                node.Count -= removals;
                return removals;
            }
            else
            {
                Node branch = node as Node;
                int skipped = 0;
                for (int i = 0; i + skipped < branch.Children.Length; )
                {
                    removals += this.Update(branch.Children[i], depth + 1);
                    if (branch.Children[i].Count == 0)
                        branch.Children[i] = branch.Children[branch.Children.Length - skipped++ - 1];
                    else
                        i++;
                }
                Node[] newArray = new Node[branch.Children.Length - skipped];
                Array.Copy(branch.Children, newArray, newArray.Length);
                branch.Children = newArray;

                branch.Count -= removals;

                if (branch.Count < _load && branch.Count != 0)
                    ShrinkChild(branch.Parent, branch.Index);
            }

            return removals;
        }

        /// <summary>Iterates through the provided dimensions and ensures each item is in the proper leaf.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
        public void Update(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5)
        {
            this.Update(new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5), this._top, 0);
        }
        /// <summary>Iterates through the provided dimensions and ensures each item is in the proper leaf.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
        public void Update(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5)
        {
            this.Update(new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5), this._top, 0);
        }
        /// <summary>Iterates through the provided dimensions and ensures each item is in the proper leaf.</summary>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
		/// <param name="axis5">The coordinate along the 5D axis.</param>
        public void Update(Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Axis5 axis5)
        {
            this.Update(new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>(axis1, axis1, axis2, axis2, axis3, axis3, axis4, axis4, axis5, axis5), this._top, 0);
        }
        /// <summary>Iterates through the provided dimensions and ensures each item is in the proper leaf.</summary>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
		/// <param name="axis5">The coordinate along the 5D axis.</param>
        public void Update(Omnitree.Bound<Axis1> axis1, Omnitree.Bound<Axis2> axis2, Omnitree.Bound<Axis3> axis3, Omnitree.Bound<Axis4> axis4, Omnitree.Bound<Axis5> axis5)
        {
            this.Update(new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>(axis1, axis1, axis2, axis2, axis3, axis3, axis4, axis4, axis5, axis5), this._top, 0);
        }
        private int Update(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5> bounds, Node node, int depth)
        {
			// I messed up this function in the conversion
			throw new System.NotImplementedException();

            if (!InclusionCheck(bounds, node.Bounds))
                return 0;

            int removals = 0;

            if (!node.PointOfDivision.HasValue)
            {
                Node.ValueNode current = node.Head;
                Node.ValueNode previous = null;
                while (current != null)
                {
                    Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5> item_bounds = GetBoundings(current.Value);
                    if (!this.EncapsulationCheck(node.Bounds, item_bounds))
                    {
                        removals++;
                        T updated = current.Value;
                        if (previous == null)
                        {
                            node.Head = current.Next;
                            goto HeadRemoved;
                        }
                        else
                            previous.Next = current.Next;
                        Node whereToAdd = GetEncapsulationParent(node.Parent, item_bounds);
                        if (whereToAdd == null)
                            throw new System.Exception("an item was updates outside the range of the omnitree");
                        this.Add(updated, whereToAdd, item_bounds, whereToAdd.Depth);
                    }
                    previous = current;
                HeadRemoved:
                    current = current.Next;
                }
                node.Count -= removals;
                return removals;
            }
            else
            {
                Node branch = node as Node;
                int skipped = 0;
                for (int i = 0; i + skipped < branch.Children.Length; )
                {
                    removals += this.Update(branch.Children[i], depth + 1);
                    if (branch.Children[i].Count == 0)
                        branch.Children[i] = branch.Children[branch.Children.Length - skipped++ - 1];
                    else
                        i++;
                }
                Node[] newArray = new Node[branch.Children.Length - skipped];
                Array.Copy(branch.Children, newArray, newArray.Length);
                branch.Children = newArray;

                branch.Count -= removals;

                if (branch.Count < _load && branch.Count != 0)
                    ShrinkChild(branch.Parent, branch.Index);
            }

            return removals;
        }

        #endregion

        #region Remove

        /// <summary>Removes all the items qualified by the delegate.</summary>
        /// <param name="where">The predicate to qualify removals.</param>
        public void Remove(Predicate<T> where)
        {
            this.Remove(this._top, where);
            Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
        }

        /// <summary>Recursive version of the remove method.</summary>
        /// <param name="node">The current node of traversal.</param>
        /// <param name="where">The predicate to qualify removals.</param>
        private int Remove(Node node, Predicate<T> where)
        {
            int removals = 0;

			// items
            while (node.Head != null && where(node.Head.Value))
            {
                node.Head = node.Head.Next;
                removals++;
            }
            if (node.Head != null)
            {
                Node.ValueNode list = node.Head;
                while (list.Next != null)
                {
                    if (where(list.Next.Value))
                    {
                        list.Next = list.Next.Next;
                        removals++;
                    }
                }
            }
            node.Count -= removals;
            
			// children
			if (node.Children != null)
			{
				int skipped = 0;
				for (int i = 0; i + skipped < node.Children.Length; )
				{
				    removals += this.Remove(node.Children[i], where);
				    if (node.Children[i].Count == 0)
				        node.Children[i] = node.Children[node.Children.Length - skipped++ - 1];
				    else
				        i++;
				}
				Node[] newArray = new Node[node.Children.Length - skipped];
				Array.Copy(node.Children, newArray, newArray.Length);
				node.Children = newArray;

				node.Count -= removals;

				if (node.Count < _load && node.Count != 0)
				    ShrinkChild(node.Parent, node.Index);
			}
            return removals;
        }

        /// <summary>Removes all the items encapsulated in a given space.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
        /// <returns>The number of items that were removed.</returns>
        public void RemoveEncapsulated(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5)
        {
            this.RemoveEncapsulated(this._top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5));
        }
        /// <summary>Removes all the items encapsulated in a given space.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
        /// <returns>The number of items that were removed.</returns>
        public void RemoveEncapsulated(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5)
        {
            this.RemoveEncapsulated(this._top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5));
        }
        /// <summary>Removes all the items encapsulated in a given space.</summary>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
		/// <param name="axis5">The coordinate along the 5D axis.</param>
        public void RemoveEncapsulated(Omnitree.Bound<Axis1> axis1, Omnitree.Bound<Axis2> axis2, Omnitree.Bound<Axis3> axis3, Omnitree.Bound<Axis4> axis4, Omnitree.Bound<Axis5> axis5)
        {
            this.RemoveEncapsulated(this._top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>(axis1, axis1, axis2, axis2, axis3, axis3, axis4, axis4, axis5, axis5));
        }
        private int RemoveEncapsulated(Node node, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5> bounds)
        {
            int removals = this.RemoveBase(node, bounds, (a, b) => this.EncapsulationCheck(a, b));
			Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
			return removals;
        }

		/// <summary>Removes all the items overlapping a given space.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
        /// <returns>The number of items that were removed.</returns>
        public void RemoveOverlapped(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5)
        {
            this.RemoveOverlapped(this._top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5));
        }
        /// <summary>Removes all the items overlapping a given space.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
        /// <returns>The number of items that were removed.</returns>
        public void RemoveOverlapped(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5)
        {
            this.RemoveOverlapped(this._top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5));
        }
        private int RemoveOverlapped(Node node, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5> bounds)
        {
            int removals = this.RemoveBase(node, bounds, (a, b) => this.InclusionCheck(a, b));
			Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
			return removals;
        }

		private int RemoveBase(
			Node node,
			Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5> bounds,
			Omnitree.SpatialCheck<Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>> spatialCheck)
        {
            int removals = 0;
            if (InclusionCheck(bounds, node.Bounds))
            {
				// items
                Node.ValueNode current_node = node.Head;
                Node.ValueNode previous_node = null;
                while (current_node != null)
                {
                    Node.ValueNode temp_previous = current_node;
                    if (spatialCheck(bounds, GetBoundings(current_node.Value)))
                    {
                        removals++;
                        if (current_node == node.Head)
                            node.Head = node.Head.Next;
                        else
                        {
                            previous_node.Next = current_node.Next;
                            temp_previous = previous_node;
                        }
                    }
                    previous_node = temp_previous;
                    current_node = current_node.Next;
                }
                node.Count -= removals;
                
				// children
				if (node.Children != null)
				{
					int skipped = 0;
					for (int i = 0; i + skipped < node.Children.Length; )
					{
					    removals += this.RemoveBase(node.Children[i], bounds, spatialCheck);
					    if (node.Children[i].Count == 0)
					        node.Children[i] = node.Children[node.Children.Length - skipped++ - 1];
					    else
					        i++;
					}
					Node[] newArray = new Node[node.Children.Length - skipped];
					Array.Copy(node.Children, newArray, newArray.Length);
					node.Children = newArray;

					node.Count -= removals;
					// convert this branch back into a leaf
					// Note: if count is zero, it will be chopped off
					if (node.Count < _load && node.Count > 0)
					    ShrinkChild(node.Parent, node.Index);
				}
            }
			
            return removals;
        }

		/// <summary>Removes all the items in a given space validated by a predicate.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
        /// <param name="where">The equality constraint of the removal.</param>
        public void RemoveEncapsulated(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5, Predicate<T> where)
        {
            this.RemoveEncapsulated(this._top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5), where);
        }
        /// <summary>Removes all the items in a given space validated by a predicate.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
        /// <param name="where">The equality constraint of the removal.</param>
        public void RemoveEncapsulated(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5, Predicate<T> where)
        {
            this.RemoveEncapsulated(this._top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5), where);
        }
        private int RemoveEncapsulated(Node node, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5> bounds, Predicate<T> where)
        {
            int removals = RemoveBase(node, bounds, where, (a, b) => this.EncapsulationCheck(a, b));
			Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
			return removals;
        }

        /// <summary>Removes all the items in a given space validated by a predicate.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
        /// <param name="where">The equality constraint of the removal.</param>
        public void RemoveOverlapped(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5, Predicate<T> where)
        {
            this.RemoveOverlapped(this._top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5), where);
        }
        /// <summary>Removes all the items in a given space validated by a predicate.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
        /// <param name="where">The equality constraint of the removal.</param>
        public void RemoveOverlapped(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5, Predicate<T> where)
        {
            this.RemoveOverlapped(this._top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5), where);
        }
        private int RemoveOverlapped(Node node, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5> bounds, Predicate<T> where)
        {
            int removals = RemoveBase(node, bounds, where, (a, b) => this.InclusionCheck(a, b));
			Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
			return removals;
        }

		private int RemoveBase(
			Node node,
			Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5> bounds,
			Predicate<T> where,
			Omnitree.SpatialCheck<Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>> spatialCheck)
        {
            if (!InclusionCheck(node.Bounds, bounds))
                return 0;
            int removals = 0;
            
			// items
            Node.ValueNode current = node.Head;
            Node.ValueNode previous = null;
            while (current != null)
            {
                if (spatialCheck(bounds, GetBoundings(current.Value)) && where(current.Value))
                {
                    removals++;
                    if (previous == null)
                    {
                        node.Head = current.Next;
                        goto HeadRemoved;
                    }
                    else
                        previous.Next = current.Next;
                }
                previous = current;
            HeadRemoved:
                current = current.Next;
            }
            node.Count -= removals;

            // children
			if (node.Children != null)
			{
				int skipped = 0;
				for (int i = 0; i + skipped < node.Children.Length; )
				{
				    removals += this.RemoveBase(node.Children[i], bounds, where, spatialCheck);
				    if (node.Children[i].Count == 0)
				        node.Children[i] = node.Children[node.Children.Length - skipped++ - 1];
				    else
				        i++;
				}
				Node[] newArray = new Node[node.Children.Length - skipped];
				Array.Copy(node.Children, newArray, newArray.Length);
				node.Children = newArray;

				node.Count -= removals;

				if (node.Count < _load && node.Count != 0)
				    ShrinkChild(node.Parent, node.Index);
			}
            return removals;
        }

        /// <summary>Removes all instances of a given value.</summary>
        public void Remove(T removal)
        {
            Omnitree.Bound<Axis1> min1; Omnitree.Bound<Axis1> max1;
            Omnitree.Bound<Axis2> min2; Omnitree.Bound<Axis2> max2;
            Omnitree.Bound<Axis3> min3; Omnitree.Bound<Axis3> max3;
            Omnitree.Bound<Axis4> min4; Omnitree.Bound<Axis4> max4;
            Omnitree.Bound<Axis5> min5; Omnitree.Bound<Axis5> max5;
            this._getBounds(removal, out min1, out max1, out min2, out max2, out min3, out max3, out min4, out max4, out min5, out max5);
            this.RemoveOverlapped(this._top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5), item => this._equate(item, removal));
        }
        /// <summary>Removes all the items in a given space.</summary>
        /// <param name="axis1">The axis of the removal along the  1D axis.</param>
		/// <param name="axis2">The axis of the removal along the  2D axis.</param>
		/// <param name="axis3">The axis of the removal along the  3D axis.</param>
		/// <param name="axis4">The axis of the removal along the  4D axis.</param>
		/// <param name="axis5">The axis of the removal along the  5D axis.</param>
        /// <returns>The number of items that were removed.</returns>
        public void RemoveOverlapped(Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Axis5 axis5)
        {
            this.RemoveOverlapped(axis1, axis1, axis2, axis2, axis3, axis3, axis4, axis4, axis5, axis5);
            Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
        }
        
        /// <summary>Removes all the items in a given space validated by a predicate.</summary>
        /// <param name="axis1">The axis of the removal along the  1D axis.</param>
		/// <param name="axis2">The axis of the removal along the  2D axis.</param>
		/// <param name="axis3">The axis of the removal along the  3D axis.</param>
		/// <param name="axis4">The axis of the removal along the  4D axis.</param>
		/// <param name="axis5">The axis of the removal along the  5D axis.</param>
        /// <param name="where">The equality constraint of the removal.</param>
        public void RemoveOverlapped(Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Axis5 axis5, Predicate<T> where)
        {
			this.RemoveOverlapped(axis1, axis1, axis2, axis2, axis3, axis3, axis4, axis4, axis5, axis5, where);
            Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
        }

        #endregion

        #region Stepper And IEnumerable

        /// <summary>Traverses every item in the tree and performs the delegate in them.</summary>
        /// <param name="function">The delegate to perform on every item in the tree.</param>
        public void Stepper(Step<T> function)
        {
            this.Stepper(function, this._top);
        }
        private void Stepper(Step<T> function, Node node)
        {
            Node.ValueNode list = node.Head;
            while (list != null)
            {
                function(list.Value);
                list = list.Next;
            }
			if (node.Children != null)
				foreach (Node child in node.Children)
				    this.Stepper(function, child);
        }

        /// <summary>Traverses every item in the tree and performs the delegate in them.</summary>
        /// <param name="function">The delegate to perform on every item in the tree.</param>
        public StepStatus Stepper(StepBreak<T> function)
        {
            return Stepper(function, _top);
        }
        private StepStatus Stepper(StepBreak<T> function, Node node)
        {
            StepStatus status = StepStatus.Continue;
            
            for (Node.ValueNode list = node.Head; list != null; list = list.Next)
                if ((status = function(list._value)) != StepStatus.Continue)
                    break;
            
			if (node.Children != null)
				foreach (Node child in node.Children)
				    if ((status = Stepper(function, child)) != StepStatus.Continue)
				        break;
            
            return status;
        }

        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="function">The delegate to perform on all items in the tree within the given bounds.</param>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
        public void StepperEncapsulated(Step<T> function, Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5)
        {
            StepperEncapsulated(function, _top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5));
        }
        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="function">The delegate to perform on all items in the tree within the given bounds.</param>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
        public void StepperEncapsulated(Step<T> function, Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5)
        {
            StepperEncapsulated(function, _top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5));
        }
        private void StepperEncapsulated(Step<T> function, Node node, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5> bounds)
        {
            StepperBase(function, node, bounds, (a, b) => this.EncapsulationCheck(a, b));
        }

		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="function">The delegate to perform on all items in the tree within the given bounds.</param>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
        public void StepperOverlapped(Step<T> function, Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5)
        {
            StepperOverlapped(function, _top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5));
        }
        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="function">The delegate to perform on all items in the tree within the given bounds.</param>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
        public void StepperOverlapped(Step<T> function, Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5)
        {
            StepperOverlapped(function, _top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5));
        }
        private void StepperOverlapped(Step<T> function, Node node, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5> bounds)
        {
            StepperBase(function, node, bounds, (a, b) => this.InclusionCheck(a, b));
        }

		private void StepperBase(
			Step<T> function,
			Node node,
			Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5> bounds,
			Omnitree.SpatialCheck<Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>> spatialCheck)
        {
            for (Node.ValueNode list = node.Head; list != null; list = list.Next)
                if (spatialCheck(bounds, GetBoundings(list.Value)))
                    function(list.Value);

			if (node.Children != null)
			{
				foreach (Node child in node.Children)
				    // optimization: stop bounds checking if space encapsulates node
				    if (EncapsulationCheck(bounds, child.Bounds))
				        this.Stepper(function, child);
				    else if (InclusionCheck(child.Bounds, bounds))
				        this.StepperBase(function, child, bounds, spatialCheck);
			}
        }

        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
        public StepStatus StepperEncapsulated(StepBreak<T> function, Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5)
        {
            return StepperEncapsulated(function, _top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5));
        }
        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
        public StepStatus StepperEncapsulated(StepBreak<T> function, Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5)
        {
			return StepperEncapsulated(function, _top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5));
        }
        private StepStatus StepperEncapsulated(StepBreak<T> function, Node node, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5> bounds)
        {
            return StepperBase(function, node, bounds, (a, b) => this.EncapsulationCheck(a, b));
        }

		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
        public StepStatus StepperOverlapped(StepBreak<T> function, Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5)
        {
            return StepperOverlapped(function, _top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5));
        }
        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
        public StepStatus StepperOverlapped(StepBreak<T> function, Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5)
        {
			return StepperOverlapped(function, _top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5));
        }
        private StepStatus StepperOverlapped(StepBreak<T> function, Node node, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5> bounds)
        {
            return StepperBase(function, node, bounds, (a, b) => this.InclusionCheck(a, b));
        }

		private StepStatus StepperBase(
			StepBreak<T> function,
			Node node,
			Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5> bounds,
			Omnitree.SpatialCheck<Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>> spatialCheck)
        {
            StepStatus status = StepStatus.Continue;

            for (Node.ValueNode list = node.Head; list != null; list = list.Next)
                if (spatialCheck(bounds, GetBoundings(list.Value)) &&
                    (status = function(list.Value)) != StepStatus.Continue)
                    break;

			if (node.Children != null)
			{
				foreach (Node child in node.Children)
				    // optimization: stop bounds checking if space encapsulates node
				    if (EncapsulationCheck(bounds, child.Bounds) &&
				        (status = this.Stepper(function, child)) != StepStatus.Continue)
				        break;
				    else if (!InclusionCheck(child.Bounds, bounds) &&
				        (status = this.StepperBase(function, child, bounds, spatialCheck)) != StepStatus.Continue)
				        break;
			}

            return status;
        }

        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="axis1">The axis of the removal along the  1D axis.</param>
		/// <param name="axis2">The axis of the removal along the  2D axis.</param>
		/// <param name="axis3">The axis of the removal along the  3D axis.</param>
		/// <param name="axis4">The axis of the removal along the  4D axis.</param>
		/// <param name="axis5">The axis of the removal along the  5D axis.</param>
        public void StepperOverlapped(Step<T> function, Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Axis5 axis5)
        {
            StepperOverlapped(function, this._top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>(axis1, axis1, axis2, axis2, axis3, axis3, axis4, axis4, axis5, axis5));
        }

        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="function">The delegate to perform on all items in the tree within the given bounds.</param>
        /// <param name="axis1">The axis of the removal along the  1D axis.</param>
		/// <param name="axis2">The axis of the removal along the  2D axis.</param>
		/// <param name="axis3">The axis of the removal along the  3D axis.</param>
		/// <param name="axis4">The axis of the removal along the  4D axis.</param>
		/// <param name="axis5">The axis of the removal along the  5D axis.</param>
        public StepStatus StepperOverlapped(StepBreak<T> function, Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Axis5 axis5)
        {
			return StepperOverlapped(function, this._top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>(axis1, axis1, axis2, axis2, axis3, axis3, axis4, axis4, axis5, axis5));
        }

        /// <summary>FOR COMPATIBILITY ONLY. AVOID IF POSSIBLE.</summary>
        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
        {
            throw new System.NotImplementedException();
            //return (this.ToArray() as System.Collections.Generic.IEnumerable<T>).GetEnumerator();
        }

        /// <summary>FOR COMPATIBILITY ONLY. AVOID IF POSSIBLE.</summary>
        System.Collections.Generic.IEnumerator<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator()
        {
            throw new System.NotImplementedException();
            //return (this.ToArray() as System.Collections.Generic.IEnumerable<T>).GetEnumerator();
        }

        #endregion

        #region Helpers

        private bool StraddlesLines(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5> bounds, Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5> vector)
        {
			if ((!bounds.Min1.Exists || (this._compare1(bounds.Min1.Value, vector.Axis1) != Comparison.Greater)) &&
				(!bounds.Max1.Exists || (this._compare1(bounds.Max1.Value, vector.Axis1) != Comparison.Less)))
				return true;
			if ((!bounds.Min2.Exists || (this._compare2(bounds.Min2.Value, vector.Axis2) != Comparison.Greater)) &&
				(!bounds.Max2.Exists || (this._compare2(bounds.Max2.Value, vector.Axis2) != Comparison.Less)))
				return true;
			if ((!bounds.Min3.Exists || (this._compare3(bounds.Min3.Value, vector.Axis3) != Comparison.Greater)) &&
				(!bounds.Max3.Exists || (this._compare3(bounds.Max3.Value, vector.Axis3) != Comparison.Less)))
				return true;
			if ((!bounds.Min4.Exists || (this._compare4(bounds.Min4.Value, vector.Axis4) != Comparison.Greater)) &&
				(!bounds.Max4.Exists || (this._compare4(bounds.Max4.Value, vector.Axis4) != Comparison.Less)))
				return true;
			if ((!bounds.Min5.Exists || (this._compare5(bounds.Min5.Value, vector.Axis5) != Comparison.Greater)) &&
				(!bounds.Max5.Exists || (this._compare5(bounds.Max5.Value, vector.Axis5) != Comparison.Less)))
				return true;
            return false;
        }

        /// <summary>Computes the child index that contains the desired dimensions.</summary>
        /// <param name="node">The branch .</param>
        /// <param name="vector">The dimensions to determine the child index.</param>
        /// <returns>The computed child index based on the coordinates relative to the center of the node.</returns>
        private int DetermineChildIndex(Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5> pointOfDivision, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5> bounds)
        {
			// make sure a child encapsulates the bounds (otherwise the bounds cannot move down the tree)
			if (StraddlesLines(bounds, pointOfDivision))
				return -1;

            int child = 0;
            if (!bounds.Min1.Exists || !(this._compare1(bounds.Min1.Value, pointOfDivision.Axis1) == Comparison.Less))
                child += 1 << 0;
            if (!bounds.Min2.Exists || !(this._compare2(bounds.Min2.Value, pointOfDivision.Axis2) == Comparison.Less))
                child += 1 << 1;
            if (!bounds.Min3.Exists || !(this._compare3(bounds.Min3.Value, pointOfDivision.Axis3) == Comparison.Less))
                child += 1 << 2;
            if (!bounds.Min4.Exists || !(this._compare4(bounds.Min4.Value, pointOfDivision.Axis4) == Comparison.Less))
                child += 1 << 3;
            if (!bounds.Min5.Exists || !(this._compare5(bounds.Min5.Value, pointOfDivision.Axis5) == Comparison.Less))
                child += 1 << 4;
            return child;
        }

        /// <summary>Converts a branch back into a leaf when the count is reduced.</summary>
        /// <param name="parent">The parent to shrink a child of.</param>
        /// <param name="child">The index of the child to shrink.</param>
        private void ShrinkChild(Node parent, int child_index)
        {
            Node leaf;
            Node removal = null;
            if (parent == null) // top of tree
            {
                removal = this._top;
                leaf = new Node(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>.None, null, -1);
                this._top = leaf;
            }
            else // non-top branch
            {
                removal = parent[child_index];
                leaf = new Node(removal.Bounds, removal.Parent, removal.Index);
                parent[child_index] = leaf;
            }

            this.Stepper((T step) => { leaf.Add(step); }, removal);
        }

        /// <summary>Reduces the counts of all the parents of a given node by a given amount.</summary>
        /// <param name="parent">The starting parent of the reduction.</param>
        /// <param name="reduction">The amount to reduce the parent counts by.</param>
        private void ReduceParentCounts(Node parent, int reduction)
        {
            IncreaseParentCounts(parent, -reduction);
        }

        /// <summary>Increases the counts of all the parents of a given node by a given amount.</summary>
        /// <param name="parent">The starting parent of the increase.</param>
        /// <param name="increase">The amount to increase the parent counts by.</param>
        private void IncreaseParentCounts(Node parent, int increase)
        {
            Node looper = parent;
            while (looper != null)
            {
                looper.Count += increase;
                looper = looper.Parent;
            }
        }

        /// <summary>Checks a node for inclusion (overlap) between two bounds.</summary>
        /// <returns>True if the spaces overlap; False if not.</returns>
        private bool InclusionCheck(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5> a, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5> b)
        {

            if (a.Max1.Exists && b.Min1.Exists && this._compare1(a.Max1.Value, b.Min1.Value) == Comparison.Less)
                return false;
            else if (a.Min1.Exists && b.Max1.Exists && this._compare1(a.Min1.Value, b.Max1.Value) == Comparison.Greater)
                return false;

            if (a.Max2.Exists && b.Min2.Exists && this._compare2(a.Max2.Value, b.Min2.Value) == Comparison.Less)
                return false;
            else if (a.Min2.Exists && b.Max2.Exists && this._compare2(a.Min2.Value, b.Max2.Value) == Comparison.Greater)
                return false;

            if (a.Max3.Exists && b.Min3.Exists && this._compare3(a.Max3.Value, b.Min3.Value) == Comparison.Less)
                return false;
            else if (a.Min3.Exists && b.Max3.Exists && this._compare3(a.Min3.Value, b.Max3.Value) == Comparison.Greater)
                return false;

            if (a.Max4.Exists && b.Min4.Exists && this._compare4(a.Max4.Value, b.Min4.Value) == Comparison.Less)
                return false;
            else if (a.Min4.Exists && b.Max4.Exists && this._compare4(a.Min4.Value, b.Max4.Value) == Comparison.Greater)
                return false;

            if (a.Max5.Exists && b.Min5.Exists && this._compare5(a.Max5.Value, b.Min5.Value) == Comparison.Less)
                return false;
            else if (a.Min5.Exists && b.Max5.Exists && this._compare5(a.Min5.Value, b.Max5.Value) == Comparison.Greater)
                return false;

            return true;
        }

        /// <summary>Checks if a space encapsulates a point.</summary>
        /// <returns>True if the space encapsulates the point; False if not.</returns>
        private bool EncapsulationCheck(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5> bounds, Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5> vector)
        {
            // if the location is not outside the bounds, it must be inside

            if (bounds.Min1.Exists && this._compare1(vector.Axis1, bounds.Min1.Value) == Comparison.Less)
                return false;
            else if (bounds.Max1.Exists && this._compare1(vector.Axis1, bounds.Max1.Value) == Comparison.Greater)
                return false;

            if (bounds.Min2.Exists && this._compare2(vector.Axis2, bounds.Min2.Value) == Comparison.Less)
                return false;
            else if (bounds.Max2.Exists && this._compare2(vector.Axis2, bounds.Max2.Value) == Comparison.Greater)
                return false;

            if (bounds.Min3.Exists && this._compare3(vector.Axis3, bounds.Min3.Value) == Comparison.Less)
                return false;
            else if (bounds.Max3.Exists && this._compare3(vector.Axis3, bounds.Max3.Value) == Comparison.Greater)
                return false;

            if (bounds.Min4.Exists && this._compare4(vector.Axis4, bounds.Min4.Value) == Comparison.Less)
                return false;
            else if (bounds.Max4.Exists && this._compare4(vector.Axis4, bounds.Max4.Value) == Comparison.Greater)
                return false;

            if (bounds.Min5.Exists && this._compare5(vector.Axis5, bounds.Min5.Value) == Comparison.Less)
                return false;
            else if (bounds.Max5.Exists && this._compare5(vector.Axis5, bounds.Max5.Value) == Comparison.Greater)
                return false;

            return true;
        }

        /// <summary>Checks if a space (left) encapsulates another space (right).</summary>
        /// <returns>True if the left space encapsulates the right; False if not.</returns>
        private bool EncapsulationCheck(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5> a, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5> b)
        {
            if ((a.Min1.Exists && !b.Min1.Exists) || (a.Min2.Exists && !b.Min2.Exists) || (a.Min3.Exists && !b.Min3.Exists) || (a.Min4.Exists && !b.Min4.Exists) || (a.Min5.Exists && !b.Min5.Exists))
                return false;
			if ((a.Max1.Exists && !b.Max1.Exists) || (a.Max2.Exists && !b.Max2.Exists) || (a.Max3.Exists && !b.Max3.Exists) || (a.Max4.Exists && !b.Max4.Exists) || (a.Max5.Exists && !b.Max5.Exists))
                return false;

            if (b.Min1.Exists && a.Min1.Exists && this._compare1(a.Min1.Value, b.Min1.Value) != Comparison.Less)
                return false;
            if (b.Max1.Exists && a.Max1.Exists && this._compare1(a.Max1.Value, b.Max1.Value) != Comparison.Greater)
                return false;

            if (b.Min2.Exists && a.Min2.Exists && this._compare2(a.Min2.Value, b.Min2.Value) != Comparison.Less)
                return false;
            if (b.Max2.Exists && a.Max2.Exists && this._compare2(a.Max2.Value, b.Max2.Value) != Comparison.Greater)
                return false;

            if (b.Min3.Exists && a.Min3.Exists && this._compare3(a.Min3.Value, b.Min3.Value) != Comparison.Less)
                return false;
            if (b.Max3.Exists && a.Max3.Exists && this._compare3(a.Max3.Value, b.Max3.Value) != Comparison.Greater)
                return false;

            if (b.Min4.Exists && a.Min4.Exists && this._compare4(a.Min4.Value, b.Min4.Value) != Comparison.Less)
                return false;
            if (b.Max4.Exists && a.Max4.Exists && this._compare4(a.Max4.Value, b.Max4.Value) != Comparison.Greater)
                return false;

            if (b.Min5.Exists && a.Min5.Exists && this._compare5(a.Min5.Value, b.Min5.Value) != Comparison.Less)
                return false;
            if (b.Max5.Exists && a.Max5.Exists && this._compare5(a.Max5.Value, b.Max5.Value) != Comparison.Greater)
                return false;

            return true;
        }

        /// <summary>Checks for equality between two locations.</summary>
        /// <returns>True if equal; False if not;</returns>
        private bool EqualsCheck(Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5> a, Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5> b)
        {

            if (!this._equate1(a.Axis1, b.Axis1))
                return false;

            if (!this._equate2(a.Axis2, b.Axis2))
                return false;

            if (!this._equate3(a.Axis3, b.Axis3))
                return false;

            if (!this._equate4(a.Axis4, b.Axis4))
                return false;

            if (!this._equate5(a.Axis5, b.Axis5))
                return false;

            return true;
        }

        /// <summary>Gets the nearest parent that encapsulates a location.</summary>
        /// <param name="node">The starting node to find the encapsulating parent of the location.</param>
        /// <param name="bounds">The bounds to get the encapsulating parent from.</param>
        /// <returns>The nearest node that encapsulates the given location.</returns>
        private Node GetEncapsulationParent(Node node, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5> bounds)
        {
            while (node != null && !EncapsulationCheck(node.Bounds, bounds))
                node = node.Parent;
            return node;
        }

        private Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5> GetBoundings(T value)
        {
            Omnitree.Bound<Axis1> min1; Omnitree.Bound<Axis1> max1;
            Omnitree.Bound<Axis2> min2; Omnitree.Bound<Axis2> max2;
            Omnitree.Bound<Axis3> min3; Omnitree.Bound<Axis3> max3;
            Omnitree.Bound<Axis4> min4; Omnitree.Bound<Axis4> max4;
            Omnitree.Bound<Axis5> min5; Omnitree.Bound<Axis5> max5;
            this._getBounds(value,
				out min1, out max1,
				out min2, out max2,
				out min3, out max3,
				out min4, out max4,
				out min5, out max5);
            return new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>(
				min1, max1,
				min2, max2,
				min3, max3,
				min4, max4,
				min5, max5);
        }

        #endregion

        #endregion
    }

    #endregion

    #region 6 Dimensional

    public interface IOmnitreeBounds<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> : IDataStructure<T>,
            DataStructure.ICountable,
            DataStructure.IAddable<T>,
            DataStructure.IClearable,
            DataStructure.IRemovable<T>,
            DataStructure.IEquating<T>
    {
        #region Properties

        /// <summary>The number of dimensions in this tree.</summary>
        int Dimensions { get; }

        #endregion

        #region Methods

        /// <summary>Counts the number of items encapsulated by a sub space.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
        /// <returns>The number of items in the provided sub space.</returns>
        int CountSubSpaceEncapsulated(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5, Axis6 min6, Axis6 max6);

		/// <summary>Counts the number of items overlapped by a sub space.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
        /// <returns>The number of items in the provided sub space.</returns>
        int CountSubSpaceOverlapped(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5, Axis6 min6, Axis6 max6);

        /// <summary>Iterates through the entire tree and ensures each item is in the proper leaf.</summary>
        void Update();
        /// <summary>Iterates through the provided dimensions and ensures each item is in the proper leaf.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
        void Update(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5, Axis6 min6, Axis6 max6);

        /// <summary>Removes all the items in a given space.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
        void RemoveEncapsulated(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5, Axis6 min6, Axis6 max6);
        /// <summary>Removes all the items in a given space where predicate is met.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
        /// <param name="where">The predicate constraint of the removal.</param>
        void RemoveEncapsulated(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5, Axis6 min6, Axis6 max6, Predicate<T> where);

		/// <summary>Removes all the items in a given space.</summary>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
		/// <param name="axis5">The coordinate along the 5D axis.</param>
		/// <param name="axis6">The coordinate along the 6D axis.</param>
        void RemoveOverlapped(Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Axis5 axis5, Axis6 axis6);
        /// <summary>Removes all the items in a given space.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
        void RemoveOverlapped(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5, Axis6 min6, Axis6 max6);
        /// <summary>Removes all the items in a given space where equality is met.</summary>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
		/// <param name="axis5">The coordinate along the 5D axis.</param>
		/// <param name="axis6">The coordinate along the 6D axis.</param>
        /// <param name="where">The equality constraint of the removal.</param>
        void RemoveOverlapped(Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Axis5 axis5, Axis6 axis6, Predicate<T> where);
        /// <summary>Removes all the items in a given space where predicate is met.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
        /// <param name="where">The predicate constraint of the removal.</param>
        void RemoveOverlapped(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5, Axis6 min6, Axis6 max6, Predicate<T> where);

        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="step">The step function to perform on all items in the tree within the given bounds.</param>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
        void StepperEncapsulated(Step<T> step, Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5, Omnitree.Bound<Axis6> min6, Omnitree.Bound<Axis6> max6);
        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="step">The step function to perform on all items in the tree within the given bounds.</param>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
        StepStatus StepperEncapsulated(StepBreak<T> step, Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5, Omnitree.Bound<Axis6> min6, Omnitree.Bound<Axis6> max6);
        
		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="step">The step function to perform on all items in the tree within the given bounds.</param>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
        void StepperOverlapped(Step<T> step, Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5, Omnitree.Bound<Axis6> min6, Omnitree.Bound<Axis6> max6);
        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="step">The step function to perform on all items in the tree within the given bounds.</param>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
        StepStatus StepperOverlapped(StepBreak<T> step, Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5, Omnitree.Bound<Axis6> min6, Omnitree.Bound<Axis6> max6);

		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="step">The step function to perform on all items in the tree within the given bounds.</param>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
		/// <param name="axis5">The coordinate along the 5D axis.</param>
		/// <param name="axis6">The coordinate along the 6D axis.</param>
        void StepperOverlapped(Step<T> step, Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Axis5 axis5, Axis6 axis6);
        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="step">The step function to perform on all items in the tree within the given bounds.</param>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
		/// <param name="axis5">The coordinate along the 5D axis.</param>
		/// <param name="axis6">The coordinate along the 6D axis.</param>
        StepStatus StepperOverlapped(StepBreak<T> function, Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Axis5 axis5, Axis6 axis6);

        #endregion
    }

    public class OmnitreeBoundsLinked<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> : IOmnitreeBounds<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>
    {
        private const int _dimensions = 6;
        internal static int _children_per_node = (int)BigInteger.Pow(2, 6);

        private Node _top;

		private int _naturalLogLower = 1; // caching the next time to calculate loads (lower count)
		private int _naturalLogUpper = -1; // caching the next time to calculate loads (upper count)
        private int _load; // ln(count); min = _defaultLoad
        private Omnitree.GetBounds<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> _getBounds;

        private bool _defaultEquate;
        private Equate<T> _equate;


        private bool _defaultEquate1;
        private Equate<Axis1> _equate1;

        private bool _defaultEquate2;
        private Equate<Axis2> _equate2;

        private bool _defaultEquate3;
        private Equate<Axis3> _equate3;

        private bool _defaultEquate4;
        private Equate<Axis4> _equate4;

        private bool _defaultEquate5;
        private Equate<Axis5> _equate5;

        private bool _defaultEquate6;
        private Equate<Axis6> _equate6;



        private bool _defaultCompare1;
        private Compare<Axis1> _compare1;

        private bool _defaultCompare2;
        private Compare<Axis2> _compare2;

        private bool _defaultCompare3;
        private Compare<Axis3> _compare3;

        private bool _defaultCompare4;
        private Compare<Axis4> _compare4;

        private bool _defaultCompare5;
        private Compare<Axis5> _compare5;

        private bool _defaultCompare6;
        private Compare<Axis6> _compare6;


        // allows median overriding for custom optimizations (USE AT YOUR OWN RISK)
        private Omnitree.SubdivisionOverride<T, Axis1, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>> _subdivisionOverride1;
        private Omnitree.SubdivisionOverride<T, Axis2, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>> _subdivisionOverride2;
        private Omnitree.SubdivisionOverride<T, Axis3, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>> _subdivisionOverride3;
        private Omnitree.SubdivisionOverride<T, Axis4, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>> _subdivisionOverride4;
        private Omnitree.SubdivisionOverride<T, Axis5, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>> _subdivisionOverride5;
        private Omnitree.SubdivisionOverride<T, Axis6, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>> _subdivisionOverride6;

        #region Nested Types

        /// <summary>Can be a leaf or a branch.</summary>
        internal class Node
        {
            public class ValueNode
            {
                internal T _value;
                internal ValueNode _next;

                public T Value { get { return _value; } set { _value = value; } }
                public ValueNode Next { get { return _next; } set { _next = value; } }

                public ValueNode(T value, ValueNode next)
                {
                    _value = value;
                    _next = next;
                }
            }

            internal Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> _bounds;
            internal Node _parent;
            internal int _index;
            internal int _count;
            internal ValueNode _head;
            private Node[] _children;
            private Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>? _pointOfDivision;

            /// <summary>The parent of this node.</summary>
            public Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> Bounds { get { return this._bounds; } }
            /// <summary>The parent of this node.</summary>
            public Node Parent { get { return this._parent; } }
            /// <summary>The computed child index of this node (see the "Notes" region in "Omnitree.cs" for the algorithm.</summary>
            public int Index { get { return this._index; } }
            /// <summary>The number of elements stored in this node and its children.</summary>
            public int Count { get { return this._count; } set { this._count = value; } }
            /// <summary>The first object stored in this node.</summary>
            public ValueNode Head { get { return this._head; } set { this._head = value; } }
            public Node[] Children { get { return this._children; } set { this._children = value; } }
            public Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>? PointOfDivision { get { return this._pointOfDivision; } internal set { this._pointOfDivision = value; } }

            /// <summary>Gets child by index.</summary>
            /// <param name="child_index">The index of the child to get.</param>
            /// <returns>The child of the given index or null if non-existent.</returns>
            public Node this[int child_index]
            {
                get
                {
                    if (this._children == null)
                        return null;
                    if (this._children.Length == OmnitreePointsLinked<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>._children_per_node)
                        return this._children[(int)child_index];
                    foreach (Node node in this._children)
                        if (node.Index == child_index)
                            return node;
                    return null;
                }
                set
                {
                    // This error check should be unnecessary... but fuck it... might as well
                    if (value.Index != child_index)
                        throw new System.Exception("Bug in Omnitree (index/property mis-match when setting a child on a branch)");

                    // no children yet
                    if (this._children == null)
                    {
                        this._children = new Node[] { value };
                        return;
                    }
                    // max children overwrite
                    else if (this._children.Length == OmnitreePointsLinked<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>._children_per_node)
                    {
                        this._children[(int)child_index] = value;
                        return;
                    }
                    // non-max child overwrite
                    for (int i = 0; i < this._children.Length; i++)
                        if (this._children[i].Index == child_index)
                        {
                            this._children[i] = value;
                            return;
                        }
                    // new child
                    Node[] newArray = new Node[this._children.Length + 1];
                    if (newArray.Length == OmnitreePointsLinked<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>._children_per_node)
                    {
                        // new child resulting in a max children branch (sorting required)
                        for (int i = 0; i < this._children.Length; i++)
                        {
                            newArray[(int)this._children[i]._index] = this._children[i];
                        }
                        newArray[(int)value._index] = value;
                    }
                    else
                    {
                        // new child resulting in a non-max children branch
                        Array.Copy(this._children, newArray, this._children.Length);
                        newArray[newArray.Length - 1] = value;
                    }
                    this._children = newArray;
                }
            }

            /// <summary>The depth this node is located in the Omnitree.</summary>
            public int Depth
            {
                get
                {
                    int depth = -1;
                    for (Node looper = this; looper != null; looper = looper.Parent)
                        depth++;
                    return depth;
                }
            }

            /// <summary>Constructs a node.</summary>
            /// <param name="bounds">The bounds of this node.</param>
            /// <param name="parent">The parent of this node.</param>
            /// <param name="index">The number of elements stored in this node and its children.</param>
            public Node(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> bounds, Node parent, int index)
            {
                this._bounds = bounds;
                this._parent = parent;
                this._index = index;
            }

            public Node(Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> pointOfDivision, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> bounds, Node parent, int index)
                : this(bounds, parent, index)
            {
                this._pointOfDivision = pointOfDivision;
            }

            internal Node(Node nodeToClone)
            {
                this._bounds = nodeToClone._bounds;
                this._parent = nodeToClone._parent;
                this._index = nodeToClone._index;
                this._count = nodeToClone._count;

                this._children = nodeToClone._children.Clone() as Node[];
                this._pointOfDivision = nodeToClone._pointOfDivision;

                ValueNode this_looper = this._head;
                ValueNode other_looper = nodeToClone._head;

                while (other_looper != null)
                {
                    this_looper.Next = new ValueNode(other_looper.Next.Value, null);
                    this_looper = this_looper.Next;
                    other_looper = other_looper.Next;
                }
            }

            public void Add(T addition)
            {
                this._head = new ValueNode(addition, this._head);
                this.Count++;
            }

            internal Node Clone()
            {
                return new Node(this);
            }
        }
        
        #endregion

        #region Constructors

        /// <summary>This constructor is for cloning purposes</summary>
        private OmnitreeBoundsLinked(OmnitreeBoundsLinked<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> omnitree)
        {
            this._top = omnitree._top.Clone();
            this._load = omnitree._load;
            this._getBounds = omnitree._getBounds;
            this._defaultEquate = omnitree._defaultEquate;
            this._equate = omnitree._equate;

            this._defaultEquate1 = omnitree._defaultEquate1;
            this._equate1 = omnitree._equate1;
            this._defaultEquate2 = omnitree._defaultEquate2;
            this._equate2 = omnitree._equate2;
            this._defaultEquate3 = omnitree._defaultEquate3;
            this._equate3 = omnitree._equate3;
            this._defaultEquate4 = omnitree._defaultEquate4;
            this._equate4 = omnitree._equate4;
            this._defaultEquate5 = omnitree._defaultEquate5;
            this._equate5 = omnitree._equate5;
            this._defaultEquate6 = omnitree._defaultEquate6;
            this._equate6 = omnitree._equate6;

            this._defaultCompare1 = omnitree._defaultCompare1;
            this._compare1 = omnitree._compare1;
            this._defaultCompare2 = omnitree._defaultCompare2;
            this._compare2 = omnitree._compare2;
            this._defaultCompare3 = omnitree._defaultCompare3;
            this._compare3 = omnitree._compare3;
            this._defaultCompare4 = omnitree._defaultCompare4;
            this._compare4 = omnitree._compare4;
            this._defaultCompare5 = omnitree._defaultCompare5;
            this._compare5 = omnitree._compare5;
            this._defaultCompare6 = omnitree._defaultCompare6;
            this._compare6 = omnitree._compare6;

            this._subdivisionOverride1 = omnitree._subdivisionOverride1;
            this._subdivisionOverride2 = omnitree._subdivisionOverride2;
            this._subdivisionOverride3 = omnitree._subdivisionOverride3;
            this._subdivisionOverride4 = omnitree._subdivisionOverride4;
            this._subdivisionOverride5 = omnitree._subdivisionOverride5;
            this._subdivisionOverride6 = omnitree._subdivisionOverride6;
        }

        private OmnitreeBoundsLinked(
            Omnitree.GetBounds<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> getBounds,

            bool defaultEquate,
            Equate<T> equate,

            bool defaultEquate1,
            Equate<Axis1> equateAxis1,
            bool defaultEquate2,
            Equate<Axis2> equateAxis2,
            bool defaultEquate3,
            Equate<Axis3> equateAxis3,
            bool defaultEquate4,
            Equate<Axis4> equateAxis4,
            bool defaultEquate5,
            Equate<Axis5> equateAxis5,
            bool defaultEquate6,
            Equate<Axis6> equateAxis6,

            bool defaultCompare1,
            Compare<Axis1> compare1,
            bool defaultCompare2,
            Compare<Axis2> compare2,
            bool defaultCompare3,
            Compare<Axis3> compare3,
            bool defaultCompare4,
            Compare<Axis4> compare4,
            bool defaultCompare5,
            Compare<Axis5> compare5,
            bool defaultCompare6,
            Compare<Axis6> compare6,

            Omnitree.SubdivisionOverride<T, Axis1, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>> subdivisionOverride1,
            Omnitree.SubdivisionOverride<T, Axis2, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>> subdivisionOverride2,
            Omnitree.SubdivisionOverride<T, Axis3, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>> subdivisionOverride3,
            Omnitree.SubdivisionOverride<T, Axis4, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>> subdivisionOverride4,
            Omnitree.SubdivisionOverride<T, Axis5, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>> subdivisionOverride5,
            Omnitree.SubdivisionOverride<T, Axis6, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>> subdivisionOverride6)
        {
			if (getBounds == null)
			{
				throw new ArgumentNullException(nameof(getBounds));
			}
			if (equate == null)
			{
				throw new ArgumentNullException(nameof(equate));
			}

			if (equateAxis1 == null)
			{
				throw new ArgumentNullException(nameof(equateAxis1));
			}
			if (equateAxis2 == null)
			{
				throw new ArgumentNullException(nameof(equateAxis2));
			}
			if (equateAxis3 == null)
			{
				throw new ArgumentNullException(nameof(equateAxis3));
			}
			if (equateAxis4 == null)
			{
				throw new ArgumentNullException(nameof(equateAxis4));
			}
			if (equateAxis5 == null)
			{
				throw new ArgumentNullException(nameof(equateAxis5));
			}
			if (equateAxis6 == null)
			{
				throw new ArgumentNullException(nameof(equateAxis6));
			}

			if (compare1 == null)
			{
				throw new ArgumentNullException(nameof(compare1));
			}
			if (compare2 == null)
			{
				throw new ArgumentNullException(nameof(compare2));
			}
			if (compare3 == null)
			{
				throw new ArgumentNullException(nameof(compare3));
			}
			if (compare4 == null)
			{
				throw new ArgumentNullException(nameof(compare4));
			}
			if (compare5 == null)
			{
				throw new ArgumentNullException(nameof(compare5));
			}
			if (compare6 == null)
			{
				throw new ArgumentNullException(nameof(compare6));
			}

            this._getBounds = getBounds;
            this._defaultEquate = defaultEquate;
            this._equate = equate;

            this._defaultEquate1 = defaultEquate1;
            this._equate1 = equateAxis1;
            this._defaultEquate2 = defaultEquate2;
            this._equate2 = equateAxis2;
            this._defaultEquate3 = defaultEquate3;
            this._equate3 = equateAxis3;
            this._defaultEquate4 = defaultEquate4;
            this._equate4 = equateAxis4;
            this._defaultEquate5 = defaultEquate5;
            this._equate5 = equateAxis5;
            this._defaultEquate6 = defaultEquate6;
            this._equate6 = equateAxis6;

            this._defaultCompare1 = defaultCompare1;
            this._compare1 = compare1;
            this._defaultCompare2 = defaultCompare2;
            this._compare2 = compare2;
            this._defaultCompare3 = defaultCompare3;
            this._compare3 = compare3;
            this._defaultCompare4 = defaultCompare4;
            this._compare4 = compare4;
            this._defaultCompare5 = defaultCompare5;
            this._compare5 = compare5;
            this._defaultCompare6 = defaultCompare6;
            this._compare6 = compare6;

            this._subdivisionOverride1 = subdivisionOverride1;
            this._subdivisionOverride2 = subdivisionOverride2;
            this._subdivisionOverride3 = subdivisionOverride3;
            this._subdivisionOverride4 = subdivisionOverride4;
            this._subdivisionOverride5 = subdivisionOverride5;
            this._subdivisionOverride6 = subdivisionOverride6;

            this._top = new Node(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>.None, null, -1);
            Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
        }

        private OmnitreeBoundsLinked(
            Omnitree.GetBounds<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> getBounds,
            Equate<T> equate,

            Equate<Axis1> equateAxis1,
            Equate<Axis2> equateAxis2,
            Equate<Axis3> equateAxis3,
            Equate<Axis4> equateAxis4,
            Equate<Axis5> equateAxis5,
            Equate<Axis6> equateAxis6,

            Compare<Axis1> compare1,
            Compare<Axis2> compare2,
            Compare<Axis3> compare3,
            Compare<Axis4> compare4,
            Compare<Axis5> compare5,
            Compare<Axis6> compare6,

            Omnitree.SubdivisionOverride<T, Axis1, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>> subdivisionOverride1,
            Omnitree.SubdivisionOverride<T, Axis2, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>> subdivisionOverride2,
            Omnitree.SubdivisionOverride<T, Axis3, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>> subdivisionOverride3,
            Omnitree.SubdivisionOverride<T, Axis4, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>> subdivisionOverride4,
            Omnitree.SubdivisionOverride<T, Axis5, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>> subdivisionOverride5,
            Omnitree.SubdivisionOverride<T, Axis6, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>> subdivisionOverride6)
            : this(
            getBounds,

            false,
            equate,

            false,
            equateAxis1,
            false,
            equateAxis2,
            false,
            equateAxis3,
            false,
            equateAxis4,
            false,
            equateAxis5,
            false,
            equateAxis6,

            false,
            compare1,
            false,
            compare2,
            false,
            compare3,
            false,
            compare4,
            false,
            compare5,
            false,
            compare6,

            subdivisionOverride1,
            subdivisionOverride2,
            subdivisionOverride3,
            subdivisionOverride4,
            subdivisionOverride5,
            subdivisionOverride6)
        { }

        public OmnitreeBoundsLinked(
            Omnitree.GetBounds<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> getBounds,

            Equate<T> equate,

            Equate<Axis1> equateAxis1,
            Equate<Axis2> equateAxis2,
            Equate<Axis3> equateAxis3,
            Equate<Axis4> equateAxis4,
            Equate<Axis5> equateAxis5,
            Equate<Axis6> equateAxis6,

            Compare<Axis1> compare1,
            Compare<Axis2> compare2,
            Compare<Axis3> compare3,
            Compare<Axis4> compare4,
            Compare<Axis5> compare5,
            Compare<Axis6> compare6)
            : this(
                getBounds,

                false,
                equate,

                false,
                equateAxis1,
                false,
                equateAxis2,
                false,
                equateAxis3,
                false,
                equateAxis4,
                false,
                equateAxis5,
                false,
                equateAxis6,

                false,
                compare1,
                false,
                compare2,
                false,
                compare3,
                false,
                compare4,
                false,
                compare5,
                false,
                compare6,

                null,
                null,
                null,
                null,
                null,
                null)
        { }



        public OmnitreeBoundsLinked(
            Omnitree.GetBounds<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> getBounds,

            Equate<T> equate,

            Compare<Axis1> compare1,
            Compare<Axis2> compare2,
            Compare<Axis3> compare3,
            Compare<Axis4> compare4,
            Compare<Axis5> compare5,
            Compare<Axis6> compare6)
            : this(
                getBounds,
                false,
                equate,

                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,

                false,
                compare1,
                false,
                compare2,
                false,
                compare3,
                false,
                compare4,
                false,
                compare5,
                false,
                compare6,

                null,
                null,
                null,
                null,
                null,
                null)
        { }

        public OmnitreeBoundsLinked(
            Omnitree.GetBounds<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> getBounds,
            Equate<T> equate,

            Compare<Axis1> compare1,
            Compare<Axis2> compare2,
            Compare<Axis3> compare3,
            Compare<Axis4> compare4,
            Compare<Axis5> compare5,
            Compare<Axis6> compare6,

            Omnitree.SubdivisionOverride<T, Axis1, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>> subdivisionOverride1,
            Omnitree.SubdivisionOverride<T, Axis2, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>> subdivisionOverride2,
            Omnitree.SubdivisionOverride<T, Axis3, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>> subdivisionOverride3,
            Omnitree.SubdivisionOverride<T, Axis4, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>> subdivisionOverride4,
            Omnitree.SubdivisionOverride<T, Axis5, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>> subdivisionOverride5,
            Omnitree.SubdivisionOverride<T, Axis6, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>> subdivisionOverride6)
            : this(
                getBounds,

                false,
                equate,

                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,

                false,
                compare1,
                false,
                compare2,
                false,
                compare3,
                false,
                compare4,
                false,
                compare5,
                false,
                compare6,

                subdivisionOverride1,
                subdivisionOverride2,
                subdivisionOverride3,
                subdivisionOverride4,
                subdivisionOverride5,
                subdivisionOverride6)
        { }

        public OmnitreeBoundsLinked(
            Omnitree.GetBounds<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> getBounds,

            Compare<Axis1> compare1,
            Compare<Axis2> compare2,
            Compare<Axis3> compare3,
            Compare<Axis4> compare4,
            Compare<Axis5> compare5,
            Compare<Axis6> compare6)
            : this(
                getBounds,
                true,
                Towel.Equate.Default,

                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,

                false,
                compare1,
                false,
                compare2,
                false,
                compare3,
                false,
                compare4,
                false,
                compare5,
                false,
                compare6,

                null,
                null,
                null,
                null,
                null,
                null)
        { }

        public OmnitreeBoundsLinked(
            Omnitree.GetBounds<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> getBounds,

            Compare<Axis1> compare1,
            Compare<Axis2> compare2,
            Compare<Axis3> compare3,
            Compare<Axis4> compare4,
            Compare<Axis5> compare5,
            Compare<Axis6> compare6,

            Omnitree.SubdivisionOverride<T, Axis1, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>> subdivisionOverride1,
            Omnitree.SubdivisionOverride<T, Axis2, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>> subdivisionOverride2,
            Omnitree.SubdivisionOverride<T, Axis3, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>> subdivisionOverride3,
            Omnitree.SubdivisionOverride<T, Axis4, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>> subdivisionOverride4,
            Omnitree.SubdivisionOverride<T, Axis5, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>> subdivisionOverride5,
            Omnitree.SubdivisionOverride<T, Axis6, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>> subdivisionOverride6)
            : this(
                getBounds,

                true,
                Towel.Equate.Default,

                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,

                false,
                compare1,
                false,
                compare2,
                false,
                compare3,
                false,
                compare4,
                false,
                compare5,
                false,
                compare6,

                subdivisionOverride1,
                subdivisionOverride2,
                subdivisionOverride3,
                subdivisionOverride4,
                subdivisionOverride5,
                subdivisionOverride6)
        { }

        public OmnitreeBoundsLinked(
            Omnitree.GetBounds<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> getBounds,
            Equate<T> equate)
            : this(
                getBounds,

                false,
                equate,

                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,

                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,

                null,
                null,
                null,
                null,
                null,
                null)
        { }

        public OmnitreeBoundsLinked(
            Omnitree.GetBounds<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> getBounds,
            Equate<T> equate,
            Omnitree.SubdivisionOverride<T, Axis1, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>> subdivisionOverride1,
            Omnitree.SubdivisionOverride<T, Axis2, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>> subdivisionOverride2,
            Omnitree.SubdivisionOverride<T, Axis3, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>> subdivisionOverride3,
            Omnitree.SubdivisionOverride<T, Axis4, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>> subdivisionOverride4,
            Omnitree.SubdivisionOverride<T, Axis5, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>> subdivisionOverride5,
            Omnitree.SubdivisionOverride<T, Axis6, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>> subdivisionOverride6)
            : this(
                getBounds,

                false,
                equate,

                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,

                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,

                subdivisionOverride1,
                subdivisionOverride2,
                subdivisionOverride3,
                subdivisionOverride4,
                subdivisionOverride5,
                subdivisionOverride6)
        { }

        public OmnitreeBoundsLinked(
            Omnitree.GetBounds<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> getBounds)
            : this(
                getBounds,

                true,
                Towel.Equate.Default,

                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,

                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,

                null,
                null,
                null,
                null,
                null,
                null)
        { }

		public OmnitreeBoundsLinked(
            Omnitree.GetBoundings<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> getBoundings)
            : this(
                Omnitree.ConvertToGetBounds(getBoundings),

                true,
                Towel.Equate.Default,

                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,

                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,

                null,
                null,
                null,
                null,
                null,
                null)
        { }

        public OmnitreeBoundsLinked(
            Omnitree.GetBounds<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> getBounds,
            Omnitree.SubdivisionOverride<T, Axis1, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>> subdivisionOverride1,
            Omnitree.SubdivisionOverride<T, Axis2, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>> subdivisionOverride2,
            Omnitree.SubdivisionOverride<T, Axis3, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>> subdivisionOverride3,
            Omnitree.SubdivisionOverride<T, Axis4, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>> subdivisionOverride4,
            Omnitree.SubdivisionOverride<T, Axis5, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>> subdivisionOverride5,
            Omnitree.SubdivisionOverride<T, Axis6, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>> subdivisionOverride6)
            : this(
                getBounds,

                true,
                Towel.Equate.Default,

                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,

                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,

                subdivisionOverride1,
                subdivisionOverride2,
                subdivisionOverride3,
                subdivisionOverride4,
                subdivisionOverride5,
                subdivisionOverride6)
        { }

        #endregion

        #region Properties

        /// <summary>The number of dimensions in this tree.</summary>
        public int Dimensions { get { return _dimensions; } }

        /// <summary>The function for equating keys in this table.</summary>
        public Equate<T> Equate { get { return this._equate; } }

        /// <summary>The location function the Omnitree is using.</summary>
        public Omnitree.GetBounds<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> GetBounds { get { return this._getBounds; } }

        /// <summary>The comparison function the Omnitree is using along the 1D axis.</summary>
        public Compare<Axis1> Compare1 { get { return this._compare1; } }
        /// <summary>The comparison function the Omnitree is using along the 2D axis.</summary>
        public Compare<Axis2> Compare2 { get { return this._compare2; } }
        /// <summary>The comparison function the Omnitree is using along the 3D axis.</summary>
        public Compare<Axis3> Compare3 { get { return this._compare3; } }
        /// <summary>The comparison function the Omnitree is using along the 4D axis.</summary>
        public Compare<Axis4> Compare4 { get { return this._compare4; } }
        /// <summary>The comparison function the Omnitree is using along the 5D axis.</summary>
        public Compare<Axis5> Compare5 { get { return this._compare5; } }
        /// <summary>The comparison function the Omnitree is using along the 6D axis.</summary>
        public Compare<Axis6> Compare6 { get { return this._compare6; } }

        /// <summary>The function for equating values along the 1D axis.</summary>
        public Equate<Axis1> EquateAxis1 { get { return this._equate1; } }
        /// <summary>The function for equating values along the 2D axis.</summary>
        public Equate<Axis2> EquateAxis2 { get { return this._equate2; } }
        /// <summary>The function for equating values along the 3D axis.</summary>
        public Equate<Axis3> EquateAxis3 { get { return this._equate3; } }
        /// <summary>The function for equating values along the 4D axis.</summary>
        public Equate<Axis4> EquateAxis4 { get { return this._equate4; } }
        /// <summary>The function for equating values along the 5D axis.</summary>
        public Equate<Axis5> EquateAxis5 { get { return this._equate5; } }
        /// <summary>The function for equating values along the 6D axis.</summary>
        public Equate<Axis6> EquateAxis6 { get { return this._equate6; } }

        /// <summary>The current number of items in the tree.</summary>
        public int Count { get { return this._top.Count; } }

        private delegate void MaxDepthFinder(Node node, int current_depth, ref int max_depth);
        /// <summary>Finds the current maximum depth of the tree. NOT AN O(1) OPERATION. Intended for educational purposes only.</summary>
        public int MaxDepth
        {
            get
            {
                MaxDepthFinder maxDepthFinder = null;
                maxDepthFinder =
                        (Node node, int current_depth, ref int max_depth) =>
                        {
                            if (current_depth > max_depth)
                                max_depth = current_depth;
                            foreach (Node child in node.Children)
                                maxDepthFinder(child, current_depth + 1, ref max_depth);
                        };
                int _max_depth = -1;
                maxDepthFinder(this._top, 0, ref _max_depth);
                return _max_depth;
            }
        }

        private delegate void NodeCountFinder(Node node, ref int current_count);
        /// <summary>Counts the current number of nodes in the tree. NOT AN O(1) OPERATION. Intended for educational purposes only.</summary>
        public int NodeCount
        {
            get
            {
                NodeCountFinder nodeCountFinder = null;
                nodeCountFinder =
                        (Node node, ref int current_count) =>
                        {
                            current_count++;
                            foreach (Node child in node.Children)
                                nodeCountFinder(child, ref current_count);
                        };

                int _current_count = 0;
                nodeCountFinder(this._top, ref _current_count);
                return _current_count;
            }
        }

        #endregion

        #region Methods

        #region Add

        #region Bulk

		// not yet implemented

//        public void Add(IndexedBigArray<T> additions, bool allowMultithreading)
//        {
//            if (additions.Length > int.MaxValue)
//                throw new System.Exception("The maximum size of the Omnitree was exceeded during bulk addition.");
//
//            if (this._top.Count != 0 || (int)additions.Length <= _load)
//            {
//                for (ulong i = 0; i < additions.Length; i++)
//                    this.Add(additions[i]);
//            }
//            else
//            {
//                // adjust the loads prior to additions
//                ComputeLoads((int)additions.Length);
//
//                Node new_top = new Node(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>.None, null, -1);
//                new_top.Count = (int)additions.Length;
//
//
//                // prepare data for median computations
//                IndexedBigArray<Axis1> values1;
//                IAsyncResult result1 = null;
//                if (this._subdivisionOverride1 != null)
//                    values1 = null;
//                else
//                {
//                    values1 = null;
//                    Towel.Parallels.Parallel.Operation operation = () =>
//                    {
//                        values1 = new IndexedBigArray<Axis1>(additions.Length * 2);
//                        for (ulong i = 0; i < additions.Length; i++)
//						{
//							Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> bounds = GetBoundings(additions[i]);
//                            values1[i * 2] = bounds.Min1;
//							values1[i * 2 + 1] = bounds.Max1;
//						}
//
//                        Towel.Algorithms.Sort.Merge(this._compare1, (int i) => { return values1[(ulong)i]; }, (int i, Axis1 value) => { values1[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
//                    };
//
//                    if (allowMultithreading)
//                        result1 = Towel.Parallels.Parallel.Thread(operation);
//                    else
//                        operation();
//                }
//
//                // prepare data for median computations
//                IndexedBigArray<Axis2> values2;
//                IAsyncResult result2 = null;
//                if (this._subdivisionOverride2 != null)
//                    values2 = null;
//                else
//                {
//                    values2 = null;
//                    Towel.Parallels.Parallel.Operation operation = () =>
//                    {
//                        values2 = new IndexedBigArray<Axis2>(additions.Length * 2);
//                        for (ulong i = 0; i < additions.Length; i++)
//						{
//							Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> bounds = GetBoundings(additions[i]);
//                            values2[i * 2] = bounds.Min1;
//							values2[i * 2 + 1] = bounds.Max1;
//						}
//
//                        Towel.Algorithms.Sort.Merge(this._compare2, (int i) => { return values2[(ulong)i]; }, (int i, Axis2 value) => { values2[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
//                    };
//
//                    if (allowMultithreading)
//                        result2 = Towel.Parallels.Parallel.Thread(operation);
//                    else
//                        operation();
//                }
//
//                // prepare data for median computations
//                IndexedBigArray<Axis3> values3;
//                IAsyncResult result3 = null;
//                if (this._subdivisionOverride3 != null)
//                    values3 = null;
//                else
//                {
//                    values3 = null;
//                    Towel.Parallels.Parallel.Operation operation = () =>
//                    {
//                        values3 = new IndexedBigArray<Axis3>(additions.Length * 2);
//                        for (ulong i = 0; i < additions.Length; i++)
//						{
//							Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> bounds = GetBoundings(additions[i]);
//                            values3[i * 2] = bounds.Min1;
//							values3[i * 2 + 1] = bounds.Max1;
//						}
//
//                        Towel.Algorithms.Sort.Merge(this._compare3, (int i) => { return values3[(ulong)i]; }, (int i, Axis3 value) => { values3[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
//                    };
//
//                    if (allowMultithreading)
//                        result3 = Towel.Parallels.Parallel.Thread(operation);
//                    else
//                        operation();
//                }
//
//                // prepare data for median computations
//                IndexedBigArray<Axis4> values4;
//                IAsyncResult result4 = null;
//                if (this._subdivisionOverride4 != null)
//                    values4 = null;
//                else
//                {
//                    values4 = null;
//                    Towel.Parallels.Parallel.Operation operation = () =>
//                    {
//                        values4 = new IndexedBigArray<Axis4>(additions.Length * 2);
//                        for (ulong i = 0; i < additions.Length; i++)
//						{
//							Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> bounds = GetBoundings(additions[i]);
//                            values4[i * 2] = bounds.Min1;
//							values4[i * 2 + 1] = bounds.Max1;
//						}
//
//                        Towel.Algorithms.Sort.Merge(this._compare4, (int i) => { return values4[(ulong)i]; }, (int i, Axis4 value) => { values4[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
//                    };
//
//                    if (allowMultithreading)
//                        result4 = Towel.Parallels.Parallel.Thread(operation);
//                    else
//                        operation();
//                }
//
//                // prepare data for median computations
//                IndexedBigArray<Axis5> values5;
//                IAsyncResult result5 = null;
//                if (this._subdivisionOverride5 != null)
//                    values5 = null;
//                else
//                {
//                    values5 = null;
//                    Towel.Parallels.Parallel.Operation operation = () =>
//                    {
//                        values5 = new IndexedBigArray<Axis5>(additions.Length * 2);
//                        for (ulong i = 0; i < additions.Length; i++)
//						{
//							Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> bounds = GetBoundings(additions[i]);
//                            values5[i * 2] = bounds.Min1;
//							values5[i * 2 + 1] = bounds.Max1;
//						}
//
//                        Towel.Algorithms.Sort.Merge(this._compare5, (int i) => { return values5[(ulong)i]; }, (int i, Axis5 value) => { values5[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
//                    };
//
//                    if (allowMultithreading)
//                        result5 = Towel.Parallels.Parallel.Thread(operation);
//                    else
//                        operation();
//                }
//
//                // prepare data for median computations
//                IndexedBigArray<Axis6> values6;
//                IAsyncResult result6 = null;
//                if (this._subdivisionOverride6 != null)
//                    values6 = null;
//                else
//                {
//                    values6 = null;
//                    Towel.Parallels.Parallel.Operation operation = () =>
//                    {
//                        values6 = new IndexedBigArray<Axis6>(additions.Length * 2);
//                        for (ulong i = 0; i < additions.Length; i++)
//						{
//							Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> bounds = GetBoundings(additions[i]);
//                            values6[i * 2] = bounds.Min1;
//							values6[i * 2 + 1] = bounds.Max1;
//						}
//
//                        Towel.Algorithms.Sort.Merge(this._compare6, (int i) => { return values6[(ulong)i]; }, (int i, Axis6 value) => { values6[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
//                    };
//
//                    if (allowMultithreading)
//                        result6 = Towel.Parallels.Parallel.Thread(operation);
//                    else
//                        operation();
//                }
//
//
//
//                if (this._subdivisionOverride1 == null && allowMultithreading)
//                    result1.AsyncWaitHandle.WaitOne();
//                if (this._subdivisionOverride2 == null && allowMultithreading)
//                    result2.AsyncWaitHandle.WaitOne();
//                if (this._subdivisionOverride3 == null && allowMultithreading)
//                    result3.AsyncWaitHandle.WaitOne();
//                if (this._subdivisionOverride4 == null && allowMultithreading)
//                    result4.AsyncWaitHandle.WaitOne();
//                if (this._subdivisionOverride5 == null && allowMultithreading)
//                    result5.AsyncWaitHandle.WaitOne();
//                if (this._subdivisionOverride6 == null && allowMultithreading)
//                    result6.AsyncWaitHandle.WaitOne();
//
//                // build the tree
//                Add(new_top, 1, -1, additions.Stepper(), (int)additions.Length, int.MinValue, int.MinValue, int.MinValue, int.MinValue, int.MinValue, int.MinValue, (int)additions.Length, (int index) => { return values1[index]; }, (int index) => { return values2[index]; }, (int index) => { return values3[index]; }, (int index) => { return values4[index]; }, (int index) => { return values5[index]; }, (int index) => { return values6[index]; }, allowMultithreading);
//                
//                this._top = new_top;
//            }
//        }
//
//        public void Add(bool allowMultithreading, params T[] additions)
//        {
//            if (additions.Length > int.MaxValue)
//                throw new System.Exception("The maximum size of the Omnitree was exceeded during bulk addition.");
//
//            if (this._top.Count != 0 || (int)additions.Length <= _load)
//            {
//                for (int i = 0; i < additions.Length; i++)
//                    this.Add(additions[i]);
//            }
//            else
//            {
//                // adjust the loads prior to additions
//                ComputeLoads((int)additions.Length);
//
//                Node new_top = new Node(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>.None, null, -1);
//                new_top.Count = (int)additions.Length;
//
//
//                // prepare data for median computations
//                IndexedBigArray<Axis1> values1;
//                IAsyncResult result1 = null;
//                if (this._subdivisionOverride1 != null)
//                    values1 = null;
//                else
//                {
//                    values1 = null;
//                    Towel.Parallels.Parallel.Operation operation = () =>
//                    {
//                        values1 = new IndexedBigArray<Axis1>(additions.Length);
//                        for (int i = 0; i < additions.Length; i++)
//                            values1[i] = LocateVector(additions[i]).Axis1;
//                        Towel.Algorithms.Sort.Merge(this._compare1, (int i) => { return values1[(ulong)i]; }, (int i, Axis1 value) => { values1[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
//                    };
//
//                    if (allowMultithreading)
//                        result1 = Towel.Parallels.Parallel.Thread(operation);
//                    else
//                        operation();
//                }
//
//                // prepare data for median computations
//                IndexedBigArray<Axis2> values2;
//                IAsyncResult result2 = null;
//                if (this._subdivisionOverride2 != null)
//                    values2 = null;
//                else
//                {
//                    values2 = null;
//                    Towel.Parallels.Parallel.Operation operation = () =>
//                    {
//                        values2 = new IndexedBigArray<Axis2>(additions.Length);
//                        for (int i = 0; i < additions.Length; i++)
//                            values2[i] = LocateVector(additions[i]).Axis2;
//                        Towel.Algorithms.Sort.Merge(this._compare2, (int i) => { return values2[(ulong)i]; }, (int i, Axis2 value) => { values2[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
//                    };
//
//                    if (allowMultithreading)
//                        result2 = Towel.Parallels.Parallel.Thread(operation);
//                    else
//                        operation();
//                }
//
//                // prepare data for median computations
//                IndexedBigArray<Axis3> values3;
//                IAsyncResult result3 = null;
//                if (this._subdivisionOverride3 != null)
//                    values3 = null;
//                else
//                {
//                    values3 = null;
//                    Towel.Parallels.Parallel.Operation operation = () =>
//                    {
//                        values3 = new IndexedBigArray<Axis3>(additions.Length);
//                        for (int i = 0; i < additions.Length; i++)
//                            values3[i] = LocateVector(additions[i]).Axis3;
//                        Towel.Algorithms.Sort.Merge(this._compare3, (int i) => { return values3[(ulong)i]; }, (int i, Axis3 value) => { values3[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
//                    };
//
//                    if (allowMultithreading)
//                        result3 = Towel.Parallels.Parallel.Thread(operation);
//                    else
//                        operation();
//                }
//
//                // prepare data for median computations
//                IndexedBigArray<Axis4> values4;
//                IAsyncResult result4 = null;
//                if (this._subdivisionOverride4 != null)
//                    values4 = null;
//                else
//                {
//                    values4 = null;
//                    Towel.Parallels.Parallel.Operation operation = () =>
//                    {
//                        values4 = new IndexedBigArray<Axis4>(additions.Length);
//                        for (int i = 0; i < additions.Length; i++)
//                            values4[i] = LocateVector(additions[i]).Axis4;
//                        Towel.Algorithms.Sort.Merge(this._compare4, (int i) => { return values4[(ulong)i]; }, (int i, Axis4 value) => { values4[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
//                    };
//
//                    if (allowMultithreading)
//                        result4 = Towel.Parallels.Parallel.Thread(operation);
//                    else
//                        operation();
//                }
//
//                // prepare data for median computations
//                IndexedBigArray<Axis5> values5;
//                IAsyncResult result5 = null;
//                if (this._subdivisionOverride5 != null)
//                    values5 = null;
//                else
//                {
//                    values5 = null;
//                    Towel.Parallels.Parallel.Operation operation = () =>
//                    {
//                        values5 = new IndexedBigArray<Axis5>(additions.Length);
//                        for (int i = 0; i < additions.Length; i++)
//                            values5[i] = LocateVector(additions[i]).Axis5;
//                        Towel.Algorithms.Sort.Merge(this._compare5, (int i) => { return values5[(ulong)i]; }, (int i, Axis5 value) => { values5[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
//                    };
//
//                    if (allowMultithreading)
//                        result5 = Towel.Parallels.Parallel.Thread(operation);
//                    else
//                        operation();
//                }
//
//                // prepare data for median computations
//                IndexedBigArray<Axis6> values6;
//                IAsyncResult result6 = null;
//                if (this._subdivisionOverride6 != null)
//                    values6 = null;
//                else
//                {
//                    values6 = null;
//                    Towel.Parallels.Parallel.Operation operation = () =>
//                    {
//                        values6 = new IndexedBigArray<Axis6>(additions.Length);
//                        for (int i = 0; i < additions.Length; i++)
//                            values6[i] = LocateVector(additions[i]).Axis6;
//                        Towel.Algorithms.Sort.Merge(this._compare6, (int i) => { return values6[(ulong)i]; }, (int i, Axis6 value) => { values6[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
//                    };
//
//                    if (allowMultithreading)
//                        result6 = Towel.Parallels.Parallel.Thread(operation);
//                    else
//                        operation();
//                }
//
//
//
//                if (this._subdivisionOverride1 == null && allowMultithreading)
//                    result1.AsyncWaitHandle.WaitOne();
//
//                if (this._subdivisionOverride2 == null && allowMultithreading)
//                    result2.AsyncWaitHandle.WaitOne();
//
//                if (this._subdivisionOverride3 == null && allowMultithreading)
//                    result3.AsyncWaitHandle.WaitOne();
//
//                if (this._subdivisionOverride4 == null && allowMultithreading)
//                    result4.AsyncWaitHandle.WaitOne();
//
//                if (this._subdivisionOverride5 == null && allowMultithreading)
//                    result5.AsyncWaitHandle.WaitOne();
//
//                if (this._subdivisionOverride6 == null && allowMultithreading)
//                    result6.AsyncWaitHandle.WaitOne();
//
//
//                // build the tree
//                Add(new_top, 1, -1, additions.Stepper(), additions.Length, int.MinValue, int.MinValue, int.MinValue, int.MinValue, int.MinValue, int.MinValue, (int)additions.Length, (int index) => { return values1[index]; }, (int index) => { return values2[index]; }, (int index) => { return values3[index]; }, (int index) => { return values4[index]; }, (int index) => { return values5[index]; }, (int index) => { return values6[index]; }, allowMultithreading);
//                
//                this._top = new_top;
//            }
//        }
//
//        
//        private int Add(Node parent, int depth, int child, Stepper<T> additions, int parent_count, int prevmed1, int prevmed2, int prevmed3, int prevmed4, int prevmed5, int prevmed6, int initial_count, Get<Axis1> values1, Get<Axis2> values2, Get<Axis3> values3, Get<Axis4> values4, Get<Axis5> values5, Get<Axis6> values6, bool allowMultithreading)
//        {
//            Axis1 pointOfDivision1;
//            Axis2 pointOfDivision2;
//            Axis3 pointOfDivision3;
//            Axis4 pointOfDivision4;
//            Axis5 pointOfDivision5;
//            Axis6 pointOfDivision6;
//
//            int median_axis1 = -1;
//            int median_axis2 = -1;
//            int median_axis3 = -1;
//            int median_axis4 = -1;
//            int median_axis5 = -1;
//            int median_axis6 = -1;
//            if (this._subdivisionOverride1 == null || this._subdivisionOverride2 == null || this._subdivisionOverride3 == null || this._subdivisionOverride4 == null || this._subdivisionOverride5 == null || this._subdivisionOverride6 == null)
//                GetMedianIndexes(initial_count, child, depth, prevmed1, prevmed2, prevmed3, prevmed4, prevmed5, prevmed6, out median_axis1, out median_axis2, out median_axis3, out median_axis4, out median_axis5, out median_axis6);
//
//            if (this._subdivisionOverride1 != null)
//                pointOfDivision1 = this._subdivisionOverride1(parent.Bounds, additions);
//            else
//                pointOfDivision1 = values1(median_axis1);
//
//            if (this._subdivisionOverride2 != null)
//                pointOfDivision2 = this._subdivisionOverride2(parent.Bounds, additions);
//            else
//                pointOfDivision2 = values2(median_axis2);
//
//            if (this._subdivisionOverride3 != null)
//                pointOfDivision3 = this._subdivisionOverride3(parent.Bounds, additions);
//            else
//                pointOfDivision3 = values3(median_axis3);
//
//            if (this._subdivisionOverride4 != null)
//                pointOfDivision4 = this._subdivisionOverride4(parent.Bounds, additions);
//            else
//                pointOfDivision4 = values4(median_axis4);
//
//            if (this._subdivisionOverride5 != null)
//                pointOfDivision5 = this._subdivisionOverride5(parent.Bounds, additions);
//            else
//                pointOfDivision5 = values5(median_axis5);
//
//            if (this._subdivisionOverride6 != null)
//                pointOfDivision6 = this._subdivisionOverride6(parent.Bounds, additions);
//            else
//                pointOfDivision6 = values6(median_axis6);
//
//            parent.PointOfDivision = new Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>(pointOfDivision1, pointOfDivision2, pointOfDivision3, pointOfDivision4, pointOfDivision5, pointOfDivision6);
//
//            // divide the values along the medians
//            IMap<IAddable<T>, int> collection_map = new MapHashLinked<IAddable<T>, int>();
//            additions((T value) => 
//            {
//                int index = DetermineChildIndex(parent.PointOfDivision.Value, LocateVector(value));
//                IAddable<T> list = null;
//                if (collection_map.TryGet(index, out list))
//                {
//                    list.Add(value);
//                }
//                else
//                {
//                    if (parent_count < 100000)
//                        list = new AddableArray<T>();
//                    else
//                        list = new AddableLinked<T>();
//                    collection_map.Add(index, list);
//                    list.Add(value);
//                }
//            });
//
//            if (depth == 1 && allowMultithreading)
//            {
//                // NOTE: Must assign placeholders before multithreading so that the threads do not overwrite each other
//                collection_map.Keys((int key) => { parent[key] = new Node(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>.None, parent, key); });
//                IAsyncResult[] handles = new IAsyncResult[Environment.ProcessorCount];
//                for (int i = 0; i < handles.Length; i++)
//                {
//                    int multiTheadSafe_i = i; // used as catpure variable below making it multithread-safe
//                    handles[i] = Towel.Parallels.Parallel.Thread(() =>
//                    {
//                        Step.EveryNth<Link<IAddable<T>, int>>(collection_map.Pairs, multiTheadSafe_i + 1)(
//                        (Link<IAddable<T>, int> link) =>
//                            {
//                                ReversedChildBuilding(parent, link._2, depth, link._1.Stepper, link._1.Count, median_axis1, median_axis2, median_axis3, median_axis4, median_axis5, median_axis6, initial_count, values1, values2, values3, values4, values5, values6, allowMultithreading);
//                            });
//                    });
//                }
//                
//                foreach (IAsyncResult handle in handles)
//                {
//                    handle.AsyncWaitHandle.WaitOne();
//                }
//            }
//            else
//            {
//                collection_map.Pairs((Link<IAddable<T>, int> link) =>
//                { 
//                    ReversedChildBuilding(parent, link._2, depth, link._1.Stepper, link._1.Count, median_axis1, median_axis2, median_axis3, median_axis4, median_axis5, median_axis6, initial_count, values1, values2, values3, values4, values5, values6, allowMultithreading);
//                });
//            }
//
//            int count = 0;
//            foreach (Node node in parent.Children)
//                count += node.Count;
//            return count;
//        }
//
//        int ReversedChildBuilding(Node parent, int child_index, int depth, Stepper<T> additions, int count, int prevmed1, int prevmed2, int prevmed3, int prevmed4, int prevmed5, int prevmed6, int initial_count, Get<Axis1> values1, Get<Axis2> values2, Get<Axis3> values3, Get<Axis4> values4, Get<Axis5> values5, Get<Axis6> values6, bool allowMultithreading)
//        {
//            Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> child_bounds = DetermineChildBounds(parent, child_index);
//            if (depth >= _load || count <= _load)
//            {
//                Node new_leaf = new Node(child_bounds, parent, child_index);
//                additions((T value) => { new_leaf.Add(value); });
//                parent[new_leaf.Index] = new_leaf;
//                return new_leaf.Count;
//            }
//            else
//            {
//                Node new_branch = new Node(Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>.Default, child_bounds, parent, child_index);
//                parent[new_branch.Index] = new_branch;
//                new_branch.Count = Add(new_branch, depth + 1, child_index, additions, count, prevmed1, prevmed2, prevmed3, prevmed4, prevmed5, prevmed6, count, values1, values2, values3, values4, values5, values6, allowMultithreading);
//                return new_branch.Count;
//            }
//        }
//
//        /// <summary>Gets the indeces of the median values at the given position during bulk additions.</summary>
//        private void GetMedianIndexes(int count, int child_index, int depth, int previous1, int previous2, int previous3, int previous4, int previous5, int previous6, out int index1, out int index2, out int index3, out int index4, out int index5, out int index6)
//        {
//            if (depth == 1)
//            {
//                index1 = (count - 1) / 2;
//                index2 = (count - 1) / 2;
//                index3 = (count - 1) / 2;
//                index4 = (count - 1) / 2;
//                index5 = (count - 1) / 2;
//                index6 = (count - 1) / 2;
//                return;
//            }
//
//            int splits = Compute.Power(2, depth);
//            int mid_child_range = count / splits;
//
//            if (child_index >= 32)
//            {
//                index6 = previous6 + mid_child_range;
//                child_index -= 32;
//            }
//            else
//            {
//                index6 = previous6 - mid_child_range;
//            }
//
//            if (child_index >= 16)
//            {
//                index5 = previous5 + mid_child_range;
//                child_index -= 16;
//            }
//            else
//            {
//                index5 = previous5 - mid_child_range;
//            }
//
//            if (child_index >= 8)
//            {
//                index4 = previous4 + mid_child_range;
//                child_index -= 8;
//            }
//            else
//            {
//                index4 = previous4 - mid_child_range;
//            }
//
//            if (child_index >= 4)
//            {
//                index3 = previous3 + mid_child_range;
//                child_index -= 4;
//            }
//            else
//            {
//                index3 = previous3 - mid_child_range;
//            }
//
//            if (child_index >= 2)
//            {
//                index2 = previous2 + mid_child_range;
//                child_index -= 2;
//            }
//            else
//            {
//                index2 = previous2 - mid_child_range;
//            }
//
//            if (child_index >= 1)
//            {
//                index1 = previous1 + mid_child_range;
//                child_index -= 1;
//            }
//            else
//            {
//                index1 = previous1 - mid_child_range;
//            }
//
//        }

		

        #endregion

        #region single

        /// <summary>Adds an item to the tree.</summary>
        /// <param name="addition">The item to be added.</param>
        public void Add(T addition)
        {
            if (this._top.Count == int.MaxValue)
                throw new System.InvalidOperationException("(Count == int.MaxValue) max Omnitree size reached (change ints to longs if you need to).");

            // dynamic tree sizes
            Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);

            Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> bounds = GetBoundings(addition);

            // grow the first branch of the tree
            if (!this._top.PointOfDivision.HasValue && this._top.Count >= _load)
            {
                Node top = this._top;

                // create the new branch from the median values
                this._top = new Node(DetermineMedians(top), Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>.None, null, -1);

                // iterate through the elements and add them to the appropriate children
                for (Node.ValueNode list = top.Head; list != null; list = list.Next)
                    Add(list.Value, this._top, GetBoundings(list.Value), 0);
            }

            this.Add(addition, this._top, bounds, 0);
        }
        
        /// <summary>Recursive version of the add function.</summary>
        /// <param name="addition">The item to be added.</param>
        /// <param name="node">The current node for tree trversal.</param>
        /// <param name="ms">The location of the addition.</param>
        /// <param name="depth">The current depth of iteration.</param>
        private void Add(T addition, Node node, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> bounds, int depth)
        {
            if (!node.PointOfDivision.HasValue)
            {
                //Leaf leaf = node as Leaf;
                if (depth >= _load || !(node.Count >= _load))
                {
                    node.Add(addition);
                    return;
                }
                else
                {
                    //Node parent = node.Parent;
                    //int child_index = this.DetermineChildIndex(parent.PointOfDivision, location);
                    //Node growth = new Node(DetermineMedians(leaf), leaf.Bounds, parent, child_index);
                    //parent[child_index] = growth;

					Node growth = new Node(DetermineMedians(node), node.Bounds, node.Parent, node.Index);
                    node.Parent[node.Index] = growth;

                    for (Node.ValueNode list = node.Head; list != null; list = list.Next)
                    {
                        Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> temp_bounds = GetBoundings(list.Value);
                        if (EncapsulationCheck(growth.Bounds, temp_bounds))
                            Add(list.Value, growth, temp_bounds, depth);
                        else
                        {
                            ReduceParentCounts(node.Parent, 1);
                            Add(list.Value, this._top, temp_bounds, depth);
                        }
                    }

                    Add(addition, growth, bounds, depth);
                    return;
                }
            }
            else
            {
                //Node branch = node as Node;
                int child_index = this.DetermineChildIndex(node.PointOfDivision.Value, bounds); // determine the child "index" (0 through 2^Dimensions) the addition belongs in
                
				// if -1, then the bounds of the addition straddle the point of division (keep it in current node)
				if (child_index == -1)
				{
					node.Add(addition);
                    return;
				}
				
				Node child_node = node[child_index];

                // null children in branches are just empty leaves
                if (child_node == null)
                {
                    Node new_node = new Node(DetermineChildBounds(node, child_index), node, child_index);
                    node[child_index] = new_node;
                    new_node.Add(addition);
                }
                else
                    // child exists already, continue adding
                    Add(addition, child_node, bounds, depth + 1);

                node.Count++;
                return;
            }
        }

        /// <summary>Determins the dimensions of the child at the given index.</summary>
        /// <param name="leaf">The parent of the node to compute dimensions for.</param>
        /// <param name="child">The index of the child to compute dimensions for.</param>
        /// <param name="median1">The computed minimum dimensions of the child node along the 1D axis.</param>
        /// <param name="median2">The computed minimum dimensions of the child node along the 2D axis.</param>
        /// <param name="median3">The computed minimum dimensions of the child node along the 3D axis.</param>
        private Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> DetermineMedians(Node node)
        {
            try
            {
                // extract the values
                Omnitree.Bound<Axis1>[] values1 = new Omnitree.Bound<Axis1>[node.Count * 2];
                Omnitree.Bound<Axis2>[] values2 = new Omnitree.Bound<Axis2>[node.Count * 2];
                Omnitree.Bound<Axis3>[] values3 = new Omnitree.Bound<Axis3>[node.Count * 2];
                Omnitree.Bound<Axis4>[] values4 = new Omnitree.Bound<Axis4>[node.Count * 2];
                Omnitree.Bound<Axis5>[] values5 = new Omnitree.Bound<Axis5>[node.Count * 2];
                Omnitree.Bound<Axis6>[] values6 = new Omnitree.Bound<Axis6>[node.Count * 2];
                Node.ValueNode for_current = node.Head; // used in for loop
                for (int i = 0; i < node.Count; i++, for_current = for_current.Next)
                    this._getBounds(for_current.Value, 
					out values1[i * 2], out values1[i * 2 + 1], 
					out values2[i * 2], out values2[i * 2 + 1], 
					out values3[i * 2], out values3[i * 2 + 1], 
					out values4[i * 2], out values4[i * 2 + 1], 
					out values5[i * 2], out values5[i * 2 + 1], 
					out values6[i * 2], out values6[i * 2 + 1]);
                return new Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>(
					Omnitree.SubDivide(values1, this._defaultCompare1 ? Compare.Default : this._compare1), 
					Omnitree.SubDivide(values2, this._defaultCompare2 ? Compare.Default : this._compare2), 
					Omnitree.SubDivide(values3, this._defaultCompare3 ? Compare.Default : this._compare3), 
					Omnitree.SubDivide(values4, this._defaultCompare4 ? Compare.Default : this._compare4), 
					Omnitree.SubDivide(values5, this._defaultCompare5 ? Compare.Default : this._compare5), 
					Omnitree.SubDivide(values6, this._defaultCompare6 ? Compare.Default : this._compare6));
            }
            catch
            {
                // extract the values
                IndexedBigArray<Omnitree.Bound<Axis1>> values1 = new IndexedBigArray<Omnitree.Bound<Axis1>>(node.Count * 2);
                IndexedBigArray<Omnitree.Bound<Axis2>> values2 = new IndexedBigArray<Omnitree.Bound<Axis2>>(node.Count * 2);
                IndexedBigArray<Omnitree.Bound<Axis3>> values3 = new IndexedBigArray<Omnitree.Bound<Axis3>>(node.Count * 2);
                IndexedBigArray<Omnitree.Bound<Axis4>> values4 = new IndexedBigArray<Omnitree.Bound<Axis4>>(node.Count * 2);
                IndexedBigArray<Omnitree.Bound<Axis5>> values5 = new IndexedBigArray<Omnitree.Bound<Axis5>>(node.Count * 2);
                IndexedBigArray<Omnitree.Bound<Axis6>> values6 = new IndexedBigArray<Omnitree.Bound<Axis6>>(node.Count * 2);
                Node.ValueNode for_current = node.Head; // used in for loop
                for (int i = 0; i < node.Count; i++, for_current = for_current.Next)
                {
                    Omnitree.Bound<Axis1> min1; Omnitree.Bound<Axis1> max1;
                    Omnitree.Bound<Axis2> min2; Omnitree.Bound<Axis2> max2;
                    Omnitree.Bound<Axis3> min3; Omnitree.Bound<Axis3> max3;
                    Omnitree.Bound<Axis4> min4; Omnitree.Bound<Axis4> max4;
                    Omnitree.Bound<Axis5> min5; Omnitree.Bound<Axis5> max5;
                    Omnitree.Bound<Axis6> min6; Omnitree.Bound<Axis6> max6;
                    this._getBounds(for_current.Value,
						out min1, out max1,
						out min2, out max2,
						out min3, out max3,
						out min4, out max4,
						out min5, out max5,
						out min6, out max6);
                    values1[i * 2] = min1; values1[i * 2 + 1] = max1;
                    values2[i * 2] = min2; values2[i * 2 + 1] = max2;
                    values3[i * 2] = min3; values3[i * 2 + 1] = max3;
                    values4[i * 2] = min4; values4[i * 2 + 1] = max4;
                    values5[i * 2] = min5; values5[i * 2 + 1] = max5;
                    values6[i * 2] = min6; values6[i * 2 + 1] = max6;
                }
				return new Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>(
					Omnitree.SubDivide(values1, this._defaultCompare1 ? Compare.Default : this._compare1), 
					Omnitree.SubDivide(values2, this._defaultCompare2 ? Compare.Default : this._compare2), 
					Omnitree.SubDivide(values3, this._defaultCompare3 ? Compare.Default : this._compare3), 
					Omnitree.SubDivide(values4, this._defaultCompare4 ? Compare.Default : this._compare4), 
					Omnitree.SubDivide(values5, this._defaultCompare5 ? Compare.Default : this._compare5), 
					Omnitree.SubDivide(values6, this._defaultCompare6 ? Compare.Default : this._compare6));
            }
        }

        #endregion

        #region Add Helpers

        private Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> DetermineChildBounds(Node node, int child_index)
        {
			// the node parameter should always have a point of division value for this function
			Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> pointOfDivision = node.PointOfDivision.Value;

            Omnitree.Bound<Axis6> min6, max6;
            if (child_index >= 32)
            {
                min6 = pointOfDivision.Axis6;
                max6 = node.Bounds.Max6;
                child_index -= 32;
            }
            else
            {
                min6 = node.Bounds.Min6;
                max6 = pointOfDivision.Axis6;
            }

            Omnitree.Bound<Axis5> min5, max5;
            if (child_index >= 16)
            {
                min5 = pointOfDivision.Axis5;
                max5 = node.Bounds.Max5;
                child_index -= 16;
            }
            else
            {
                min5 = node.Bounds.Min5;
                max5 = pointOfDivision.Axis5;
            }

            Omnitree.Bound<Axis4> min4, max4;
            if (child_index >= 8)
            {
                min4 = pointOfDivision.Axis4;
                max4 = node.Bounds.Max4;
                child_index -= 8;
            }
            else
            {
                min4 = node.Bounds.Min4;
                max4 = pointOfDivision.Axis4;
            }

            Omnitree.Bound<Axis3> min3, max3;
            if (child_index >= 4)
            {
                min3 = pointOfDivision.Axis3;
                max3 = node.Bounds.Max3;
                child_index -= 4;
            }
            else
            {
                min3 = node.Bounds.Min3;
                max3 = pointOfDivision.Axis3;
            }

            Omnitree.Bound<Axis2> min2, max2;
            if (child_index >= 2)
            {
                min2 = pointOfDivision.Axis2;
                max2 = node.Bounds.Max2;
                child_index -= 2;
            }
            else
            {
                min2 = node.Bounds.Min2;
                max2 = pointOfDivision.Axis2;
            }

            Omnitree.Bound<Axis1> min1, max1;
            if (child_index >= 1)
            {
                min1 = pointOfDivision.Axis1;
                max1 = node.Bounds.Max1;
                child_index -= 1;
            }
            else
            {
                min1 = node.Bounds.Min1;
                max1 = pointOfDivision.Axis1;
            }

            return new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6);
        }

        #endregion

        #endregion

        #region Clear

        /// <summary>Returns the tree to an empty state.</summary>
        public void Clear()
        {
            this._top = new Node(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>.None, null, -1);
            Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
        }

        #endregion

        #region Clone

        /// <summary>Creates a shallow clone of this data structure.</summary>
        /// <returns>A shallow clone of this data structure.</returns>
        public OmnitreeBoundsLinked<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> Clone()
        {
            return new OmnitreeBoundsLinked<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>(this);
        }

        #endregion

        #region Count

        /// <summary>Counts the number of items encapsulated by a sub space.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
        /// <returns>The number of items in the provided sub space.</returns>
        public int CountSubSpaceEncapsulated(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5, Axis6 min6, Axis6 max6)
        {
            return CountSubSpaceEncapsulated(_top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6));
        }
        /// <summary>Counts the number of items encapsulated by a sub space.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
        /// <returns>The number of items in the provided sub space.</returns>
        public int CountSubSpaceEncapsulated(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5, Omnitree.Bound<Axis6> min6, Omnitree.Bound<Axis6> max6)
        {
            return CountSubSpaceEncapsulated(_top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6));
        }
        /// <summary>Counts the number of items encapsulated by a sub space.</summary>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
		/// <param name="axis5">The coordinate along the 5D axis.</param>
		/// <param name="axis6">The coordinate along the 6D axis.</param>
        /// <returns>The number of items in the provided sub space.</returns>
        public int CountSubSpaceEncapsulated(Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Axis5 axis5, Axis6 axis6)
        {
            return CountSubSpaceEncapsulated(_top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>(axis1, axis1, axis2, axis2, axis3, axis3, axis4, axis4, axis5, axis5, axis6, axis6));
        }
        /// <summary>Counts the number of items encapsulated by a sub space.</summary>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
		/// <param name="axis5">The coordinate along the 5D axis.</param>
		/// <param name="axis6">The coordinate along the 6D axis.</param>
        /// <returns>The number of items in the provided sub space.</returns>
        public int CountSubSpaceEncapsulated(Omnitree.Bound<Axis1> axis1, Omnitree.Bound<Axis2> axis2, Omnitree.Bound<Axis3> axis3, Omnitree.Bound<Axis4> axis4, Omnitree.Bound<Axis5> axis5, Omnitree.Bound<Axis6> axis6)
        {
            return CountSubSpaceEncapsulated(_top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>(axis1, axis1, axis2, axis2, axis3, axis3, axis4, axis4, axis5, axis5, axis6, axis6));
        }

        /// <summary>Counts the number of items overlapped by a sub space.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
        /// <returns>The number of items in the provided sub space.</returns>
        public int CountSubSpaceOverlapped(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5, Axis6 min6, Axis6 max6)
        {
            return CountSubSpaceOverlapped(_top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6));
        }
        /// <summary>Counts the number of items overlapped by a sub space.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
        /// <returns>The number of items in the provided sub space.</returns>
        public int CountSubSpaceOverlapped(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5, Omnitree.Bound<Axis6> min6, Omnitree.Bound<Axis6> max6)
        {
            return CountSubSpaceOverlapped(_top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6));
        }
        /// <summary>Counts the number of items overlapped by a sub space.</summary>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
		/// <param name="axis5">The coordinate along the 5D axis.</param>
		/// <param name="axis6">The coordinate along the 6D axis.</param>
        /// <returns>The number of items in the provided sub space.</returns>
        public int CountSubSpaceOverlapped(Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Axis5 axis5, Axis6 axis6)
        {
            return CountSubSpaceOverlapped(_top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>(axis1, axis1, axis2, axis2, axis3, axis3, axis4, axis4, axis5, axis5, axis6, axis6));
        }
        /// <summary>Counts the number of items overlapped by a sub space.</summary>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
		/// <param name="axis5">The coordinate along the 5D axis.</param>
		/// <param name="axis6">The coordinate along the 6D axis.</param>
        /// <returns>The number of items in the provided sub space.</returns>
        public int CountSubSpaceOverlapped(Omnitree.Bound<Axis1> axis1, Omnitree.Bound<Axis2> axis2, Omnitree.Bound<Axis3> axis3, Omnitree.Bound<Axis4> axis4, Omnitree.Bound<Axis5> axis5, Omnitree.Bound<Axis6> axis6)
        {
            return CountSubSpaceOverlapped(_top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>(axis1, axis1, axis2, axis2, axis3, axis3, axis4, axis4, axis5, axis5, axis6, axis6));
        }

		private int CountSubSpaceEncapsulated(Node node, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> bounds)
		{
			return CountSubSpaceBase(_top, bounds, (a, b) => EncapsulationCheck(a, b));
		}

		private int CountSubSpaceOverlapped(Node node, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> bounds)
		{
			return CountSubSpaceBase(_top, bounds, (a, b) => InclusionCheck(a, b));
		}

		private int CountSubSpaceBase(
			Node node,
			Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> bounds,
			Omnitree.SpatialCheck<Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>> spatialCheck)
        {
            // adjust min/max values
            int count = 0;
            if (EncapsulationCheck(bounds, node.Bounds))
                count += node.Count;
            else if (!node.PointOfDivision.HasValue)
            {
                for (Node.ValueNode list = node.Head; list != null; list = list.Next)
                    if (spatialCheck(bounds, GetBoundings(list.Value)))
                        count++;
            }
            else
            {
                Node branch = node as Node;
                if (!StraddlesLines(branch.Bounds, branch.PointOfDivision.Value))
                {
                    int child_index = DetermineChildIndex(branch.PointOfDivision.Value, bounds);
                    Node child = branch[child_index];
                    if (child != null)
                      count += this.CountSubSpaceBase(child, bounds, spatialCheck);
                }
                else
                {
                    foreach (Node child in node.Children)
                        count += this.CountSubSpaceBase(child, bounds, spatialCheck);
                }
            }
            return count;
        }

        #endregion

        #region Update

        /// <summary>Iterates through the entire tree and ensures each item is in the proper leaf.</summary>
        public void Update()
        {
            this.Update(this._top, 0);
        }

        /// <summary>Recursive version of the Update method.</summary>
        /// <param name="node">The current node of iteration.</param>
        /// <param name="depth">The current depth of iteration.</param>
        private int Update(Node node, int depth)
        {
			// I messed up this function in the conversion
			throw new System.NotImplementedException();

            int removals = 0;

            if (!node.PointOfDivision.HasValue)
            {
                Node.ValueNode current = node.Head;
                Node.ValueNode previous = null;
                while (current != null)
                {
                    Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> bounds = GetBoundings(current.Value);
                    if (!this.EncapsulationCheck(node.Bounds, bounds))
                    {
                        removals++;
                        T updated = current.Value;
                        if (previous == null)
                        {
                            node.Head = current.Next;
                            goto HeadRemoved;
                        }
                        else
                            previous.Next = current.Next;

                        Node whereToAdd = GetEncapsulationParent(node.Parent, bounds);

                        if (whereToAdd == null)
                            throw new System.Exception("an item was updated outside the range of the omnitree");

                        this.Add(updated, whereToAdd, bounds, whereToAdd.Depth);
                    }
                    previous = current;
                HeadRemoved:
                    current = current.Next;
                }
                node.Count -= removals;
                return removals;
            }
            else
            {
                Node branch = node as Node;
                int skipped = 0;
                for (int i = 0; i + skipped < branch.Children.Length; )
                {
                    removals += this.Update(branch.Children[i], depth + 1);
                    if (branch.Children[i].Count == 0)
                        branch.Children[i] = branch.Children[branch.Children.Length - skipped++ - 1];
                    else
                        i++;
                }
                Node[] newArray = new Node[branch.Children.Length - skipped];
                Array.Copy(branch.Children, newArray, newArray.Length);
                branch.Children = newArray;

                branch.Count -= removals;

                if (branch.Count < _load && branch.Count != 0)
                    ShrinkChild(branch.Parent, branch.Index);
            }

            return removals;
        }

        /// <summary>Iterates through the provided dimensions and ensures each item is in the proper leaf.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
        public void Update(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5, Axis6 min6, Axis6 max6)
        {
            this.Update(new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6), this._top, 0);
        }
        /// <summary>Iterates through the provided dimensions and ensures each item is in the proper leaf.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
        public void Update(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5, Omnitree.Bound<Axis6> min6, Omnitree.Bound<Axis6> max6)
        {
            this.Update(new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6), this._top, 0);
        }
        /// <summary>Iterates through the provided dimensions and ensures each item is in the proper leaf.</summary>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
		/// <param name="axis5">The coordinate along the 5D axis.</param>
		/// <param name="axis6">The coordinate along the 6D axis.</param>
        public void Update(Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Axis5 axis5, Axis6 axis6)
        {
            this.Update(new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>(axis1, axis1, axis2, axis2, axis3, axis3, axis4, axis4, axis5, axis5, axis6, axis6), this._top, 0);
        }
        /// <summary>Iterates through the provided dimensions and ensures each item is in the proper leaf.</summary>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
		/// <param name="axis5">The coordinate along the 5D axis.</param>
		/// <param name="axis6">The coordinate along the 6D axis.</param>
        public void Update(Omnitree.Bound<Axis1> axis1, Omnitree.Bound<Axis2> axis2, Omnitree.Bound<Axis3> axis3, Omnitree.Bound<Axis4> axis4, Omnitree.Bound<Axis5> axis5, Omnitree.Bound<Axis6> axis6)
        {
            this.Update(new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>(axis1, axis1, axis2, axis2, axis3, axis3, axis4, axis4, axis5, axis5, axis6, axis6), this._top, 0);
        }
        private int Update(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> bounds, Node node, int depth)
        {
			// I messed up this function in the conversion
			throw new System.NotImplementedException();

            if (!InclusionCheck(bounds, node.Bounds))
                return 0;

            int removals = 0;

            if (!node.PointOfDivision.HasValue)
            {
                Node.ValueNode current = node.Head;
                Node.ValueNode previous = null;
                while (current != null)
                {
                    Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> item_bounds = GetBoundings(current.Value);
                    if (!this.EncapsulationCheck(node.Bounds, item_bounds))
                    {
                        removals++;
                        T updated = current.Value;
                        if (previous == null)
                        {
                            node.Head = current.Next;
                            goto HeadRemoved;
                        }
                        else
                            previous.Next = current.Next;
                        Node whereToAdd = GetEncapsulationParent(node.Parent, item_bounds);
                        if (whereToAdd == null)
                            throw new System.Exception("an item was updates outside the range of the omnitree");
                        this.Add(updated, whereToAdd, item_bounds, whereToAdd.Depth);
                    }
                    previous = current;
                HeadRemoved:
                    current = current.Next;
                }
                node.Count -= removals;
                return removals;
            }
            else
            {
                Node branch = node as Node;
                int skipped = 0;
                for (int i = 0; i + skipped < branch.Children.Length; )
                {
                    removals += this.Update(branch.Children[i], depth + 1);
                    if (branch.Children[i].Count == 0)
                        branch.Children[i] = branch.Children[branch.Children.Length - skipped++ - 1];
                    else
                        i++;
                }
                Node[] newArray = new Node[branch.Children.Length - skipped];
                Array.Copy(branch.Children, newArray, newArray.Length);
                branch.Children = newArray;

                branch.Count -= removals;

                if (branch.Count < _load && branch.Count != 0)
                    ShrinkChild(branch.Parent, branch.Index);
            }

            return removals;
        }

        #endregion

        #region Remove

        /// <summary>Removes all the items qualified by the delegate.</summary>
        /// <param name="where">The predicate to qualify removals.</param>
        public void Remove(Predicate<T> where)
        {
            this.Remove(this._top, where);
            Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
        }

        /// <summary>Recursive version of the remove method.</summary>
        /// <param name="node">The current node of traversal.</param>
        /// <param name="where">The predicate to qualify removals.</param>
        private int Remove(Node node, Predicate<T> where)
        {
            int removals = 0;

			// items
            while (node.Head != null && where(node.Head.Value))
            {
                node.Head = node.Head.Next;
                removals++;
            }
            if (node.Head != null)
            {
                Node.ValueNode list = node.Head;
                while (list.Next != null)
                {
                    if (where(list.Next.Value))
                    {
                        list.Next = list.Next.Next;
                        removals++;
                    }
                }
            }
            node.Count -= removals;
            
			// children
			if (node.Children != null)
			{
				int skipped = 0;
				for (int i = 0; i + skipped < node.Children.Length; )
				{
				    removals += this.Remove(node.Children[i], where);
				    if (node.Children[i].Count == 0)
				        node.Children[i] = node.Children[node.Children.Length - skipped++ - 1];
				    else
				        i++;
				}
				Node[] newArray = new Node[node.Children.Length - skipped];
				Array.Copy(node.Children, newArray, newArray.Length);
				node.Children = newArray;

				node.Count -= removals;

				if (node.Count < _load && node.Count != 0)
				    ShrinkChild(node.Parent, node.Index);
			}
            return removals;
        }

        /// <summary>Removes all the items encapsulated in a given space.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
        /// <returns>The number of items that were removed.</returns>
        public void RemoveEncapsulated(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5, Axis6 min6, Axis6 max6)
        {
            this.RemoveEncapsulated(this._top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6));
        }
        /// <summary>Removes all the items encapsulated in a given space.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
        /// <returns>The number of items that were removed.</returns>
        public void RemoveEncapsulated(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5, Omnitree.Bound<Axis6> min6, Omnitree.Bound<Axis6> max6)
        {
            this.RemoveEncapsulated(this._top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6));
        }
        /// <summary>Removes all the items encapsulated in a given space.</summary>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
		/// <param name="axis5">The coordinate along the 5D axis.</param>
		/// <param name="axis6">The coordinate along the 6D axis.</param>
        public void RemoveEncapsulated(Omnitree.Bound<Axis1> axis1, Omnitree.Bound<Axis2> axis2, Omnitree.Bound<Axis3> axis3, Omnitree.Bound<Axis4> axis4, Omnitree.Bound<Axis5> axis5, Omnitree.Bound<Axis6> axis6)
        {
            this.RemoveEncapsulated(this._top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>(axis1, axis1, axis2, axis2, axis3, axis3, axis4, axis4, axis5, axis5, axis6, axis6));
        }
        private int RemoveEncapsulated(Node node, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> bounds)
        {
            int removals = this.RemoveBase(node, bounds, (a, b) => this.EncapsulationCheck(a, b));
			Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
			return removals;
        }

		/// <summary>Removes all the items overlapping a given space.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
        /// <returns>The number of items that were removed.</returns>
        public void RemoveOverlapped(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5, Axis6 min6, Axis6 max6)
        {
            this.RemoveOverlapped(this._top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6));
        }
        /// <summary>Removes all the items overlapping a given space.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
        /// <returns>The number of items that were removed.</returns>
        public void RemoveOverlapped(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5, Omnitree.Bound<Axis6> min6, Omnitree.Bound<Axis6> max6)
        {
            this.RemoveOverlapped(this._top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6));
        }
        private int RemoveOverlapped(Node node, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> bounds)
        {
            int removals = this.RemoveBase(node, bounds, (a, b) => this.InclusionCheck(a, b));
			Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
			return removals;
        }

		private int RemoveBase(
			Node node,
			Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> bounds,
			Omnitree.SpatialCheck<Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>> spatialCheck)
        {
            int removals = 0;
            if (InclusionCheck(bounds, node.Bounds))
            {
				// items
                Node.ValueNode current_node = node.Head;
                Node.ValueNode previous_node = null;
                while (current_node != null)
                {
                    Node.ValueNode temp_previous = current_node;
                    if (spatialCheck(bounds, GetBoundings(current_node.Value)))
                    {
                        removals++;
                        if (current_node == node.Head)
                            node.Head = node.Head.Next;
                        else
                        {
                            previous_node.Next = current_node.Next;
                            temp_previous = previous_node;
                        }
                    }
                    previous_node = temp_previous;
                    current_node = current_node.Next;
                }
                node.Count -= removals;
                
				// children
				if (node.Children != null)
				{
					int skipped = 0;
					for (int i = 0; i + skipped < node.Children.Length; )
					{
					    removals += this.RemoveBase(node.Children[i], bounds, spatialCheck);
					    if (node.Children[i].Count == 0)
					        node.Children[i] = node.Children[node.Children.Length - skipped++ - 1];
					    else
					        i++;
					}
					Node[] newArray = new Node[node.Children.Length - skipped];
					Array.Copy(node.Children, newArray, newArray.Length);
					node.Children = newArray;

					node.Count -= removals;
					// convert this branch back into a leaf
					// Note: if count is zero, it will be chopped off
					if (node.Count < _load && node.Count > 0)
					    ShrinkChild(node.Parent, node.Index);
				}
            }
			
            return removals;
        }

		/// <summary>Removes all the items in a given space validated by a predicate.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
        /// <param name="where">The equality constraint of the removal.</param>
        public void RemoveEncapsulated(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5, Axis6 min6, Axis6 max6, Predicate<T> where)
        {
            this.RemoveEncapsulated(this._top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6), where);
        }
        /// <summary>Removes all the items in a given space validated by a predicate.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
        /// <param name="where">The equality constraint of the removal.</param>
        public void RemoveEncapsulated(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5, Omnitree.Bound<Axis6> min6, Omnitree.Bound<Axis6> max6, Predicate<T> where)
        {
            this.RemoveEncapsulated(this._top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6), where);
        }
        private int RemoveEncapsulated(Node node, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> bounds, Predicate<T> where)
        {
            int removals = RemoveBase(node, bounds, where, (a, b) => this.EncapsulationCheck(a, b));
			Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
			return removals;
        }

        /// <summary>Removes all the items in a given space validated by a predicate.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
        /// <param name="where">The equality constraint of the removal.</param>
        public void RemoveOverlapped(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5, Axis6 min6, Axis6 max6, Predicate<T> where)
        {
            this.RemoveOverlapped(this._top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6), where);
        }
        /// <summary>Removes all the items in a given space validated by a predicate.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
        /// <param name="where">The equality constraint of the removal.</param>
        public void RemoveOverlapped(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5, Omnitree.Bound<Axis6> min6, Omnitree.Bound<Axis6> max6, Predicate<T> where)
        {
            this.RemoveOverlapped(this._top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6), where);
        }
        private int RemoveOverlapped(Node node, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> bounds, Predicate<T> where)
        {
            int removals = RemoveBase(node, bounds, where, (a, b) => this.InclusionCheck(a, b));
			Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
			return removals;
        }

		private int RemoveBase(
			Node node,
			Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> bounds,
			Predicate<T> where,
			Omnitree.SpatialCheck<Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>> spatialCheck)
        {
            if (!InclusionCheck(node.Bounds, bounds))
                return 0;
            int removals = 0;
            
			// items
            Node.ValueNode current = node.Head;
            Node.ValueNode previous = null;
            while (current != null)
            {
                if (spatialCheck(bounds, GetBoundings(current.Value)) && where(current.Value))
                {
                    removals++;
                    if (previous == null)
                    {
                        node.Head = current.Next;
                        goto HeadRemoved;
                    }
                    else
                        previous.Next = current.Next;
                }
                previous = current;
            HeadRemoved:
                current = current.Next;
            }
            node.Count -= removals;

            // children
			if (node.Children != null)
			{
				int skipped = 0;
				for (int i = 0; i + skipped < node.Children.Length; )
				{
				    removals += this.RemoveBase(node.Children[i], bounds, where, spatialCheck);
				    if (node.Children[i].Count == 0)
				        node.Children[i] = node.Children[node.Children.Length - skipped++ - 1];
				    else
				        i++;
				}
				Node[] newArray = new Node[node.Children.Length - skipped];
				Array.Copy(node.Children, newArray, newArray.Length);
				node.Children = newArray;

				node.Count -= removals;

				if (node.Count < _load && node.Count != 0)
				    ShrinkChild(node.Parent, node.Index);
			}
            return removals;
        }

        /// <summary>Removes all instances of a given value.</summary>
        public void Remove(T removal)
        {
            Omnitree.Bound<Axis1> min1; Omnitree.Bound<Axis1> max1;
            Omnitree.Bound<Axis2> min2; Omnitree.Bound<Axis2> max2;
            Omnitree.Bound<Axis3> min3; Omnitree.Bound<Axis3> max3;
            Omnitree.Bound<Axis4> min4; Omnitree.Bound<Axis4> max4;
            Omnitree.Bound<Axis5> min5; Omnitree.Bound<Axis5> max5;
            Omnitree.Bound<Axis6> min6; Omnitree.Bound<Axis6> max6;
            this._getBounds(removal, out min1, out max1, out min2, out max2, out min3, out max3, out min4, out max4, out min5, out max5, out min6, out max6);
            this.RemoveOverlapped(this._top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6), item => this._equate(item, removal));
        }
        /// <summary>Removes all the items in a given space.</summary>
        /// <param name="axis1">The axis of the removal along the  1D axis.</param>
		/// <param name="axis2">The axis of the removal along the  2D axis.</param>
		/// <param name="axis3">The axis of the removal along the  3D axis.</param>
		/// <param name="axis4">The axis of the removal along the  4D axis.</param>
		/// <param name="axis5">The axis of the removal along the  5D axis.</param>
		/// <param name="axis6">The axis of the removal along the  6D axis.</param>
        /// <returns>The number of items that were removed.</returns>
        public void RemoveOverlapped(Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Axis5 axis5, Axis6 axis6)
        {
            this.RemoveOverlapped(axis1, axis1, axis2, axis2, axis3, axis3, axis4, axis4, axis5, axis5, axis6, axis6);
            Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
        }
        
        /// <summary>Removes all the items in a given space validated by a predicate.</summary>
        /// <param name="axis1">The axis of the removal along the  1D axis.</param>
		/// <param name="axis2">The axis of the removal along the  2D axis.</param>
		/// <param name="axis3">The axis of the removal along the  3D axis.</param>
		/// <param name="axis4">The axis of the removal along the  4D axis.</param>
		/// <param name="axis5">The axis of the removal along the  5D axis.</param>
		/// <param name="axis6">The axis of the removal along the  6D axis.</param>
        /// <param name="where">The equality constraint of the removal.</param>
        public void RemoveOverlapped(Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Axis5 axis5, Axis6 axis6, Predicate<T> where)
        {
			this.RemoveOverlapped(axis1, axis1, axis2, axis2, axis3, axis3, axis4, axis4, axis5, axis5, axis6, axis6, where);
            Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
        }

        #endregion

        #region Stepper And IEnumerable

        /// <summary>Traverses every item in the tree and performs the delegate in them.</summary>
        /// <param name="function">The delegate to perform on every item in the tree.</param>
        public void Stepper(Step<T> function)
        {
            this.Stepper(function, this._top);
        }
        private void Stepper(Step<T> function, Node node)
        {
            Node.ValueNode list = node.Head;
            while (list != null)
            {
                function(list.Value);
                list = list.Next;
            }
			if (node.Children != null)
				foreach (Node child in node.Children)
				    this.Stepper(function, child);
        }

        /// <summary>Traverses every item in the tree and performs the delegate in them.</summary>
        /// <param name="function">The delegate to perform on every item in the tree.</param>
        public StepStatus Stepper(StepBreak<T> function)
        {
            return Stepper(function, _top);
        }
        private StepStatus Stepper(StepBreak<T> function, Node node)
        {
            StepStatus status = StepStatus.Continue;
            
            for (Node.ValueNode list = node.Head; list != null; list = list.Next)
                if ((status = function(list._value)) != StepStatus.Continue)
                    break;
            
			if (node.Children != null)
				foreach (Node child in node.Children)
				    if ((status = Stepper(function, child)) != StepStatus.Continue)
				        break;
            
            return status;
        }

        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="function">The delegate to perform on all items in the tree within the given bounds.</param>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
        public void StepperEncapsulated(Step<T> function, Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5, Axis6 min6, Axis6 max6)
        {
            StepperEncapsulated(function, _top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6));
        }
        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="function">The delegate to perform on all items in the tree within the given bounds.</param>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
        public void StepperEncapsulated(Step<T> function, Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5, Omnitree.Bound<Axis6> min6, Omnitree.Bound<Axis6> max6)
        {
            StepperEncapsulated(function, _top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6));
        }
        private void StepperEncapsulated(Step<T> function, Node node, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> bounds)
        {
            StepperBase(function, node, bounds, (a, b) => this.EncapsulationCheck(a, b));
        }

		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="function">The delegate to perform on all items in the tree within the given bounds.</param>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
        public void StepperOverlapped(Step<T> function, Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5, Axis6 min6, Axis6 max6)
        {
            StepperOverlapped(function, _top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6));
        }
        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="function">The delegate to perform on all items in the tree within the given bounds.</param>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
        public void StepperOverlapped(Step<T> function, Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5, Omnitree.Bound<Axis6> min6, Omnitree.Bound<Axis6> max6)
        {
            StepperOverlapped(function, _top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6));
        }
        private void StepperOverlapped(Step<T> function, Node node, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> bounds)
        {
            StepperBase(function, node, bounds, (a, b) => this.InclusionCheck(a, b));
        }

		private void StepperBase(
			Step<T> function,
			Node node,
			Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> bounds,
			Omnitree.SpatialCheck<Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>> spatialCheck)
        {
            for (Node.ValueNode list = node.Head; list != null; list = list.Next)
                if (spatialCheck(bounds, GetBoundings(list.Value)))
                    function(list.Value);

			if (node.Children != null)
			{
				foreach (Node child in node.Children)
				    // optimization: stop bounds checking if space encapsulates node
				    if (EncapsulationCheck(bounds, child.Bounds))
				        this.Stepper(function, child);
				    else if (InclusionCheck(child.Bounds, bounds))
				        this.StepperBase(function, child, bounds, spatialCheck);
			}
        }

        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
        public StepStatus StepperEncapsulated(StepBreak<T> function, Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5, Axis6 min6, Axis6 max6)
        {
            return StepperEncapsulated(function, _top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6));
        }
        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
        public StepStatus StepperEncapsulated(StepBreak<T> function, Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5, Omnitree.Bound<Axis6> min6, Omnitree.Bound<Axis6> max6)
        {
			return StepperEncapsulated(function, _top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6));
        }
        private StepStatus StepperEncapsulated(StepBreak<T> function, Node node, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> bounds)
        {
            return StepperBase(function, node, bounds, (a, b) => this.EncapsulationCheck(a, b));
        }

		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
        public StepStatus StepperOverlapped(StepBreak<T> function, Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5, Axis6 min6, Axis6 max6)
        {
            return StepperOverlapped(function, _top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6));
        }
        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
        public StepStatus StepperOverlapped(StepBreak<T> function, Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5, Omnitree.Bound<Axis6> min6, Omnitree.Bound<Axis6> max6)
        {
			return StepperOverlapped(function, _top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6));
        }
        private StepStatus StepperOverlapped(StepBreak<T> function, Node node, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> bounds)
        {
            return StepperBase(function, node, bounds, (a, b) => this.InclusionCheck(a, b));
        }

		private StepStatus StepperBase(
			StepBreak<T> function,
			Node node,
			Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> bounds,
			Omnitree.SpatialCheck<Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>> spatialCheck)
        {
            StepStatus status = StepStatus.Continue;

            for (Node.ValueNode list = node.Head; list != null; list = list.Next)
                if (spatialCheck(bounds, GetBoundings(list.Value)) &&
                    (status = function(list.Value)) != StepStatus.Continue)
                    break;

			if (node.Children != null)
			{
				foreach (Node child in node.Children)
				    // optimization: stop bounds checking if space encapsulates node
				    if (EncapsulationCheck(bounds, child.Bounds) &&
				        (status = this.Stepper(function, child)) != StepStatus.Continue)
				        break;
				    else if (!InclusionCheck(child.Bounds, bounds) &&
				        (status = this.StepperBase(function, child, bounds, spatialCheck)) != StepStatus.Continue)
				        break;
			}

            return status;
        }

        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="axis1">The axis of the removal along the  1D axis.</param>
		/// <param name="axis2">The axis of the removal along the  2D axis.</param>
		/// <param name="axis3">The axis of the removal along the  3D axis.</param>
		/// <param name="axis4">The axis of the removal along the  4D axis.</param>
		/// <param name="axis5">The axis of the removal along the  5D axis.</param>
		/// <param name="axis6">The axis of the removal along the  6D axis.</param>
        public void StepperOverlapped(Step<T> function, Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Axis5 axis5, Axis6 axis6)
        {
            StepperOverlapped(function, this._top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>(axis1, axis1, axis2, axis2, axis3, axis3, axis4, axis4, axis5, axis5, axis6, axis6));
        }

        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="function">The delegate to perform on all items in the tree within the given bounds.</param>
        /// <param name="axis1">The axis of the removal along the  1D axis.</param>
		/// <param name="axis2">The axis of the removal along the  2D axis.</param>
		/// <param name="axis3">The axis of the removal along the  3D axis.</param>
		/// <param name="axis4">The axis of the removal along the  4D axis.</param>
		/// <param name="axis5">The axis of the removal along the  5D axis.</param>
		/// <param name="axis6">The axis of the removal along the  6D axis.</param>
        public StepStatus StepperOverlapped(StepBreak<T> function, Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Axis5 axis5, Axis6 axis6)
        {
			return StepperOverlapped(function, this._top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>(axis1, axis1, axis2, axis2, axis3, axis3, axis4, axis4, axis5, axis5, axis6, axis6));
        }

        /// <summary>FOR COMPATIBILITY ONLY. AVOID IF POSSIBLE.</summary>
        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
        {
            throw new System.NotImplementedException();
            //return (this.ToArray() as System.Collections.Generic.IEnumerable<T>).GetEnumerator();
        }

        /// <summary>FOR COMPATIBILITY ONLY. AVOID IF POSSIBLE.</summary>
        System.Collections.Generic.IEnumerator<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator()
        {
            throw new System.NotImplementedException();
            //return (this.ToArray() as System.Collections.Generic.IEnumerable<T>).GetEnumerator();
        }

        #endregion

        #region Helpers

        private bool StraddlesLines(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> bounds, Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> vector)
        {
			if ((!bounds.Min1.Exists || (this._compare1(bounds.Min1.Value, vector.Axis1) != Comparison.Greater)) &&
				(!bounds.Max1.Exists || (this._compare1(bounds.Max1.Value, vector.Axis1) != Comparison.Less)))
				return true;
			if ((!bounds.Min2.Exists || (this._compare2(bounds.Min2.Value, vector.Axis2) != Comparison.Greater)) &&
				(!bounds.Max2.Exists || (this._compare2(bounds.Max2.Value, vector.Axis2) != Comparison.Less)))
				return true;
			if ((!bounds.Min3.Exists || (this._compare3(bounds.Min3.Value, vector.Axis3) != Comparison.Greater)) &&
				(!bounds.Max3.Exists || (this._compare3(bounds.Max3.Value, vector.Axis3) != Comparison.Less)))
				return true;
			if ((!bounds.Min4.Exists || (this._compare4(bounds.Min4.Value, vector.Axis4) != Comparison.Greater)) &&
				(!bounds.Max4.Exists || (this._compare4(bounds.Max4.Value, vector.Axis4) != Comparison.Less)))
				return true;
			if ((!bounds.Min5.Exists || (this._compare5(bounds.Min5.Value, vector.Axis5) != Comparison.Greater)) &&
				(!bounds.Max5.Exists || (this._compare5(bounds.Max5.Value, vector.Axis5) != Comparison.Less)))
				return true;
			if ((!bounds.Min6.Exists || (this._compare6(bounds.Min6.Value, vector.Axis6) != Comparison.Greater)) &&
				(!bounds.Max6.Exists || (this._compare6(bounds.Max6.Value, vector.Axis6) != Comparison.Less)))
				return true;
            return false;
        }

        /// <summary>Computes the child index that contains the desired dimensions.</summary>
        /// <param name="node">The branch .</param>
        /// <param name="vector">The dimensions to determine the child index.</param>
        /// <returns>The computed child index based on the coordinates relative to the center of the node.</returns>
        private int DetermineChildIndex(Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> pointOfDivision, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> bounds)
        {
			// make sure a child encapsulates the bounds (otherwise the bounds cannot move down the tree)
			if (StraddlesLines(bounds, pointOfDivision))
				return -1;

            int child = 0;
            if (!bounds.Min1.Exists || !(this._compare1(bounds.Min1.Value, pointOfDivision.Axis1) == Comparison.Less))
                child += 1 << 0;
            if (!bounds.Min2.Exists || !(this._compare2(bounds.Min2.Value, pointOfDivision.Axis2) == Comparison.Less))
                child += 1 << 1;
            if (!bounds.Min3.Exists || !(this._compare3(bounds.Min3.Value, pointOfDivision.Axis3) == Comparison.Less))
                child += 1 << 2;
            if (!bounds.Min4.Exists || !(this._compare4(bounds.Min4.Value, pointOfDivision.Axis4) == Comparison.Less))
                child += 1 << 3;
            if (!bounds.Min5.Exists || !(this._compare5(bounds.Min5.Value, pointOfDivision.Axis5) == Comparison.Less))
                child += 1 << 4;
            if (!bounds.Min6.Exists || !(this._compare6(bounds.Min6.Value, pointOfDivision.Axis6) == Comparison.Less))
                child += 1 << 5;
            return child;
        }

        /// <summary>Converts a branch back into a leaf when the count is reduced.</summary>
        /// <param name="parent">The parent to shrink a child of.</param>
        /// <param name="child">The index of the child to shrink.</param>
        private void ShrinkChild(Node parent, int child_index)
        {
            Node leaf;
            Node removal = null;
            if (parent == null) // top of tree
            {
                removal = this._top;
                leaf = new Node(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>.None, null, -1);
                this._top = leaf;
            }
            else // non-top branch
            {
                removal = parent[child_index];
                leaf = new Node(removal.Bounds, removal.Parent, removal.Index);
                parent[child_index] = leaf;
            }

            this.Stepper((T step) => { leaf.Add(step); }, removal);
        }

        /// <summary>Reduces the counts of all the parents of a given node by a given amount.</summary>
        /// <param name="parent">The starting parent of the reduction.</param>
        /// <param name="reduction">The amount to reduce the parent counts by.</param>
        private void ReduceParentCounts(Node parent, int reduction)
        {
            IncreaseParentCounts(parent, -reduction);
        }

        /// <summary>Increases the counts of all the parents of a given node by a given amount.</summary>
        /// <param name="parent">The starting parent of the increase.</param>
        /// <param name="increase">The amount to increase the parent counts by.</param>
        private void IncreaseParentCounts(Node parent, int increase)
        {
            Node looper = parent;
            while (looper != null)
            {
                looper.Count += increase;
                looper = looper.Parent;
            }
        }

        /// <summary>Checks a node for inclusion (overlap) between two bounds.</summary>
        /// <returns>True if the spaces overlap; False if not.</returns>
        private bool InclusionCheck(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> a, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> b)
        {

            if (a.Max1.Exists && b.Min1.Exists && this._compare1(a.Max1.Value, b.Min1.Value) == Comparison.Less)
                return false;
            else if (a.Min1.Exists && b.Max1.Exists && this._compare1(a.Min1.Value, b.Max1.Value) == Comparison.Greater)
                return false;

            if (a.Max2.Exists && b.Min2.Exists && this._compare2(a.Max2.Value, b.Min2.Value) == Comparison.Less)
                return false;
            else if (a.Min2.Exists && b.Max2.Exists && this._compare2(a.Min2.Value, b.Max2.Value) == Comparison.Greater)
                return false;

            if (a.Max3.Exists && b.Min3.Exists && this._compare3(a.Max3.Value, b.Min3.Value) == Comparison.Less)
                return false;
            else if (a.Min3.Exists && b.Max3.Exists && this._compare3(a.Min3.Value, b.Max3.Value) == Comparison.Greater)
                return false;

            if (a.Max4.Exists && b.Min4.Exists && this._compare4(a.Max4.Value, b.Min4.Value) == Comparison.Less)
                return false;
            else if (a.Min4.Exists && b.Max4.Exists && this._compare4(a.Min4.Value, b.Max4.Value) == Comparison.Greater)
                return false;

            if (a.Max5.Exists && b.Min5.Exists && this._compare5(a.Max5.Value, b.Min5.Value) == Comparison.Less)
                return false;
            else if (a.Min5.Exists && b.Max5.Exists && this._compare5(a.Min5.Value, b.Max5.Value) == Comparison.Greater)
                return false;

            if (a.Max6.Exists && b.Min6.Exists && this._compare6(a.Max6.Value, b.Min6.Value) == Comparison.Less)
                return false;
            else if (a.Min6.Exists && b.Max6.Exists && this._compare6(a.Min6.Value, b.Max6.Value) == Comparison.Greater)
                return false;

            return true;
        }

        /// <summary>Checks if a space encapsulates a point.</summary>
        /// <returns>True if the space encapsulates the point; False if not.</returns>
        private bool EncapsulationCheck(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> bounds, Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> vector)
        {
            // if the location is not outside the bounds, it must be inside

            if (bounds.Min1.Exists && this._compare1(vector.Axis1, bounds.Min1.Value) == Comparison.Less)
                return false;
            else if (bounds.Max1.Exists && this._compare1(vector.Axis1, bounds.Max1.Value) == Comparison.Greater)
                return false;

            if (bounds.Min2.Exists && this._compare2(vector.Axis2, bounds.Min2.Value) == Comparison.Less)
                return false;
            else if (bounds.Max2.Exists && this._compare2(vector.Axis2, bounds.Max2.Value) == Comparison.Greater)
                return false;

            if (bounds.Min3.Exists && this._compare3(vector.Axis3, bounds.Min3.Value) == Comparison.Less)
                return false;
            else if (bounds.Max3.Exists && this._compare3(vector.Axis3, bounds.Max3.Value) == Comparison.Greater)
                return false;

            if (bounds.Min4.Exists && this._compare4(vector.Axis4, bounds.Min4.Value) == Comparison.Less)
                return false;
            else if (bounds.Max4.Exists && this._compare4(vector.Axis4, bounds.Max4.Value) == Comparison.Greater)
                return false;

            if (bounds.Min5.Exists && this._compare5(vector.Axis5, bounds.Min5.Value) == Comparison.Less)
                return false;
            else if (bounds.Max5.Exists && this._compare5(vector.Axis5, bounds.Max5.Value) == Comparison.Greater)
                return false;

            if (bounds.Min6.Exists && this._compare6(vector.Axis6, bounds.Min6.Value) == Comparison.Less)
                return false;
            else if (bounds.Max6.Exists && this._compare6(vector.Axis6, bounds.Max6.Value) == Comparison.Greater)
                return false;

            return true;
        }

        /// <summary>Checks if a space (left) encapsulates another space (right).</summary>
        /// <returns>True if the left space encapsulates the right; False if not.</returns>
        private bool EncapsulationCheck(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> a, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> b)
        {
            if ((a.Min1.Exists && !b.Min1.Exists) || (a.Min2.Exists && !b.Min2.Exists) || (a.Min3.Exists && !b.Min3.Exists) || (a.Min4.Exists && !b.Min4.Exists) || (a.Min5.Exists && !b.Min5.Exists) || (a.Min6.Exists && !b.Min6.Exists))
                return false;
			if ((a.Max1.Exists && !b.Max1.Exists) || (a.Max2.Exists && !b.Max2.Exists) || (a.Max3.Exists && !b.Max3.Exists) || (a.Max4.Exists && !b.Max4.Exists) || (a.Max5.Exists && !b.Max5.Exists) || (a.Max6.Exists && !b.Max6.Exists))
                return false;

            if (b.Min1.Exists && a.Min1.Exists && this._compare1(a.Min1.Value, b.Min1.Value) != Comparison.Less)
                return false;
            if (b.Max1.Exists && a.Max1.Exists && this._compare1(a.Max1.Value, b.Max1.Value) != Comparison.Greater)
                return false;

            if (b.Min2.Exists && a.Min2.Exists && this._compare2(a.Min2.Value, b.Min2.Value) != Comparison.Less)
                return false;
            if (b.Max2.Exists && a.Max2.Exists && this._compare2(a.Max2.Value, b.Max2.Value) != Comparison.Greater)
                return false;

            if (b.Min3.Exists && a.Min3.Exists && this._compare3(a.Min3.Value, b.Min3.Value) != Comparison.Less)
                return false;
            if (b.Max3.Exists && a.Max3.Exists && this._compare3(a.Max3.Value, b.Max3.Value) != Comparison.Greater)
                return false;

            if (b.Min4.Exists && a.Min4.Exists && this._compare4(a.Min4.Value, b.Min4.Value) != Comparison.Less)
                return false;
            if (b.Max4.Exists && a.Max4.Exists && this._compare4(a.Max4.Value, b.Max4.Value) != Comparison.Greater)
                return false;

            if (b.Min5.Exists && a.Min5.Exists && this._compare5(a.Min5.Value, b.Min5.Value) != Comparison.Less)
                return false;
            if (b.Max5.Exists && a.Max5.Exists && this._compare5(a.Max5.Value, b.Max5.Value) != Comparison.Greater)
                return false;

            if (b.Min6.Exists && a.Min6.Exists && this._compare6(a.Min6.Value, b.Min6.Value) != Comparison.Less)
                return false;
            if (b.Max6.Exists && a.Max6.Exists && this._compare6(a.Max6.Value, b.Max6.Value) != Comparison.Greater)
                return false;

            return true;
        }

        /// <summary>Checks for equality between two locations.</summary>
        /// <returns>True if equal; False if not;</returns>
        private bool EqualsCheck(Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> a, Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> b)
        {

            if (!this._equate1(a.Axis1, b.Axis1))
                return false;

            if (!this._equate2(a.Axis2, b.Axis2))
                return false;

            if (!this._equate3(a.Axis3, b.Axis3))
                return false;

            if (!this._equate4(a.Axis4, b.Axis4))
                return false;

            if (!this._equate5(a.Axis5, b.Axis5))
                return false;

            if (!this._equate6(a.Axis6, b.Axis6))
                return false;

            return true;
        }

        /// <summary>Gets the nearest parent that encapsulates a location.</summary>
        /// <param name="node">The starting node to find the encapsulating parent of the location.</param>
        /// <param name="bounds">The bounds to get the encapsulating parent from.</param>
        /// <returns>The nearest node that encapsulates the given location.</returns>
        private Node GetEncapsulationParent(Node node, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> bounds)
        {
            while (node != null && !EncapsulationCheck(node.Bounds, bounds))
                node = node.Parent;
            return node;
        }

        private Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> GetBoundings(T value)
        {
            Omnitree.Bound<Axis1> min1; Omnitree.Bound<Axis1> max1;
            Omnitree.Bound<Axis2> min2; Omnitree.Bound<Axis2> max2;
            Omnitree.Bound<Axis3> min3; Omnitree.Bound<Axis3> max3;
            Omnitree.Bound<Axis4> min4; Omnitree.Bound<Axis4> max4;
            Omnitree.Bound<Axis5> min5; Omnitree.Bound<Axis5> max5;
            Omnitree.Bound<Axis6> min6; Omnitree.Bound<Axis6> max6;
            this._getBounds(value,
				out min1, out max1,
				out min2, out max2,
				out min3, out max3,
				out min4, out max4,
				out min5, out max5,
				out min6, out max6);
            return new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>(
				min1, max1,
				min2, max2,
				min3, max3,
				min4, max4,
				min5, max5,
				min6, max6);
        }

        #endregion

        #endregion
    }

    #endregion

    #region 7 Dimensional

    public interface IOmnitreeBounds<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> : IDataStructure<T>,
            DataStructure.ICountable,
            DataStructure.IAddable<T>,
            DataStructure.IClearable,
            DataStructure.IRemovable<T>,
            DataStructure.IEquating<T>
    {
        #region Properties

        /// <summary>The number of dimensions in this tree.</summary>
        int Dimensions { get; }

        #endregion

        #region Methods

        /// <summary>Counts the number of items encapsulated by a sub space.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		/// <param name="min7">The minimum coordinate of the space along the 7 axis.</param>
		/// <param name="max7">The maximum coordinate of the space along the 7 axis.</param>
        /// <returns>The number of items in the provided sub space.</returns>
        int CountSubSpaceEncapsulated(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5, Axis6 min6, Axis6 max6, Axis7 min7, Axis7 max7);

		/// <summary>Counts the number of items overlapped by a sub space.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		/// <param name="min7">The minimum coordinate of the space along the 7 axis.</param>
		/// <param name="max7">The maximum coordinate of the space along the 7 axis.</param>
        /// <returns>The number of items in the provided sub space.</returns>
        int CountSubSpaceOverlapped(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5, Axis6 min6, Axis6 max6, Axis7 min7, Axis7 max7);

        /// <summary>Iterates through the entire tree and ensures each item is in the proper leaf.</summary>
        void Update();
        /// <summary>Iterates through the provided dimensions and ensures each item is in the proper leaf.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		/// <param name="min7">The minimum coordinate of the space along the 7 axis.</param>
		/// <param name="max7">The maximum coordinate of the space along the 7 axis.</param>
        void Update(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5, Axis6 min6, Axis6 max6, Axis7 min7, Axis7 max7);

        /// <summary>Removes all the items in a given space.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		/// <param name="min7">The minimum coordinate of the space along the 7 axis.</param>
		/// <param name="max7">The maximum coordinate of the space along the 7 axis.</param>
        void RemoveEncapsulated(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5, Axis6 min6, Axis6 max6, Axis7 min7, Axis7 max7);
        /// <summary>Removes all the items in a given space where predicate is met.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		/// <param name="min7">The minimum coordinate of the space along the 7 axis.</param>
		/// <param name="max7">The maximum coordinate of the space along the 7 axis.</param>
        /// <param name="where">The predicate constraint of the removal.</param>
        void RemoveEncapsulated(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5, Axis6 min6, Axis6 max6, Axis7 min7, Axis7 max7, Predicate<T> where);

		/// <summary>Removes all the items in a given space.</summary>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
		/// <param name="axis5">The coordinate along the 5D axis.</param>
		/// <param name="axis6">The coordinate along the 6D axis.</param>
		/// <param name="axis7">The coordinate along the 7D axis.</param>
        void RemoveOverlapped(Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Axis5 axis5, Axis6 axis6, Axis7 axis7);
        /// <summary>Removes all the items in a given space.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		/// <param name="min7">The minimum coordinate of the space along the 7 axis.</param>
		/// <param name="max7">The maximum coordinate of the space along the 7 axis.</param>
        void RemoveOverlapped(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5, Axis6 min6, Axis6 max6, Axis7 min7, Axis7 max7);
        /// <summary>Removes all the items in a given space where equality is met.</summary>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
		/// <param name="axis5">The coordinate along the 5D axis.</param>
		/// <param name="axis6">The coordinate along the 6D axis.</param>
		/// <param name="axis7">The coordinate along the 7D axis.</param>
        /// <param name="where">The equality constraint of the removal.</param>
        void RemoveOverlapped(Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Axis5 axis5, Axis6 axis6, Axis7 axis7, Predicate<T> where);
        /// <summary>Removes all the items in a given space where predicate is met.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		/// <param name="min7">The minimum coordinate of the space along the 7 axis.</param>
		/// <param name="max7">The maximum coordinate of the space along the 7 axis.</param>
        /// <param name="where">The predicate constraint of the removal.</param>
        void RemoveOverlapped(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5, Axis6 min6, Axis6 max6, Axis7 min7, Axis7 max7, Predicate<T> where);

        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="step">The step function to perform on all items in the tree within the given bounds.</param>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		/// <param name="min7">The minimum coordinate of the space along the 7 axis.</param>
		/// <param name="max7">The maximum coordinate of the space along the 7 axis.</param>
        void StepperEncapsulated(Step<T> step, Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5, Omnitree.Bound<Axis6> min6, Omnitree.Bound<Axis6> max6, Omnitree.Bound<Axis7> min7, Omnitree.Bound<Axis7> max7);
        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="step">The step function to perform on all items in the tree within the given bounds.</param>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		/// <param name="min7">The minimum coordinate of the space along the 7 axis.</param>
		/// <param name="max7">The maximum coordinate of the space along the 7 axis.</param>
        StepStatus StepperEncapsulated(StepBreak<T> step, Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5, Omnitree.Bound<Axis6> min6, Omnitree.Bound<Axis6> max6, Omnitree.Bound<Axis7> min7, Omnitree.Bound<Axis7> max7);
        
		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="step">The step function to perform on all items in the tree within the given bounds.</param>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		/// <param name="min7">The minimum coordinate of the space along the 7 axis.</param>
		/// <param name="max7">The maximum coordinate of the space along the 7 axis.</param>
        void StepperOverlapped(Step<T> step, Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5, Omnitree.Bound<Axis6> min6, Omnitree.Bound<Axis6> max6, Omnitree.Bound<Axis7> min7, Omnitree.Bound<Axis7> max7);
        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="step">The step function to perform on all items in the tree within the given bounds.</param>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		/// <param name="min7">The minimum coordinate of the space along the 7 axis.</param>
		/// <param name="max7">The maximum coordinate of the space along the 7 axis.</param>
        StepStatus StepperOverlapped(StepBreak<T> step, Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5, Omnitree.Bound<Axis6> min6, Omnitree.Bound<Axis6> max6, Omnitree.Bound<Axis7> min7, Omnitree.Bound<Axis7> max7);

		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="step">The step function to perform on all items in the tree within the given bounds.</param>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
		/// <param name="axis5">The coordinate along the 5D axis.</param>
		/// <param name="axis6">The coordinate along the 6D axis.</param>
		/// <param name="axis7">The coordinate along the 7D axis.</param>
        void StepperOverlapped(Step<T> step, Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Axis5 axis5, Axis6 axis6, Axis7 axis7);
        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="step">The step function to perform on all items in the tree within the given bounds.</param>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
		/// <param name="axis5">The coordinate along the 5D axis.</param>
		/// <param name="axis6">The coordinate along the 6D axis.</param>
		/// <param name="axis7">The coordinate along the 7D axis.</param>
        StepStatus StepperOverlapped(StepBreak<T> function, Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Axis5 axis5, Axis6 axis6, Axis7 axis7);

        #endregion
    }

    public class OmnitreeBoundsLinked<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> : IOmnitreeBounds<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>
    {
        private const int _dimensions = 7;
        internal static int _children_per_node = (int)BigInteger.Pow(2, 7);

        private Node _top;

		private int _naturalLogLower = 1; // caching the next time to calculate loads (lower count)
		private int _naturalLogUpper = -1; // caching the next time to calculate loads (upper count)
        private int _load; // ln(count); min = _defaultLoad
        private Omnitree.GetBounds<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> _getBounds;

        private bool _defaultEquate;
        private Equate<T> _equate;


        private bool _defaultEquate1;
        private Equate<Axis1> _equate1;

        private bool _defaultEquate2;
        private Equate<Axis2> _equate2;

        private bool _defaultEquate3;
        private Equate<Axis3> _equate3;

        private bool _defaultEquate4;
        private Equate<Axis4> _equate4;

        private bool _defaultEquate5;
        private Equate<Axis5> _equate5;

        private bool _defaultEquate6;
        private Equate<Axis6> _equate6;

        private bool _defaultEquate7;
        private Equate<Axis7> _equate7;



        private bool _defaultCompare1;
        private Compare<Axis1> _compare1;

        private bool _defaultCompare2;
        private Compare<Axis2> _compare2;

        private bool _defaultCompare3;
        private Compare<Axis3> _compare3;

        private bool _defaultCompare4;
        private Compare<Axis4> _compare4;

        private bool _defaultCompare5;
        private Compare<Axis5> _compare5;

        private bool _defaultCompare6;
        private Compare<Axis6> _compare6;

        private bool _defaultCompare7;
        private Compare<Axis7> _compare7;


        // allows median overriding for custom optimizations (USE AT YOUR OWN RISK)
        private Omnitree.SubdivisionOverride<T, Axis1, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>> _subdivisionOverride1;
        private Omnitree.SubdivisionOverride<T, Axis2, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>> _subdivisionOverride2;
        private Omnitree.SubdivisionOverride<T, Axis3, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>> _subdivisionOverride3;
        private Omnitree.SubdivisionOverride<T, Axis4, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>> _subdivisionOverride4;
        private Omnitree.SubdivisionOverride<T, Axis5, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>> _subdivisionOverride5;
        private Omnitree.SubdivisionOverride<T, Axis6, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>> _subdivisionOverride6;
        private Omnitree.SubdivisionOverride<T, Axis7, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>> _subdivisionOverride7;

        #region Nested Types

        /// <summary>Can be a leaf or a branch.</summary>
        internal class Node
        {
            public class ValueNode
            {
                internal T _value;
                internal ValueNode _next;

                public T Value { get { return _value; } set { _value = value; } }
                public ValueNode Next { get { return _next; } set { _next = value; } }

                public ValueNode(T value, ValueNode next)
                {
                    _value = value;
                    _next = next;
                }
            }

            internal Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> _bounds;
            internal Node _parent;
            internal int _index;
            internal int _count;
            internal ValueNode _head;
            private Node[] _children;
            private Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>? _pointOfDivision;

            /// <summary>The parent of this node.</summary>
            public Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> Bounds { get { return this._bounds; } }
            /// <summary>The parent of this node.</summary>
            public Node Parent { get { return this._parent; } }
            /// <summary>The computed child index of this node (see the "Notes" region in "Omnitree.cs" for the algorithm.</summary>
            public int Index { get { return this._index; } }
            /// <summary>The number of elements stored in this node and its children.</summary>
            public int Count { get { return this._count; } set { this._count = value; } }
            /// <summary>The first object stored in this node.</summary>
            public ValueNode Head { get { return this._head; } set { this._head = value; } }
            public Node[] Children { get { return this._children; } set { this._children = value; } }
            public Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>? PointOfDivision { get { return this._pointOfDivision; } internal set { this._pointOfDivision = value; } }

            /// <summary>Gets child by index.</summary>
            /// <param name="child_index">The index of the child to get.</param>
            /// <returns>The child of the given index or null if non-existent.</returns>
            public Node this[int child_index]
            {
                get
                {
                    if (this._children == null)
                        return null;
                    if (this._children.Length == OmnitreePointsLinked<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>._children_per_node)
                        return this._children[(int)child_index];
                    foreach (Node node in this._children)
                        if (node.Index == child_index)
                            return node;
                    return null;
                }
                set
                {
                    // This error check should be unnecessary... but fuck it... might as well
                    if (value.Index != child_index)
                        throw new System.Exception("Bug in Omnitree (index/property mis-match when setting a child on a branch)");

                    // no children yet
                    if (this._children == null)
                    {
                        this._children = new Node[] { value };
                        return;
                    }
                    // max children overwrite
                    else if (this._children.Length == OmnitreePointsLinked<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>._children_per_node)
                    {
                        this._children[(int)child_index] = value;
                        return;
                    }
                    // non-max child overwrite
                    for (int i = 0; i < this._children.Length; i++)
                        if (this._children[i].Index == child_index)
                        {
                            this._children[i] = value;
                            return;
                        }
                    // new child
                    Node[] newArray = new Node[this._children.Length + 1];
                    if (newArray.Length == OmnitreePointsLinked<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>._children_per_node)
                    {
                        // new child resulting in a max children branch (sorting required)
                        for (int i = 0; i < this._children.Length; i++)
                        {
                            newArray[(int)this._children[i]._index] = this._children[i];
                        }
                        newArray[(int)value._index] = value;
                    }
                    else
                    {
                        // new child resulting in a non-max children branch
                        Array.Copy(this._children, newArray, this._children.Length);
                        newArray[newArray.Length - 1] = value;
                    }
                    this._children = newArray;
                }
            }

            /// <summary>The depth this node is located in the Omnitree.</summary>
            public int Depth
            {
                get
                {
                    int depth = -1;
                    for (Node looper = this; looper != null; looper = looper.Parent)
                        depth++;
                    return depth;
                }
            }

            /// <summary>Constructs a node.</summary>
            /// <param name="bounds">The bounds of this node.</param>
            /// <param name="parent">The parent of this node.</param>
            /// <param name="index">The number of elements stored in this node and its children.</param>
            public Node(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> bounds, Node parent, int index)
            {
                this._bounds = bounds;
                this._parent = parent;
                this._index = index;
            }

            public Node(Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> pointOfDivision, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> bounds, Node parent, int index)
                : this(bounds, parent, index)
            {
                this._pointOfDivision = pointOfDivision;
            }

            internal Node(Node nodeToClone)
            {
                this._bounds = nodeToClone._bounds;
                this._parent = nodeToClone._parent;
                this._index = nodeToClone._index;
                this._count = nodeToClone._count;

                this._children = nodeToClone._children.Clone() as Node[];
                this._pointOfDivision = nodeToClone._pointOfDivision;

                ValueNode this_looper = this._head;
                ValueNode other_looper = nodeToClone._head;

                while (other_looper != null)
                {
                    this_looper.Next = new ValueNode(other_looper.Next.Value, null);
                    this_looper = this_looper.Next;
                    other_looper = other_looper.Next;
                }
            }

            public void Add(T addition)
            {
                this._head = new ValueNode(addition, this._head);
                this.Count++;
            }

            internal Node Clone()
            {
                return new Node(this);
            }
        }
        
        #endregion

        #region Constructors

        /// <summary>This constructor is for cloning purposes</summary>
        private OmnitreeBoundsLinked(OmnitreeBoundsLinked<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> omnitree)
        {
            this._top = omnitree._top.Clone();
            this._load = omnitree._load;
            this._getBounds = omnitree._getBounds;
            this._defaultEquate = omnitree._defaultEquate;
            this._equate = omnitree._equate;

            this._defaultEquate1 = omnitree._defaultEquate1;
            this._equate1 = omnitree._equate1;
            this._defaultEquate2 = omnitree._defaultEquate2;
            this._equate2 = omnitree._equate2;
            this._defaultEquate3 = omnitree._defaultEquate3;
            this._equate3 = omnitree._equate3;
            this._defaultEquate4 = omnitree._defaultEquate4;
            this._equate4 = omnitree._equate4;
            this._defaultEquate5 = omnitree._defaultEquate5;
            this._equate5 = omnitree._equate5;
            this._defaultEquate6 = omnitree._defaultEquate6;
            this._equate6 = omnitree._equate6;
            this._defaultEquate7 = omnitree._defaultEquate7;
            this._equate7 = omnitree._equate7;

            this._defaultCompare1 = omnitree._defaultCompare1;
            this._compare1 = omnitree._compare1;
            this._defaultCompare2 = omnitree._defaultCompare2;
            this._compare2 = omnitree._compare2;
            this._defaultCompare3 = omnitree._defaultCompare3;
            this._compare3 = omnitree._compare3;
            this._defaultCompare4 = omnitree._defaultCompare4;
            this._compare4 = omnitree._compare4;
            this._defaultCompare5 = omnitree._defaultCompare5;
            this._compare5 = omnitree._compare5;
            this._defaultCompare6 = omnitree._defaultCompare6;
            this._compare6 = omnitree._compare6;
            this._defaultCompare7 = omnitree._defaultCompare7;
            this._compare7 = omnitree._compare7;

            this._subdivisionOverride1 = omnitree._subdivisionOverride1;
            this._subdivisionOverride2 = omnitree._subdivisionOverride2;
            this._subdivisionOverride3 = omnitree._subdivisionOverride3;
            this._subdivisionOverride4 = omnitree._subdivisionOverride4;
            this._subdivisionOverride5 = omnitree._subdivisionOverride5;
            this._subdivisionOverride6 = omnitree._subdivisionOverride6;
            this._subdivisionOverride7 = omnitree._subdivisionOverride7;
        }

        private OmnitreeBoundsLinked(
            Omnitree.GetBounds<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> getBounds,

            bool defaultEquate,
            Equate<T> equate,

            bool defaultEquate1,
            Equate<Axis1> equateAxis1,
            bool defaultEquate2,
            Equate<Axis2> equateAxis2,
            bool defaultEquate3,
            Equate<Axis3> equateAxis3,
            bool defaultEquate4,
            Equate<Axis4> equateAxis4,
            bool defaultEquate5,
            Equate<Axis5> equateAxis5,
            bool defaultEquate6,
            Equate<Axis6> equateAxis6,
            bool defaultEquate7,
            Equate<Axis7> equateAxis7,

            bool defaultCompare1,
            Compare<Axis1> compare1,
            bool defaultCompare2,
            Compare<Axis2> compare2,
            bool defaultCompare3,
            Compare<Axis3> compare3,
            bool defaultCompare4,
            Compare<Axis4> compare4,
            bool defaultCompare5,
            Compare<Axis5> compare5,
            bool defaultCompare6,
            Compare<Axis6> compare6,
            bool defaultCompare7,
            Compare<Axis7> compare7,

            Omnitree.SubdivisionOverride<T, Axis1, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>> subdivisionOverride1,
            Omnitree.SubdivisionOverride<T, Axis2, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>> subdivisionOverride2,
            Omnitree.SubdivisionOverride<T, Axis3, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>> subdivisionOverride3,
            Omnitree.SubdivisionOverride<T, Axis4, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>> subdivisionOverride4,
            Omnitree.SubdivisionOverride<T, Axis5, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>> subdivisionOverride5,
            Omnitree.SubdivisionOverride<T, Axis6, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>> subdivisionOverride6,
            Omnitree.SubdivisionOverride<T, Axis7, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>> subdivisionOverride7)
        {
			if (getBounds == null)
			{
				throw new ArgumentNullException(nameof(getBounds));
			}
			if (equate == null)
			{
				throw new ArgumentNullException(nameof(equate));
			}

			if (equateAxis1 == null)
			{
				throw new ArgumentNullException(nameof(equateAxis1));
			}
			if (equateAxis2 == null)
			{
				throw new ArgumentNullException(nameof(equateAxis2));
			}
			if (equateAxis3 == null)
			{
				throw new ArgumentNullException(nameof(equateAxis3));
			}
			if (equateAxis4 == null)
			{
				throw new ArgumentNullException(nameof(equateAxis4));
			}
			if (equateAxis5 == null)
			{
				throw new ArgumentNullException(nameof(equateAxis5));
			}
			if (equateAxis6 == null)
			{
				throw new ArgumentNullException(nameof(equateAxis6));
			}
			if (equateAxis7 == null)
			{
				throw new ArgumentNullException(nameof(equateAxis7));
			}

			if (compare1 == null)
			{
				throw new ArgumentNullException(nameof(compare1));
			}
			if (compare2 == null)
			{
				throw new ArgumentNullException(nameof(compare2));
			}
			if (compare3 == null)
			{
				throw new ArgumentNullException(nameof(compare3));
			}
			if (compare4 == null)
			{
				throw new ArgumentNullException(nameof(compare4));
			}
			if (compare5 == null)
			{
				throw new ArgumentNullException(nameof(compare5));
			}
			if (compare6 == null)
			{
				throw new ArgumentNullException(nameof(compare6));
			}
			if (compare7 == null)
			{
				throw new ArgumentNullException(nameof(compare7));
			}

            this._getBounds = getBounds;
            this._defaultEquate = defaultEquate;
            this._equate = equate;

            this._defaultEquate1 = defaultEquate1;
            this._equate1 = equateAxis1;
            this._defaultEquate2 = defaultEquate2;
            this._equate2 = equateAxis2;
            this._defaultEquate3 = defaultEquate3;
            this._equate3 = equateAxis3;
            this._defaultEquate4 = defaultEquate4;
            this._equate4 = equateAxis4;
            this._defaultEquate5 = defaultEquate5;
            this._equate5 = equateAxis5;
            this._defaultEquate6 = defaultEquate6;
            this._equate6 = equateAxis6;
            this._defaultEquate7 = defaultEquate7;
            this._equate7 = equateAxis7;

            this._defaultCompare1 = defaultCompare1;
            this._compare1 = compare1;
            this._defaultCompare2 = defaultCompare2;
            this._compare2 = compare2;
            this._defaultCompare3 = defaultCompare3;
            this._compare3 = compare3;
            this._defaultCompare4 = defaultCompare4;
            this._compare4 = compare4;
            this._defaultCompare5 = defaultCompare5;
            this._compare5 = compare5;
            this._defaultCompare6 = defaultCompare6;
            this._compare6 = compare6;
            this._defaultCompare7 = defaultCompare7;
            this._compare7 = compare7;

            this._subdivisionOverride1 = subdivisionOverride1;
            this._subdivisionOverride2 = subdivisionOverride2;
            this._subdivisionOverride3 = subdivisionOverride3;
            this._subdivisionOverride4 = subdivisionOverride4;
            this._subdivisionOverride5 = subdivisionOverride5;
            this._subdivisionOverride6 = subdivisionOverride6;
            this._subdivisionOverride7 = subdivisionOverride7;

            this._top = new Node(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>.None, null, -1);
            Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
        }

        private OmnitreeBoundsLinked(
            Omnitree.GetBounds<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> getBounds,
            Equate<T> equate,

            Equate<Axis1> equateAxis1,
            Equate<Axis2> equateAxis2,
            Equate<Axis3> equateAxis3,
            Equate<Axis4> equateAxis4,
            Equate<Axis5> equateAxis5,
            Equate<Axis6> equateAxis6,
            Equate<Axis7> equateAxis7,

            Compare<Axis1> compare1,
            Compare<Axis2> compare2,
            Compare<Axis3> compare3,
            Compare<Axis4> compare4,
            Compare<Axis5> compare5,
            Compare<Axis6> compare6,
            Compare<Axis7> compare7,

            Omnitree.SubdivisionOverride<T, Axis1, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>> subdivisionOverride1,
            Omnitree.SubdivisionOverride<T, Axis2, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>> subdivisionOverride2,
            Omnitree.SubdivisionOverride<T, Axis3, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>> subdivisionOverride3,
            Omnitree.SubdivisionOverride<T, Axis4, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>> subdivisionOverride4,
            Omnitree.SubdivisionOverride<T, Axis5, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>> subdivisionOverride5,
            Omnitree.SubdivisionOverride<T, Axis6, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>> subdivisionOverride6,
            Omnitree.SubdivisionOverride<T, Axis7, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>> subdivisionOverride7)
            : this(
            getBounds,

            false,
            equate,

            false,
            equateAxis1,
            false,
            equateAxis2,
            false,
            equateAxis3,
            false,
            equateAxis4,
            false,
            equateAxis5,
            false,
            equateAxis6,
            false,
            equateAxis7,

            false,
            compare1,
            false,
            compare2,
            false,
            compare3,
            false,
            compare4,
            false,
            compare5,
            false,
            compare6,
            false,
            compare7,

            subdivisionOverride1,
            subdivisionOverride2,
            subdivisionOverride3,
            subdivisionOverride4,
            subdivisionOverride5,
            subdivisionOverride6,
            subdivisionOverride7)
        { }

        public OmnitreeBoundsLinked(
            Omnitree.GetBounds<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> getBounds,

            Equate<T> equate,

            Equate<Axis1> equateAxis1,
            Equate<Axis2> equateAxis2,
            Equate<Axis3> equateAxis3,
            Equate<Axis4> equateAxis4,
            Equate<Axis5> equateAxis5,
            Equate<Axis6> equateAxis6,
            Equate<Axis7> equateAxis7,

            Compare<Axis1> compare1,
            Compare<Axis2> compare2,
            Compare<Axis3> compare3,
            Compare<Axis4> compare4,
            Compare<Axis5> compare5,
            Compare<Axis6> compare6,
            Compare<Axis7> compare7)
            : this(
                getBounds,

                false,
                equate,

                false,
                equateAxis1,
                false,
                equateAxis2,
                false,
                equateAxis3,
                false,
                equateAxis4,
                false,
                equateAxis5,
                false,
                equateAxis6,
                false,
                equateAxis7,

                false,
                compare1,
                false,
                compare2,
                false,
                compare3,
                false,
                compare4,
                false,
                compare5,
                false,
                compare6,
                false,
                compare7,

                null,
                null,
                null,
                null,
                null,
                null,
                null)
        { }



        public OmnitreeBoundsLinked(
            Omnitree.GetBounds<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> getBounds,

            Equate<T> equate,

            Compare<Axis1> compare1,
            Compare<Axis2> compare2,
            Compare<Axis3> compare3,
            Compare<Axis4> compare4,
            Compare<Axis5> compare5,
            Compare<Axis6> compare6,
            Compare<Axis7> compare7)
            : this(
                getBounds,
                false,
                equate,

                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,

                false,
                compare1,
                false,
                compare2,
                false,
                compare3,
                false,
                compare4,
                false,
                compare5,
                false,
                compare6,
                false,
                compare7,

                null,
                null,
                null,
                null,
                null,
                null,
                null)
        { }

        public OmnitreeBoundsLinked(
            Omnitree.GetBounds<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> getBounds,
            Equate<T> equate,

            Compare<Axis1> compare1,
            Compare<Axis2> compare2,
            Compare<Axis3> compare3,
            Compare<Axis4> compare4,
            Compare<Axis5> compare5,
            Compare<Axis6> compare6,
            Compare<Axis7> compare7,

            Omnitree.SubdivisionOverride<T, Axis1, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>> subdivisionOverride1,
            Omnitree.SubdivisionOverride<T, Axis2, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>> subdivisionOverride2,
            Omnitree.SubdivisionOverride<T, Axis3, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>> subdivisionOverride3,
            Omnitree.SubdivisionOverride<T, Axis4, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>> subdivisionOverride4,
            Omnitree.SubdivisionOverride<T, Axis5, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>> subdivisionOverride5,
            Omnitree.SubdivisionOverride<T, Axis6, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>> subdivisionOverride6,
            Omnitree.SubdivisionOverride<T, Axis7, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>> subdivisionOverride7)
            : this(
                getBounds,

                false,
                equate,

                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,

                false,
                compare1,
                false,
                compare2,
                false,
                compare3,
                false,
                compare4,
                false,
                compare5,
                false,
                compare6,
                false,
                compare7,

                subdivisionOverride1,
                subdivisionOverride2,
                subdivisionOverride3,
                subdivisionOverride4,
                subdivisionOverride5,
                subdivisionOverride6,
                subdivisionOverride7)
        { }

        public OmnitreeBoundsLinked(
            Omnitree.GetBounds<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> getBounds,

            Compare<Axis1> compare1,
            Compare<Axis2> compare2,
            Compare<Axis3> compare3,
            Compare<Axis4> compare4,
            Compare<Axis5> compare5,
            Compare<Axis6> compare6,
            Compare<Axis7> compare7)
            : this(
                getBounds,
                true,
                Towel.Equate.Default,

                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,

                false,
                compare1,
                false,
                compare2,
                false,
                compare3,
                false,
                compare4,
                false,
                compare5,
                false,
                compare6,
                false,
                compare7,

                null,
                null,
                null,
                null,
                null,
                null,
                null)
        { }

        public OmnitreeBoundsLinked(
            Omnitree.GetBounds<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> getBounds,

            Compare<Axis1> compare1,
            Compare<Axis2> compare2,
            Compare<Axis3> compare3,
            Compare<Axis4> compare4,
            Compare<Axis5> compare5,
            Compare<Axis6> compare6,
            Compare<Axis7> compare7,

            Omnitree.SubdivisionOverride<T, Axis1, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>> subdivisionOverride1,
            Omnitree.SubdivisionOverride<T, Axis2, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>> subdivisionOverride2,
            Omnitree.SubdivisionOverride<T, Axis3, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>> subdivisionOverride3,
            Omnitree.SubdivisionOverride<T, Axis4, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>> subdivisionOverride4,
            Omnitree.SubdivisionOverride<T, Axis5, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>> subdivisionOverride5,
            Omnitree.SubdivisionOverride<T, Axis6, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>> subdivisionOverride6,
            Omnitree.SubdivisionOverride<T, Axis7, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>> subdivisionOverride7)
            : this(
                getBounds,

                true,
                Towel.Equate.Default,

                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,

                false,
                compare1,
                false,
                compare2,
                false,
                compare3,
                false,
                compare4,
                false,
                compare5,
                false,
                compare6,
                false,
                compare7,

                subdivisionOverride1,
                subdivisionOverride2,
                subdivisionOverride3,
                subdivisionOverride4,
                subdivisionOverride5,
                subdivisionOverride6,
                subdivisionOverride7)
        { }

        public OmnitreeBoundsLinked(
            Omnitree.GetBounds<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> getBounds,
            Equate<T> equate)
            : this(
                getBounds,

                false,
                equate,

                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,

                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,

                null,
                null,
                null,
                null,
                null,
                null,
                null)
        { }

        public OmnitreeBoundsLinked(
            Omnitree.GetBounds<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> getBounds,
            Equate<T> equate,
            Omnitree.SubdivisionOverride<T, Axis1, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>> subdivisionOverride1,
            Omnitree.SubdivisionOverride<T, Axis2, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>> subdivisionOverride2,
            Omnitree.SubdivisionOverride<T, Axis3, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>> subdivisionOverride3,
            Omnitree.SubdivisionOverride<T, Axis4, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>> subdivisionOverride4,
            Omnitree.SubdivisionOverride<T, Axis5, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>> subdivisionOverride5,
            Omnitree.SubdivisionOverride<T, Axis6, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>> subdivisionOverride6,
            Omnitree.SubdivisionOverride<T, Axis7, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>> subdivisionOverride7)
            : this(
                getBounds,

                false,
                equate,

                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,

                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,

                subdivisionOverride1,
                subdivisionOverride2,
                subdivisionOverride3,
                subdivisionOverride4,
                subdivisionOverride5,
                subdivisionOverride6,
                subdivisionOverride7)
        { }

        public OmnitreeBoundsLinked(
            Omnitree.GetBounds<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> getBounds)
            : this(
                getBounds,

                true,
                Towel.Equate.Default,

                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,

                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,

                null,
                null,
                null,
                null,
                null,
                null,
                null)
        { }

		public OmnitreeBoundsLinked(
            Omnitree.GetBoundings<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> getBoundings)
            : this(
                Omnitree.ConvertToGetBounds(getBoundings),

                true,
                Towel.Equate.Default,

                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,

                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,

                null,
                null,
                null,
                null,
                null,
                null,
                null)
        { }

        public OmnitreeBoundsLinked(
            Omnitree.GetBounds<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> getBounds,
            Omnitree.SubdivisionOverride<T, Axis1, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>> subdivisionOverride1,
            Omnitree.SubdivisionOverride<T, Axis2, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>> subdivisionOverride2,
            Omnitree.SubdivisionOverride<T, Axis3, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>> subdivisionOverride3,
            Omnitree.SubdivisionOverride<T, Axis4, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>> subdivisionOverride4,
            Omnitree.SubdivisionOverride<T, Axis5, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>> subdivisionOverride5,
            Omnitree.SubdivisionOverride<T, Axis6, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>> subdivisionOverride6,
            Omnitree.SubdivisionOverride<T, Axis7, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>> subdivisionOverride7)
            : this(
                getBounds,

                true,
                Towel.Equate.Default,

                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,
                true,
                Towel.Equate.Default,

                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,
                true,
                Compare.Default,

                subdivisionOverride1,
                subdivisionOverride2,
                subdivisionOverride3,
                subdivisionOverride4,
                subdivisionOverride5,
                subdivisionOverride6,
                subdivisionOverride7)
        { }

        #endregion

        #region Properties

        /// <summary>The number of dimensions in this tree.</summary>
        public int Dimensions { get { return _dimensions; } }

        /// <summary>The function for equating keys in this table.</summary>
        public Equate<T> Equate { get { return this._equate; } }

        /// <summary>The location function the Omnitree is using.</summary>
        public Omnitree.GetBounds<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> GetBounds { get { return this._getBounds; } }

        /// <summary>The comparison function the Omnitree is using along the 1D axis.</summary>
        public Compare<Axis1> Compare1 { get { return this._compare1; } }
        /// <summary>The comparison function the Omnitree is using along the 2D axis.</summary>
        public Compare<Axis2> Compare2 { get { return this._compare2; } }
        /// <summary>The comparison function the Omnitree is using along the 3D axis.</summary>
        public Compare<Axis3> Compare3 { get { return this._compare3; } }
        /// <summary>The comparison function the Omnitree is using along the 4D axis.</summary>
        public Compare<Axis4> Compare4 { get { return this._compare4; } }
        /// <summary>The comparison function the Omnitree is using along the 5D axis.</summary>
        public Compare<Axis5> Compare5 { get { return this._compare5; } }
        /// <summary>The comparison function the Omnitree is using along the 6D axis.</summary>
        public Compare<Axis6> Compare6 { get { return this._compare6; } }
        /// <summary>The comparison function the Omnitree is using along the 7D axis.</summary>
        public Compare<Axis7> Compare7 { get { return this._compare7; } }

        /// <summary>The function for equating values along the 1D axis.</summary>
        public Equate<Axis1> EquateAxis1 { get { return this._equate1; } }
        /// <summary>The function for equating values along the 2D axis.</summary>
        public Equate<Axis2> EquateAxis2 { get { return this._equate2; } }
        /// <summary>The function for equating values along the 3D axis.</summary>
        public Equate<Axis3> EquateAxis3 { get { return this._equate3; } }
        /// <summary>The function for equating values along the 4D axis.</summary>
        public Equate<Axis4> EquateAxis4 { get { return this._equate4; } }
        /// <summary>The function for equating values along the 5D axis.</summary>
        public Equate<Axis5> EquateAxis5 { get { return this._equate5; } }
        /// <summary>The function for equating values along the 6D axis.</summary>
        public Equate<Axis6> EquateAxis6 { get { return this._equate6; } }
        /// <summary>The function for equating values along the 7D axis.</summary>
        public Equate<Axis7> EquateAxis7 { get { return this._equate7; } }

        /// <summary>The current number of items in the tree.</summary>
        public int Count { get { return this._top.Count; } }

        private delegate void MaxDepthFinder(Node node, int current_depth, ref int max_depth);
        /// <summary>Finds the current maximum depth of the tree. NOT AN O(1) OPERATION. Intended for educational purposes only.</summary>
        public int MaxDepth
        {
            get
            {
                MaxDepthFinder maxDepthFinder = null;
                maxDepthFinder =
                        (Node node, int current_depth, ref int max_depth) =>
                        {
                            if (current_depth > max_depth)
                                max_depth = current_depth;
                            foreach (Node child in node.Children)
                                maxDepthFinder(child, current_depth + 1, ref max_depth);
                        };
                int _max_depth = -1;
                maxDepthFinder(this._top, 0, ref _max_depth);
                return _max_depth;
            }
        }

        private delegate void NodeCountFinder(Node node, ref int current_count);
        /// <summary>Counts the current number of nodes in the tree. NOT AN O(1) OPERATION. Intended for educational purposes only.</summary>
        public int NodeCount
        {
            get
            {
                NodeCountFinder nodeCountFinder = null;
                nodeCountFinder =
                        (Node node, ref int current_count) =>
                        {
                            current_count++;
                            foreach (Node child in node.Children)
                                nodeCountFinder(child, ref current_count);
                        };

                int _current_count = 0;
                nodeCountFinder(this._top, ref _current_count);
                return _current_count;
            }
        }

        #endregion

        #region Methods

        #region Add

        #region Bulk

		// not yet implemented

//        public void Add(IndexedBigArray<T> additions, bool allowMultithreading)
//        {
//            if (additions.Length > int.MaxValue)
//                throw new System.Exception("The maximum size of the Omnitree was exceeded during bulk addition.");
//
//            if (this._top.Count != 0 || (int)additions.Length <= _load)
//            {
//                for (ulong i = 0; i < additions.Length; i++)
//                    this.Add(additions[i]);
//            }
//            else
//            {
//                // adjust the loads prior to additions
//                ComputeLoads((int)additions.Length);
//
//                Node new_top = new Node(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>.None, null, -1);
//                new_top.Count = (int)additions.Length;
//
//
//                // prepare data for median computations
//                IndexedBigArray<Axis1> values1;
//                IAsyncResult result1 = null;
//                if (this._subdivisionOverride1 != null)
//                    values1 = null;
//                else
//                {
//                    values1 = null;
//                    Towel.Parallels.Parallel.Operation operation = () =>
//                    {
//                        values1 = new IndexedBigArray<Axis1>(additions.Length * 2);
//                        for (ulong i = 0; i < additions.Length; i++)
//						{
//							Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> bounds = GetBoundings(additions[i]);
//                            values1[i * 2] = bounds.Min1;
//							values1[i * 2 + 1] = bounds.Max1;
//						}
//
//                        Towel.Algorithms.Sort.Merge(this._compare1, (int i) => { return values1[(ulong)i]; }, (int i, Axis1 value) => { values1[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
//                    };
//
//                    if (allowMultithreading)
//                        result1 = Towel.Parallels.Parallel.Thread(operation);
//                    else
//                        operation();
//                }
//
//                // prepare data for median computations
//                IndexedBigArray<Axis2> values2;
//                IAsyncResult result2 = null;
//                if (this._subdivisionOverride2 != null)
//                    values2 = null;
//                else
//                {
//                    values2 = null;
//                    Towel.Parallels.Parallel.Operation operation = () =>
//                    {
//                        values2 = new IndexedBigArray<Axis2>(additions.Length * 2);
//                        for (ulong i = 0; i < additions.Length; i++)
//						{
//							Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> bounds = GetBoundings(additions[i]);
//                            values2[i * 2] = bounds.Min1;
//							values2[i * 2 + 1] = bounds.Max1;
//						}
//
//                        Towel.Algorithms.Sort.Merge(this._compare2, (int i) => { return values2[(ulong)i]; }, (int i, Axis2 value) => { values2[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
//                    };
//
//                    if (allowMultithreading)
//                        result2 = Towel.Parallels.Parallel.Thread(operation);
//                    else
//                        operation();
//                }
//
//                // prepare data for median computations
//                IndexedBigArray<Axis3> values3;
//                IAsyncResult result3 = null;
//                if (this._subdivisionOverride3 != null)
//                    values3 = null;
//                else
//                {
//                    values3 = null;
//                    Towel.Parallels.Parallel.Operation operation = () =>
//                    {
//                        values3 = new IndexedBigArray<Axis3>(additions.Length * 2);
//                        for (ulong i = 0; i < additions.Length; i++)
//						{
//							Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> bounds = GetBoundings(additions[i]);
//                            values3[i * 2] = bounds.Min1;
//							values3[i * 2 + 1] = bounds.Max1;
//						}
//
//                        Towel.Algorithms.Sort.Merge(this._compare3, (int i) => { return values3[(ulong)i]; }, (int i, Axis3 value) => { values3[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
//                    };
//
//                    if (allowMultithreading)
//                        result3 = Towel.Parallels.Parallel.Thread(operation);
//                    else
//                        operation();
//                }
//
//                // prepare data for median computations
//                IndexedBigArray<Axis4> values4;
//                IAsyncResult result4 = null;
//                if (this._subdivisionOverride4 != null)
//                    values4 = null;
//                else
//                {
//                    values4 = null;
//                    Towel.Parallels.Parallel.Operation operation = () =>
//                    {
//                        values4 = new IndexedBigArray<Axis4>(additions.Length * 2);
//                        for (ulong i = 0; i < additions.Length; i++)
//						{
//							Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> bounds = GetBoundings(additions[i]);
//                            values4[i * 2] = bounds.Min1;
//							values4[i * 2 + 1] = bounds.Max1;
//						}
//
//                        Towel.Algorithms.Sort.Merge(this._compare4, (int i) => { return values4[(ulong)i]; }, (int i, Axis4 value) => { values4[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
//                    };
//
//                    if (allowMultithreading)
//                        result4 = Towel.Parallels.Parallel.Thread(operation);
//                    else
//                        operation();
//                }
//
//                // prepare data for median computations
//                IndexedBigArray<Axis5> values5;
//                IAsyncResult result5 = null;
//                if (this._subdivisionOverride5 != null)
//                    values5 = null;
//                else
//                {
//                    values5 = null;
//                    Towel.Parallels.Parallel.Operation operation = () =>
//                    {
//                        values5 = new IndexedBigArray<Axis5>(additions.Length * 2);
//                        for (ulong i = 0; i < additions.Length; i++)
//						{
//							Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> bounds = GetBoundings(additions[i]);
//                            values5[i * 2] = bounds.Min1;
//							values5[i * 2 + 1] = bounds.Max1;
//						}
//
//                        Towel.Algorithms.Sort.Merge(this._compare5, (int i) => { return values5[(ulong)i]; }, (int i, Axis5 value) => { values5[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
//                    };
//
//                    if (allowMultithreading)
//                        result5 = Towel.Parallels.Parallel.Thread(operation);
//                    else
//                        operation();
//                }
//
//                // prepare data for median computations
//                IndexedBigArray<Axis6> values6;
//                IAsyncResult result6 = null;
//                if (this._subdivisionOverride6 != null)
//                    values6 = null;
//                else
//                {
//                    values6 = null;
//                    Towel.Parallels.Parallel.Operation operation = () =>
//                    {
//                        values6 = new IndexedBigArray<Axis6>(additions.Length * 2);
//                        for (ulong i = 0; i < additions.Length; i++)
//						{
//							Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> bounds = GetBoundings(additions[i]);
//                            values6[i * 2] = bounds.Min1;
//							values6[i * 2 + 1] = bounds.Max1;
//						}
//
//                        Towel.Algorithms.Sort.Merge(this._compare6, (int i) => { return values6[(ulong)i]; }, (int i, Axis6 value) => { values6[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
//                    };
//
//                    if (allowMultithreading)
//                        result6 = Towel.Parallels.Parallel.Thread(operation);
//                    else
//                        operation();
//                }
//
//                // prepare data for median computations
//                IndexedBigArray<Axis7> values7;
//                IAsyncResult result7 = null;
//                if (this._subdivisionOverride7 != null)
//                    values7 = null;
//                else
//                {
//                    values7 = null;
//                    Towel.Parallels.Parallel.Operation operation = () =>
//                    {
//                        values7 = new IndexedBigArray<Axis7>(additions.Length * 2);
//                        for (ulong i = 0; i < additions.Length; i++)
//						{
//							Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> bounds = GetBoundings(additions[i]);
//                            values7[i * 2] = bounds.Min1;
//							values7[i * 2 + 1] = bounds.Max1;
//						}
//
//                        Towel.Algorithms.Sort.Merge(this._compare7, (int i) => { return values7[(ulong)i]; }, (int i, Axis7 value) => { values7[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
//                    };
//
//                    if (allowMultithreading)
//                        result7 = Towel.Parallels.Parallel.Thread(operation);
//                    else
//                        operation();
//                }
//
//
//
//                if (this._subdivisionOverride1 == null && allowMultithreading)
//                    result1.AsyncWaitHandle.WaitOne();
//                if (this._subdivisionOverride2 == null && allowMultithreading)
//                    result2.AsyncWaitHandle.WaitOne();
//                if (this._subdivisionOverride3 == null && allowMultithreading)
//                    result3.AsyncWaitHandle.WaitOne();
//                if (this._subdivisionOverride4 == null && allowMultithreading)
//                    result4.AsyncWaitHandle.WaitOne();
//                if (this._subdivisionOverride5 == null && allowMultithreading)
//                    result5.AsyncWaitHandle.WaitOne();
//                if (this._subdivisionOverride6 == null && allowMultithreading)
//                    result6.AsyncWaitHandle.WaitOne();
//                if (this._subdivisionOverride7 == null && allowMultithreading)
//                    result7.AsyncWaitHandle.WaitOne();
//
//                // build the tree
//                Add(new_top, 1, -1, additions.Stepper(), (int)additions.Length, int.MinValue, int.MinValue, int.MinValue, int.MinValue, int.MinValue, int.MinValue, int.MinValue, (int)additions.Length, (int index) => { return values1[index]; }, (int index) => { return values2[index]; }, (int index) => { return values3[index]; }, (int index) => { return values4[index]; }, (int index) => { return values5[index]; }, (int index) => { return values6[index]; }, (int index) => { return values7[index]; }, allowMultithreading);
//                
//                this._top = new_top;
//            }
//        }
//
//        public void Add(bool allowMultithreading, params T[] additions)
//        {
//            if (additions.Length > int.MaxValue)
//                throw new System.Exception("The maximum size of the Omnitree was exceeded during bulk addition.");
//
//            if (this._top.Count != 0 || (int)additions.Length <= _load)
//            {
//                for (int i = 0; i < additions.Length; i++)
//                    this.Add(additions[i]);
//            }
//            else
//            {
//                // adjust the loads prior to additions
//                ComputeLoads((int)additions.Length);
//
//                Node new_top = new Node(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>.None, null, -1);
//                new_top.Count = (int)additions.Length;
//
//
//                // prepare data for median computations
//                IndexedBigArray<Axis1> values1;
//                IAsyncResult result1 = null;
//                if (this._subdivisionOverride1 != null)
//                    values1 = null;
//                else
//                {
//                    values1 = null;
//                    Towel.Parallels.Parallel.Operation operation = () =>
//                    {
//                        values1 = new IndexedBigArray<Axis1>(additions.Length);
//                        for (int i = 0; i < additions.Length; i++)
//                            values1[i] = LocateVector(additions[i]).Axis1;
//                        Towel.Algorithms.Sort.Merge(this._compare1, (int i) => { return values1[(ulong)i]; }, (int i, Axis1 value) => { values1[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
//                    };
//
//                    if (allowMultithreading)
//                        result1 = Towel.Parallels.Parallel.Thread(operation);
//                    else
//                        operation();
//                }
//
//                // prepare data for median computations
//                IndexedBigArray<Axis2> values2;
//                IAsyncResult result2 = null;
//                if (this._subdivisionOverride2 != null)
//                    values2 = null;
//                else
//                {
//                    values2 = null;
//                    Towel.Parallels.Parallel.Operation operation = () =>
//                    {
//                        values2 = new IndexedBigArray<Axis2>(additions.Length);
//                        for (int i = 0; i < additions.Length; i++)
//                            values2[i] = LocateVector(additions[i]).Axis2;
//                        Towel.Algorithms.Sort.Merge(this._compare2, (int i) => { return values2[(ulong)i]; }, (int i, Axis2 value) => { values2[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
//                    };
//
//                    if (allowMultithreading)
//                        result2 = Towel.Parallels.Parallel.Thread(operation);
//                    else
//                        operation();
//                }
//
//                // prepare data for median computations
//                IndexedBigArray<Axis3> values3;
//                IAsyncResult result3 = null;
//                if (this._subdivisionOverride3 != null)
//                    values3 = null;
//                else
//                {
//                    values3 = null;
//                    Towel.Parallels.Parallel.Operation operation = () =>
//                    {
//                        values3 = new IndexedBigArray<Axis3>(additions.Length);
//                        for (int i = 0; i < additions.Length; i++)
//                            values3[i] = LocateVector(additions[i]).Axis3;
//                        Towel.Algorithms.Sort.Merge(this._compare3, (int i) => { return values3[(ulong)i]; }, (int i, Axis3 value) => { values3[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
//                    };
//
//                    if (allowMultithreading)
//                        result3 = Towel.Parallels.Parallel.Thread(operation);
//                    else
//                        operation();
//                }
//
//                // prepare data for median computations
//                IndexedBigArray<Axis4> values4;
//                IAsyncResult result4 = null;
//                if (this._subdivisionOverride4 != null)
//                    values4 = null;
//                else
//                {
//                    values4 = null;
//                    Towel.Parallels.Parallel.Operation operation = () =>
//                    {
//                        values4 = new IndexedBigArray<Axis4>(additions.Length);
//                        for (int i = 0; i < additions.Length; i++)
//                            values4[i] = LocateVector(additions[i]).Axis4;
//                        Towel.Algorithms.Sort.Merge(this._compare4, (int i) => { return values4[(ulong)i]; }, (int i, Axis4 value) => { values4[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
//                    };
//
//                    if (allowMultithreading)
//                        result4 = Towel.Parallels.Parallel.Thread(operation);
//                    else
//                        operation();
//                }
//
//                // prepare data for median computations
//                IndexedBigArray<Axis5> values5;
//                IAsyncResult result5 = null;
//                if (this._subdivisionOverride5 != null)
//                    values5 = null;
//                else
//                {
//                    values5 = null;
//                    Towel.Parallels.Parallel.Operation operation = () =>
//                    {
//                        values5 = new IndexedBigArray<Axis5>(additions.Length);
//                        for (int i = 0; i < additions.Length; i++)
//                            values5[i] = LocateVector(additions[i]).Axis5;
//                        Towel.Algorithms.Sort.Merge(this._compare5, (int i) => { return values5[(ulong)i]; }, (int i, Axis5 value) => { values5[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
//                    };
//
//                    if (allowMultithreading)
//                        result5 = Towel.Parallels.Parallel.Thread(operation);
//                    else
//                        operation();
//                }
//
//                // prepare data for median computations
//                IndexedBigArray<Axis6> values6;
//                IAsyncResult result6 = null;
//                if (this._subdivisionOverride6 != null)
//                    values6 = null;
//                else
//                {
//                    values6 = null;
//                    Towel.Parallels.Parallel.Operation operation = () =>
//                    {
//                        values6 = new IndexedBigArray<Axis6>(additions.Length);
//                        for (int i = 0; i < additions.Length; i++)
//                            values6[i] = LocateVector(additions[i]).Axis6;
//                        Towel.Algorithms.Sort.Merge(this._compare6, (int i) => { return values6[(ulong)i]; }, (int i, Axis6 value) => { values6[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
//                    };
//
//                    if (allowMultithreading)
//                        result6 = Towel.Parallels.Parallel.Thread(operation);
//                    else
//                        operation();
//                }
//
//                // prepare data for median computations
//                IndexedBigArray<Axis7> values7;
//                IAsyncResult result7 = null;
//                if (this._subdivisionOverride7 != null)
//                    values7 = null;
//                else
//                {
//                    values7 = null;
//                    Towel.Parallels.Parallel.Operation operation = () =>
//                    {
//                        values7 = new IndexedBigArray<Axis7>(additions.Length);
//                        for (int i = 0; i < additions.Length; i++)
//                            values7[i] = LocateVector(additions[i]).Axis7;
//                        Towel.Algorithms.Sort.Merge(this._compare7, (int i) => { return values7[(ulong)i]; }, (int i, Axis7 value) => { values7[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
//                    };
//
//                    if (allowMultithreading)
//                        result7 = Towel.Parallels.Parallel.Thread(operation);
//                    else
//                        operation();
//                }
//
//
//
//                if (this._subdivisionOverride1 == null && allowMultithreading)
//                    result1.AsyncWaitHandle.WaitOne();
//
//                if (this._subdivisionOverride2 == null && allowMultithreading)
//                    result2.AsyncWaitHandle.WaitOne();
//
//                if (this._subdivisionOverride3 == null && allowMultithreading)
//                    result3.AsyncWaitHandle.WaitOne();
//
//                if (this._subdivisionOverride4 == null && allowMultithreading)
//                    result4.AsyncWaitHandle.WaitOne();
//
//                if (this._subdivisionOverride5 == null && allowMultithreading)
//                    result5.AsyncWaitHandle.WaitOne();
//
//                if (this._subdivisionOverride6 == null && allowMultithreading)
//                    result6.AsyncWaitHandle.WaitOne();
//
//                if (this._subdivisionOverride7 == null && allowMultithreading)
//                    result7.AsyncWaitHandle.WaitOne();
//
//
//                // build the tree
//                Add(new_top, 1, -1, additions.Stepper(), additions.Length, int.MinValue, int.MinValue, int.MinValue, int.MinValue, int.MinValue, int.MinValue, int.MinValue, (int)additions.Length, (int index) => { return values1[index]; }, (int index) => { return values2[index]; }, (int index) => { return values3[index]; }, (int index) => { return values4[index]; }, (int index) => { return values5[index]; }, (int index) => { return values6[index]; }, (int index) => { return values7[index]; }, allowMultithreading);
//                
//                this._top = new_top;
//            }
//        }
//
//        
//        private int Add(Node parent, int depth, int child, Stepper<T> additions, int parent_count, int prevmed1, int prevmed2, int prevmed3, int prevmed4, int prevmed5, int prevmed6, int prevmed7, int initial_count, Get<Axis1> values1, Get<Axis2> values2, Get<Axis3> values3, Get<Axis4> values4, Get<Axis5> values5, Get<Axis6> values6, Get<Axis7> values7, bool allowMultithreading)
//        {
//            Axis1 pointOfDivision1;
//            Axis2 pointOfDivision2;
//            Axis3 pointOfDivision3;
//            Axis4 pointOfDivision4;
//            Axis5 pointOfDivision5;
//            Axis6 pointOfDivision6;
//            Axis7 pointOfDivision7;
//
//            int median_axis1 = -1;
//            int median_axis2 = -1;
//            int median_axis3 = -1;
//            int median_axis4 = -1;
//            int median_axis5 = -1;
//            int median_axis6 = -1;
//            int median_axis7 = -1;
//            if (this._subdivisionOverride1 == null || this._subdivisionOverride2 == null || this._subdivisionOverride3 == null || this._subdivisionOverride4 == null || this._subdivisionOverride5 == null || this._subdivisionOverride6 == null || this._subdivisionOverride7 == null)
//                GetMedianIndexes(initial_count, child, depth, prevmed1, prevmed2, prevmed3, prevmed4, prevmed5, prevmed6, prevmed7, out median_axis1, out median_axis2, out median_axis3, out median_axis4, out median_axis5, out median_axis6, out median_axis7);
//
//            if (this._subdivisionOverride1 != null)
//                pointOfDivision1 = this._subdivisionOverride1(parent.Bounds, additions);
//            else
//                pointOfDivision1 = values1(median_axis1);
//
//            if (this._subdivisionOverride2 != null)
//                pointOfDivision2 = this._subdivisionOverride2(parent.Bounds, additions);
//            else
//                pointOfDivision2 = values2(median_axis2);
//
//            if (this._subdivisionOverride3 != null)
//                pointOfDivision3 = this._subdivisionOverride3(parent.Bounds, additions);
//            else
//                pointOfDivision3 = values3(median_axis3);
//
//            if (this._subdivisionOverride4 != null)
//                pointOfDivision4 = this._subdivisionOverride4(parent.Bounds, additions);
//            else
//                pointOfDivision4 = values4(median_axis4);
//
//            if (this._subdivisionOverride5 != null)
//                pointOfDivision5 = this._subdivisionOverride5(parent.Bounds, additions);
//            else
//                pointOfDivision5 = values5(median_axis5);
//
//            if (this._subdivisionOverride6 != null)
//                pointOfDivision6 = this._subdivisionOverride6(parent.Bounds, additions);
//            else
//                pointOfDivision6 = values6(median_axis6);
//
//            if (this._subdivisionOverride7 != null)
//                pointOfDivision7 = this._subdivisionOverride7(parent.Bounds, additions);
//            else
//                pointOfDivision7 = values7(median_axis7);
//
//            parent.PointOfDivision = new Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>(pointOfDivision1, pointOfDivision2, pointOfDivision3, pointOfDivision4, pointOfDivision5, pointOfDivision6, pointOfDivision7);
//
//            // divide the values along the medians
//            IMap<IAddable<T>, int> collection_map = new MapHashLinked<IAddable<T>, int>();
//            additions((T value) => 
//            {
//                int index = DetermineChildIndex(parent.PointOfDivision.Value, LocateVector(value));
//                IAddable<T> list = null;
//                if (collection_map.TryGet(index, out list))
//                {
//                    list.Add(value);
//                }
//                else
//                {
//                    if (parent_count < 100000)
//                        list = new AddableArray<T>();
//                    else
//                        list = new AddableLinked<T>();
//                    collection_map.Add(index, list);
//                    list.Add(value);
//                }
//            });
//
//            if (depth == 1 && allowMultithreading)
//            {
//                // NOTE: Must assign placeholders before multithreading so that the threads do not overwrite each other
//                collection_map.Keys((int key) => { parent[key] = new Node(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>.None, parent, key); });
//                IAsyncResult[] handles = new IAsyncResult[Environment.ProcessorCount];
//                for (int i = 0; i < handles.Length; i++)
//                {
//                    int multiTheadSafe_i = i; // used as catpure variable below making it multithread-safe
//                    handles[i] = Towel.Parallels.Parallel.Thread(() =>
//                    {
//                        Step.EveryNth<Link<IAddable<T>, int>>(collection_map.Pairs, multiTheadSafe_i + 1)(
//                        (Link<IAddable<T>, int> link) =>
//                            {
//                                ReversedChildBuilding(parent, link._2, depth, link._1.Stepper, link._1.Count, median_axis1, median_axis2, median_axis3, median_axis4, median_axis5, median_axis6, median_axis7, initial_count, values1, values2, values3, values4, values5, values6, values7, allowMultithreading);
//                            });
//                    });
//                }
//                
//                foreach (IAsyncResult handle in handles)
//                {
//                    handle.AsyncWaitHandle.WaitOne();
//                }
//            }
//            else
//            {
//                collection_map.Pairs((Link<IAddable<T>, int> link) =>
//                { 
//                    ReversedChildBuilding(parent, link._2, depth, link._1.Stepper, link._1.Count, median_axis1, median_axis2, median_axis3, median_axis4, median_axis5, median_axis6, median_axis7, initial_count, values1, values2, values3, values4, values5, values6, values7, allowMultithreading);
//                });
//            }
//
//            int count = 0;
//            foreach (Node node in parent.Children)
//                count += node.Count;
//            return count;
//        }
//
//        int ReversedChildBuilding(Node parent, int child_index, int depth, Stepper<T> additions, int count, int prevmed1, int prevmed2, int prevmed3, int prevmed4, int prevmed5, int prevmed6, int prevmed7, int initial_count, Get<Axis1> values1, Get<Axis2> values2, Get<Axis3> values3, Get<Axis4> values4, Get<Axis5> values5, Get<Axis6> values6, Get<Axis7> values7, bool allowMultithreading)
//        {
//            Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> child_bounds = DetermineChildBounds(parent, child_index);
//            if (depth >= _load || count <= _load)
//            {
//                Node new_leaf = new Node(child_bounds, parent, child_index);
//                additions((T value) => { new_leaf.Add(value); });
//                parent[new_leaf.Index] = new_leaf;
//                return new_leaf.Count;
//            }
//            else
//            {
//                Node new_branch = new Node(Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>.Default, child_bounds, parent, child_index);
//                parent[new_branch.Index] = new_branch;
//                new_branch.Count = Add(new_branch, depth + 1, child_index, additions, count, prevmed1, prevmed2, prevmed3, prevmed4, prevmed5, prevmed6, prevmed7, count, values1, values2, values3, values4, values5, values6, values7, allowMultithreading);
//                return new_branch.Count;
//            }
//        }
//
//        /// <summary>Gets the indeces of the median values at the given position during bulk additions.</summary>
//        private void GetMedianIndexes(int count, int child_index, int depth, int previous1, int previous2, int previous3, int previous4, int previous5, int previous6, int previous7, out int index1, out int index2, out int index3, out int index4, out int index5, out int index6, out int index7)
//        {
//            if (depth == 1)
//            {
//                index1 = (count - 1) / 2;
//                index2 = (count - 1) / 2;
//                index3 = (count - 1) / 2;
//                index4 = (count - 1) / 2;
//                index5 = (count - 1) / 2;
//                index6 = (count - 1) / 2;
//                index7 = (count - 1) / 2;
//                return;
//            }
//
//            int splits = Compute.Power(2, depth);
//            int mid_child_range = count / splits;
//
//            if (child_index >= 64)
//            {
//                index7 = previous7 + mid_child_range;
//                child_index -= 64;
//            }
//            else
//            {
//                index7 = previous7 - mid_child_range;
//            }
//
//            if (child_index >= 32)
//            {
//                index6 = previous6 + mid_child_range;
//                child_index -= 32;
//            }
//            else
//            {
//                index6 = previous6 - mid_child_range;
//            }
//
//            if (child_index >= 16)
//            {
//                index5 = previous5 + mid_child_range;
//                child_index -= 16;
//            }
//            else
//            {
//                index5 = previous5 - mid_child_range;
//            }
//
//            if (child_index >= 8)
//            {
//                index4 = previous4 + mid_child_range;
//                child_index -= 8;
//            }
//            else
//            {
//                index4 = previous4 - mid_child_range;
//            }
//
//            if (child_index >= 4)
//            {
//                index3 = previous3 + mid_child_range;
//                child_index -= 4;
//            }
//            else
//            {
//                index3 = previous3 - mid_child_range;
//            }
//
//            if (child_index >= 2)
//            {
//                index2 = previous2 + mid_child_range;
//                child_index -= 2;
//            }
//            else
//            {
//                index2 = previous2 - mid_child_range;
//            }
//
//            if (child_index >= 1)
//            {
//                index1 = previous1 + mid_child_range;
//                child_index -= 1;
//            }
//            else
//            {
//                index1 = previous1 - mid_child_range;
//            }
//
//        }

		

        #endregion

        #region single

        /// <summary>Adds an item to the tree.</summary>
        /// <param name="addition">The item to be added.</param>
        public void Add(T addition)
        {
            if (this._top.Count == int.MaxValue)
                throw new System.InvalidOperationException("(Count == int.MaxValue) max Omnitree size reached (change ints to longs if you need to).");

            // dynamic tree sizes
            Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);

            Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> bounds = GetBoundings(addition);

            // grow the first branch of the tree
            if (!this._top.PointOfDivision.HasValue && this._top.Count >= _load)
            {
                Node top = this._top;

                // create the new branch from the median values
                this._top = new Node(DetermineMedians(top), Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>.None, null, -1);

                // iterate through the elements and add them to the appropriate children
                for (Node.ValueNode list = top.Head; list != null; list = list.Next)
                    Add(list.Value, this._top, GetBoundings(list.Value), 0);
            }

            this.Add(addition, this._top, bounds, 0);
        }
        
        /// <summary>Recursive version of the add function.</summary>
        /// <param name="addition">The item to be added.</param>
        /// <param name="node">The current node for tree trversal.</param>
        /// <param name="ms">The location of the addition.</param>
        /// <param name="depth">The current depth of iteration.</param>
        private void Add(T addition, Node node, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> bounds, int depth)
        {
            if (!node.PointOfDivision.HasValue)
            {
                //Leaf leaf = node as Leaf;
                if (depth >= _load || !(node.Count >= _load))
                {
                    node.Add(addition);
                    return;
                }
                else
                {
                    //Node parent = node.Parent;
                    //int child_index = this.DetermineChildIndex(parent.PointOfDivision, location);
                    //Node growth = new Node(DetermineMedians(leaf), leaf.Bounds, parent, child_index);
                    //parent[child_index] = growth;

					Node growth = new Node(DetermineMedians(node), node.Bounds, node.Parent, node.Index);
                    node.Parent[node.Index] = growth;

                    for (Node.ValueNode list = node.Head; list != null; list = list.Next)
                    {
                        Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> temp_bounds = GetBoundings(list.Value);
                        if (EncapsulationCheck(growth.Bounds, temp_bounds))
                            Add(list.Value, growth, temp_bounds, depth);
                        else
                        {
                            ReduceParentCounts(node.Parent, 1);
                            Add(list.Value, this._top, temp_bounds, depth);
                        }
                    }

                    Add(addition, growth, bounds, depth);
                    return;
                }
            }
            else
            {
                //Node branch = node as Node;
                int child_index = this.DetermineChildIndex(node.PointOfDivision.Value, bounds); // determine the child "index" (0 through 2^Dimensions) the addition belongs in
                
				// if -1, then the bounds of the addition straddle the point of division (keep it in current node)
				if (child_index == -1)
				{
					node.Add(addition);
                    return;
				}
				
				Node child_node = node[child_index];

                // null children in branches are just empty leaves
                if (child_node == null)
                {
                    Node new_node = new Node(DetermineChildBounds(node, child_index), node, child_index);
                    node[child_index] = new_node;
                    new_node.Add(addition);
                }
                else
                    // child exists already, continue adding
                    Add(addition, child_node, bounds, depth + 1);

                node.Count++;
                return;
            }
        }

        /// <summary>Determins the dimensions of the child at the given index.</summary>
        /// <param name="leaf">The parent of the node to compute dimensions for.</param>
        /// <param name="child">The index of the child to compute dimensions for.</param>
        /// <param name="median1">The computed minimum dimensions of the child node along the 1D axis.</param>
        /// <param name="median2">The computed minimum dimensions of the child node along the 2D axis.</param>
        /// <param name="median3">The computed minimum dimensions of the child node along the 3D axis.</param>
        private Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> DetermineMedians(Node node)
        {
            try
            {
                // extract the values
                Omnitree.Bound<Axis1>[] values1 = new Omnitree.Bound<Axis1>[node.Count * 2];
                Omnitree.Bound<Axis2>[] values2 = new Omnitree.Bound<Axis2>[node.Count * 2];
                Omnitree.Bound<Axis3>[] values3 = new Omnitree.Bound<Axis3>[node.Count * 2];
                Omnitree.Bound<Axis4>[] values4 = new Omnitree.Bound<Axis4>[node.Count * 2];
                Omnitree.Bound<Axis5>[] values5 = new Omnitree.Bound<Axis5>[node.Count * 2];
                Omnitree.Bound<Axis6>[] values6 = new Omnitree.Bound<Axis6>[node.Count * 2];
                Omnitree.Bound<Axis7>[] values7 = new Omnitree.Bound<Axis7>[node.Count * 2];
                Node.ValueNode for_current = node.Head; // used in for loop
                for (int i = 0; i < node.Count; i++, for_current = for_current.Next)
                    this._getBounds(for_current.Value, 
					out values1[i * 2], out values1[i * 2 + 1], 
					out values2[i * 2], out values2[i * 2 + 1], 
					out values3[i * 2], out values3[i * 2 + 1], 
					out values4[i * 2], out values4[i * 2 + 1], 
					out values5[i * 2], out values5[i * 2 + 1], 
					out values6[i * 2], out values6[i * 2 + 1], 
					out values7[i * 2], out values7[i * 2 + 1]);
                return new Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>(
					Omnitree.SubDivide(values1, this._defaultCompare1 ? Compare.Default : this._compare1), 
					Omnitree.SubDivide(values2, this._defaultCompare2 ? Compare.Default : this._compare2), 
					Omnitree.SubDivide(values3, this._defaultCompare3 ? Compare.Default : this._compare3), 
					Omnitree.SubDivide(values4, this._defaultCompare4 ? Compare.Default : this._compare4), 
					Omnitree.SubDivide(values5, this._defaultCompare5 ? Compare.Default : this._compare5), 
					Omnitree.SubDivide(values6, this._defaultCompare6 ? Compare.Default : this._compare6), 
					Omnitree.SubDivide(values7, this._defaultCompare7 ? Compare.Default : this._compare7));
            }
            catch
            {
                // extract the values
                IndexedBigArray<Omnitree.Bound<Axis1>> values1 = new IndexedBigArray<Omnitree.Bound<Axis1>>(node.Count * 2);
                IndexedBigArray<Omnitree.Bound<Axis2>> values2 = new IndexedBigArray<Omnitree.Bound<Axis2>>(node.Count * 2);
                IndexedBigArray<Omnitree.Bound<Axis3>> values3 = new IndexedBigArray<Omnitree.Bound<Axis3>>(node.Count * 2);
                IndexedBigArray<Omnitree.Bound<Axis4>> values4 = new IndexedBigArray<Omnitree.Bound<Axis4>>(node.Count * 2);
                IndexedBigArray<Omnitree.Bound<Axis5>> values5 = new IndexedBigArray<Omnitree.Bound<Axis5>>(node.Count * 2);
                IndexedBigArray<Omnitree.Bound<Axis6>> values6 = new IndexedBigArray<Omnitree.Bound<Axis6>>(node.Count * 2);
                IndexedBigArray<Omnitree.Bound<Axis7>> values7 = new IndexedBigArray<Omnitree.Bound<Axis7>>(node.Count * 2);
                Node.ValueNode for_current = node.Head; // used in for loop
                for (int i = 0; i < node.Count; i++, for_current = for_current.Next)
                {
                    Omnitree.Bound<Axis1> min1; Omnitree.Bound<Axis1> max1;
                    Omnitree.Bound<Axis2> min2; Omnitree.Bound<Axis2> max2;
                    Omnitree.Bound<Axis3> min3; Omnitree.Bound<Axis3> max3;
                    Omnitree.Bound<Axis4> min4; Omnitree.Bound<Axis4> max4;
                    Omnitree.Bound<Axis5> min5; Omnitree.Bound<Axis5> max5;
                    Omnitree.Bound<Axis6> min6; Omnitree.Bound<Axis6> max6;
                    Omnitree.Bound<Axis7> min7; Omnitree.Bound<Axis7> max7;
                    this._getBounds(for_current.Value,
						out min1, out max1,
						out min2, out max2,
						out min3, out max3,
						out min4, out max4,
						out min5, out max5,
						out min6, out max6,
						out min7, out max7);
                    values1[i * 2] = min1; values1[i * 2 + 1] = max1;
                    values2[i * 2] = min2; values2[i * 2 + 1] = max2;
                    values3[i * 2] = min3; values3[i * 2 + 1] = max3;
                    values4[i * 2] = min4; values4[i * 2 + 1] = max4;
                    values5[i * 2] = min5; values5[i * 2 + 1] = max5;
                    values6[i * 2] = min6; values6[i * 2 + 1] = max6;
                    values7[i * 2] = min7; values7[i * 2 + 1] = max7;
                }
				return new Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>(
					Omnitree.SubDivide(values1, this._defaultCompare1 ? Compare.Default : this._compare1), 
					Omnitree.SubDivide(values2, this._defaultCompare2 ? Compare.Default : this._compare2), 
					Omnitree.SubDivide(values3, this._defaultCompare3 ? Compare.Default : this._compare3), 
					Omnitree.SubDivide(values4, this._defaultCompare4 ? Compare.Default : this._compare4), 
					Omnitree.SubDivide(values5, this._defaultCompare5 ? Compare.Default : this._compare5), 
					Omnitree.SubDivide(values6, this._defaultCompare6 ? Compare.Default : this._compare6), 
					Omnitree.SubDivide(values7, this._defaultCompare7 ? Compare.Default : this._compare7));
            }
        }

        #endregion

        #region Add Helpers

        private Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> DetermineChildBounds(Node node, int child_index)
        {
			// the node parameter should always have a point of division value for this function
			Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> pointOfDivision = node.PointOfDivision.Value;

            Omnitree.Bound<Axis7> min7, max7;
            if (child_index >= 64)
            {
                min7 = pointOfDivision.Axis7;
                max7 = node.Bounds.Max7;
                child_index -= 64;
            }
            else
            {
                min7 = node.Bounds.Min7;
                max7 = pointOfDivision.Axis7;
            }

            Omnitree.Bound<Axis6> min6, max6;
            if (child_index >= 32)
            {
                min6 = pointOfDivision.Axis6;
                max6 = node.Bounds.Max6;
                child_index -= 32;
            }
            else
            {
                min6 = node.Bounds.Min6;
                max6 = pointOfDivision.Axis6;
            }

            Omnitree.Bound<Axis5> min5, max5;
            if (child_index >= 16)
            {
                min5 = pointOfDivision.Axis5;
                max5 = node.Bounds.Max5;
                child_index -= 16;
            }
            else
            {
                min5 = node.Bounds.Min5;
                max5 = pointOfDivision.Axis5;
            }

            Omnitree.Bound<Axis4> min4, max4;
            if (child_index >= 8)
            {
                min4 = pointOfDivision.Axis4;
                max4 = node.Bounds.Max4;
                child_index -= 8;
            }
            else
            {
                min4 = node.Bounds.Min4;
                max4 = pointOfDivision.Axis4;
            }

            Omnitree.Bound<Axis3> min3, max3;
            if (child_index >= 4)
            {
                min3 = pointOfDivision.Axis3;
                max3 = node.Bounds.Max3;
                child_index -= 4;
            }
            else
            {
                min3 = node.Bounds.Min3;
                max3 = pointOfDivision.Axis3;
            }

            Omnitree.Bound<Axis2> min2, max2;
            if (child_index >= 2)
            {
                min2 = pointOfDivision.Axis2;
                max2 = node.Bounds.Max2;
                child_index -= 2;
            }
            else
            {
                min2 = node.Bounds.Min2;
                max2 = pointOfDivision.Axis2;
            }

            Omnitree.Bound<Axis1> min1, max1;
            if (child_index >= 1)
            {
                min1 = pointOfDivision.Axis1;
                max1 = node.Bounds.Max1;
                child_index -= 1;
            }
            else
            {
                min1 = node.Bounds.Min1;
                max1 = pointOfDivision.Axis1;
            }

            return new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6, min7, max7);
        }

        #endregion

        #endregion

        #region Clear

        /// <summary>Returns the tree to an empty state.</summary>
        public void Clear()
        {
            this._top = new Node(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>.None, null, -1);
            Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
        }

        #endregion

        #region Clone

        /// <summary>Creates a shallow clone of this data structure.</summary>
        /// <returns>A shallow clone of this data structure.</returns>
        public OmnitreeBoundsLinked<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> Clone()
        {
            return new OmnitreeBoundsLinked<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>(this);
        }

        #endregion

        #region Count

        /// <summary>Counts the number of items encapsulated by a sub space.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		/// <param name="min7">The minimum coordinate of the space along the 7 axis.</param>
		/// <param name="max7">The maximum coordinate of the space along the 7 axis.</param>
        /// <returns>The number of items in the provided sub space.</returns>
        public int CountSubSpaceEncapsulated(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5, Axis6 min6, Axis6 max6, Axis7 min7, Axis7 max7)
        {
            return CountSubSpaceEncapsulated(_top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6, min7, max7));
        }
        /// <summary>Counts the number of items encapsulated by a sub space.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		/// <param name="min7">The minimum coordinate of the space along the 7 axis.</param>
		/// <param name="max7">The maximum coordinate of the space along the 7 axis.</param>
        /// <returns>The number of items in the provided sub space.</returns>
        public int CountSubSpaceEncapsulated(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5, Omnitree.Bound<Axis6> min6, Omnitree.Bound<Axis6> max6, Omnitree.Bound<Axis7> min7, Omnitree.Bound<Axis7> max7)
        {
            return CountSubSpaceEncapsulated(_top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6, min7, max7));
        }
        /// <summary>Counts the number of items encapsulated by a sub space.</summary>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
		/// <param name="axis5">The coordinate along the 5D axis.</param>
		/// <param name="axis6">The coordinate along the 6D axis.</param>
		/// <param name="axis7">The coordinate along the 7D axis.</param>
        /// <returns>The number of items in the provided sub space.</returns>
        public int CountSubSpaceEncapsulated(Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Axis5 axis5, Axis6 axis6, Axis7 axis7)
        {
            return CountSubSpaceEncapsulated(_top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>(axis1, axis1, axis2, axis2, axis3, axis3, axis4, axis4, axis5, axis5, axis6, axis6, axis7, axis7));
        }
        /// <summary>Counts the number of items encapsulated by a sub space.</summary>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
		/// <param name="axis5">The coordinate along the 5D axis.</param>
		/// <param name="axis6">The coordinate along the 6D axis.</param>
		/// <param name="axis7">The coordinate along the 7D axis.</param>
        /// <returns>The number of items in the provided sub space.</returns>
        public int CountSubSpaceEncapsulated(Omnitree.Bound<Axis1> axis1, Omnitree.Bound<Axis2> axis2, Omnitree.Bound<Axis3> axis3, Omnitree.Bound<Axis4> axis4, Omnitree.Bound<Axis5> axis5, Omnitree.Bound<Axis6> axis6, Omnitree.Bound<Axis7> axis7)
        {
            return CountSubSpaceEncapsulated(_top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>(axis1, axis1, axis2, axis2, axis3, axis3, axis4, axis4, axis5, axis5, axis6, axis6, axis7, axis7));
        }

        /// <summary>Counts the number of items overlapped by a sub space.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		/// <param name="min7">The minimum coordinate of the space along the 7 axis.</param>
		/// <param name="max7">The maximum coordinate of the space along the 7 axis.</param>
        /// <returns>The number of items in the provided sub space.</returns>
        public int CountSubSpaceOverlapped(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5, Axis6 min6, Axis6 max6, Axis7 min7, Axis7 max7)
        {
            return CountSubSpaceOverlapped(_top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6, min7, max7));
        }
        /// <summary>Counts the number of items overlapped by a sub space.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		/// <param name="min7">The minimum coordinate of the space along the 7 axis.</param>
		/// <param name="max7">The maximum coordinate of the space along the 7 axis.</param>
        /// <returns>The number of items in the provided sub space.</returns>
        public int CountSubSpaceOverlapped(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5, Omnitree.Bound<Axis6> min6, Omnitree.Bound<Axis6> max6, Omnitree.Bound<Axis7> min7, Omnitree.Bound<Axis7> max7)
        {
            return CountSubSpaceOverlapped(_top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6, min7, max7));
        }
        /// <summary>Counts the number of items overlapped by a sub space.</summary>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
		/// <param name="axis5">The coordinate along the 5D axis.</param>
		/// <param name="axis6">The coordinate along the 6D axis.</param>
		/// <param name="axis7">The coordinate along the 7D axis.</param>
        /// <returns>The number of items in the provided sub space.</returns>
        public int CountSubSpaceOverlapped(Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Axis5 axis5, Axis6 axis6, Axis7 axis7)
        {
            return CountSubSpaceOverlapped(_top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>(axis1, axis1, axis2, axis2, axis3, axis3, axis4, axis4, axis5, axis5, axis6, axis6, axis7, axis7));
        }
        /// <summary>Counts the number of items overlapped by a sub space.</summary>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
		/// <param name="axis5">The coordinate along the 5D axis.</param>
		/// <param name="axis6">The coordinate along the 6D axis.</param>
		/// <param name="axis7">The coordinate along the 7D axis.</param>
        /// <returns>The number of items in the provided sub space.</returns>
        public int CountSubSpaceOverlapped(Omnitree.Bound<Axis1> axis1, Omnitree.Bound<Axis2> axis2, Omnitree.Bound<Axis3> axis3, Omnitree.Bound<Axis4> axis4, Omnitree.Bound<Axis5> axis5, Omnitree.Bound<Axis6> axis6, Omnitree.Bound<Axis7> axis7)
        {
            return CountSubSpaceOverlapped(_top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>(axis1, axis1, axis2, axis2, axis3, axis3, axis4, axis4, axis5, axis5, axis6, axis6, axis7, axis7));
        }

		private int CountSubSpaceEncapsulated(Node node, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> bounds)
		{
			return CountSubSpaceBase(_top, bounds, (a, b) => EncapsulationCheck(a, b));
		}

		private int CountSubSpaceOverlapped(Node node, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> bounds)
		{
			return CountSubSpaceBase(_top, bounds, (a, b) => InclusionCheck(a, b));
		}

		private int CountSubSpaceBase(
			Node node,
			Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> bounds,
			Omnitree.SpatialCheck<Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>> spatialCheck)
        {
            // adjust min/max values
            int count = 0;
            if (EncapsulationCheck(bounds, node.Bounds))
                count += node.Count;
            else if (!node.PointOfDivision.HasValue)
            {
                for (Node.ValueNode list = node.Head; list != null; list = list.Next)
                    if (spatialCheck(bounds, GetBoundings(list.Value)))
                        count++;
            }
            else
            {
                Node branch = node as Node;
                if (!StraddlesLines(branch.Bounds, branch.PointOfDivision.Value))
                {
                    int child_index = DetermineChildIndex(branch.PointOfDivision.Value, bounds);
                    Node child = branch[child_index];
                    if (child != null)
                      count += this.CountSubSpaceBase(child, bounds, spatialCheck);
                }
                else
                {
                    foreach (Node child in node.Children)
                        count += this.CountSubSpaceBase(child, bounds, spatialCheck);
                }
            }
            return count;
        }

        #endregion

        #region Update

        /// <summary>Iterates through the entire tree and ensures each item is in the proper leaf.</summary>
        public void Update()
        {
            this.Update(this._top, 0);
        }

        /// <summary>Recursive version of the Update method.</summary>
        /// <param name="node">The current node of iteration.</param>
        /// <param name="depth">The current depth of iteration.</param>
        private int Update(Node node, int depth)
        {
			// I messed up this function in the conversion
			throw new System.NotImplementedException();

            int removals = 0;

            if (!node.PointOfDivision.HasValue)
            {
                Node.ValueNode current = node.Head;
                Node.ValueNode previous = null;
                while (current != null)
                {
                    Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> bounds = GetBoundings(current.Value);
                    if (!this.EncapsulationCheck(node.Bounds, bounds))
                    {
                        removals++;
                        T updated = current.Value;
                        if (previous == null)
                        {
                            node.Head = current.Next;
                            goto HeadRemoved;
                        }
                        else
                            previous.Next = current.Next;

                        Node whereToAdd = GetEncapsulationParent(node.Parent, bounds);

                        if (whereToAdd == null)
                            throw new System.Exception("an item was updated outside the range of the omnitree");

                        this.Add(updated, whereToAdd, bounds, whereToAdd.Depth);
                    }
                    previous = current;
                HeadRemoved:
                    current = current.Next;
                }
                node.Count -= removals;
                return removals;
            }
            else
            {
                Node branch = node as Node;
                int skipped = 0;
                for (int i = 0; i + skipped < branch.Children.Length; )
                {
                    removals += this.Update(branch.Children[i], depth + 1);
                    if (branch.Children[i].Count == 0)
                        branch.Children[i] = branch.Children[branch.Children.Length - skipped++ - 1];
                    else
                        i++;
                }
                Node[] newArray = new Node[branch.Children.Length - skipped];
                Array.Copy(branch.Children, newArray, newArray.Length);
                branch.Children = newArray;

                branch.Count -= removals;

                if (branch.Count < _load && branch.Count != 0)
                    ShrinkChild(branch.Parent, branch.Index);
            }

            return removals;
        }

        /// <summary>Iterates through the provided dimensions and ensures each item is in the proper leaf.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		/// <param name="min7">The minimum coordinate of the space along the 7 axis.</param>
		/// <param name="max7">The maximum coordinate of the space along the 7 axis.</param>
        public void Update(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5, Axis6 min6, Axis6 max6, Axis7 min7, Axis7 max7)
        {
            this.Update(new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6, min7, max7), this._top, 0);
        }
        /// <summary>Iterates through the provided dimensions and ensures each item is in the proper leaf.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		/// <param name="min7">The minimum coordinate of the space along the 7 axis.</param>
		/// <param name="max7">The maximum coordinate of the space along the 7 axis.</param>
        public void Update(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5, Omnitree.Bound<Axis6> min6, Omnitree.Bound<Axis6> max6, Omnitree.Bound<Axis7> min7, Omnitree.Bound<Axis7> max7)
        {
            this.Update(new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6, min7, max7), this._top, 0);
        }
        /// <summary>Iterates through the provided dimensions and ensures each item is in the proper leaf.</summary>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
		/// <param name="axis5">The coordinate along the 5D axis.</param>
		/// <param name="axis6">The coordinate along the 6D axis.</param>
		/// <param name="axis7">The coordinate along the 7D axis.</param>
        public void Update(Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Axis5 axis5, Axis6 axis6, Axis7 axis7)
        {
            this.Update(new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>(axis1, axis1, axis2, axis2, axis3, axis3, axis4, axis4, axis5, axis5, axis6, axis6, axis7, axis7), this._top, 0);
        }
        /// <summary>Iterates through the provided dimensions and ensures each item is in the proper leaf.</summary>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
		/// <param name="axis5">The coordinate along the 5D axis.</param>
		/// <param name="axis6">The coordinate along the 6D axis.</param>
		/// <param name="axis7">The coordinate along the 7D axis.</param>
        public void Update(Omnitree.Bound<Axis1> axis1, Omnitree.Bound<Axis2> axis2, Omnitree.Bound<Axis3> axis3, Omnitree.Bound<Axis4> axis4, Omnitree.Bound<Axis5> axis5, Omnitree.Bound<Axis6> axis6, Omnitree.Bound<Axis7> axis7)
        {
            this.Update(new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>(axis1, axis1, axis2, axis2, axis3, axis3, axis4, axis4, axis5, axis5, axis6, axis6, axis7, axis7), this._top, 0);
        }
        private int Update(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> bounds, Node node, int depth)
        {
			// I messed up this function in the conversion
			throw new System.NotImplementedException();

            if (!InclusionCheck(bounds, node.Bounds))
                return 0;

            int removals = 0;

            if (!node.PointOfDivision.HasValue)
            {
                Node.ValueNode current = node.Head;
                Node.ValueNode previous = null;
                while (current != null)
                {
                    Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> item_bounds = GetBoundings(current.Value);
                    if (!this.EncapsulationCheck(node.Bounds, item_bounds))
                    {
                        removals++;
                        T updated = current.Value;
                        if (previous == null)
                        {
                            node.Head = current.Next;
                            goto HeadRemoved;
                        }
                        else
                            previous.Next = current.Next;
                        Node whereToAdd = GetEncapsulationParent(node.Parent, item_bounds);
                        if (whereToAdd == null)
                            throw new System.Exception("an item was updates outside the range of the omnitree");
                        this.Add(updated, whereToAdd, item_bounds, whereToAdd.Depth);
                    }
                    previous = current;
                HeadRemoved:
                    current = current.Next;
                }
                node.Count -= removals;
                return removals;
            }
            else
            {
                Node branch = node as Node;
                int skipped = 0;
                for (int i = 0; i + skipped < branch.Children.Length; )
                {
                    removals += this.Update(branch.Children[i], depth + 1);
                    if (branch.Children[i].Count == 0)
                        branch.Children[i] = branch.Children[branch.Children.Length - skipped++ - 1];
                    else
                        i++;
                }
                Node[] newArray = new Node[branch.Children.Length - skipped];
                Array.Copy(branch.Children, newArray, newArray.Length);
                branch.Children = newArray;

                branch.Count -= removals;

                if (branch.Count < _load && branch.Count != 0)
                    ShrinkChild(branch.Parent, branch.Index);
            }

            return removals;
        }

        #endregion

        #region Remove

        /// <summary>Removes all the items qualified by the delegate.</summary>
        /// <param name="where">The predicate to qualify removals.</param>
        public void Remove(Predicate<T> where)
        {
            this.Remove(this._top, where);
            Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
        }

        /// <summary>Recursive version of the remove method.</summary>
        /// <param name="node">The current node of traversal.</param>
        /// <param name="where">The predicate to qualify removals.</param>
        private int Remove(Node node, Predicate<T> where)
        {
            int removals = 0;

			// items
            while (node.Head != null && where(node.Head.Value))
            {
                node.Head = node.Head.Next;
                removals++;
            }
            if (node.Head != null)
            {
                Node.ValueNode list = node.Head;
                while (list.Next != null)
                {
                    if (where(list.Next.Value))
                    {
                        list.Next = list.Next.Next;
                        removals++;
                    }
                }
            }
            node.Count -= removals;
            
			// children
			if (node.Children != null)
			{
				int skipped = 0;
				for (int i = 0; i + skipped < node.Children.Length; )
				{
				    removals += this.Remove(node.Children[i], where);
				    if (node.Children[i].Count == 0)
				        node.Children[i] = node.Children[node.Children.Length - skipped++ - 1];
				    else
				        i++;
				}
				Node[] newArray = new Node[node.Children.Length - skipped];
				Array.Copy(node.Children, newArray, newArray.Length);
				node.Children = newArray;

				node.Count -= removals;

				if (node.Count < _load && node.Count != 0)
				    ShrinkChild(node.Parent, node.Index);
			}
            return removals;
        }

        /// <summary>Removes all the items encapsulated in a given space.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		/// <param name="min7">The minimum coordinate of the space along the 7 axis.</param>
		/// <param name="max7">The maximum coordinate of the space along the 7 axis.</param>
        /// <returns>The number of items that were removed.</returns>
        public void RemoveEncapsulated(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5, Axis6 min6, Axis6 max6, Axis7 min7, Axis7 max7)
        {
            this.RemoveEncapsulated(this._top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6, min7, max7));
        }
        /// <summary>Removes all the items encapsulated in a given space.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		/// <param name="min7">The minimum coordinate of the space along the 7 axis.</param>
		/// <param name="max7">The maximum coordinate of the space along the 7 axis.</param>
        /// <returns>The number of items that were removed.</returns>
        public void RemoveEncapsulated(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5, Omnitree.Bound<Axis6> min6, Omnitree.Bound<Axis6> max6, Omnitree.Bound<Axis7> min7, Omnitree.Bound<Axis7> max7)
        {
            this.RemoveEncapsulated(this._top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6, min7, max7));
        }
        /// <summary>Removes all the items encapsulated in a given space.</summary>
        /// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
		/// <param name="axis5">The coordinate along the 5D axis.</param>
		/// <param name="axis6">The coordinate along the 6D axis.</param>
		/// <param name="axis7">The coordinate along the 7D axis.</param>
        public void RemoveEncapsulated(Omnitree.Bound<Axis1> axis1, Omnitree.Bound<Axis2> axis2, Omnitree.Bound<Axis3> axis3, Omnitree.Bound<Axis4> axis4, Omnitree.Bound<Axis5> axis5, Omnitree.Bound<Axis6> axis6, Omnitree.Bound<Axis7> axis7)
        {
            this.RemoveEncapsulated(this._top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>(axis1, axis1, axis2, axis2, axis3, axis3, axis4, axis4, axis5, axis5, axis6, axis6, axis7, axis7));
        }
        private int RemoveEncapsulated(Node node, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> bounds)
        {
            int removals = this.RemoveBase(node, bounds, (a, b) => this.EncapsulationCheck(a, b));
			Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
			return removals;
        }

		/// <summary>Removes all the items overlapping a given space.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		/// <param name="min7">The minimum coordinate of the space along the 7 axis.</param>
		/// <param name="max7">The maximum coordinate of the space along the 7 axis.</param>
        /// <returns>The number of items that were removed.</returns>
        public void RemoveOverlapped(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5, Axis6 min6, Axis6 max6, Axis7 min7, Axis7 max7)
        {
            this.RemoveOverlapped(this._top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6, min7, max7));
        }
        /// <summary>Removes all the items overlapping a given space.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		/// <param name="min7">The minimum coordinate of the space along the 7 axis.</param>
		/// <param name="max7">The maximum coordinate of the space along the 7 axis.</param>
        /// <returns>The number of items that were removed.</returns>
        public void RemoveOverlapped(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5, Omnitree.Bound<Axis6> min6, Omnitree.Bound<Axis6> max6, Omnitree.Bound<Axis7> min7, Omnitree.Bound<Axis7> max7)
        {
            this.RemoveOverlapped(this._top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6, min7, max7));
        }
        private int RemoveOverlapped(Node node, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> bounds)
        {
            int removals = this.RemoveBase(node, bounds, (a, b) => this.InclusionCheck(a, b));
			Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
			return removals;
        }

		private int RemoveBase(
			Node node,
			Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> bounds,
			Omnitree.SpatialCheck<Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>> spatialCheck)
        {
            int removals = 0;
            if (InclusionCheck(bounds, node.Bounds))
            {
				// items
                Node.ValueNode current_node = node.Head;
                Node.ValueNode previous_node = null;
                while (current_node != null)
                {
                    Node.ValueNode temp_previous = current_node;
                    if (spatialCheck(bounds, GetBoundings(current_node.Value)))
                    {
                        removals++;
                        if (current_node == node.Head)
                            node.Head = node.Head.Next;
                        else
                        {
                            previous_node.Next = current_node.Next;
                            temp_previous = previous_node;
                        }
                    }
                    previous_node = temp_previous;
                    current_node = current_node.Next;
                }
                node.Count -= removals;
                
				// children
				if (node.Children != null)
				{
					int skipped = 0;
					for (int i = 0; i + skipped < node.Children.Length; )
					{
					    removals += this.RemoveBase(node.Children[i], bounds, spatialCheck);
					    if (node.Children[i].Count == 0)
					        node.Children[i] = node.Children[node.Children.Length - skipped++ - 1];
					    else
					        i++;
					}
					Node[] newArray = new Node[node.Children.Length - skipped];
					Array.Copy(node.Children, newArray, newArray.Length);
					node.Children = newArray;

					node.Count -= removals;
					// convert this branch back into a leaf
					// Note: if count is zero, it will be chopped off
					if (node.Count < _load && node.Count > 0)
					    ShrinkChild(node.Parent, node.Index);
				}
            }
			
            return removals;
        }

		/// <summary>Removes all the items in a given space validated by a predicate.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		/// <param name="min7">The minimum coordinate of the space along the 7 axis.</param>
		/// <param name="max7">The maximum coordinate of the space along the 7 axis.</param>
        /// <param name="where">The equality constraint of the removal.</param>
        public void RemoveEncapsulated(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5, Axis6 min6, Axis6 max6, Axis7 min7, Axis7 max7, Predicate<T> where)
        {
            this.RemoveEncapsulated(this._top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6, min7, max7), where);
        }
        /// <summary>Removes all the items in a given space validated by a predicate.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		/// <param name="min7">The minimum coordinate of the space along the 7 axis.</param>
		/// <param name="max7">The maximum coordinate of the space along the 7 axis.</param>
        /// <param name="where">The equality constraint of the removal.</param>
        public void RemoveEncapsulated(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5, Omnitree.Bound<Axis6> min6, Omnitree.Bound<Axis6> max6, Omnitree.Bound<Axis7> min7, Omnitree.Bound<Axis7> max7, Predicate<T> where)
        {
            this.RemoveEncapsulated(this._top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6, min7, max7), where);
        }
        private int RemoveEncapsulated(Node node, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> bounds, Predicate<T> where)
        {
            int removals = RemoveBase(node, bounds, where, (a, b) => this.EncapsulationCheck(a, b));
			Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
			return removals;
        }

        /// <summary>Removes all the items in a given space validated by a predicate.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		/// <param name="min7">The minimum coordinate of the space along the 7 axis.</param>
		/// <param name="max7">The maximum coordinate of the space along the 7 axis.</param>
        /// <param name="where">The equality constraint of the removal.</param>
        public void RemoveOverlapped(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5, Axis6 min6, Axis6 max6, Axis7 min7, Axis7 max7, Predicate<T> where)
        {
            this.RemoveOverlapped(this._top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6, min7, max7), where);
        }
        /// <summary>Removes all the items in a given space validated by a predicate.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		/// <param name="min7">The minimum coordinate of the space along the 7 axis.</param>
		/// <param name="max7">The maximum coordinate of the space along the 7 axis.</param>
        /// <param name="where">The equality constraint of the removal.</param>
        public void RemoveOverlapped(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5, Omnitree.Bound<Axis6> min6, Omnitree.Bound<Axis6> max6, Omnitree.Bound<Axis7> min7, Omnitree.Bound<Axis7> max7, Predicate<T> where)
        {
            this.RemoveOverlapped(this._top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6, min7, max7), where);
        }
        private int RemoveOverlapped(Node node, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> bounds, Predicate<T> where)
        {
            int removals = RemoveBase(node, bounds, where, (a, b) => this.InclusionCheck(a, b));
			Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
			return removals;
        }

		private int RemoveBase(
			Node node,
			Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> bounds,
			Predicate<T> where,
			Omnitree.SpatialCheck<Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>> spatialCheck)
        {
            if (!InclusionCheck(node.Bounds, bounds))
                return 0;
            int removals = 0;
            
			// items
            Node.ValueNode current = node.Head;
            Node.ValueNode previous = null;
            while (current != null)
            {
                if (spatialCheck(bounds, GetBoundings(current.Value)) && where(current.Value))
                {
                    removals++;
                    if (previous == null)
                    {
                        node.Head = current.Next;
                        goto HeadRemoved;
                    }
                    else
                        previous.Next = current.Next;
                }
                previous = current;
            HeadRemoved:
                current = current.Next;
            }
            node.Count -= removals;

            // children
			if (node.Children != null)
			{
				int skipped = 0;
				for (int i = 0; i + skipped < node.Children.Length; )
				{
				    removals += this.RemoveBase(node.Children[i], bounds, where, spatialCheck);
				    if (node.Children[i].Count == 0)
				        node.Children[i] = node.Children[node.Children.Length - skipped++ - 1];
				    else
				        i++;
				}
				Node[] newArray = new Node[node.Children.Length - skipped];
				Array.Copy(node.Children, newArray, newArray.Length);
				node.Children = newArray;

				node.Count -= removals;

				if (node.Count < _load && node.Count != 0)
				    ShrinkChild(node.Parent, node.Index);
			}
            return removals;
        }

        /// <summary>Removes all instances of a given value.</summary>
        public void Remove(T removal)
        {
            Omnitree.Bound<Axis1> min1; Omnitree.Bound<Axis1> max1;
            Omnitree.Bound<Axis2> min2; Omnitree.Bound<Axis2> max2;
            Omnitree.Bound<Axis3> min3; Omnitree.Bound<Axis3> max3;
            Omnitree.Bound<Axis4> min4; Omnitree.Bound<Axis4> max4;
            Omnitree.Bound<Axis5> min5; Omnitree.Bound<Axis5> max5;
            Omnitree.Bound<Axis6> min6; Omnitree.Bound<Axis6> max6;
            Omnitree.Bound<Axis7> min7; Omnitree.Bound<Axis7> max7;
            this._getBounds(removal, out min1, out max1, out min2, out max2, out min3, out max3, out min4, out max4, out min5, out max5, out min6, out max6, out min7, out max7);
            this.RemoveOverlapped(this._top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6, min7, max7), item => this._equate(item, removal));
        }
        /// <summary>Removes all the items in a given space.</summary>
        /// <param name="axis1">The axis of the removal along the  1D axis.</param>
		/// <param name="axis2">The axis of the removal along the  2D axis.</param>
		/// <param name="axis3">The axis of the removal along the  3D axis.</param>
		/// <param name="axis4">The axis of the removal along the  4D axis.</param>
		/// <param name="axis5">The axis of the removal along the  5D axis.</param>
		/// <param name="axis6">The axis of the removal along the  6D axis.</param>
		/// <param name="axis7">The axis of the removal along the  7D axis.</param>
        /// <returns>The number of items that were removed.</returns>
        public void RemoveOverlapped(Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Axis5 axis5, Axis6 axis6, Axis7 axis7)
        {
            this.RemoveOverlapped(axis1, axis1, axis2, axis2, axis3, axis3, axis4, axis4, axis5, axis5, axis6, axis6, axis7, axis7);
            Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
        }
        
        /// <summary>Removes all the items in a given space validated by a predicate.</summary>
        /// <param name="axis1">The axis of the removal along the  1D axis.</param>
		/// <param name="axis2">The axis of the removal along the  2D axis.</param>
		/// <param name="axis3">The axis of the removal along the  3D axis.</param>
		/// <param name="axis4">The axis of the removal along the  4D axis.</param>
		/// <param name="axis5">The axis of the removal along the  5D axis.</param>
		/// <param name="axis6">The axis of the removal along the  6D axis.</param>
		/// <param name="axis7">The axis of the removal along the  7D axis.</param>
        /// <param name="where">The equality constraint of the removal.</param>
        public void RemoveOverlapped(Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Axis5 axis5, Axis6 axis6, Axis7 axis7, Predicate<T> where)
        {
			this.RemoveOverlapped(axis1, axis1, axis2, axis2, axis3, axis3, axis4, axis4, axis5, axis5, axis6, axis6, axis7, axis7, where);
            Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
        }

        #endregion

        #region Stepper And IEnumerable

        /// <summary>Traverses every item in the tree and performs the delegate in them.</summary>
        /// <param name="function">The delegate to perform on every item in the tree.</param>
        public void Stepper(Step<T> function)
        {
            this.Stepper(function, this._top);
        }
        private void Stepper(Step<T> function, Node node)
        {
            Node.ValueNode list = node.Head;
            while (list != null)
            {
                function(list.Value);
                list = list.Next;
            }
			if (node.Children != null)
				foreach (Node child in node.Children)
				    this.Stepper(function, child);
        }

        /// <summary>Traverses every item in the tree and performs the delegate in them.</summary>
        /// <param name="function">The delegate to perform on every item in the tree.</param>
        public StepStatus Stepper(StepBreak<T> function)
        {
            return Stepper(function, _top);
        }
        private StepStatus Stepper(StepBreak<T> function, Node node)
        {
            StepStatus status = StepStatus.Continue;
            
            for (Node.ValueNode list = node.Head; list != null; list = list.Next)
                if ((status = function(list._value)) != StepStatus.Continue)
                    break;
            
			if (node.Children != null)
				foreach (Node child in node.Children)
				    if ((status = Stepper(function, child)) != StepStatus.Continue)
				        break;
            
            return status;
        }

        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="function">The delegate to perform on all items in the tree within the given bounds.</param>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		/// <param name="min7">The minimum coordinate of the space along the 7 axis.</param>
		/// <param name="max7">The maximum coordinate of the space along the 7 axis.</param>
        public void StepperEncapsulated(Step<T> function, Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5, Axis6 min6, Axis6 max6, Axis7 min7, Axis7 max7)
        {
            StepperEncapsulated(function, _top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6, min7, max7));
        }
        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="function">The delegate to perform on all items in the tree within the given bounds.</param>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		/// <param name="min7">The minimum coordinate of the space along the 7 axis.</param>
		/// <param name="max7">The maximum coordinate of the space along the 7 axis.</param>
        public void StepperEncapsulated(Step<T> function, Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5, Omnitree.Bound<Axis6> min6, Omnitree.Bound<Axis6> max6, Omnitree.Bound<Axis7> min7, Omnitree.Bound<Axis7> max7)
        {
            StepperEncapsulated(function, _top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6, min7, max7));
        }
        private void StepperEncapsulated(Step<T> function, Node node, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> bounds)
        {
            StepperBase(function, node, bounds, (a, b) => this.EncapsulationCheck(a, b));
        }

		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="function">The delegate to perform on all items in the tree within the given bounds.</param>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		/// <param name="min7">The minimum coordinate of the space along the 7 axis.</param>
		/// <param name="max7">The maximum coordinate of the space along the 7 axis.</param>
        public void StepperOverlapped(Step<T> function, Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5, Axis6 min6, Axis6 max6, Axis7 min7, Axis7 max7)
        {
            StepperOverlapped(function, _top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6, min7, max7));
        }
        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="function">The delegate to perform on all items in the tree within the given bounds.</param>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		/// <param name="min7">The minimum coordinate of the space along the 7 axis.</param>
		/// <param name="max7">The maximum coordinate of the space along the 7 axis.</param>
        public void StepperOverlapped(Step<T> function, Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5, Omnitree.Bound<Axis6> min6, Omnitree.Bound<Axis6> max6, Omnitree.Bound<Axis7> min7, Omnitree.Bound<Axis7> max7)
        {
            StepperOverlapped(function, _top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6, min7, max7));
        }
        private void StepperOverlapped(Step<T> function, Node node, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> bounds)
        {
            StepperBase(function, node, bounds, (a, b) => this.InclusionCheck(a, b));
        }

		private void StepperBase(
			Step<T> function,
			Node node,
			Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> bounds,
			Omnitree.SpatialCheck<Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>> spatialCheck)
        {
            for (Node.ValueNode list = node.Head; list != null; list = list.Next)
                if (spatialCheck(bounds, GetBoundings(list.Value)))
                    function(list.Value);

			if (node.Children != null)
			{
				foreach (Node child in node.Children)
				    // optimization: stop bounds checking if space encapsulates node
				    if (EncapsulationCheck(bounds, child.Bounds))
				        this.Stepper(function, child);
				    else if (InclusionCheck(child.Bounds, bounds))
				        this.StepperBase(function, child, bounds, spatialCheck);
			}
        }

        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		/// <param name="min7">The minimum coordinate of the space along the 7 axis.</param>
		/// <param name="max7">The maximum coordinate of the space along the 7 axis.</param>
        public StepStatus StepperEncapsulated(StepBreak<T> function, Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5, Axis6 min6, Axis6 max6, Axis7 min7, Axis7 max7)
        {
            return StepperEncapsulated(function, _top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6, min7, max7));
        }
        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		/// <param name="min7">The minimum coordinate of the space along the 7 axis.</param>
		/// <param name="max7">The maximum coordinate of the space along the 7 axis.</param>
        public StepStatus StepperEncapsulated(StepBreak<T> function, Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5, Omnitree.Bound<Axis6> min6, Omnitree.Bound<Axis6> max6, Omnitree.Bound<Axis7> min7, Omnitree.Bound<Axis7> max7)
        {
			return StepperEncapsulated(function, _top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6, min7, max7));
        }
        private StepStatus StepperEncapsulated(StepBreak<T> function, Node node, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> bounds)
        {
            return StepperBase(function, node, bounds, (a, b) => this.EncapsulationCheck(a, b));
        }

		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		/// <param name="min7">The minimum coordinate of the space along the 7 axis.</param>
		/// <param name="max7">The maximum coordinate of the space along the 7 axis.</param>
        public StepStatus StepperOverlapped(StepBreak<T> function, Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5, Axis6 min6, Axis6 max6, Axis7 min7, Axis7 max7)
        {
            return StepperOverlapped(function, _top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6, min7, max7));
        }
        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		/// <param name="min7">The minimum coordinate of the space along the 7 axis.</param>
		/// <param name="max7">The maximum coordinate of the space along the 7 axis.</param>
        public StepStatus StepperOverlapped(StepBreak<T> function, Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5, Omnitree.Bound<Axis6> min6, Omnitree.Bound<Axis6> max6, Omnitree.Bound<Axis7> min7, Omnitree.Bound<Axis7> max7)
        {
			return StepperOverlapped(function, _top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6, min7, max7));
        }
        private StepStatus StepperOverlapped(StepBreak<T> function, Node node, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> bounds)
        {
            return StepperBase(function, node, bounds, (a, b) => this.InclusionCheck(a, b));
        }

		private StepStatus StepperBase(
			StepBreak<T> function,
			Node node,
			Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> bounds,
			Omnitree.SpatialCheck<Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>> spatialCheck)
        {
            StepStatus status = StepStatus.Continue;

            for (Node.ValueNode list = node.Head; list != null; list = list.Next)
                if (spatialCheck(bounds, GetBoundings(list.Value)) &&
                    (status = function(list.Value)) != StepStatus.Continue)
                    break;

			if (node.Children != null)
			{
				foreach (Node child in node.Children)
				    // optimization: stop bounds checking if space encapsulates node
				    if (EncapsulationCheck(bounds, child.Bounds) &&
				        (status = this.Stepper(function, child)) != StepStatus.Continue)
				        break;
				    else if (!InclusionCheck(child.Bounds, bounds) &&
				        (status = this.StepperBase(function, child, bounds, spatialCheck)) != StepStatus.Continue)
				        break;
			}

            return status;
        }

        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="axis1">The axis of the removal along the  1D axis.</param>
		/// <param name="axis2">The axis of the removal along the  2D axis.</param>
		/// <param name="axis3">The axis of the removal along the  3D axis.</param>
		/// <param name="axis4">The axis of the removal along the  4D axis.</param>
		/// <param name="axis5">The axis of the removal along the  5D axis.</param>
		/// <param name="axis6">The axis of the removal along the  6D axis.</param>
		/// <param name="axis7">The axis of the removal along the  7D axis.</param>
        public void StepperOverlapped(Step<T> function, Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Axis5 axis5, Axis6 axis6, Axis7 axis7)
        {
            StepperOverlapped(function, this._top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>(axis1, axis1, axis2, axis2, axis3, axis3, axis4, axis4, axis5, axis5, axis6, axis6, axis7, axis7));
        }

        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="function">The delegate to perform on all items in the tree within the given bounds.</param>
        /// <param name="axis1">The axis of the removal along the  1D axis.</param>
		/// <param name="axis2">The axis of the removal along the  2D axis.</param>
		/// <param name="axis3">The axis of the removal along the  3D axis.</param>
		/// <param name="axis4">The axis of the removal along the  4D axis.</param>
		/// <param name="axis5">The axis of the removal along the  5D axis.</param>
		/// <param name="axis6">The axis of the removal along the  6D axis.</param>
		/// <param name="axis7">The axis of the removal along the  7D axis.</param>
        public StepStatus StepperOverlapped(StepBreak<T> function, Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Axis5 axis5, Axis6 axis6, Axis7 axis7)
        {
			return StepperOverlapped(function, this._top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>(axis1, axis1, axis2, axis2, axis3, axis3, axis4, axis4, axis5, axis5, axis6, axis6, axis7, axis7));
        }

        /// <summary>FOR COMPATIBILITY ONLY. AVOID IF POSSIBLE.</summary>
        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
        {
            throw new System.NotImplementedException();
            //return (this.ToArray() as System.Collections.Generic.IEnumerable<T>).GetEnumerator();
        }

        /// <summary>FOR COMPATIBILITY ONLY. AVOID IF POSSIBLE.</summary>
        System.Collections.Generic.IEnumerator<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator()
        {
            throw new System.NotImplementedException();
            //return (this.ToArray() as System.Collections.Generic.IEnumerable<T>).GetEnumerator();
        }

        #endregion

        #region Helpers

        private bool StraddlesLines(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> bounds, Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> vector)
        {
			if ((!bounds.Min1.Exists || (this._compare1(bounds.Min1.Value, vector.Axis1) != Comparison.Greater)) &&
				(!bounds.Max1.Exists || (this._compare1(bounds.Max1.Value, vector.Axis1) != Comparison.Less)))
				return true;
			if ((!bounds.Min2.Exists || (this._compare2(bounds.Min2.Value, vector.Axis2) != Comparison.Greater)) &&
				(!bounds.Max2.Exists || (this._compare2(bounds.Max2.Value, vector.Axis2) != Comparison.Less)))
				return true;
			if ((!bounds.Min3.Exists || (this._compare3(bounds.Min3.Value, vector.Axis3) != Comparison.Greater)) &&
				(!bounds.Max3.Exists || (this._compare3(bounds.Max3.Value, vector.Axis3) != Comparison.Less)))
				return true;
			if ((!bounds.Min4.Exists || (this._compare4(bounds.Min4.Value, vector.Axis4) != Comparison.Greater)) &&
				(!bounds.Max4.Exists || (this._compare4(bounds.Max4.Value, vector.Axis4) != Comparison.Less)))
				return true;
			if ((!bounds.Min5.Exists || (this._compare5(bounds.Min5.Value, vector.Axis5) != Comparison.Greater)) &&
				(!bounds.Max5.Exists || (this._compare5(bounds.Max5.Value, vector.Axis5) != Comparison.Less)))
				return true;
			if ((!bounds.Min6.Exists || (this._compare6(bounds.Min6.Value, vector.Axis6) != Comparison.Greater)) &&
				(!bounds.Max6.Exists || (this._compare6(bounds.Max6.Value, vector.Axis6) != Comparison.Less)))
				return true;
			if ((!bounds.Min7.Exists || (this._compare7(bounds.Min7.Value, vector.Axis7) != Comparison.Greater)) &&
				(!bounds.Max7.Exists || (this._compare7(bounds.Max7.Value, vector.Axis7) != Comparison.Less)))
				return true;
            return false;
        }

        /// <summary>Computes the child index that contains the desired dimensions.</summary>
        /// <param name="node">The branch .</param>
        /// <param name="vector">The dimensions to determine the child index.</param>
        /// <returns>The computed child index based on the coordinates relative to the center of the node.</returns>
        private int DetermineChildIndex(Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> pointOfDivision, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> bounds)
        {
			// make sure a child encapsulates the bounds (otherwise the bounds cannot move down the tree)
			if (StraddlesLines(bounds, pointOfDivision))
				return -1;

            int child = 0;
            if (!bounds.Min1.Exists || !(this._compare1(bounds.Min1.Value, pointOfDivision.Axis1) == Comparison.Less))
                child += 1 << 0;
            if (!bounds.Min2.Exists || !(this._compare2(bounds.Min2.Value, pointOfDivision.Axis2) == Comparison.Less))
                child += 1 << 1;
            if (!bounds.Min3.Exists || !(this._compare3(bounds.Min3.Value, pointOfDivision.Axis3) == Comparison.Less))
                child += 1 << 2;
            if (!bounds.Min4.Exists || !(this._compare4(bounds.Min4.Value, pointOfDivision.Axis4) == Comparison.Less))
                child += 1 << 3;
            if (!bounds.Min5.Exists || !(this._compare5(bounds.Min5.Value, pointOfDivision.Axis5) == Comparison.Less))
                child += 1 << 4;
            if (!bounds.Min6.Exists || !(this._compare6(bounds.Min6.Value, pointOfDivision.Axis6) == Comparison.Less))
                child += 1 << 5;
            if (!bounds.Min7.Exists || !(this._compare7(bounds.Min7.Value, pointOfDivision.Axis7) == Comparison.Less))
                child += 1 << 6;
            return child;
        }

        /// <summary>Converts a branch back into a leaf when the count is reduced.</summary>
        /// <param name="parent">The parent to shrink a child of.</param>
        /// <param name="child">The index of the child to shrink.</param>
        private void ShrinkChild(Node parent, int child_index)
        {
            Node leaf;
            Node removal = null;
            if (parent == null) // top of tree
            {
                removal = this._top;
                leaf = new Node(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>.None, null, -1);
                this._top = leaf;
            }
            else // non-top branch
            {
                removal = parent[child_index];
                leaf = new Node(removal.Bounds, removal.Parent, removal.Index);
                parent[child_index] = leaf;
            }

            this.Stepper((T step) => { leaf.Add(step); }, removal);
        }

        /// <summary>Reduces the counts of all the parents of a given node by a given amount.</summary>
        /// <param name="parent">The starting parent of the reduction.</param>
        /// <param name="reduction">The amount to reduce the parent counts by.</param>
        private void ReduceParentCounts(Node parent, int reduction)
        {
            IncreaseParentCounts(parent, -reduction);
        }

        /// <summary>Increases the counts of all the parents of a given node by a given amount.</summary>
        /// <param name="parent">The starting parent of the increase.</param>
        /// <param name="increase">The amount to increase the parent counts by.</param>
        private void IncreaseParentCounts(Node parent, int increase)
        {
            Node looper = parent;
            while (looper != null)
            {
                looper.Count += increase;
                looper = looper.Parent;
            }
        }

        /// <summary>Checks a node for inclusion (overlap) between two bounds.</summary>
        /// <returns>True if the spaces overlap; False if not.</returns>
        private bool InclusionCheck(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> a, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> b)
        {

            if (a.Max1.Exists && b.Min1.Exists && this._compare1(a.Max1.Value, b.Min1.Value) == Comparison.Less)
                return false;
            else if (a.Min1.Exists && b.Max1.Exists && this._compare1(a.Min1.Value, b.Max1.Value) == Comparison.Greater)
                return false;

            if (a.Max2.Exists && b.Min2.Exists && this._compare2(a.Max2.Value, b.Min2.Value) == Comparison.Less)
                return false;
            else if (a.Min2.Exists && b.Max2.Exists && this._compare2(a.Min2.Value, b.Max2.Value) == Comparison.Greater)
                return false;

            if (a.Max3.Exists && b.Min3.Exists && this._compare3(a.Max3.Value, b.Min3.Value) == Comparison.Less)
                return false;
            else if (a.Min3.Exists && b.Max3.Exists && this._compare3(a.Min3.Value, b.Max3.Value) == Comparison.Greater)
                return false;

            if (a.Max4.Exists && b.Min4.Exists && this._compare4(a.Max4.Value, b.Min4.Value) == Comparison.Less)
                return false;
            else if (a.Min4.Exists && b.Max4.Exists && this._compare4(a.Min4.Value, b.Max4.Value) == Comparison.Greater)
                return false;

            if (a.Max5.Exists && b.Min5.Exists && this._compare5(a.Max5.Value, b.Min5.Value) == Comparison.Less)
                return false;
            else if (a.Min5.Exists && b.Max5.Exists && this._compare5(a.Min5.Value, b.Max5.Value) == Comparison.Greater)
                return false;

            if (a.Max6.Exists && b.Min6.Exists && this._compare6(a.Max6.Value, b.Min6.Value) == Comparison.Less)
                return false;
            else if (a.Min6.Exists && b.Max6.Exists && this._compare6(a.Min6.Value, b.Max6.Value) == Comparison.Greater)
                return false;

            if (a.Max7.Exists && b.Min7.Exists && this._compare7(a.Max7.Value, b.Min7.Value) == Comparison.Less)
                return false;
            else if (a.Min7.Exists && b.Max7.Exists && this._compare7(a.Min7.Value, b.Max7.Value) == Comparison.Greater)
                return false;

            return true;
        }

        /// <summary>Checks if a space encapsulates a point.</summary>
        /// <returns>True if the space encapsulates the point; False if not.</returns>
        private bool EncapsulationCheck(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> bounds, Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> vector)
        {
            // if the location is not outside the bounds, it must be inside

            if (bounds.Min1.Exists && this._compare1(vector.Axis1, bounds.Min1.Value) == Comparison.Less)
                return false;
            else if (bounds.Max1.Exists && this._compare1(vector.Axis1, bounds.Max1.Value) == Comparison.Greater)
                return false;

            if (bounds.Min2.Exists && this._compare2(vector.Axis2, bounds.Min2.Value) == Comparison.Less)
                return false;
            else if (bounds.Max2.Exists && this._compare2(vector.Axis2, bounds.Max2.Value) == Comparison.Greater)
                return false;

            if (bounds.Min3.Exists && this._compare3(vector.Axis3, bounds.Min3.Value) == Comparison.Less)
                return false;
            else if (bounds.Max3.Exists && this._compare3(vector.Axis3, bounds.Max3.Value) == Comparison.Greater)
                return false;

            if (bounds.Min4.Exists && this._compare4(vector.Axis4, bounds.Min4.Value) == Comparison.Less)
                return false;
            else if (bounds.Max4.Exists && this._compare4(vector.Axis4, bounds.Max4.Value) == Comparison.Greater)
                return false;

            if (bounds.Min5.Exists && this._compare5(vector.Axis5, bounds.Min5.Value) == Comparison.Less)
                return false;
            else if (bounds.Max5.Exists && this._compare5(vector.Axis5, bounds.Max5.Value) == Comparison.Greater)
                return false;

            if (bounds.Min6.Exists && this._compare6(vector.Axis6, bounds.Min6.Value) == Comparison.Less)
                return false;
            else if (bounds.Max6.Exists && this._compare6(vector.Axis6, bounds.Max6.Value) == Comparison.Greater)
                return false;

            if (bounds.Min7.Exists && this._compare7(vector.Axis7, bounds.Min7.Value) == Comparison.Less)
                return false;
            else if (bounds.Max7.Exists && this._compare7(vector.Axis7, bounds.Max7.Value) == Comparison.Greater)
                return false;

            return true;
        }

        /// <summary>Checks if a space (left) encapsulates another space (right).</summary>
        /// <returns>True if the left space encapsulates the right; False if not.</returns>
        private bool EncapsulationCheck(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> a, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> b)
        {
            if ((a.Min1.Exists && !b.Min1.Exists) || (a.Min2.Exists && !b.Min2.Exists) || (a.Min3.Exists && !b.Min3.Exists) || (a.Min4.Exists && !b.Min4.Exists) || (a.Min5.Exists && !b.Min5.Exists) || (a.Min6.Exists && !b.Min6.Exists) || (a.Min7.Exists && !b.Min7.Exists))
                return false;
			if ((a.Max1.Exists && !b.Max1.Exists) || (a.Max2.Exists && !b.Max2.Exists) || (a.Max3.Exists && !b.Max3.Exists) || (a.Max4.Exists && !b.Max4.Exists) || (a.Max5.Exists && !b.Max5.Exists) || (a.Max6.Exists && !b.Max6.Exists) || (a.Max7.Exists && !b.Max7.Exists))
                return false;

            if (b.Min1.Exists && a.Min1.Exists && this._compare1(a.Min1.Value, b.Min1.Value) != Comparison.Less)
                return false;
            if (b.Max1.Exists && a.Max1.Exists && this._compare1(a.Max1.Value, b.Max1.Value) != Comparison.Greater)
                return false;

            if (b.Min2.Exists && a.Min2.Exists && this._compare2(a.Min2.Value, b.Min2.Value) != Comparison.Less)
                return false;
            if (b.Max2.Exists && a.Max2.Exists && this._compare2(a.Max2.Value, b.Max2.Value) != Comparison.Greater)
                return false;

            if (b.Min3.Exists && a.Min3.Exists && this._compare3(a.Min3.Value, b.Min3.Value) != Comparison.Less)
                return false;
            if (b.Max3.Exists && a.Max3.Exists && this._compare3(a.Max3.Value, b.Max3.Value) != Comparison.Greater)
                return false;

            if (b.Min4.Exists && a.Min4.Exists && this._compare4(a.Min4.Value, b.Min4.Value) != Comparison.Less)
                return false;
            if (b.Max4.Exists && a.Max4.Exists && this._compare4(a.Max4.Value, b.Max4.Value) != Comparison.Greater)
                return false;

            if (b.Min5.Exists && a.Min5.Exists && this._compare5(a.Min5.Value, b.Min5.Value) != Comparison.Less)
                return false;
            if (b.Max5.Exists && a.Max5.Exists && this._compare5(a.Max5.Value, b.Max5.Value) != Comparison.Greater)
                return false;

            if (b.Min6.Exists && a.Min6.Exists && this._compare6(a.Min6.Value, b.Min6.Value) != Comparison.Less)
                return false;
            if (b.Max6.Exists && a.Max6.Exists && this._compare6(a.Max6.Value, b.Max6.Value) != Comparison.Greater)
                return false;

            if (b.Min7.Exists && a.Min7.Exists && this._compare7(a.Min7.Value, b.Min7.Value) != Comparison.Less)
                return false;
            if (b.Max7.Exists && a.Max7.Exists && this._compare7(a.Max7.Value, b.Max7.Value) != Comparison.Greater)
                return false;

            return true;
        }

        /// <summary>Checks for equality between two locations.</summary>
        /// <returns>True if equal; False if not;</returns>
        private bool EqualsCheck(Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> a, Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> b)
        {

            if (!this._equate1(a.Axis1, b.Axis1))
                return false;

            if (!this._equate2(a.Axis2, b.Axis2))
                return false;

            if (!this._equate3(a.Axis3, b.Axis3))
                return false;

            if (!this._equate4(a.Axis4, b.Axis4))
                return false;

            if (!this._equate5(a.Axis5, b.Axis5))
                return false;

            if (!this._equate6(a.Axis6, b.Axis6))
                return false;

            if (!this._equate7(a.Axis7, b.Axis7))
                return false;

            return true;
        }

        /// <summary>Gets the nearest parent that encapsulates a location.</summary>
        /// <param name="node">The starting node to find the encapsulating parent of the location.</param>
        /// <param name="bounds">The bounds to get the encapsulating parent from.</param>
        /// <returns>The nearest node that encapsulates the given location.</returns>
        private Node GetEncapsulationParent(Node node, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> bounds)
        {
            while (node != null && !EncapsulationCheck(node.Bounds, bounds))
                node = node.Parent;
            return node;
        }

        private Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> GetBoundings(T value)
        {
            Omnitree.Bound<Axis1> min1; Omnitree.Bound<Axis1> max1;
            Omnitree.Bound<Axis2> min2; Omnitree.Bound<Axis2> max2;
            Omnitree.Bound<Axis3> min3; Omnitree.Bound<Axis3> max3;
            Omnitree.Bound<Axis4> min4; Omnitree.Bound<Axis4> max4;
            Omnitree.Bound<Axis5> min5; Omnitree.Bound<Axis5> max5;
            Omnitree.Bound<Axis6> min6; Omnitree.Bound<Axis6> max6;
            Omnitree.Bound<Axis7> min7; Omnitree.Bound<Axis7> max7;
            this._getBounds(value,
				out min1, out max1,
				out min2, out max2,
				out min3, out max3,
				out min4, out max4,
				out min5, out max5,
				out min6, out max6,
				out min7, out max7);
            return new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>(
				min1, max1,
				min2, max2,
				min3, max3,
				min4, max4,
				min5, max5,
				min6, max6,
				min7, max7);
        }

        #endregion

        #endregion
    }

    #endregion

    #endregion
}