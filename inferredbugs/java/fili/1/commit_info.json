{"hash": "986861475474711e4e8692224ddecacea81fdcaf", "message": "Adds read locks to LuceneSearchProvider. (#52)", "file_num_lines": 385, "diff_parsed": {"added": [[104, "     * Initializes the `luceneIndexSearcher` if it has not been initialized already."], [105, "     * <p>"], [106, "     * Note that the index searcher cannot be built at construction time, because it needs the dimension and"], [107, "     * associated key-value store. However, because of a circular dependency between the `SearchProvider` and the"], [108, "     * `Dimension` classes, we cannot provide the dimension and key-value store to the search provider at"], [109, "     * construction time."], [111, "    private void initializeIndexSearcher() {"], [119, "     * <p>"], [120, "     * This method will attempt to acquire and release a write lock."], [125, "        lock.writeLock().lock();"], [155, "        } finally {"], [156, "            lock.writeLock().unlock();"], [239, "        try {"], [240, "            try (IndexWriter luceneIndexWriter = new IndexWriter(luceneDirectory, indexWriterConfig)) {"], [241, "                // Update the document fields for each row and update the document"], [242, "                for (String rowId : changedRows.keySet()) {"], [243, "                    // Get the new row from the pair"], [244, "                    DimensionRow newDimensionRow = changedRows.get(rowId).getKey();"], [245, ""], [246, "                    // Update the index"], [247, "                    updateDimensionRow(doc, dimFieldToLuceneField, luceneIndexWriter, newDimensionRow);"], [248, "                }"], [250, "            } catch (IOException e) {"], [251, "                luceneIndexIsHealthy = false;"], [252, "                LOG.error(\"Failed to refresh index for dimension rows\", e);"], [253, "                throw new RuntimeException(e);"], [254, "                // Commit all the changes to the index (on .close, called by try-resources) and refresh the cardinality"], [255, "            }"], [256, "            //This must be outside the try-resources block because it may _also_ need to open an IndexWriter, and"], [257, "            //opening an IndexWriter involves taking a write lock on lucene, of which there can only be one at a time."], [258, "            reopenIndexSearcher(true);"], [259, "            refreshCardinality();"], [297, "    /**"], [298, "     * Clears the dimension cache, and resets the indices, effectively resetting the SearchProvider to a clean state."], [299, "     * <p>"], [300, "     * Note that this method attempts to acquire a write lock before clearing the index."], [301, "     */"], [307, "        try {"], [308, "            try (IndexWriter writer = new IndexWriter(luceneDirectory, indexWriterConfig)) {"], [309, "                //Remove all dimension data from the store."], [310, "                String rowId = dimension.getKey().getName();"], [311, "                dimensionRows.stream()"], [312, "                        .map(DimensionRow::getRowMap)"], [313, "                        .map(map -> map.get(rowId))"], [314, "                        .map(id -> DimensionStoreKeyUtils.getRowKey(rowId, id))"], [315, "                        .forEach(keyValueStore::remove);"], [316, ""], [317, "                //Since Lucene's indices are being dropped, the dimension field stored via the columnKey is becoming"], [318, "                //stale."], [319, "                keyValueStore.remove(DimensionStoreKeyUtils.getColumnKey(dimension.getKey().getName()));"], [320, "                //The allValues key mapping needs to reflect the fact that we are dropping all dimension data."], [321, "                keyValueStore.put(DimensionStoreKeyUtils.getAllValuesKey(), \"[]\");"], [322, "                //We're resetting the keyValueStore, so we don't want any stale last updated date floating around."], [323, "                keyValueStore.remove(DimensionStoreKeyUtils.getLastUpdatedKey());"], [324, ""], [325, "                //In addition to clearing the keyValueStore, we also need to delete all of Lucene's segment files."], [326, "                writer.deleteAll();"], [327, "                writer.commit();"], [328, "            } catch (IOException e) {"], [329, "                LOG.error(\"Failed to wipe Lucene index at directory: {}\", luceneDirectory);"], [330, "                throw new RuntimeException(e);"], [331, "            }"], [332, ""], [333, "            //This must be outside the try-resources block because it may _also_ need to open an IndexWriter, and"], [334, "            //opening an IndexWriter involves taking a write lock on lucene, of which there can only be one at a time."], [344, "     * <p>"], [345, "     * Note that this method acquires a read lock to query the lucene index for the number of documents."], [348, "        int numDocs;"], [349, "        initializeIndexSearcher();"], [350, "        lock.readLock().lock();"], [351, "        try {"], [352, "            numDocs = luceneIndexSearcher.getIndexReader().numDocs();"], [353, "        } finally {"], [354, "            lock.readLock().unlock();"], [355, "        }"], [358, "                Integer.toString(numDocs)"], [532, "     * <p>"], [533, "     * Note that this method _may_ need to acquire and release a write lock if the index searcher needs to be"], [534, "     * initialized, and it later acquires and released a read lock when querying for dimension data from Lucene."], [545, "        TreeSet<DimensionRow> filteredDimRows;"], [546, "        int documentCount;"], [547, "        initializeIndexSearcher();"], [548, "        lock.readLock().lock();"], [549, "        try {"], [550, "            ScoreDoc[] hits = getPageOfData(luceneIndexSearcher, null, query, perPage, requestedPageNumber).scoreDocs;"], [552, "                if (requestedPageNumber == 1) {"], [553, "                    return new SinglePagePagination<>(Collections.emptyList(), paginationParameters, 0);"], [554, "                } else {"], [555, "                    throw new PageNotFoundException(requestedPageNumber, perPage, 0);"], [556, "                }"], [557, "            }"], [558, "            for (int currentPage = 1; currentPage < requestedPageNumber; currentPage++) {"], [559, "                ScoreDoc lastEntry = hits[hits.length - 1];"], [560, "                hits = getPageOfData(luceneIndexSearcher, lastEntry, query, perPage, requestedPageNumber).scoreDocs;"], [561, "                if (hits.length == 0) {"], [562, "                    throw new PageNotFoundException(requestedPageNumber, perPage, 0);"], [563, "                }"], [566, "            // convert hits to dimension rows"], [567, "            String idKey = DimensionStoreKeyUtils.getColumnKey(dimension.getKey().getName());"], [568, "            filteredDimRows = Arrays.stream(hits)"], [569, "                    .map("], [570, "                            hit -> {"], [571, "                                try {"], [572, "                                    return luceneIndexSearcher.doc(hit.doc);"], [573, "                                } catch (IOException e) {"], [574, "                                    LOG.error(\"Unable to convert hit \" + hit);"], [575, "                                    throw new RuntimeException(e);"], [576, "                                }"], [578, "                    )"], [579, "                    .map(document -> document.get(idKey))"], [580, "                    .map(dimension::findDimensionRowByKeyValue)"], [581, "                    .collect(Collectors.toCollection(TreeSet::new));"], [582, ""], [583, "            documentCount = luceneIndexSearcher.count(query); //throws the caught IOException"], [588, "        } finally {"], [589, "            lock.readLock().unlock();"], [591, "        return new SinglePagePagination<>("], [592, "                Collections.unmodifiableList(filteredDimRows.stream().collect(Collectors.toList())),"], [593, "                paginationParameters,"], [594, "                documentCount"], [595, "        );"], [615, "     * <p>"], [616, "     * Note that this method acquires and releases a read lock when querying Lucene for data."], [634, "        lock.readLock().lock();"], [643, "        } finally {"], [644, "            lock.readLock().unlock();"]], "deleted": [[104, "     * Get the IndexSearcher."], [105, "     *"], [106, "     * @return the IndexSearcher"], [108, "    private IndexSearcher getIndexSearcher() {"], [109, "        // Open the searcher if we don't have one"], [113, "        return luceneIndexSearcher;"], [130, ""], [135, "                lock.writeLock().lock();"], [144, "                } finally {"], [145, "                    lock.writeLock().unlock();"], [147, ""], [238, "        try (IndexWriter luceneIndexWriter = new IndexWriter(luceneDirectory, indexWriterConfig)) {"], [239, "            // Update the document fields for each row and update the document"], [240, "            for (String rowId : changedRows.keySet()) {"], [241, "                // Get the new row from the pair"], [242, "                DimensionRow newDimensionRow = changedRows.get(rowId).getKey();"], [243, ""], [244, "                // Update the index"], [245, "                updateDimensionRow(doc, dimFieldToLuceneField, luceneIndexWriter, newDimensionRow);"], [246, "            }"], [248, "            // Commit all the changes to the index (on .close, called by try-resources) and refresh the cardinality"], [249, "        } catch (IOException e) {"], [250, "            luceneIndexIsHealthy = false;"], [251, "            LOG.error(\"Failed to refresh index for dimension rows\", e);"], [252, "            throw new RuntimeException(e);"], [256, "        reopenIndexSearcher(true);"], [257, "        refreshCardinality();"], [297, "        try (IndexWriter writer = new IndexWriter(luceneDirectory, indexWriterConfig)) {"], [298, "            //Remove all dimension data from the store."], [299, "            String rowId = dimension.getKey().getName();"], [300, "            dimensionRows.stream()"], [301, "                    .map(DimensionRow::getRowMap)"], [302, "                    .map(map -> map.get(rowId))"], [303, "                    .map(id -> DimensionStoreKeyUtils.getRowKey(rowId, id))"], [304, "                    .forEach(keyValueStore::remove);"], [305, ""], [306, "            //Since Lucene's indices are being dropped, the dimension field stored via the columnKey is becoming stale."], [307, "            keyValueStore.remove(DimensionStoreKeyUtils.getColumnKey(dimension.getKey().getName()));"], [308, "            //The allValues key mapping needs to reflect the fact that we are dropping all dimension data."], [309, "            keyValueStore.put(DimensionStoreKeyUtils.getAllValuesKey(), \"[]\");"], [310, "            //We're resetting the keyValueStore, so we don't want any stale last updated date floating around."], [311, "            keyValueStore.remove(DimensionStoreKeyUtils.getLastUpdatedKey());"], [312, ""], [313, "            //In addition to clearing the keyValueStore, we also need to delete all of Lucene's segment files."], [314, "            writer.deleteAll();"], [315, "            writer.commit();"], [318, "        } catch (IOException e) {"], [319, "            LOG.error(\"Failed to wipe Lucene index at directory: {}\", luceneDirectory);"], [320, "            throw new RuntimeException(e);"], [332, "                Integer.toString(getIndexSearcher().getIndexReader().numDocs())"], [516, "        // get the page we want"], [517, "        IndexSearcher indexSearcher = getIndexSearcher();"], [518, "        ScoreDoc[] hits = getPageOfData(indexSearcher, null, query, perPage, requestedPageNumber).scoreDocs;"], [519, "        if (hits.length == 0) {"], [520, "            if (requestedPageNumber == 1) {"], [521, "                return new SinglePagePagination<>(Collections.emptyList(), paginationParameters, 0);"], [522, "            } else {"], [523, "                throw new PageNotFoundException(requestedPageNumber, perPage, 0);"], [524, "            }"], [525, "        }"], [526, "        for (int currentPage = 1; currentPage < requestedPageNumber; currentPage++) {"], [527, "            ScoreDoc lastEntry = hits[hits.length - 1];"], [528, "            hits = getPageOfData(indexSearcher, lastEntry, query, perPage, requestedPageNumber).scoreDocs;"], [530, "                throw new PageNotFoundException(requestedPageNumber, perPage, 0);"], [532, "        }"], [534, "        // convert hits to dimension rows"], [535, "        String idKey = DimensionStoreKeyUtils.getColumnKey(dimension.getKey().getName());"], [536, "        TreeSet<DimensionRow> filteredDimRows = Arrays.stream(hits)"], [537, "                .map("], [538, "                        hit -> {"], [539, "                            try {"], [540, "                                return indexSearcher.doc(hit.doc);"], [541, "                            } catch (IOException e) {"], [542, "                                LOG.error(\"Unable to convert hit \" + hit);"], [543, "                                throw new RuntimeException(e);"], [545, "                        }"], [546, "                )"], [547, "                .map(document -> document.get(idKey))"], [548, "                .map(dimension::findDimensionRowByKeyValue)"], [549, "                .collect(Collectors.toCollection(TreeSet::new));"], [550, "        try {"], [551, "            return new SinglePagePagination<>("], [552, "                    Collections.unmodifiableList(filteredDimRows.stream().collect(Collectors.toList())),"], [553, "                    paginationParameters,"], [554, "                    indexSearcher.count(query)"], [555, "            );"]]}, "num_lines_added": 126, "num_lines_removed": 86}