{"hash": "a19a446bd6428d62db181349775d99fe8b687c49", "message": "netty connector/container modifications (#4387)\n\n* netty connector/container modifications\r\n\r\nSigned-off-by: Maxim Nesen <maxim.nesen@oracle.com>", "file_num_lines": 251, "diff_parsed": {"added": [[23, "import java.util.ArrayList;"], [24, "import java.util.HashMap;"], [80, "    final HashMap<String, ArrayList<Channel>> connections = new HashMap<>();"], [88, "            this.group = new NioEventLoopGroup((Integer) threadPoolSize);"], [91, "            this.group = new NioEventLoopGroup();"], [100, "            CompletableFuture<ClientResponse> resultFuture = execute(jerseyRequest);"], [105, "            return (timeout != null && timeout > 0) ? resultFuture.get(timeout, TimeUnit.MILLISECONDS)"], [106, "                                                    : resultFuture.get();"], [117, "        return execute(jerseyRequest).whenCompleteAsync((r, th) -> {"], [118, "                  if (th == null) jerseyCallback.response(r);"], [119, "                  else jerseyCallback.failure(th);"], [120, "               }, executorService);"], [121, "    }"], [123, "    protected CompletableFuture<ClientResponse> execute(final ClientRequest jerseyRequest) {"], [124, "        final CompletableFuture<ClientResponse> responseAvailable = new CompletableFuture<>();"], [125, "        final CompletableFuture<?> responseDone = new CompletableFuture<>();"], [132, "            String key = requestUri.getScheme() + \"://\" + host + \":\" + port;"], [133, "            ArrayList<Channel> conns;"], [134, "            synchronized (connections) {"], [135, "               conns = connections.get(key);"], [136, "               if (conns == null) {"], [137, "                  conns = new ArrayList<>(0);"], [138, "                  connections.put(key, conns);"], [139, "               }"], [140, "            }"], [141, ""], [142, "            Channel chan;"], [143, "            synchronized (conns) {"], [144, "               chan = conns.size() == 0 ? null : conns.remove(conns.size() - 1);"], [145, "            }"], [146, ""], [147, "            if (chan == null) {"], [148, "               Bootstrap b = new Bootstrap();"], [149, "               b.group(group)"], [150, "                .channel(NioSocketChannel.class)"], [151, "                .handler(new ChannelInitializer<SocketChannel>() {"], [152, "                    @Override"], [153, "                    protected void initChannel(SocketChannel ch) throws Exception {"], [182, "                    }"], [183, "                });"], [185, "               // connect timeout"], [186, "               Integer connectTimeout = ClientProperties.getValue(jerseyRequest.getConfiguration().getProperties(),"], [187, "                                                                  ClientProperties.CONNECT_TIMEOUT, 0);"], [188, "               if (connectTimeout > 0) {"], [189, "                   b.option(ChannelOption.CONNECT_TIMEOUT_MILLIS, connectTimeout);"], [190, "               }"], [192, "               // Make the connection attempt."], [193, "               chan = b.connect(host, port).sync().channel();"], [194, "            }"], [196, "            // assert: clientHandler will always notify responseDone: either normally, or exceptionally"], [197, "            // assert: clientHandler may notify responseAvailable, if sufficient parts of response are detected to construct"], [198, "            //         a valid ClientResponse"], [199, "            // assert: responseAvailable completion may be racing against responseDone completion"], [200, "            // assert: it is ok to abort the entire response, if responseDone is completed exceptionally - in particular, nothing"], [201, "            //         will leak"], [202, "            final Channel ch = chan;"], [203, "            JerseyClientHandler clientHandler = new JerseyClientHandler(jerseyRequest, responseAvailable, responseDone);"], [204, "            ch.pipeline().addLast(clientHandler);"], [205, ""], [206, "            responseDone.whenComplete((_r, th) -> {"], [207, "               ch.pipeline().remove(clientHandler);"], [208, ""], [209, "               if (th == null) {"], [210, "                  synchronized (connections) {"], [211, "                     ArrayList<Channel> conns1 = connections.get(key);"], [212, "                     synchronized (conns1) {"], [213, "                        conns1.add(ch);"], [214, "                     }"], [215, "                  }"], [216, "               } else {"], [217, "                  ch.close();"], [218, "                  // if responseAvailable has been completed, no-op: jersey will encounter IOException while reading response body"], [219, "                  // if responseAvailable has not been completed, abort"], [220, "                  responseAvailable.completeExceptionally(th);"], [221, "               }"], [222, "            });"], [246, "                // guard against prematurely closed channel"], [247, "                final GenericFutureListener<io.netty.util.concurrent.Future<? super Void>> closeListener ="], [248, "                    new GenericFutureListener<io.netty.util.concurrent.Future<? super Void>>() {"], [249, "                        @Override"], [250, "                        public void operationComplete(io.netty.util.concurrent.Future<? super Void> future) throws Exception {"], [251, "                            if (!responseDone.isDone()) {"], [252, "                                responseDone.completeExceptionally(new IOException(\"Channel closed.\"));"], [253, "                            }"], [254, "                        }"], [255, "                    };"], [256, "                ch.closeFuture().addListener(closeListener);"], [289, "                            responseDone.completeExceptionally(e);"], [301, "            responseDone.completeExceptionally(e);"], [304, "        return responseAvailable;"]], "deleted": [[31, "import java.util.concurrent.atomic.AtomicReference;"], [90, "        this.group = new NioEventLoopGroup();"], [96, ""], [97, "        final AtomicReference<ClientResponse> syncResponse = new AtomicReference<>(null);"], [98, "        final AtomicReference<Throwable> syncException = new AtomicReference<>(null);"], [99, ""], [101, "            Future<?> resultFuture = apply(jerseyRequest, new AsyncConnectorCallback() {"], [102, "                @Override"], [103, "                public void response(ClientResponse response) {"], [104, "                    syncResponse.set(response);"], [105, "                }"], [106, ""], [107, "                @Override"], [108, "                public void failure(Throwable failure) {"], [109, "                    syncException.set(failure);"], [110, "                }"], [111, "            });"], [116, "            if (timeout != null && timeout > 0) {"], [117, "                resultFuture.get(timeout, TimeUnit.MILLISECONDS);"], [118, "            } else {"], [119, "                resultFuture.get();"], [120, "            }"], [127, ""], [128, "        Throwable throwable = syncException.get();"], [129, "        if (throwable == null) {"], [130, "            return syncResponse.get();"], [131, "        } else {"], [132, "            throw new RuntimeException(throwable);"], [133, "        }"], [139, "        final CompletableFuture<Object> settableFuture = new CompletableFuture<>();"], [146, "            Bootstrap b = new Bootstrap();"], [147, "            b.group(group)"], [148, "             .channel(NioSocketChannel.class)"], [149, "             .handler(new ChannelInitializer<SocketChannel>() {"], [150, "                 @Override"], [151, "                 protected void initChannel(SocketChannel ch) throws Exception {"], [180, "                     p.addLast(new JerseyClientHandler(NettyConnector.this, jerseyRequest, jerseyCallback, settableFuture));"], [181, "                 }"], [182, "             });"], [183, ""], [184, "            // connect timeout"], [185, "            Integer connectTimeout = ClientProperties.getValue(jerseyRequest.getConfiguration().getProperties(),"], [186, "                                                               ClientProperties.CONNECT_TIMEOUT, 0);"], [187, "            if (connectTimeout > 0) {"], [188, "                b.option(ChannelOption.CONNECT_TIMEOUT_MILLIS, connectTimeout);"], [189, "            }"], [191, "            // Make the connection attempt."], [192, "            final Channel ch = b.connect(host, port).sync().channel();"], [194, "            // guard against prematurely closed channel"], [195, "            final GenericFutureListener<io.netty.util.concurrent.Future<? super Void>> closeListener ="], [196, "                    new GenericFutureListener<io.netty.util.concurrent.Future<? super Void>>() {"], [197, "                        @Override"], [198, "                        public void operationComplete(io.netty.util.concurrent.Future<? super Void> future) throws Exception {"], [199, "                            if (!settableFuture.isDone()) {"], [200, "                                settableFuture.completeExceptionally(new IOException(\"Channel closed.\"));"], [201, "                            }"], [202, "                        }"], [203, "                    };"], [205, "            ch.closeFuture().addListener(closeListener);"], [234, "            }"], [236, "            if (jerseyRequest.hasEntity()) {"], [263, "                            jerseyCallback.failure(e);"], [264, "                            settableFuture.completeExceptionally(e);"], [271, "                // close listener is not needed any more."], [272, "                ch.closeFuture().removeListener(closeListener);"], [273, ""], [279, "            settableFuture.completeExceptionally(e);"], [280, "            return settableFuture;"], [283, "        return settableFuture;"]]}, "num_lines_added": 90, "num_lines_removed": 69}