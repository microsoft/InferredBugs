{"hash": "ed1b2e788269bac2cd354672d3b2baab075c4c0e", "message": "jillegal impl for version 2.2-SNAPSHOT", "file_num_lines": 309, "diff_parsed": {"added": [[24, "\tprotected static final byte SEGMENT_BLOCK_IS_AVAILABLE = 0;"], [25, "\tprotected static final byte SEGMENT_BLOCK_IS_IN_USE = 1;"], [26, "\tprotected static final byte BLOCK_IS_FULL = -1;"], [27, "\tprotected static final byte INDEX_NOT_YET_USED = -1;"], [28, "\tprotected static final byte INDEX_NOT_AVAILABLE = -2;"], [29, "\tprotected static final byte BLOCK_IS_FULL_VALUE = (byte)0xFF;"], [42, "\tprotected long segmentCount;"], [43, "\tprotected long inUseBlockCount;"], [44, "\tprotected long inUseBlockAddress;"], [45, "\tprotected long currentIndex;"], [46, "\tprotected long currentBlockIndex;"], [47, "\tprotected long currentSegment;"], [48, "\tprotected int sampleHeader;"], [49, "\tprotected byte fullValueOfLastBlock;"], [50, "\tprotected volatile boolean full;"], [68, "\t\tsuper.init();"], [69, "\t\tcurrentAddress = stringsStartAddress;"], [70, "\t\tfull = false;"], [71, "\t\tcurrentIndex = INDEX_NOT_YET_USED;"], [72, "\t\tcurrentBlockIndex = INDEX_NOT_YET_USED;"], [73, "\t\tdirectMemoryService.setMemory(inUseBlockAddress, inUseBlockCount, (byte)0);"], [97, "\t\t\tsegmentCount = allocationSize / STRING_SEGMENT_SIZE;"], [98, "\t\t\tlong segmentCountMod = allocationSize % STRING_SEGMENT_SIZE;"], [99, "\t\t\tif (segmentCountMod != 0) {"], [100, "\t\t\t\tsegmentCount++;"], [101, "\t\t\t}"], [102, "\t\t\tinUseBlockCount = segmentCount / STRING_SEGMENT_COUNT_AT_AN_IN_USE_BLOCK;"], [103, "\t\t\tlong blockCountMod = segmentCount % STRING_SEGMENT_COUNT_AT_AN_IN_USE_BLOCK;"], [104, "\t\t\tif (blockCountMod != 0) {"], [105, "\t\t\t\tinUseBlockCount++;"], [106, "\t\t\t\tfullValueOfLastBlock = (byte)(Math.pow(2, blockCountMod) - 1);"], [107, "\t\t\t}"], [108, "\t\t\telse {"], [109, "\t\t\t\tfullValueOfLastBlock = BLOCK_IS_FULL_VALUE;"], [110, "\t\t\t}"], [111, "\t\t\tinUseBlockAddress = directMemoryService.allocateMemory(inUseBlockCount);"], [112, "\t\t\tsampleHeader = directMemoryService.getInt(new String(), 0L);"], [113, ""], [128, "\tprotected int calculateSegmentedStringSize(String str) {"], [129, "\t\tchar[] valueArray = (char[]) directMemoryService.getObject(str, valueArrayOffsetInString);"], [130, "\t\tint valueArraySize = charArrayIndexStartOffset + (charArrayIndexScale * valueArray.length);"], [131, "\t\tint segmentedStringSize = stringSize + valueArraySize; // + JvmUtil.OBJECT_ADDRESS_SENSIVITY; // Extra memory for possible aligning"], [132, "\t\tint segmentSizeMod = segmentedStringSize % STRING_SEGMENT_SIZE;"], [133, "\t\tif (segmentSizeMod != 0) {"], [134, "\t\t\tsegmentedStringSize += (STRING_SEGMENT_SIZE - segmentSizeMod);"], [136, "\t\treturn segmentedStringSize;"], [137, "\t}"], [138, ""], [139, "\tprotected int calculateSegmentedStringSize(long strAddress) {"], [140, "\t\tchar[] valueArray = (char[]) directMemoryService.getObject(strAddress + valueArrayOffsetInString);"], [141, "\t\tint valueArraySize = charArrayIndexStartOffset + (charArrayIndexScale * valueArray.length);"], [142, "\t\tint segmentedStringSize = stringSize + valueArraySize; // + JvmUtil.OBJECT_ADDRESS_SENSIVITY; // Extra memory for possible aligning"], [143, "\t\tint segmentSizeMod = segmentedStringSize % STRING_SEGMENT_SIZE;"], [144, "\t\tif (segmentSizeMod != 0) {"], [145, "\t\t\tsegmentedStringSize += (STRING_SEGMENT_SIZE - segmentSizeMod);"], [147, "\t\treturn segmentedStringSize;"], [150, "\tprotected int calculateStringSegmentCount(String str) {"], [151, "\t\treturn calculateSegmentedStringSize(str) / STRING_SEGMENT_SIZE;"], [154, "\tprotected int calculateStringSegmentCount(long strAddress) {"], [155, "\t\treturn calculateSegmentedStringSize(strAddress) / STRING_SEGMENT_SIZE;"], [156, "\t}"], [157, ""], [158, "\tprotected byte getInUseFromStringSegment(long strSegment, int segmentCount) {"], [159, "\t\treturn 0;"], [160, "\t\t/*"], [161, "\t\tlong blockIndex = objIndex / OBJECT_COUNT_AT_AN_IN_USE_BLOCK;"], [162, "\t\tbyte blockIndexValue = directMemoryService.getByte(inUseBlockAddress + blockIndex);"], [163, "\t\tif (blockIndexValue == BLOCK_IS_FULL_VALUE) {"], [164, "\t\t\treturn BLOCK_IS_FULL;"], [167, "\t\t\tbyte blockInternalOrder = (byte) (objIndex % OBJECT_COUNT_AT_AN_IN_USE_BLOCK);"], [168, "\t\t\treturn"], [169, "\t\t\t\tgetBit(blockIndexValue, blockInternalOrder) == 1 ?"], [170, "\t\t\t\t\t\tOBJECT_IS_IN_USE : OBJECT_IS_AVAILABLE;"], [171, "\t\t}"], [172, "\t\t*/"], [175, "\tprotected byte getInUseFromStringAddress(long strAddress, int segmentCount) {"], [176, "\t\treturn"], [177, "\t\t\tgetInUseFromStringSegment("], [178, "\t\t\t\t\t(strAddress - stringsStartAddress) / STRING_SEGMENT_SIZE,"], [179, "\t\t\t\t\tsegmentCount);"], [182, "\tprotected void setUnsetInUseFromStringSegment(long strSegment, int segmentCount, boolean set) {"], [183, "\t\tlong blockIndex = strSegment / STRING_SEGMENT_COUNT_AT_AN_IN_USE_BLOCK;"], [184, "\t\tbyte blockIndexValue = directMemoryService.getByte(inUseBlockAddress + blockIndex);"], [185, "\t\tbyte blockInternalOrder = (byte) (strSegment % STRING_SEGMENT_COUNT_AT_AN_IN_USE_BLOCK);"], [186, "\t\tbyte newBlockIndexValue ="], [187, "\t\t\t\tset ?"], [188, "\t\t\t\t\tsetBit(blockIndexValue, blockInternalOrder) :"], [189, "\t\t\t\t\tunsetBit(blockIndexValue, blockInternalOrder);"], [190, "\t\tdirectMemoryService.putByte(inUseBlockAddress + blockIndex, newBlockIndexValue);"], [191, "\t}"], [192, ""], [193, "\tprotected void setUnsetInUseFromStringAddress(long strAddress, int segmentCount, boolean set) {"], [194, "\t\tsetUnsetInUseFromStringSegment("], [195, "\t\t\t\t(strAddress - stringsStartAddress) / STRING_SEGMENT_SIZE,"], [196, "\t\t\t\tsegmentCount,"], [197, "\t\t\t\tset);"], [198, "\t}"], [199, ""], [200, "\tprotected void allocateStringFromStringSegment(long strSegment, int segmentCount) {"], [201, "\t\tsetUnsetInUseFromStringSegment(strSegment, segmentCount, true);"], [202, "\t}"], [203, ""], [204, "\tprotected void freeStringFromStringSegment(long strSegment, int segmentCount) {"], [205, "\t\tsetUnsetInUseFromStringSegment(strSegment, segmentCount, false);"], [206, "\t\tfull = false;"], [207, "\t}"], [208, ""], [209, "\tprotected void allocateStringFromStringAddress(long strAddress, int segmentCount) {"], [210, "\t\tsetUnsetInUseFromStringAddress(strAddress, segmentCount, true);"], [211, "\t}"], [212, ""], [213, "\tprotected void freeStringFromStringAddress(long strAddress, int segmentCount) {"], [214, "\t\tsetUnsetInUseFromStringAddress(strAddress, segmentCount, false);"], [215, "\t\tfull = false;"], [216, "\t}"], [217, ""], [218, "\tprotected boolean nextAvailable(int segmentCount) {"], [219, "\t\treturn true;"], [220, "\t\t/*"], [221, "\t\tif (full) {"], [224, "\t\tcurrentIndex++;"], [225, "\t\tif (currentIndex >= objectCount) {"], [226, "\t\t\tcurrentIndex = 0;"], [227, "\t\t}"], [228, "\t\tbyte objectInUse = getInUseFromObjectIndex(currentIndex);"], [229, "\t\t// Object on current index is not available"], [230, "\t\tif (objectInUse != OBJECT_IS_AVAILABLE) {"], [231, "\t\t\t// Current object is not available, so search in current block for available one"], [232, "\t\t\tif (objectInUse != BLOCK_IS_FULL) {"], [233, "\t\t\t\tbyte blockIndexValue = directMemoryService.getByte(inUseBlockAddress + currentBlockIndex);"], [234, "\t\t\t\t// Check objects in block"], [235, "\t\t\t\tfor (int i = 0; i < OBJECT_COUNT_AT_AN_IN_USE_BLOCK; i++) {"], [236, "\t\t\t\t\t// If current object is not in use, use it"], [237, "\t\t\t\t\tif (((blockIndexValue >> i) & 0x01) == 0) {"], [238, "\t\t\t\t\t\tbreak;"], [239, "\t\t\t\t\t}"], [240, "\t\t\t\t\tcurrentIndex++;"], [241, "\t\t\t\t}"], [242, "\t\t\t}"], [243, "\t\t\telse {"], [244, "\t\t\t\tcurrentBlockIndex = currentIndex / OBJECT_COUNT_AT_AN_IN_USE_BLOCK;"], [245, "\t\t\t\tbyte blockIndexValue = directMemoryService.getByte(inUseBlockAddress + currentBlockIndex);"], [246, "\t\t\t\tlong checkedBlockCount;"], [247, "\t\t\t\t// Search for non-full block"], [248, "\t\t\t\tfor (\tcheckedBlockCount = 0;"], [249, "\t\t\t\t\t\tblockIndexValue == BLOCK_IS_FULL_VALUE && checkedBlockCount < inUseBlockCount;"], [250, "\t\t\t\t\t\tcheckedBlockCount++) {"], [251, "\t\t\t\t\tcurrentBlockIndex++;"], [252, "\t\t\t\t\tif (currentBlockIndex >= inUseBlockCount) {"], [253, "\t\t\t\t\t\tcurrentBlockIndex = 0;"], [254, "\t\t\t\t\t}"], [255, "\t\t\t\t\tcurrentIndex = currentBlockIndex * OBJECT_COUNT_AT_AN_IN_USE_BLOCK;"], [256, "\t\t\t\t\tblockIndexValue = directMemoryService.getByte(inUseBlockAddress + currentBlockIndex);"], [257, "\t\t\t\t}"], [258, "\t\t\t\t// All blocks are checked but there is no non-full block"], [259, "\t\t\t\tif (\tcheckedBlockCount >=  inUseBlockCount ||"], [260, "\t\t\t\t\t\t(currentBlockIndex == (inUseBlockCount - 1) && blockIndexValue == fullValueOfLastBlock)) {"], [261, "\t\t\t\t\tcurrentIndex = INDEX_NOT_AVAILABLE;"], [262, "\t\t\t\t\tcurrentBlockIndex = INDEX_NOT_AVAILABLE;"], [263, "\t\t\t\t\tfull = true;"], [264, "\t\t\t\t\treturn false;"], [265, "\t\t\t\t}"], [266, "\t\t\t\t// A non-full block found, check free object in block"], [267, "\t\t\t\tfor (int i = 0; i < OBJECT_COUNT_AT_AN_IN_USE_BLOCK; i++) {"], [268, "\t\t\t\t\t// If current object is not in use, use it"], [269, "\t\t\t\t\tif (((blockIndexValue >> i) & 0x01) == 0) {"], [270, "\t\t\t\t\t\tbreak;"], [271, "\t\t\t\t\t}"], [272, "\t\t\t\t\tcurrentIndex++;"], [273, "\t\t\t\t}"], [274, "\t\t\t}"], [275, "\t\t}"], [276, "\t\tcurrentAddress = objectsStartAddress + (currentIndex * objectSize);"], [277, "\t\treturn true;"], [278, "\t\t*/"], [281, "\tprotected synchronized String takeString(String str) {"], [282, "\t\tlong objAddress = directMemoryService.addressOf(str);"], [283, "\t\tdirectMemoryService.putInt(objAddress, sampleHeader);"], [284, "\t\tallocateStringFromStringAddress(objAddress, calculateStringSegmentCount(str));"], [285, "\t\treturn str;"], [286, "\t}"], [287, ""], [288, "\tprotected synchronized String takeString(long strAddress) {"], [289, "\t\tString str = (String) directMemoryService.getObject(strAddress);"], [290, "\t\tdirectMemoryService.putInt(strAddress, sampleHeader);"], [291, "\t\tallocateStringFromStringAddress(strAddress, calculateStringSegmentCount(strAddress));"], [292, "\t\treturn str;"], [293, "\t}"], [294, ""], [295, "\tprotected synchronized long takeStringAsAddress(long strAddress) {"], [296, "\t\tdirectMemoryService.putInt(strAddress, sampleHeader);"], [297, "\t\tallocateStringFromStringAddress(strAddress, calculateStringSegmentCount(strAddress));"], [298, "\t\treturn strAddress;"], [299, "\t}"], [300, ""], [301, "\tprotected synchronized boolean releaseString(String str) {"], [302, "\t\treturn releaseString(directMemoryService.addressOf(str));"], [303, "\t}"], [304, ""], [305, "\tprotected synchronized boolean releaseString(long strAddress) {"], [309, "\t\t// Reset free object"], [310, "\t\tint stringSegmentedSize = calculateSegmentedStringSize(strAddress);"], [311, "\t\tdirectMemoryService.setMemory(strAddress, stringSegmentedSize, (byte)0);"], [312, "\t\tfreeStringFromStringAddress(strAddress, stringSegmentedSize / STRING_SEGMENT_SIZE);"], [313, "\t\treturn true;"], [317, "\t\tlong addressOfStr = directMemoryService.addressOf(str);"], [320, "\t\tint strSize = stringSize + valueArraySize; // + JvmUtil.OBJECT_ADDRESS_SENSIVITY; // Extra memory for possible aligning"], [322, "\t\tlong addressMod1 = currentAddress % JvmUtil.OBJECT_ADDRESS_SENSIVITY;"], [324, "\t\t\tcurrentAddress += (JvmUtil.OBJECT_ADDRESS_SENSIVITY - addressMod1);"], [335, "\t\tlong addressMod2 = valueAddress % JvmUtil.OBJECT_ADDRESS_SENSIVITY;"], [337, "\t\t\tvalueAddress += (JvmUtil.OBJECT_ADDRESS_SENSIVITY - addressMod2);"], [360, "\tpublic synchronized String get(String str) {"], [361, "\t\tcheckAvailability();"], [362, "\t\tint requiredSegmentCount = calculateStringSegmentCount(str);"], [363, "\t\tif (!nextAvailable(requiredSegmentCount)) {"], [364, "\t\t\treturn null;"], [365, "\t\t}"], [366, "\t\tlong allocatedStrAddress = allocateStringFromOffHeap(str);"], [367, "\t\tif (allocatedStrAddress == JvmUtil.NULL) {"], [368, "\t\t\treturn null;"], [369, "\t\t}"], [370, "\t\telse {"], [371, "\t\t\treturn directMemoryService.getObject(allocatedStrAddress);"], [372, "\t\t}"], [373, "\t}"], [374, ""], [375, "\t@Override"], [376, "\tpublic synchronized long getAsAddress(String str) {"], [377, "\t\tcheckAvailability();"], [378, "\t\tint requiredSegmentCount = calculateStringSegmentCount(str);"], [379, "\t\tif (!nextAvailable(requiredSegmentCount)) {"], [380, "\t\t\treturn JvmUtil.NULL;"], [381, "\t\t}"], [382, "\t\treturn allocateStringFromOffHeap(str);"], [383, "\t}"], [384, ""], [385, "\t@Override"], [386, "\tpublic boolean isMine(String str) {"], [387, "\t\tcheckAvailability();"], [388, "\t\tif (str == null) {"], [389, "\t\t\treturn false;"], [390, "\t\t}"], [391, "\t\telse {"], [392, "\t\t\treturn isMine(directMemoryService.addressOf(str));"], [393, "\t\t}"], [394, "\t}"], [395, ""], [396, "\t@Override"], [397, "\tpublic boolean isMine(long address) {"], [398, "\t\tcheckAvailability();"], [399, "\t\treturn isIn(address);"], [400, "\t}"], [401, ""], [402, "\t@Override"], [403, "\tpublic synchronized boolean free(String str) {"], [404, "\t\tcheckAvailability();"], [405, "\t\tif (str == null) {"], [406, "\t\t\treturn false;"], [407, "\t\t}"], [408, "\t\treturn releaseString(str);"], [409, "\t}"], [410, ""], [411, "\t@Override"], [412, "\tpublic synchronized boolean freeFromAddress(long strAddress) {"], [413, "\t\tcheckAvailability();"], [414, "\t\treturn releaseString(strAddress);"], [415, "\t}"], [416, ""], [417, "\t@Override"], [431, "\t\tdirectMemoryService.freeMemory(inUseBlockAddress);"]], "deleted": [[36, "\tprotected String sampleStr;"], [37, "\tprotected long sampleStrAddress;"], [38, "\tprotected char[] sampleCharArray;"], [54, "\t@SuppressWarnings({ \"deprecation\" })"], [57, "\t\ttry {"], [58, "\t\t\tsuper.init();"], [59, ""], [60, "\t\t\tcharArrayIndexScale = JvmUtil.arrayIndexScale(char.class);"], [61, "\t\t\tcharArrayIndexStartOffset = JvmUtil.arrayBaseOffset(char.class);"], [62, "\t\t\tvalueArrayOffsetInString = JvmUtil.getUnsafe().fieldOffset(String.class.getDeclaredField(\"value\"));"], [63, "\t\t\tstringSize = (int) JvmUtil.sizeOf(String.class);"], [64, "\t\t\tint estimatedStringSize = (int) (stringSize + JvmUtil.sizeOfArray(char.class, estimatedStringLength));"], [65, "\t\t\tallocationSize = (estimatedStringSize * estimatedStringCount) + JvmUtil.OBJECT_ADDRESS_SENSIVITY; // Extra memory for possible aligning"], [66, "\t\t\tallocationStartAddress = directMemoryService.allocateMemory(allocationSize);"], [67, "\t\t\tallocationEndAddress = allocationStartAddress + allocationSize;"], [68, "\t\t\t// Allocated objects must start aligned as address size from start address of allocated address"], [69, "\t\t\tstringsStartAddress = allocationStartAddress;"], [70, "\t\t\tlong addressMod = stringsStartAddress % JvmUtil.OBJECT_ADDRESS_SENSIVITY;"], [71, "\t\t\tif (addressMod != 0) {"], [72, "\t\t\t\tstringsStartAddress += (JvmUtil.OBJECT_ADDRESS_SENSIVITY - addressMod);"], [73, "\t\t\t}"], [74, "\t\t\tcurrentAddress = stringsStartAddress;"], [75, "\t\t\tsampleStr = new String();"], [76, "\t\t\tsampleStrAddress = JvmUtil.addressOf(sampleStr);"], [77, "\t\t\tsampleCharArray = new char[0];"], [78, "\t\t}"], [79, "\t\tcatch (Throwable t) {"], [80, "\t\t\tlogger.error(\"Error occured while initializing \\\"StringOffHeapPool\\\"\", t);"], [81, "\t\t\tthrow new IllegalStateException(t);"], [82, "\t\t}"], [106, "\t\t\tsampleStr = new String();"], [107, "\t\t\tsampleStrAddress = JvmUtil.addressOf(sampleStr);"], [108, "\t\t\tsampleCharArray = new char[0];"], [123, "\t@Override"], [124, "\tpublic synchronized String get(String str) {"], [125, "\t\tcheckAvailability();"], [126, "\t\tlong allocatedStrAddress = allocateStringFromOffHeap(str);"], [127, "\t\tif (allocatedStrAddress == 0) {"], [128, "\t\t\treturn null;"], [130, "\t\telse {"], [131, "\t\t\treturn directMemoryService.getObject(allocatedStrAddress);"], [135, "\t@Override"], [136, "\tpublic synchronized long getAsAddress(String str) {"], [137, "\t\tcheckAvailability();"], [138, "\t\treturn allocateStringFromOffHeap(str);"], [141, "\t@Override"], [142, "\tpublic boolean isMine(String str) {"], [143, "\t\tcheckAvailability();"], [144, "\t\tif (str == null) {"], [145, "\t\t\treturn false;"], [148, "\t\t\treturn isMine(directMemoryService.addressOf(str));"], [149, "\t\t}"], [152, "\t@Override"], [153, "\tpublic boolean isMine(long address) {"], [154, "\t\tcheckAvailability();"], [155, "\t\treturn isIn(address);"], [158, "\t@Override"], [159, "\tpublic boolean free(String str) {"], [160, "\t\tcheckAvailability();"], [161, "\t\tif (str == null) {"], [164, "\t\treturn freeFromAddress(directMemoryService.addressOf(str));"], [167, "\t@Override"], [168, "\tpublic boolean freeFromAddress(long strAddress) {"], [169, "\t\tcheckAvailability();"], [173, "\t\treturn false;"], [177, "\t\tlong addressOfStr = JvmUtil.addressOf(str);"], [180, "\t\tint strSize = stringSize + valueArraySize + JvmUtil.getAddressSize(); // Extra memory for possible aligning"], [182, "\t\tlong addressMod1 = currentAddress % JvmUtil.getAddressSize();"], [184, "\t\t\tcurrentAddress += (JvmUtil.getAddressSize() - addressMod1);"], [195, "\t\tlong addressMod2 = valueAddress % JvmUtil.getAddressSize();"], [197, "\t\t\tvalueAddress += (JvmUtil.getAddressSize() - addressMod2);"]]}, "num_lines_added": 270, "num_lines_removed": 71}