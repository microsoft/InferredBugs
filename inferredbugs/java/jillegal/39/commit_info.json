{"hash": "f71ea6b4e31c7255e6bc0db107edd3eb5ebe7df5", "message": "jillegal impl for version 2.2-SNAPSHOT", "file_num_lines": 379, "diff_parsed": {"added": [[42, "\tprotected long totalSegmentCount;"], [45, "\tprotected long currentSegmentIndex;"], [46, "\tprotected long currentSegmentBlockIndex;"], [70, "\t\tcurrentSegmentIndex = INDEX_NOT_YET_USED;"], [71, "\t\tcurrentSegmentBlockIndex = INDEX_NOT_YET_USED;"], [86, "\t\t\tint estimatedSizeMod = estimatedStringSize % JvmUtil.OBJECT_ADDRESS_SENSIVITY;"], [87, "\t\t\tif (estimatedSizeMod != 0) {"], [88, "\t\t\t\testimatedStringSize += (JvmUtil.OBJECT_ADDRESS_SENSIVITY - estimatedSizeMod);"], [89, "\t\t\t}"], [100, "\t\t\ttotalSegmentCount = allocationSize / STRING_SEGMENT_SIZE;"], [103, "\t\t\t\ttotalSegmentCount++;"], [105, "\t\t\tinUseBlockCount = totalSegmentCount / STRING_SEGMENT_COUNT_AT_AN_IN_USE_BLOCK;"], [106, "\t\t\tlong blockCountMod = totalSegmentCount % STRING_SEGMENT_COUNT_AT_AN_IN_USE_BLOCK;"], [116, ""], [134, "\t\tint segmentedStringSize = stringSize + valueArraySize + JvmUtil.OBJECT_ADDRESS_SENSIVITY; // Extra memory for possible aligning"], [143, "\t\tchar[] valueArray ="], [144, "\t\t\t\t(char[])"], [145, "\t\t\t\t\tdirectMemoryService.getObject("], [146, "\t\t\t\t\t\tJvmUtil.toNativeAddress("], [147, "\t\t\t\t\t\t\t\tdirectMemoryService.getAddress("], [148, "\t\t\t\t\t\t\t\t\t\tstrAddress + valueArrayOffsetInString)));"], [150, "\t\tint segmentedStringSize = stringSize + valueArraySize + JvmUtil.OBJECT_ADDRESS_SENSIVITY; // Extra memory for possible aligning"], [167, "\t\tif (strSegment + segmentCount >= totalSegmentCount) {"], [170, "\t\tfor (int i = 0; i < segmentCount; i++) {"], [171, "\t\t\tlong blockIndex = strSegment / STRING_SEGMENT_COUNT_AT_AN_IN_USE_BLOCK;"], [172, "\t\t\tbyte blockIndexValue = directMemoryService.getByte(inUseBlockAddress + blockIndex);"], [173, "\t\t\tif (blockIndexValue == BLOCK_IS_FULL_VALUE) {"], [174, "\t\t\t\treturn BLOCK_IS_FULL;"], [175, "\t\t\t}"], [176, "\t\t\telse {"], [177, "\t\t\t\tbyte blockInternalOrder = (byte) (strSegment % STRING_SEGMENT_COUNT_AT_AN_IN_USE_BLOCK);"], [178, "\t\t\t\tif (getBit(blockIndexValue, blockInternalOrder) == 1) {"], [179, "\t\t\t\t\treturn SEGMENT_BLOCK_IS_IN_USE;"], [180, "\t\t\t\t}"], [181, "\t\t\t}"], [182, "\t\t\tstrSegment++;"], [183, "\t\t}"], [184, "\t\treturn SEGMENT_BLOCK_IS_AVAILABLE;"], [195, "\t\tif (strSegment + segmentCount >= totalSegmentCount) {"], [196, "\t\t\treturn;"], [197, "\t\t}"], [198, "\t\tfor (int i = 0; i < segmentCount; i++) {"], [199, "\t\t\tlong blockIndex = strSegment / STRING_SEGMENT_COUNT_AT_AN_IN_USE_BLOCK;"], [200, "\t\t\tbyte blockIndexValue = directMemoryService.getByte(inUseBlockAddress + blockIndex);"], [201, "\t\t\tbyte blockInternalOrder = (byte) (strSegment % STRING_SEGMENT_COUNT_AT_AN_IN_USE_BLOCK);"], [202, "\t\t\tbyte newBlockIndexValue ="], [203, "\t\t\t\t\tset ?"], [204, "\t\t\t\t\t\tsetBit(blockIndexValue, blockInternalOrder) :"], [205, "\t\t\t\t\t\tunsetBit(blockIndexValue, blockInternalOrder);"], [206, "\t\t\tdirectMemoryService.putByte(inUseBlockAddress + blockIndex, newBlockIndexValue);"], [207, "\t\t\tstrSegment++;"], [208, "\t\t}"], [240, ""], [241, "\t\tcurrentSegmentIndex++;"], [242, "\t\tif (currentSegmentIndex >= segmentCount) {"], [243, "\t\t\tcurrentSegmentIndex = 0;"], [245, "\t\tcurrentSegmentBlockIndex = currentSegmentIndex / STRING_SEGMENT_COUNT_AT_AN_IN_USE_BLOCK;"], [246, ""], [247, "\t\tbyte segmentBlockInUse = getInUseFromStringSegment(currentSegmentIndex, segmentCount);"], [248, "\t\tbyte blockIndexValue = directMemoryService.getByte(inUseBlockAddress + currentSegmentBlockIndex);"], [249, ""], [250, "\t\t// Current segment index is not available"], [251, "\t\tif (segmentBlockInUse != SEGMENT_BLOCK_IS_AVAILABLE) {"], [252, "\t\t\tboolean backToHead = false;"], [253, "\t\t\tlong lastSegmentBlockIndex = currentSegmentBlockIndex;"], [254, ""], [255, "\t\t\twhile (segmentBlockInUse != SEGMENT_BLOCK_IS_AVAILABLE) {"], [256, "\t\t\t\t// All blocks are checked but there is no available segment block"], [257, "\t\t\t\tif (backToHead && currentSegmentBlockIndex > lastSegmentBlockIndex) {"], [258, "\t\t\t\t\tcurrentSegmentBlockIndex = INDEX_NOT_AVAILABLE;"], [259, "\t\t\t\t\tcurrentSegmentIndex = INDEX_NOT_AVAILABLE;"], [263, ""], [264, "\t\t\t\t// Move to next segment block"], [265, "\t\t\t\tif (\tsegmentBlockInUse == BLOCK_IS_FULL ||"], [266, "\t\t\t\t\t\t(currentSegmentBlockIndex == (inUseBlockCount - 1) && blockIndexValue == fullValueOfLastBlock)) {"], [267, "\t\t\t\t\tcurrentSegmentBlockIndex++;"], [268, "\t\t\t\t\tcurrentSegmentIndex = currentSegmentBlockIndex * STRING_SEGMENT_COUNT_AT_AN_IN_USE_BLOCK;"], [269, "\t\t\t\t}"], [270, "\t\t\t\t// Move to next segment index"], [271, "\t\t\t\telse if (segmentBlockInUse == SEGMENT_BLOCK_IS_IN_USE) {"], [272, "\t\t\t\t\tcurrentSegmentIndex++;"], [273, "\t\t\t\t\tcurrentSegmentBlockIndex = currentSegmentIndex / STRING_SEGMENT_COUNT_AT_AN_IN_USE_BLOCK;"], [275, ""], [276, "\t\t\t\t// End of segments, back to head"], [277, "\t\t\t\tif (currentSegmentBlockIndex >= inUseBlockCount) {"], [278, "\t\t\t\t\tcurrentSegmentBlockIndex = 0;"], [279, "\t\t\t\t\tcurrentSegmentIndex = 0;"], [280, "\t\t\t\t\tbackToHead = true;"], [281, "\t\t\t\t}"], [282, ""], [283, "\t\t\t\tsegmentBlockInUse = getInUseFromStringSegment(currentSegmentIndex, segmentCount);"], [284, "\t\t\t\tblockIndexValue = directMemoryService.getByte(inUseBlockAddress + currentSegmentBlockIndex);"], [287, ""], [288, "\t\tcurrentAddress = stringsStartAddress + (currentSegmentIndex * STRING_SEGMENT_SIZE);"], [289, ""], [290, "\t\tcurrentSegmentIndex += (segmentCount - 1);"], [291, "\t\tcurrentSegmentBlockIndex = currentSegmentIndex / STRING_SEGMENT_COUNT_AT_AN_IN_USE_BLOCK;"], [292, ""], [335, "\t\tint strSize = stringSize + valueArraySize + JvmUtil.OBJECT_ADDRESS_SENSIVITY; // Extra memory for possible aligning"], [343, "\t\t\treturn JvmUtil.NULL;"], [367, "\t\treturn takeStringAsAddress(currentAddress);"]], "deleted": [[42, "\tprotected long segmentCount;"], [45, "\tprotected long currentIndex;"], [46, "\tprotected long currentBlockIndex;"], [47, "\tprotected long currentSegment;"], [71, "\t\tcurrentIndex = INDEX_NOT_YET_USED;"], [72, "\t\tcurrentBlockIndex = INDEX_NOT_YET_USED;"], [97, "\t\t\tsegmentCount = allocationSize / STRING_SEGMENT_SIZE;"], [100, "\t\t\t\tsegmentCount++;"], [102, "\t\t\tinUseBlockCount = segmentCount / STRING_SEGMENT_COUNT_AT_AN_IN_USE_BLOCK;"], [103, "\t\t\tlong blockCountMod = segmentCount % STRING_SEGMENT_COUNT_AT_AN_IN_USE_BLOCK;"], [113, ""], [131, "\t\tint segmentedStringSize = stringSize + valueArraySize; // + JvmUtil.OBJECT_ADDRESS_SENSIVITY; // Extra memory for possible aligning"], [140, "\t\tchar[] valueArray = (char[]) directMemoryService.getObject(strAddress + valueArrayOffsetInString);"], [142, "\t\tint segmentedStringSize = stringSize + valueArraySize; // + JvmUtil.OBJECT_ADDRESS_SENSIVITY; // Extra memory for possible aligning"], [159, "\t\treturn 0;"], [160, "\t\t/*"], [161, "\t\tlong blockIndex = objIndex / OBJECT_COUNT_AT_AN_IN_USE_BLOCK;"], [162, "\t\tbyte blockIndexValue = directMemoryService.getByte(inUseBlockAddress + blockIndex);"], [163, "\t\tif (blockIndexValue == BLOCK_IS_FULL_VALUE) {"], [166, "\t\telse {"], [167, "\t\t\tbyte blockInternalOrder = (byte) (objIndex % OBJECT_COUNT_AT_AN_IN_USE_BLOCK);"], [168, "\t\t\treturn"], [169, "\t\t\t\tgetBit(blockIndexValue, blockInternalOrder) == 1 ?"], [170, "\t\t\t\t\t\tOBJECT_IS_IN_USE : OBJECT_IS_AVAILABLE;"], [171, "\t\t}"], [172, "\t\t*/"], [183, "\t\tlong blockIndex = strSegment / STRING_SEGMENT_COUNT_AT_AN_IN_USE_BLOCK;"], [184, "\t\tbyte blockIndexValue = directMemoryService.getByte(inUseBlockAddress + blockIndex);"], [185, "\t\tbyte blockInternalOrder = (byte) (strSegment % STRING_SEGMENT_COUNT_AT_AN_IN_USE_BLOCK);"], [186, "\t\tbyte newBlockIndexValue ="], [187, "\t\t\t\tset ?"], [188, "\t\t\t\t\tsetBit(blockIndexValue, blockInternalOrder) :"], [189, "\t\t\t\t\tunsetBit(blockIndexValue, blockInternalOrder);"], [190, "\t\tdirectMemoryService.putByte(inUseBlockAddress + blockIndex, newBlockIndexValue);"], [219, "\t\treturn true;"], [220, "\t\t/*"], [224, "\t\tcurrentIndex++;"], [225, "\t\tif (currentIndex >= objectCount) {"], [226, "\t\t\tcurrentIndex = 0;"], [228, "\t\tbyte objectInUse = getInUseFromObjectIndex(currentIndex);"], [229, "\t\t// Object on current index is not available"], [230, "\t\tif (objectInUse != OBJECT_IS_AVAILABLE) {"], [231, "\t\t\t// Current object is not available, so search in current block for available one"], [232, "\t\t\tif (objectInUse != BLOCK_IS_FULL) {"], [233, "\t\t\t\tbyte blockIndexValue = directMemoryService.getByte(inUseBlockAddress + currentBlockIndex);"], [234, "\t\t\t\t// Check objects in block"], [235, "\t\t\t\tfor (int i = 0; i < OBJECT_COUNT_AT_AN_IN_USE_BLOCK; i++) {"], [236, "\t\t\t\t\t// If current object is not in use, use it"], [237, "\t\t\t\t\tif (((blockIndexValue >> i) & 0x01) == 0) {"], [238, "\t\t\t\t\t\tbreak;"], [239, "\t\t\t\t\t}"], [240, "\t\t\t\t\tcurrentIndex++;"], [241, "\t\t\t\t}"], [242, "\t\t\t}"], [243, "\t\t\telse {"], [244, "\t\t\t\tcurrentBlockIndex = currentIndex / OBJECT_COUNT_AT_AN_IN_USE_BLOCK;"], [245, "\t\t\t\tbyte blockIndexValue = directMemoryService.getByte(inUseBlockAddress + currentBlockIndex);"], [246, "\t\t\t\tlong checkedBlockCount;"], [247, "\t\t\t\t// Search for non-full block"], [248, "\t\t\t\tfor (\tcheckedBlockCount = 0;"], [249, "\t\t\t\t\t\tblockIndexValue == BLOCK_IS_FULL_VALUE && checkedBlockCount < inUseBlockCount;"], [250, "\t\t\t\t\t\tcheckedBlockCount++) {"], [251, "\t\t\t\t\tcurrentBlockIndex++;"], [252, "\t\t\t\t\tif (currentBlockIndex >= inUseBlockCount) {"], [253, "\t\t\t\t\t\tcurrentBlockIndex = 0;"], [254, "\t\t\t\t\t}"], [255, "\t\t\t\t\tcurrentIndex = currentBlockIndex * OBJECT_COUNT_AT_AN_IN_USE_BLOCK;"], [256, "\t\t\t\t\tblockIndexValue = directMemoryService.getByte(inUseBlockAddress + currentBlockIndex);"], [257, "\t\t\t\t}"], [258, "\t\t\t\t// All blocks are checked but there is no non-full block"], [259, "\t\t\t\tif (\tcheckedBlockCount >=  inUseBlockCount ||"], [260, "\t\t\t\t\t\t(currentBlockIndex == (inUseBlockCount - 1) && blockIndexValue == fullValueOfLastBlock)) {"], [261, "\t\t\t\t\tcurrentIndex = INDEX_NOT_AVAILABLE;"], [262, "\t\t\t\t\tcurrentBlockIndex = INDEX_NOT_AVAILABLE;"], [266, "\t\t\t\t// A non-full block found, check free object in block"], [267, "\t\t\t\tfor (int i = 0; i < OBJECT_COUNT_AT_AN_IN_USE_BLOCK; i++) {"], [268, "\t\t\t\t\t// If current object is not in use, use it"], [269, "\t\t\t\t\tif (((blockIndexValue >> i) & 0x01) == 0) {"], [270, "\t\t\t\t\t\tbreak;"], [271, "\t\t\t\t\t}"], [272, "\t\t\t\t\tcurrentIndex++;"], [276, "\t\tcurrentAddress = objectsStartAddress + (currentIndex * objectSize);"], [278, "\t\t*/"], [320, "\t\tint strSize = stringSize + valueArraySize; // + JvmUtil.OBJECT_ADDRESS_SENSIVITY; // Extra memory for possible aligning"], [328, "\t\t\treturn 0;"], [352, "\t\tlong allocatedStrAddress = currentAddress;"], [353, ""], [354, "\t\tcurrentAddress += strSize;"], [355, ""], [356, "\t\treturn allocatedStrAddress;"]]}, "num_lines_added": 101, "num_lines_removed": 90}