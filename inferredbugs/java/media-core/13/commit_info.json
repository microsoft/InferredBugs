{"hash": "6de9ae35fa74b4c7a1268a881a285b74c8b19c2f", "message": "Fixed the potential race in JitterBuffer", "file_num_lines": 191, "diff_parsed": {"added": [[213, "\t\ttry {"], [214, "\t\t\tLOCK.lock();"], [215, "\t\t\t// checking format"], [216, "\t\t\tif (format == null) {"], [217, "\t\t\t\tlogger.warn(\"No format specified. Packet dropped!\");"], [218, "\t\t\t\treturn;"], [219, "\t\t\t}"], [221, "\t\t\tif (this.format == null || this.format.getID() != format.getID()) {"], [222, "\t\t\t\tthis.format = format;"], [223, "\t\t\t\tlogger.info(\"Format has been changed: \" + this.format.toString());"], [224, "\t\t\t}"], [226, "\t\t\t// if this is first packet then synchronize clock"], [227, "\t\t\tif (isn == -1) {"], [228, "\t\t\t\trtpClock.synchronize(packet.getTimestamp());"], [229, "\t\t\t\tisn = packet.getSeqNumber();"], [230, "\t\t\t\tinitJitter(packet);"], [231, "\t\t\t} else {"], [232, "\t\t\t\testimateJitter(packet);"], [233, "\t\t\t}"], [235, "\t\t\t// update clock rate"], [236, "\t\t\trtpClock.setClockRate(this.format.getClockRate());"], [238, "\t\t\t// drop outstanding packets"], [239, "\t\t\t// packet is outstanding if its timestamp of arrived packet is less"], [240, "\t\t\t// then consumer media time"], [241, "\t\t\tif (packet.getTimestamp() < this.arrivalDeadLine) {"], [242, "\t\t\t\tlogger.warn(\"drop packet: dead line=\" + arrivalDeadLine + \", packet time=\" + packet.getTimestamp() + \", seq=\" + packet.getSeqNumber() + \", payload length=\" + packet.getPayloadLength() + \", format=\" + this.format.toString());"], [243, "\t\t\t\tdropCount++;"], [245, "\t\t\t\t// checking if not dropping too much"], [246, "\t\t\t\tdroppedInRaw++;"], [247, "\t\t\t\tif (droppedInRaw == QUEUE_SIZE / 2 || queue.size() == 0) {"], [248, "\t\t\t\t\tarrivalDeadLine = 0;"], [249, "\t\t\t\t} else {"], [250, "\t\t\t\t\treturn;"], [251, "\t\t\t\t}"], [254, "\t\t\tFrame f = Memory.allocate(packet.getPayloadLength());"], [255, "\t\t\t// put packet into buffer irrespective of its sequence number"], [256, "\t\t\tf.setHeader(null);"], [257, "\t\t\tf.setSequenceNumber(packet.getSeqNumber());"], [258, "\t\t\t// here time is in milliseconds"], [259, "\t\t\tf.setTimestamp(rtpClock.convertToAbsoluteTime(packet.getTimestamp()));"], [260, "\t\t\tf.setOffset(0);"], [261, "\t\t\tf.setLength(packet.getPayloadLength());"], [262, "\t\t\tpacket.getPayload(f.getData(), 0);"], [264, "\t\t\t// set format"], [265, "\t\t\tf.setFormat(this.format.getFormat());"], [267, "\t\t\t// make checks only if have packet"], [268, "\t\t\tif (f != null) {"], [270, "\t\t\t\tdroppedInRaw = 0;"], [272, "\t\t\t\t// find correct position to insert a packet"], [273, "\t\t\t\t// use timestamp since its always positive"], [274, "\t\t\t\tint currIndex = queue.size() - 1;"], [275, "\t\t\t\twhile (currIndex >= 0 && queue.get(currIndex).getTimestamp() > f.getTimestamp()) {"], [276, "\t\t\t\t\tcurrIndex--;"], [277, "\t\t\t\t}"], [279, "\t\t\t\t// check for duplicate packet"], [280, "\t\t\t\tif (currIndex >= 0 && queue.get(currIndex).getSequenceNumber() == f.getSequenceNumber()) {"], [281, "\t\t\t\t\tLOCK.unlock();"], [282, "\t\t\t\t\treturn;"], [283, "\t\t\t\t}"], [285, "\t\t\t\tqueue.add(currIndex + 1, f);"], [286, ""], [287, "\t\t\t\t// recalculate duration of each frame in queue and overall duration"], [288, "\t\t\t\t// since we could insert the frame in the middle of the queue"], [289, "\t\t\t\tduration = 0;"], [290, "\t\t\t\tif (queue.size() > 1) {"], [291, "\t\t\t\t\tduration = queue.get(queue.size() - 1).getTimestamp() - queue.get(0).getTimestamp();"], [292, "\t\t\t\t}"], [293, ""], [294, "\t\t\t\tfor (int i = 0; i < queue.size() - 1; i++) {"], [295, "\t\t\t\t\t// duration measured by wall clock"], [296, "\t\t\t\t\tlong d = queue.get(i + 1).getTimestamp() - queue.get(i).getTimestamp();"], [297, "\t\t\t\t\t// in case of RFC2833 event timestamp remains same"], [298, "\t\t\t\t\tqueue.get(i).setDuration(d > 0 ? d : 0);"], [299, "\t\t\t\t}"], [300, ""], [301, "\t\t\t\t// if overall duration is negative we have some mess here,try to"], [302, "\t\t\t\t// reset"], [303, "\t\t\t\tif (duration < 0 && queue.size() > 1) {"], [304, "\t\t\t\t\tlogger.warn(\"Something messy happened. Reseting jitter buffer!\");"], [305, "\t\t\t\t\treset();"], [306, "\t\t\t\t\treturn;"], [307, "\t\t\t\t}"], [308, ""], [309, "\t\t\t\t// overflow?"], [310, "\t\t\t\t// only now remove packet if overflow , possibly the same packet we just received"], [311, "\t\t\t\tif (queue.size() > QUEUE_SIZE) {"], [312, "\t\t\t\t\tlogger.warn(\"Buffer overflow!\");"], [313, "\t\t\t\t\tdropCount++;"], [314, "\t\t\t\t\tqueue.remove(0).recycle();"], [315, "\t\t\t\t}"], [317, "\t\t\t\t// check if this buffer already full"], [318, "\t\t\t\tif (!ready) {"], [319, "\t\t\t\t\tready = !useBuffer || (duration >= jitterBufferSize && queue.size() > 1);"], [320, "\t\t\t\t\tif (ready && listener != null) {"], [321, "\t\t\t\t\t\tlistener.onFill();"], [322, "\t\t\t\t\t}"], [325, "\t\t} finally {"], [326, "\t\t\tLOCK.unlock();"], [337, "\t\ttry {"], [338, "\t\t\tif (queue.size() == 0) {"], [339, "\t\t\t\tthis.ready = false;"], [340, "\t\t\t\treturn null;"], [341, "\t\t\t}"], [342, ""], [343, ""], [344, "\t\t\t//extract packet"], [345, "\t\t\tFrame frame = queue.remove(0);"], [346, ""], [347, "\t\t\t//buffer empty now? - change ready flag."], [348, "\t\t\tif (queue.size() == 0) {"], [349, "\t\t\t\tthis.ready = false;"], [350, "\t\t\t\t//arrivalDeadLine = 0;"], [351, "\t\t\t\t//set it as 1 ms since otherwise will be dropped by pipe"], [352, "\t\t\t\tframe.setDuration(1);"], [353, "\t\t\t}"], [354, ""], [355, ""], [356, "\t\t\tarrivalDeadLine = rtpClock.convertToRtpTime(frame.getTimestamp() + frame.getDuration());"], [357, ""], [358, "\t\t\t//convert duration to nanoseconds"], [359, "\t\t\tframe.setDuration(frame.getDuration() * 1000000L);"], [360, "\t\t\tframe.setTimestamp(frame.getTimestamp() * 1000000L);"], [361, ""], [362, "\t\t\treturn frame;"], [363, "\t\t} finally {"], [364, "\t\t\tLOCK.unlock();"], [365, "\t\t}"], [372, "\t\ttry {"], [373, "\t\t\tLOCK.lock();"], [374, "\t\t\twhile (queue.size() > 0)"], [375, "\t\t\t\tqueue.remove(0).recycle();"], [376, "\t\t} finally {"], [377, "\t\t\tLOCK.unlock();"], [378, "\t\t}"]], "deleted": [[213, "\t\t// checking format"], [214, "\t\tif (format == null) {"], [215, "\t\t\tlogger.warn(\"No format specified. Packet dropped!\");"], [216, "\t\t\treturn;"], [217, "\t\t}"], [219, "\t\tif (this.format == null || this.format.getID() != format.getID()) {"], [220, "\t\t\tthis.format = format;"], [221, "\t\t\tlogger.info(\"Format has been changed: \" + this.format.toString());"], [222, "\t\t}"], [224, "\t\t// if this is first packet then synchronize clock"], [225, "\t\tif (isn == -1) {"], [226, "\t\t\trtpClock.synchronize(packet.getTimestamp());"], [227, "\t\t\tisn = packet.getSeqNumber();"], [228, "\t\t\tinitJitter(packet);"], [229, "\t\t} else {"], [230, "\t\t\testimateJitter(packet);"], [231, "\t\t}"], [233, "\t\t// update clock rate"], [234, "\t\trtpClock.setClockRate(this.format.getClockRate());"], [236, "\t\t// drop outstanding packets"], [237, "\t\t// packet is outstanding if its timestamp of arrived packet is less"], [238, "\t\t// then consumer media time"], [239, "\t\tif (packet.getTimestamp() < this.arrivalDeadLine) {"], [240, "\t\t\tlogger.warn(\"drop packet: dead line=\" + arrivalDeadLine + \", packet time=\" + packet.getTimestamp() + \", seq=\" + packet.getSeqNumber() + \", payload length=\" + packet.getPayloadLength() + \", format=\" + this.format.toString());"], [241, "\t\t\tdropCount++;"], [243, "\t\t\t// checking if not dropping too much"], [244, "\t\t\tdroppedInRaw++;"], [245, "\t\t\tif (droppedInRaw == QUEUE_SIZE / 2 || queue.size() == 0) {"], [246, "\t\t\t\tarrivalDeadLine = 0;"], [247, "\t\t\t} else {"], [248, "\t\t\t\treturn;"], [250, "\t\t}"], [252, "\t\tFrame f = Memory.allocate(packet.getPayloadLength());"], [253, "\t\t// put packet into buffer irrespective of its sequence number"], [254, "\t\tf.setHeader(null);"], [255, "\t\tf.setSequenceNumber(packet.getSeqNumber());"], [256, "\t\t// here time is in milliseconds"], [257, "\t\tf.setTimestamp(rtpClock.convertToAbsoluteTime(packet.getTimestamp()));"], [258, "\t\tf.setOffset(0);"], [259, "\t\tf.setLength(packet.getPayloadLength());"], [260, "\t\tpacket.getPayload(f.getData(), 0);"], [261, ""], [262, "\t\t// set format"], [263, "\t\tf.setFormat(this.format.getFormat());"], [264, ""], [265, "\t\t// make checks only if have packet"], [266, "\t\tif (f != null) {"], [267, "\t\t    LOCK.lock();"], [268, ""], [269, "\t\t    droppedInRaw = 0;"], [270, ""], [271, "\t\t\t// find correct position to insert a packet"], [272, "\t\t\t// use timestamp since its always positive"], [273, "\t\t\tint currIndex = queue.size() - 1;"], [274, "\t\t\twhile (currIndex >= 0 && queue.get(currIndex).getTimestamp() > f.getTimestamp()) {"], [275, "\t\t\t\tcurrIndex--;"], [276, "\t\t\t}"], [278, "\t\t\t// check for duplicate packet"], [279, "\t\t\tif (currIndex >= 0 && queue.get(currIndex).getSequenceNumber() == f.getSequenceNumber()) {"], [280, "\t\t\t    LOCK.unlock();"], [281, "\t\t\t\treturn;"], [282, "\t\t\t}"], [284, "\t\t\tqueue.add(currIndex + 1, f);"], [286, "\t\t\t// recalculate duration of each frame in queue and overall duration"], [287, "\t\t\t// since we could insert the frame in the middle of the queue"], [288, "\t\t\tduration = 0;"], [289, "\t\t\tif (queue.size() > 1) {"], [290, "\t\t\t\tduration = queue.get(queue.size() - 1).getTimestamp() - queue.get(0).getTimestamp();"], [291, "\t\t\t}"], [293, "\t\t\tfor (int i = 0; i < queue.size() - 1; i++) {"], [294, "\t\t\t\t// duration measured by wall clock"], [295, "\t\t\t\tlong d = queue.get(i + 1).getTimestamp() - queue.get(i).getTimestamp();"], [296, "\t\t\t\t// in case of RFC2833 event timestamp remains same"], [297, "\t\t\t\tqueue.get(i).setDuration(d > 0 ? d : 0);"], [298, "\t\t\t}"], [300, "\t\t\t// if overall duration is negative we have some mess here,try to"], [301, "\t\t\t// reset"], [302, "\t\t\tif (duration < 0 && queue.size() > 1) {"], [303, "\t\t\t\tlogger.warn(\"Something messy happened. Reseting jitter buffer!\");"], [304, "\t\t\t\treset();"], [305, "\t\t\t\tLOCK.unlock();"], [306, "\t\t\t\treturn;"], [307, "\t\t\t}"], [309, "\t\t\t// overflow?"], [310, "\t\t\t// only now remove packet if overflow , possibly the same packet we just received"], [311, "\t\t\tif (queue.size() > QUEUE_SIZE) {"], [312, "\t\t\t\tlogger.warn(\"Buffer overflow!\");"], [313, "\t\t\t\tdropCount++;"], [314, "\t\t\t\tqueue.remove(0).recycle();"], [315, "\t\t\t}"], [316, "\t\t\tLOCK.unlock();"], [318, "\t\t\t// check if this buffer already full"], [319, "\t\t\tif (!ready) {"], [320, "\t\t\t\tready = !useBuffer || (duration >= jitterBufferSize && queue.size() > 1);"], [321, "\t\t\t\tif (ready && listener != null) {"], [322, "\t\t\t\t\tlistener.onFill();"], [335, "    \tif (queue.size()==0) {"], [336, "    \t\tthis.ready = false;"], [337, "    \t\treturn null;"], [338, "    \t}"], [339, ""], [340, "    \tLOCK.lock();"], [341, ""], [342, "    \t//extract packet"], [343, "    \tFrame frame = queue.remove(0);"], [344, ""], [345, "    \t//buffer empty now? - change ready flag."], [346, "    \tif (queue.size() == 0) {"], [347, "    \t\tthis.ready = false;"], [348, "    \t\t//arrivalDeadLine = 0;"], [349, "    \t\t//set it as 1 ms since otherwise will be dropped by pipe"], [350, "    \t\tframe.setDuration(1);"], [351, "    \t}"], [352, ""], [353, "    \tLOCK.unlock();"], [354, ""], [355, "    \tarrivalDeadLine = rtpClock.convertToRtpTime(frame.getTimestamp() + frame.getDuration());"], [356, ""], [357, "    \t//convert duration to nanoseconds"], [358, "    \tframe.setDuration(frame.getDuration() * 1000000L);"], [359, "    \tframe.setTimestamp(frame.getTimestamp() * 1000000L);"], [360, ""], [361, "    \treturn frame;"], [368, "    \twhile(queue.size()>0)"], [369, "    \t\tqueue.remove(0).recycle();"]]}, "num_lines_added": 134, "num_lines_removed": 125}