{"hash": "e70ed82620b5bce4b03df9b535ca83d294bc1114", "message": "Move file locking logic to table store to make use of it for all clients", "file_num_lines": 193, "diff_parsed": {"added": [[31, "import net.openhft.chronicle.wire.*;"], [36, "import java.io.IOException;"], [38, "import java.nio.channels.FileChannel;"], [39, "import java.nio.channels.FileLock;"], [40, "import java.nio.channels.OverlappingFileLockException;"], [41, "import java.nio.file.StandardOpenOption;"], [42, "import java.util.function.Function;"], [45, "    private static final long timeoutMS = Long.getLong(\"chronicle.table.store.timeoutMS\", 10_000);"], [56, "    @NotNull"], [64, "    @SuppressWarnings(\"unused\")"], [77, "                this.recovery = wire.read(MetaDataField.recovery).typedMarshallable();"], [90, "     * @param recovery    used to recover from concurrent modifications"], [94, "                            @NotNull StoreRecovery recovery) {"], [112, "    @NotNull"], [115, "        return mappedFile.file();"], [219, "            long pos = recovery.writeHeader(mappedWire, Wires.UNKNOWN_LENGTH, safeLength, timeoutMS, null);"], [232, ""], [233, "    @Override"], [234, "    public <R> R doWithExclusiveLock(Function<TableStore, ? extends R> code) {"], [235, "        final long timeoutAt = System.currentTimeMillis() + 2 * timeoutMS;"], [236, "        boolean warnedOnFailure = false;"], [237, "        try (final FileChannel channel = FileChannel.open(file().toPath(), StandardOpenOption.WRITE)) {"], [238, "            while (System.currentTimeMillis() < timeoutAt) {"], [239, "                try {"], [240, "                    FileLock fileLock = channel.tryLock();"], [241, "                    if (fileLock != null) {"], [242, "                        return code.apply(this);"], [243, "                    }"], [244, "                } catch (IOException | OverlappingFileLockException e) {"], [245, "                    // failed to acquire the lock, wait until other operation completes"], [246, "                    if (!warnedOnFailure) {"], [247, "                        Jvm.warn().on(getClass(), \"Failed to acquire a lock on the table store file. Retrying\", e);"], [248, "                        warnedOnFailure = true;"], [249, "                    }"], [250, "                }"], [251, "                Jvm.pause(50L);"], [252, "            }"], [253, "        } catch (IOException e) {"], [254, "            throw new IllegalStateException(\"Couldn't open table store file for writing\", e);"], [255, "        }"], [256, "        throw new IllegalStateException(\"Unable to claim exclusive lock on file \" + file());"], [257, "    }"]], "deleted": [[18, "import net.openhft.chronicle.bytes.Bytes;"], [31, "import net.openhft.chronicle.queue.impl.single.SingleChronicleQueue;"], [32, "import net.openhft.chronicle.queue.impl.single.SingleChronicleQueueBuilder;"], [34, "import net.openhft.chronicle.wire.Demarshallable;"], [35, "import net.openhft.chronicle.wire.UnrecoverableTimeoutException;"], [36, "import net.openhft.chronicle.wire.ValueIn;"], [37, "import net.openhft.chronicle.wire.Wire;"], [38, "import net.openhft.chronicle.wire.WireIn;"], [39, "import net.openhft.chronicle.wire.WireOut;"], [40, "import net.openhft.chronicle.wire.WireType;"], [41, "import net.openhft.chronicle.wire.Wires;"], [43, "import org.jetbrains.annotations.Nullable;"], [60, "    @Nullable"], [80, "                this.recovery = wire.read(MetaDataField.recovery)"], [81, "                        .typedMarshallable();"], [94, "     * @param recovery"], [98, "                            StoreRecovery recovery) {"], [107, "    public static void dumpStore(@NotNull Wire wire) {"], [108, "        Bytes<?> bytes = wire.bytes();"], [109, "        bytes.readPositionUnlimited(0);"], [110, "        Jvm.debug().on(SingleTableStore.class, Wires.fromSizePrefixedBlobs(wire));"], [111, "    }"], [112, ""], [113, "    @NotNull"], [114, "    public static String dump(@NotNull String directoryFilePath) {"], [115, "        SingleChronicleQueue q = SingleChronicleQueueBuilder.binary(directoryFilePath).build();"], [116, "        return q.dump();"], [117, "    }"], [118, ""], [128, "    @Nullable"], [131, "        return mappedFile == null ? null : mappedFile.file();"], [235, "            long pos = recovery.writeHeader(mappedWire, Wires.UNKNOWN_LENGTH, safeLength, 10_000, null);"]]}, "num_lines_added": 42, "num_lines_removed": 32}