{"hash": "3caf797162ae14e37f3f5ca7d743f50974ef25e8", "message": "Fix bug in direct dependencies validation:\nThe validation should be done only on direct dependency, not recursively. It's a shallow validation", "file_num_lines": 208, "diff_parsed": {"added": [[84, "    @Override"], [85, "    public List<RuntimeException> validateModelWithDirectDependencies(Executable executable, Map<String, Executable> directDependencies) {"], [86, "        List<RuntimeException> errors = new ArrayList<>();"], [87, "        Flow flow = (Flow) executable;"], [88, "        Collection<Step> steps = flow.getWorkflow().getSteps();"], [89, ""], [90, "        for (Step step : steps) {"], [91, "            errors.addAll(validateStepAgainstItsDependency(flow, step, directDependencies));"], [92, "        }"], [93, "        return errors;"], [94, "    }"], [95, ""], [112, "            Executable reference = dependencies.get(step.getRefId());"], [113, "            errors.addAll(validateStepAgainstItsDependency(flow, step, dependencies));"], [123, "    private List<RuntimeException> validateStepAgainstItsDependency(Flow flow, Step step, Map<String, Executable> dependencies) {"], [124, "        List<RuntimeException> errors = new ArrayList<>();"], [125, "        String refId = step.getRefId();"], [126, "        Executable reference = dependencies.get(refId);"], [127, "        if (reference == null) {"], [128, "            throw new RuntimeException(\"Dependency \" + step.getRefId() + \" used by step: \" + step.getName() + \" must be supplied for validation\");"], [129, "        }"], [130, "        errors.addAll(validateMandatoryInputsAreWired(flow, step, reference));"], [131, "        errors.addAll(validateStepInputNamesDifferentFromDependencyOutputNames(flow, step, reference));"], [132, "        errors.addAll(validateDependenciesResultsHaveMatchingNavigations(flow, refId, step, reference));"], [133, "        return errors;"], [134, "    }"], [135, ""], [136, "    private List<RuntimeException> validateDependenciesResultsHaveMatchingNavigations(Flow flow, String refId, Step step, Executable reference) {"], [137, "        List<RuntimeException> errors = new ArrayList<>();"], [138, "        if (!StringUtils.equals(refId, flow.getId())) {"], [141, "                errors.add(new IllegalArgumentException(\"Cannot compile flow: \\'\" + flow.getName() + \"\\' since for step: \\'\" + step.getName()"], [142, "                        + \"\\', the dependency: \\'\" + refId + \"\\' is missing.\"));"], [148, "                        errors.add(new IllegalArgumentException(\"Cannot compile flow: \\'\" + flow.getName() +"], [150, "                                \"\\' of its dependency: \\'\"+ refId + \"\\' has no matching navigation\"));"], [155, "        return errors;"], [158, "    private List<RuntimeException> validateStepInputNamesDifferentFromDependencyOutputNames(Flow flow, Step step, Executable reference) {"], [159, "        List<RuntimeException> errors = new ArrayList<>();"], [166, "        try {"], [167, "            validateListsHaveMutuallyExclusiveNames(stepArguments, outputs, errorMessage);"], [168, "        } catch (RuntimeException e) {"], [169, "            errors.add(e);"], [170, "        }"], [171, "        return errors;"], [208, "    private List<RuntimeException> validateMandatoryInputsAreWired(Flow flow, Step step, Executable reference) {"], [209, "        List<RuntimeException> errors = new ArrayList<>();"], [213, "        if (!CollectionUtils.isEmpty(inputsNotWired)) {"], [214, "            errors.add(new IllegalArgumentException(prepareErrorMessageValidateInputNamesEmpty(inputsNotWired, flow, step, reference)));"], [215, "        }"], [216, "        return errors;"]], "deleted": [[100, "            String refId = step.getRefId();"], [101, "            Executable reference = dependencies.get(refId);"], [102, ""], [103, "            try {"], [104, "                validateMandatoryInputsAreWired(flow, step, reference);"], [105, "                validateStepInputNamesDifferentFromDependencyOutputNames(flow, step, reference);"], [106, "                validateDependenciesResultsHaveMatchingNavigations(executable, refId, step, reference);"], [107, "            } catch (RuntimeException e) {"], [108, "                errors.add(e);"], [109, "            }"], [110, ""], [120, "    private void validateDependenciesResultsHaveMatchingNavigations(Executable executable, String refId, Step step, Executable reference) {"], [121, "        if (!StringUtils.equals(refId, executable.getId())) {"], [124, "                throw new IllegalArgumentException(\"Cannot compile flow: \\'\" + executable.getName() + \"\\' since for step: \\'\" + step.getName()"], [125, "                        + \"\\', the dependency: \\'\" + refId + \"\\' is missing.\");"], [131, "                        throw new IllegalArgumentException(\"Cannot compile flow: \\'\" + executable.getName() +"], [133, "                                \"\\' of its dependency: \\'\"+ refId + \"\\' has no matching navigation\");"], [140, "    private void validateStepInputNamesDifferentFromDependencyOutputNames(Flow flow, Step step, Executable reference) {"], [147, "        validateListsHaveMutuallyExclusiveNames(stepArguments, outputs, errorMessage);"], [184, "    private void validateMandatoryInputsAreWired(Flow flow, Step step, Executable reference) {"], [188, "        Validate.isTrue("], [189, "                CollectionUtils.isEmpty(inputsNotWired),"], [190, "                prepareErrorMessageValidateInputNamesEmpty(inputsNotWired, flow, step, reference)"], [191, "        );"]]}, "num_lines_added": 49, "num_lines_removed": 24}