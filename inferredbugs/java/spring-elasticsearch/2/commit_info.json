{"hash": "ed7c698e0072fca1af6991ad01830a8c8c7fb42a", "message": "Wait only for known indices when starting a client\n\nFor now, we wait for `yellow` status whichever  indices exist.\n\nWe should only wait for known indices.\n\nCloses #86.", "file_num_lines": 272, "diff_parsed": {"added": [[26, "import org.elasticsearch.action.admin.cluster.health.ClusterHealthRequestBuilder;"], [27, "import org.elasticsearch.action.admin.cluster.health.ClusterHealthResponse;"], [28, "import org.elasticsearch.action.admin.cluster.health.ClusterHealthStatus;"], [29, "import org.elasticsearch.action.admin.cluster.health.ClusterIndexHealth;"], [30, "import org.elasticsearch.action.admin.cluster.state.ClusterStateRequestBuilder;"], [31, "import org.elasticsearch.action.admin.cluster.state.ClusterStateResponse;"], [343, ""], [344, "\t\t// We extract indexes and mappings to manage from mappings definition"], [345, "\t\tif (mappings != null && mappings.length > 0) {"], [346, "            ClusterHealthRequestBuilder healthRequestBuilder = client.admin().cluster().prepareHealth().setWaitForYellowStatus();"], [347, "            ClusterStateRequestBuilder clusterStateRequestBuilder = client.admin().cluster().prepareState();"], [348, "            Map<String, Collection<String>> indices = getIndexMappings(mappings);"], [349, "            for (String index : indices.keySet()) {"], [350, "                clusterStateRequestBuilder.setIndices(index);"], [351, "            }"], [352, "            ClusterStateResponse clusterStateResponse = clusterStateRequestBuilder.get();"], [353, ""], [354, "            boolean checkIndicesStatus = false;"], [355, "            for (String index : indices.keySet()) {"], [356, "                if (clusterStateResponse.getState().getMetaData().indices().containsKey(index)) {"], [357, "                    healthRequestBuilder.setIndices(index);"], [358, "                    checkIndicesStatus = true;"], [359, "                }"], [360, "            }"], [361, ""], [362, "            if (checkIndicesStatus) {"], [363, "                logger.debug(\"we have to check some indices status as they already exist...\");"], [364, "                ClusterHealthResponse healths = healthRequestBuilder.get();"], [365, "                if (healths.isTimedOut()) {"], [366, "                    logger.warn(\"we got a timeout when checking indices status...\");"], [367, "                    if (healths.getIndices() != null) {"], [368, "                        for (ClusterIndexHealth health : healths.getIndices().values()) {"], [369, "                            if (health.getStatus() == ClusterHealthStatus.RED) {"], [370, "                                logger.warn(\"index [{}] is in RED state\", health.getIndex());"], [371, "                            } else {"], [372, "                                logger.debug(\"index [{}] is in [{}] state\", health.getIndex(), health.getStatus().name());"], [373, "                            }"], [374, "                        }"], [375, "                    }"], [376, "                }"], [377, "            }"], [378, "        }"], [379, ""], [380, "\t\tinitTemplates();"], [504, "            Map<String, Collection<String>> indices = getIndexMappings(mappings);"], [507, "\t\t\tfor (String index : indices.keySet()) {"], [513, "\t\t\t\tCollection<String> mappings = indices.get(index);"], [523, "    private static Map<String, Collection<String>> getIndexMappings(String[] mappings) throws Exception {"], [524, "        Map<String, Collection<String>> indices = new HashMap<>();"], [525, ""], [526, "        for (int i = 0; i < mappings.length; i++) {"], [527, "            String indexmapping = mappings[i];"], [528, "            String[] indexmappingsplitted = indexmapping.split(\"/\");"], [529, "            String index = indexmappingsplitted[0];"], [530, ""], [531, "            if (index == null) throw new Exception(\"Can not read index in [\" + indexmapping +"], [532, "            \"]. Check that mappings contains only indexname/mappingname elements.\");"], [533, ""], [534, "            // We add the mapping in the collection of its index"], [535, "            if (!indices.containsKey(index)) {"], [536, "                indices.put(index, new ArrayList<String>());"], [537, "            }"], [538, ""], [539, "            if (indexmappingsplitted.length > 1) {"], [540, "                indices.get(index).add(indexmappingsplitted[1]);"], [541, "            }"], [542, "        }"], [543, "        return indices;"], [544, "    }"], [545, ""], [546, "    /**"]], "deleted": [[333, "\t\t// TODO Only wait for potential indices"], [334, "\t\tclient.admin().cluster().prepareHealth().setWaitForYellowStatus().get();"], [339, "\t\tinitTemplates();"], [463, "\t\t\tMap<String, Collection<String>> indexes = new HashMap<>();"], [464, ""], [465, "\t\t\tfor (int i = 0; i < mappings.length; i++) {"], [466, "\t\t\t\tString indexmapping = mappings[i];"], [467, "\t\t\t\tString[] indexmappingsplitted = indexmapping.split(\"/\");"], [468, "\t\t\t\tString index = indexmappingsplitted[0];"], [469, ""], [470, "                if (index == null) throw new Exception(\"Can not read index in [\" + indexmapping +"], [471, "                        \"]. Check that mappings contains only indexname/mappingname elements.\");"], [472, ""], [473, "                // We add the mapping in the collection of its index"], [474, "                if (!indexes.containsKey(index)) {"], [475, "                    indexes.put(index, new ArrayList<String>());"], [476, "                }"], [477, ""], [478, "                if (indexmappingsplitted.length > 1) {"], [479, "                    String mapping = indexmappingsplitted[1];"], [480, "                    indexes.get(index).add(mapping);"], [481, "                }"], [482, "\t\t\t}"], [485, "\t\t\tfor (String index : indexes.keySet()) {"], [491, "\t\t\t\tCollection<String> mappings = indexes.get(index);"], [501, "\t/**"]]}, "num_lines_added": 71, "num_lines_removed": 26}