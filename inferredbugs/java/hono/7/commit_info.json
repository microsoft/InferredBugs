{"hash": "4ff8c6b4a493b0fe3e5db0108dba66bec4f9f056", "message": "Improve readability of code.\n\nSigned-off-by: Kai Hudalla <kai.hudalla@bosch-si.com>", "file_num_lines": 298, "diff_parsed": {"added": [[2, " * Copyright (c) 2017, 2018 Bosch Software Innovations GmbH."], [15, "import static org.mockito.Mockito.*;"], [25, "import org.junit.AfterClass;"], [27, "import org.junit.BeforeClass;"], [28, "import org.junit.Rule;"], [30, "import org.junit.rules.Timeout;"], [51, "     * Global timeout for each test case."], [52, "     */"], [53, "    @Rule"], [54, "    public Timeout timeout = Timeout.seconds(5);"], [55, ""], [56, "    private static Vertx vertx;"], [57, ""], [58, "    private ProtonConnection con;"], [59, "    private DisconnectHandlerProvidingConnectionFactory connectionFactory;"], [60, ""], [61, "    /**"], [62, "     * Sets up vertx."], [63, "     */"], [64, "    @BeforeClass"], [65, "    public static void setUpVertx() {"], [66, "        vertx = Vertx.vertx();"], [67, "    }"], [68, ""], [69, "    /**"], [70, "     * Sets up fixture."], [74, "        con = mock(ProtonConnection.class);"], [75, "        when(con.getRemoteContainer()).thenReturn(\"server\");"], [76, "        connectionFactory = new DisconnectHandlerProvidingConnectionFactory(con);"], [84, "    @AfterClass"], [85, "    public static void shutdown(final TestContext ctx) {"], [100, "        final Async connected = ctx.async();"], [101, "        final HonoClientImpl client = new HonoClientImpl(vertx, connectionFactory);"], [102, "        client.connect(new ProtonClientOptions(), ctx.asyncAssertSuccess(ok -> connected.complete()));"], [103, "        connected.await();"], [105, "        client.getOrCreateRequestResponseClient("], [106, "                \"registration/tenant\","], [107, "                () -> Future.future(),"], [108, "                result -> {});"], [110, "        // WHEN an additional, concurrent attempt is made to create a client for \"tenant\""], [111, "        client.getOrCreateRequestResponseClient("], [112, "                \"registration/tenant\","], [113, "                () -> {"], [114, "                    ctx.fail(\"should not create concurrent client\");"], [115, "                    return Future.succeededFuture(mock(RegistrationClient.class));"], [116, "                },"], [117, "                ctx.asyncAssertFailure(t -> {"], [118, "                    // THEN the concurrent attempt fails without any attempt being made to create another client"], [119, "                    ctx.assertTrue(ServerErrorException.class.isInstance(t));"], [120, "                }));"], [134, "        final HonoClientImpl client = new HonoClientImpl(vertx, connectionFactory);"], [136, "        connected.await();"], [138, "        final Async creationFailure = ctx.async();"], [139, "        client.getOrCreateRequestResponseClient("], [140, "                \"registration/tenant\","], [141, "                () -> {"], [142, "                    ctx.assertFalse(creationFailure.isCompleted());"], [143, "                    return Future.future();"], [144, "                },"], [145, "                ctx.asyncAssertFailure(cause -> creationFailure.complete()));"], [151, "        creationFailure.await();"], [163, "        final Async connected = ctx.async();"], [164, "        final HonoClientImpl client = new HonoClientImpl(vertx, connectionFactory);"], [165, "        client.connect(new ProtonClientOptions(), ctx.asyncAssertSuccess(ok -> connected.complete()));"], [166, "        connected.await();"], [168, "        client.getOrCreateSender(\"telemetry/tenant\", () -> Future.future(), result -> {});"], [170, "        // WHEN an additional, concurrent attempt is made to create a telemetry sender for \"tenant\""], [171, "        client.getOrCreateSender("], [172, "                \"telemetry/tenant\","], [173, "                () -> {"], [174, "                    ctx.fail(\"should not create concurrent client\");"], [175, "                    return Future.succeededFuture(mock(MessageSender.class));"], [176, "                },"], [177, "                ctx.asyncAssertFailure(t -> {"], [178, "                    // THEN the concurrent attempt fails without any attempt being made to create another sender"], [179, "                    ctx.assertTrue(ServerErrorException.class.isInstance(t));"], [180, "                }));"], [194, "        final HonoClientImpl client = new HonoClientImpl(vertx, connectionFactory);"], [196, "        connected.await();"], [198, "        final Async disconnected = ctx.async();"], [199, "        client.getOrCreateSender("], [200, "                \"telemetry/tenant\","], [201, "                () -> Future.future(),"], [202, "                ctx.asyncAssertFailure(cause -> {"], [203, "                    disconnected.complete();"], [204, "                }));"], [210, "        disconnected.await();"], [224, "        final HonoClientImpl client = new HonoClientImpl(vertx, connectionFactory);"], [226, "        connected.await();"], [228, "        final Async disconnected = ctx.async();"], [237, "        disconnected.await();"], [251, "        final HonoClientImpl client = new HonoClientImpl(vertx, connectionFactory);"], [253, "        connected.await();"], [264, "        disconnected.await();"], [278, "        connectionFactory = new DisconnectHandlerProvidingConnectionFactory(con, 2);"], [282, "        final HonoClientImpl client = new HonoClientImpl(vertx, connectionFactory);"], [284, "        connected.await();"], [288, "        client.getOrCreateSender(\"telemetry/tenant\", () -> {"], [289, "            connectionFactory.getDisconnectHandler().handle(con);"], [290, "            return Future.future();"], [294, "        senderCreationFailure.await();"], [298, "        client.getOrCreateSender("], [299, "                \"telemetry/tenant\","], [300, "                () -> Future.succeededFuture(mock(MessageSender.class)),"], [301, "                ctx.asyncAssertSuccess());"], [315, "        connectionFactory = new DisconnectHandlerProvidingConnectionFactory(con, 2);"], [319, "        final HonoClientImpl client = new HonoClientImpl(vertx, connectionFactory);"], [321, "        connected.await();"], [324, "        connectionFactory.getDisconnectHandler().handle(con);"], [326, "        // THEN the adapter reconnects to the downstream container"], [340, "        connectionFactory = new DisconnectHandlerProvidingConnectionFactory(con, 1, 2);"], [341, "        final HonoClientImpl client = new HonoClientImpl(vertx, connectionFactory);"], [349, "                failedCon -> disconnectHandlerInvocation.complete());"], [355, "        disconnectHandlerInvocation.await();"], [359, "     * Verifies that the client tries to re-connect to a server instance if the"], [360, "     * connection is closed by the peer."], [369, "        final Async connected = ctx.async();"], [370, "        final Async disconnectHandlerInvocation = ctx.async();"], [371, "        final HonoClientImpl client = new HonoClientImpl(vertx, connectionFactory);"], [372, "        client.connect("], [373, "                new ProtonClientOptions().setReconnectAttempts(1),"], [374, "                ctx.asyncAssertSuccess(ok -> connected.complete()),"], [375, "                failedCon -> disconnectHandlerInvocation.complete());"], [376, "        connected.await();"], [382, "        disconnectHandlerInvocation.await();"], [383, "        // and the original connection has been closed locally"], [384, "        verify(con).close();"], [385, "        verify(con).disconnectHandler(null);"], [398, "        final HonoClientImpl client = new HonoClientImpl(vertx, connectionFactory);"], [402, "        client.connect("], [403, "                new ProtonClientOptions(),"], [404, "                ctx.asyncAssertFailure(cause -> {"], [405, "                    //THEN connect fails"], [406, "                }));"], [419, "        connectionFactory = new DisconnectHandlerProvidingConnectionFactory(con, 1, Integer.MAX_VALUE);"], [420, "        final HonoClientImpl client = new HonoClientImpl(vertx, connectionFactory);"], [421, "        final Async connectionHandlerInvocation = ctx.async();"], [422, "        client.connect("], [423, "                new ProtonClientOptions().setReconnectAttempts(1),"], [424, "                ctx.asyncAssertFailure(cause -> connectionHandlerInvocation.complete()));"], [430, "        connectionHandlerInvocation.await();"], [433, "    private static class DisconnectHandlerProvidingConnectionFactory implements ConnectionFactory {"]], "deleted": [[2, " * Copyright (c) 2017 Bosch Software Innovations GmbH."], [15, "import static org.mockito.Mockito.mock;"], [16, "import static org.mockito.Mockito.when;"], [21, "import org.eclipse.hono.client.HonoClient;"], [24, "import org.eclipse.hono.client.RequestResponseClient;"], [28, "import org.junit.After;"], [49, "    Vertx vertx;"], [52, "     * Sets up common test bed."], [56, "        vertx = Vertx.vertx();"], [64, "    @After"], [65, "    public void shutdown(final TestContext ctx) {"], [80, "        ConnectionFactory connectionFactory = mock(ConnectionFactory.class);"], [81, "        HonoClientImpl client = new HonoClientImpl(vertx, connectionFactory);"], [82, "        final Future<RequestResponseClient> firstClientTracker = Future.future();"], [83, "        client.getOrCreateRequestResponseClient(\"registration/tenant\", handler -> {"], [84, "            firstClientTracker.setHandler(creationAttempt -> {"], [85, "                handler.handle(creationAttempt);"], [86, "            });"], [87, "        }, result -> {});"], [88, ""], [89, "        // WHEN an additional, concurrent attempt is made to create a client for \"tenant\""], [90, "        final Async creationFailure = ctx.async();"], [91, "        client.getOrCreateRequestResponseClient(\"registration/tenant\", handler -> {"], [92, "            handler.handle(Future.succeededFuture(mock(RegistrationClient.class)));"], [93, "        }, ctx.asyncAssertFailure(t -> {"], [94, "            ctx.assertTrue(ServerErrorException.class.isInstance(t));"], [95, "            creationFailure.complete();"], [96, "        }));"], [98, "        // succeed first creation attempt, thus invoking result handler"], [99, "        firstClientTracker.complete(mock(RegistrationClient.class));"], [101, "        // THEN the concurrent attempt fails immediately without any attempt being made to create another client"], [102, "        creationFailure.await(2000);"], [115, "        ProtonConnection con = mock(ProtonConnection.class);"], [116, "        DisconnectHandlerProvidingConnectionFactory connectionFactory = new DisconnectHandlerProvidingConnectionFactory(con);"], [118, "        final Async disconnected = ctx.async();"], [119, "        HonoClientImpl client = new HonoClientImpl(vertx, connectionFactory);"], [121, "        connected.await(200);"], [123, "        client.getOrCreateRequestResponseClient(\"registration/tenant\", creationResultHandler -> {"], [124, "            ctx.assertFalse(disconnected.isCompleted());"], [125, "        }, ctx.asyncAssertFailure(cause -> {"], [126, "            disconnected.complete();"], [127, "        }));"], [133, "        disconnected.await(200);"], [145, "        ConnectionFactory connectionFactory = mock(ConnectionFactory.class);"], [146, "        HonoClientImpl client = new HonoClientImpl(vertx, connectionFactory);"], [147, "        final Future<MessageSender> firstSenderTracker = Future.future();"], [148, "        client.getOrCreateSender(\"telemetry/tenant\", handler -> {"], [149, "            firstSenderTracker.setHandler(creationAttempt -> {"], [150, "                handler.handle(creationAttempt);"], [151, "            });"], [152, "        }, result -> {});"], [153, ""], [154, "        // WHEN an additional, concurrent attempt is made to create a telemetry sender for \"tenant\""], [155, "        final Async creationFailure = ctx.async();"], [156, "        client.getOrCreateSender(\"telemetry/tenant\", handler -> {"], [157, "            handler.handle(Future.succeededFuture(mock(MessageSender.class)));"], [158, "        }, ctx.asyncAssertFailure(t -> {"], [159, "            ctx.assertTrue(ServerErrorException.class.isInstance(t));"], [160, "            creationFailure.complete();"], [161, "        }));"], [163, "        // succeed first creation attempt, thus invoking result handler"], [164, "        firstSenderTracker.complete(mock(MessageSender.class));"], [166, "        // THEN the concurrent attempt fails immediately without any attempt being made to create another sender"], [167, "        creationFailure.await(2000);"], [180, "        ProtonConnection con = mock(ProtonConnection.class);"], [181, "        DisconnectHandlerProvidingConnectionFactory connectionFactory = new DisconnectHandlerProvidingConnectionFactory(con);"], [183, "        final Async disconnected = ctx.async();"], [184, "        HonoClientImpl client = new HonoClientImpl(vertx, connectionFactory);"], [186, "        connected.await(200);"], [188, "        client.getOrCreateSender(\"telemetry/tenant\", creationResultHandler -> {"], [189, "            ctx.assertFalse(disconnected.isCompleted());"], [190, "        }, ctx.asyncAssertFailure(cause -> {"], [191, "            disconnected.complete();"], [192, "        }));"], [198, "        disconnected.await(200);"], [211, "        ProtonConnection con = mock(ProtonConnection.class);"], [212, "        DisconnectHandlerProvidingConnectionFactory connectionFactory = new DisconnectHandlerProvidingConnectionFactory(con);"], [214, "        final Async disconnected = ctx.async();"], [215, "        HonoClientImpl client = new HonoClientImpl(vertx, connectionFactory);"], [217, "        connected.await(200);"], [227, "        disconnected.await(200);"], [240, "        ProtonConnection con = mock(ProtonConnection.class);"], [241, "        DisconnectHandlerProvidingConnectionFactory connectionFactory = new DisconnectHandlerProvidingConnectionFactory(con);"], [243, "        HonoClientImpl client = new HonoClientImpl(vertx, connectionFactory);"], [245, "        connected.await(200);"], [256, "        disconnected.await(200);"], [267, "        final ProtonConnection connectionToCreate = mock(ProtonConnection.class);"], [268, "        when(connectionToCreate.getRemoteContainer()).thenReturn(\"server\");"], [272, "        DisconnectHandlerProvidingConnectionFactory connectionFactory = new DisconnectHandlerProvidingConnectionFactory(connectionToCreate, 2);"], [276, "        HonoClientImpl client = new HonoClientImpl(vertx, connectionFactory);"], [278, "        connected.await(200);"], [282, "        client.getOrCreateSender(\"telemetry/tenant\", creationAttemptHandler -> {"], [283, "            connectionFactory.getDisconnectHandler().handle(connectionToCreate);"], [284, "            // the creationAttempHandler will not be invoked at all"], [288, "        senderCreationFailure.await(1000);"], [292, "        final Async senderSupplierInvocation = ctx.async();"], [293, "        client.getOrCreateSender(\"telemetry/tenant\", creationAttemptHandler -> {"], [294, "            senderSupplierInvocation.complete();"], [295, "            creationAttemptHandler.handle(Future.succeededFuture(mock(MessageSender.class)));"], [296, "        }, ctx.asyncAssertSuccess());"], [297, "        senderSupplierInvocation.await(1000);"], [308, "        final ProtonConnection connectionToCreate = mock(ProtonConnection.class);"], [309, "        when(connectionToCreate.getRemoteContainer()).thenReturn(\"server\");"], [313, "        DisconnectHandlerProvidingConnectionFactory connectionFactory = new DisconnectHandlerProvidingConnectionFactory(connectionToCreate, 2);"], [317, "        HonoClientImpl client = new HonoClientImpl(vertx, connectionFactory);"], [319, "        connected.await(200);"], [322, "        connectionFactory.getDisconnectHandler().handle(connectionToCreate);"], [324, "        // THEN the adapter tries to reconnect to the downstream container"], [337, "        ProtonConnection con = mock(ProtonConnection.class);"], [339, "        DisconnectHandlerProvidingConnectionFactory connectionFactory = new DisconnectHandlerProvidingConnectionFactory(con, 1, 2);"], [340, "        HonoClientImpl client = new HonoClientImpl(vertx, connectionFactory);"], [345, "        Handler<ProtonConnection> disconnectHandler = failedCon -> disconnectHandlerInvocation.complete();"], [349, "                disconnectHandler);"], [355, "        disconnectHandlerInvocation.await(1000);"], [359, "     * Verifies that the client tries to re-connect to a server instance if the connection is closed by the peer."], [368, "        ProtonConnection con = mock(ProtonConnection.class);"], [369, "        DisconnectHandlerProvidingConnectionFactory connectionFactory = new DisconnectHandlerProvidingConnectionFactory(con, 2);"], [370, "        HonoClientImpl client = new HonoClientImpl(vertx, connectionFactory);"], [371, "        Async disconnectHandlerInvocation = ctx.async();"], [372, "        Handler<ProtonConnection> disconnectHandler = failedCon -> disconnectHandlerInvocation.complete();"], [373, "        client.connect(new ProtonClientOptions().setReconnectAttempts(1), attempt -> {}, disconnectHandler);"], [379, "        disconnectHandlerInvocation.await(500);"], [392, "        ConnectionFactory connectionFactory = mock(ConnectionFactory.class);"], [393, "        HonoClientImpl client = new HonoClientImpl(vertx, connectionFactory);"], [397, "        Async connectionHandlerInvocation = ctx.async();"], [398, "        Handler<AsyncResult<HonoClient>> connectionHandler = result -> {"], [399, "            if (result.failed()) {"], [400, "                connectionHandlerInvocation.complete();"], [401, "            }"], [402, "        };"], [403, "        client.connect(new ProtonClientOptions(), connectionHandler );"], [404, ""], [405, "        //THEN connect fails"], [406, "        connectionHandlerInvocation.await(500);"], [419, "        ProtonConnection con = mock(ProtonConnection.class);"], [420, "        DisconnectHandlerProvidingConnectionFactory connectionFactory = new DisconnectHandlerProvidingConnectionFactory(con, 1, Integer.MAX_VALUE);"], [421, "        HonoClientImpl client = new HonoClientImpl(vertx, connectionFactory);"], [422, "        Async connectionHandlerInvocation = ctx.async();"], [423, "        Handler<AsyncResult<HonoClient>> connectionHandler = result -> {"], [424, "            if (result.failed()) {"], [425, "                connectionHandlerInvocation.complete();"], [426, "            }"], [427, "        };"], [428, "        client.connect(new ProtonClientOptions().setReconnectAttempts(1), connectionHandler);"], [434, "        connectionHandlerInvocation.await(1000);"], [437, "    private class DisconnectHandlerProvidingConnectionFactory implements ConnectionFactory {"]]}, "num_lines_added": 142, "num_lines_removed": 146}