{"hash": "c83936270ff569aff5398f68a910eb7e76060573", "message": "Changes related to FT 1.1.3:\n\n(1) Support for flag to disable FT metrics\n(2) Fixes related to global and retry counters\n(3) Fixed counter for circuit breaker calls prevented\n\nSigned-off-by: Santiago Pericas-Geertsen <Santiago.PericasGeertsen@oracle.com>", "file_num_lines": 275, "diff_parsed": {"added": [[35, "import static io.helidon.microprofile.faulttolerance.FaultToleranceExtension.isFaultToleranceMetricsEnabled;"], [142, "            if (isFaultToleranceMetricsEnabled()) {"], [143, "                FaultToleranceMetrics.registerGauge(introspector.getMethod(),"], [144, "                        FaultToleranceMetrics.BREAKER_OPEN_TOTAL,"], [145, "                        \"Amount of time the circuit breaker has spent in open state\","], [146, "                        () -> breakerHelper.getInStateNanos(CircuitBreakerHelper.State.OPEN_MP));"], [147, "                FaultToleranceMetrics.registerGauge(introspector.getMethod(),"], [148, "                        FaultToleranceMetrics.BREAKER_HALF_OPEN_TOTAL,"], [149, "                        \"Amount of time the circuit breaker has spent in half-open state\","], [150, "                        () -> breakerHelper.getInStateNanos(CircuitBreakerHelper.State.HALF_OPEN_MP));"], [151, "                FaultToleranceMetrics.registerGauge(introspector.getMethod(),"], [152, "                        FaultToleranceMetrics.BREAKER_CLOSED_TOTAL,"], [153, "                        \"Amount of time the circuit breaker has spent in closed state\","], [154, "                        () -> breakerHelper.getInStateNanos(CircuitBreakerHelper.State.CLOSED_MP));"], [155, "            }"], [165, "            if (isFaultToleranceMetricsEnabled()) {"], [166, "                // Register gauges for this method"], [168, "                        FaultToleranceMetrics.BULKHEAD_CONCURRENT_EXECUTIONS,"], [169, "                        \"Number of currently running executions\","], [170, "                        () -> bulkheadHelper.runningInvocations());"], [171, "                if (introspector.isAsynchronous()) {"], [172, "                    FaultToleranceMetrics.registerGauge(introspector.getMethod(),"], [173, "                            FaultToleranceMetrics.BULKHEAD_WAITING_QUEUE_POPULATION,"], [174, "                            \"Number of executions currently waiting in the queue\","], [175, "                            () -> bulkheadHelper.waitingInvocations());"], [176, "                }"], [205, "            if (isFaultToleranceMetricsEnabled()) {"], [206, "                // Update waiting time histogram"], [207, "                if (introspector.isAsynchronous() && queuedNanos != -1L) {"], [208, "                    FaultToleranceMetrics.getHistogram(introspector.getMethod(),"], [209, "                            FaultToleranceMetrics.BULKHEAD_WAITING_DURATION)"], [210, "                            .update(System.nanoTime() - queuedNanos);"], [211, "                }"], [285, "                    updateMetricsAfter(throwable, wasBreakerOpen, isClosedNow, breakerWillOpen);"], [313, "                    updateMetricsAfter(throwable, wasBreakerOpen, isClosedNow, breakerWillOpen);"], [332, "            updateMetricsAfter(throwable, wasBreakerOpen, isClosedNow, breakerWillOpen);"], [353, "    private void updateMetricsAfter(Throwable throwable, boolean wasBreakerOpen, boolean isClosedNow,"], [354, "                                    boolean breakerWillOpen) {"], [355, "        if (!isFaultToleranceMetricsEnabled()) {"], [356, "            return;"], [357, "        }"], [358, ""], [373, "        // If breaker was open and still is, increment prevented counter"], [374, "        if (wasBreakerOpen && !isClosedNow) {"]], "deleted": [[141, "            FaultToleranceMetrics.registerGauge(introspector.getMethod(),"], [142, "                                                FaultToleranceMetrics.BREAKER_OPEN_TOTAL,"], [143, "                                                \"Amount of time the circuit breaker has spent in open state\","], [144, "                                                () -> breakerHelper.getInStateNanos(CircuitBreakerHelper.State.OPEN_MP));"], [145, "            FaultToleranceMetrics.registerGauge(introspector.getMethod(),"], [146, "                                                FaultToleranceMetrics.BREAKER_HALF_OPEN_TOTAL,"], [147, "                                                \"Amount of time the circuit breaker has spent in half-open state\","], [148, "                                                () -> breakerHelper.getInStateNanos(CircuitBreakerHelper.State.HALF_OPEN_MP));"], [149, "            FaultToleranceMetrics.registerGauge(introspector.getMethod(),"], [150, "                                                FaultToleranceMetrics.BREAKER_CLOSED_TOTAL,"], [151, "                                                \"Amount of time the circuit breaker has spent in closed state\","], [152, "                                                () -> breakerHelper.getInStateNanos(CircuitBreakerHelper.State.CLOSED_MP));"], [162, "            // Register gauges for this method"], [163, "            FaultToleranceMetrics.registerGauge(introspector.getMethod(),"], [164, "                                                FaultToleranceMetrics.BULKHEAD_CONCURRENT_EXECUTIONS,"], [165, "                                                \"Number of currently running executions\","], [166, "                                                () -> bulkheadHelper.runningInvocations());"], [167, "            if (introspector.isAsynchronous()) {"], [169, "                                                    FaultToleranceMetrics.BULKHEAD_WAITING_QUEUE_POPULATION,"], [170, "                                                    \"Number of executions currently waiting in the queue\","], [171, "                                                    () -> bulkheadHelper.waitingInvocations());"], [200, "            // Update waiting time histogram"], [201, "            if (introspector.isAsynchronous() && queuedNanos != -1L) {"], [202, "                FaultToleranceMetrics.getHistogram(introspector.getMethod(),"], [203, "                                                   FaultToleranceMetrics.BULKHEAD_WAITING_DURATION)"], [204, "                                     .update(System.nanoTime() - queuedNanos);"], [278, "                    updateMetricsAfter(throwable, wasBreakerOpen, breakerWillOpen);"], [306, "                    updateMetricsAfter(throwable, wasBreakerOpen, breakerWillOpen);"], [325, "            updateMetricsAfter(throwable, wasBreakerOpen, breakerWillOpen);"], [346, "    private void updateMetricsAfter(Throwable throwable, boolean wasBreakerOpen, boolean breakerWillOpen) {"], [361, "        if (wasBreakerOpen) {"], [362, "            // If breaker was open, increment prevented counter"]]}, "num_lines_added": 44, "num_lines_removed": 32}