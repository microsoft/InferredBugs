{"hash": "975aaf2879ea3e3590bc91e7a744f777f15722c8", "message": "Upgrading to Hystrix 1.5.18. New strategy to support circuit breaker state transitions as defined by the FT spec. Most of the Hystrix circuit breaker support is turned off and state transitions are implemented manually using Hystrix dynamic properties. The old strategy was difficult to extend with the new version of Hystrix and the new implementation is simpler to understand.\n\nSigned-off-by: Santiago Pericas-Geertsen <Santiago.PericasGeertsen@oracle.com>", "file_num_lines": 267, "diff_parsed": {"added": [[2, " * Copyright (c) 2018, 2019 Oracle and/or its affiliates. All rights reserved."], [36, ""], [37, "import static io.helidon.microprofile.faulttolerance.CircuitBreakerHelper.State;"], [61, "    static final String HELIDON_MICROPROFILE_FAULTTOLERANCE = \"io.helidon.microprofile.faulttolerance\";"], [98, "                .andCommandKey("], [100, "                .andCommandPropertiesDefaults("], [102, "                                .withFallbackEnabled(false)"], [103, "                                .withExecutionIsolationStrategy(THREAD))"], [104, "                .andThreadPoolKey("], [106, "                                ? HystrixThreadPoolKey.Factory.asKey(commandKey)"], [107, "                                : null)"], [108, "                .andThreadPoolPropertiesDefaults("], [110, "                                .withCoreSize("], [111, "                                        introspector.hasBulkhead()"], [112, "                                                ? introspector.getBulkhead().value()"], [113, "                                                : MAX_THREAD_POOL_SIZE)"], [114, "                                .withMaximumSize("], [115, "                                        introspector.hasBulkhead()"], [116, "                                                ? introspector.getBulkhead().value()"], [117, "                                                : MAX_THREAD_POOL_SIZE)"], [118, "                                .withMaxQueueSize("], [119, "                                        introspector.hasBulkhead() && introspector.isAsynchronous()"], [120, "                                                ? introspector.getBulkhead().waitingTaskQueue()"], [121, "                                                : MAX_THREAD_POOL_QUEUE_SIZE)"], [122, "                                .withQueueSizeRejectionThreshold("], [123, "                                        introspector.hasBulkhead() && introspector.isAsynchronous()"], [124, "                                                ? introspector.getBulkhead().waitingTaskQueue()"], [125, "                                                : MAX_THREAD_POOL_QUEUE_SIZE)));"], [139, "                        () -> breakerHelper.getInStateNanos(State.OPEN_MP));"], [143, "                        () -> breakerHelper.getInStateNanos(State.HALF_OPEN_MP));"], [147, "                        () -> breakerHelper.getInStateNanos(State.CLOSED_MP));"], [234, "        boolean lockRemoved = false;"], [235, ""], [236, "        try {"], [237, "            // Configure command before execution"], [238, "            introspector.getHystrixProperties()"], [242, "            // Get lock and check breaker delay"], [243, "            if (introspector.hasCircuitBreaker()) {"], [244, "                breakerHelper.lock();       // acquire exclusive access to command data"], [246, "                // OPEN_MP -> HALF_OPEN_MP"], [247, "                if (breakerHelper.getState() == State.OPEN_MP) {"], [248, "                    long delayNanos = TimeUtil.convertToNanos(introspector.getCircuitBreaker().delay(),"], [249, "                            introspector.getCircuitBreaker().delayUnit());"], [250, "                    if (breakerHelper.getCurrentStateNanos() > delayNanos) {"], [251, "                        breakerHelper.setState(State.HALF_OPEN_MP);"], [252, "                    }"], [253, "                }"], [254, "                logCircuitBreakerState(\"Enter\");"], [255, "            }"], [257, "            // Record state of breaker"], [258, "            boolean wasBreakerOpen = isCircuitBreakerOpen();"], [260, "            // Track invocation in a bulkhead"], [261, "            if (introspector.hasBulkhead()) {"], [262, "                bulkheadHelper.trackInvocation(this);"], [263, "            }"], [265, "            // Execute command"], [266, "            Object result = null;"], [267, "            Throwable throwable = null;"], [268, "            long startNanos = System.nanoTime();"], [269, "            try {"], [270, "                result = super.execute();"], [271, "            } catch (Throwable t) {"], [272, "                throwable = t;"], [273, "            }"], [275, "            executionTime = System.nanoTime() - startNanos;"], [276, "            boolean hasFailed = (throwable != null);"], [277, ""], [278, "            if (introspector.hasCircuitBreaker()) {"], [279, "                // Keep track of failure ratios"], [280, "                breakerHelper.pushResult(throwable == null);"], [281, ""], [282, "                // Query breaker states"], [283, "                boolean breakerOpening = false;"], [284, "                boolean isClosedNow = !wasBreakerOpen;"], [285, ""], [286, "                /*"], [287, "                 * Special logic for MP circuit breakers to support failOn. If not a"], [288, "                 * throwable to fail on, restore underlying breaker and return."], [289, "                 */"], [290, "                if (hasFailed) {"], [291, "                    final Throwable throwableFinal = throwable;"], [292, "                    Class<? extends Throwable>[] throwableClasses = introspector.getCircuitBreaker().failOn();"], [293, "                    boolean failOn = Arrays.asList(throwableClasses)"], [294, "                            .stream()"], [295, "                            .anyMatch(c -> c.isAssignableFrom(throwableFinal.getClass()));"], [296, "                    if (!failOn) {"], [297, "                        updateMetricsAfter(throwable, wasBreakerOpen, isClosedNow, breakerOpening);"], [298, "                        logCircuitBreakerState(\"Exit 1\");"], [299, "                        throw ExceptionUtil.toWrappedException(throwable);"], [300, "                    }"], [303, "                // CLOSED_MP -> OPEN_MP"], [304, "                if (breakerHelper.getState() == State.CLOSED_MP) {"], [307, "                        breakerHelper.setState(State.OPEN_MP);"], [308, "                        breakerOpening = true;"], [312, "                // HALF_OPEN_MP -> OPEN_MP"], [314, "                    if (breakerHelper.getState() == State.HALF_OPEN_MP) {"], [315, "                        breakerHelper.setState(State.OPEN_MP);"], [317, "                    updateMetricsAfter(throwable, wasBreakerOpen, isClosedNow, breakerOpening);"], [318, "                    logCircuitBreakerState(\"Exit 2\");"], [322, "                // Otherwise, increment success count"], [323, "                breakerHelper.incSuccessCount();"], [325, "                // HALF_OPEN_MP -> CLOSED_MP"], [326, "                if (breakerHelper.getState() == State.HALF_OPEN_MP) {"], [327, "                    if (breakerHelper.getSuccessCount() == introspector.getCircuitBreaker().successThreshold()) {"], [328, "                        breakerHelper.setState(State.CLOSED_MP);"], [330, "                        lockRemoved = true;"], [331, "                        isClosedNow = true;"], [335, "                updateMetricsAfter(throwable, wasBreakerOpen, isClosedNow, breakerOpening);"], [336, "            }"], [338, "            // Untrack invocation in a bulkhead"], [339, "            if (introspector.hasBulkhead()) {"], [340, "                bulkheadHelper.untrackInvocation(this);"], [341, "            }"], [343, "            // Display circuit breaker state at exit"], [344, "            logCircuitBreakerState(\"Exit 3\");"], [346, "            // Outcome of execution"], [347, "            if (throwable != null) {"], [348, "                throw ExceptionUtil.toWrappedException(throwable);"], [349, "            } else {"], [350, "                return result;"], [351, "            }"], [352, "        } finally {"], [353, "            // Free lock unless command data was reset"], [354, "            if (introspector.hasCircuitBreaker() && !lockRemoved) {"], [355, "                breakerHelper.unlock();"], [356, "            }"], [396, ""], [397, "    /**"], [398, "     * Logs circuit breaker state, if one is present."], [399, "     *"], [400, "     * @param preamble Message preamble."], [401, "     */"], [402, "    private void logCircuitBreakerState(String preamble) {"], [403, "        if (introspector.hasCircuitBreaker()) {"], [404, "            String hystrixState = isCircuitBreakerOpen() ? \"OPEN\" : \"CLOSED\";"], [405, "            LOGGER.info(preamble + \": breaker for \" + getCommandKey() + \" in state \""], [406, "                    + breakerHelper.getState() + \" (Hystrix: \" + hystrixState"], [407, "                    + \" Thread:\" + Thread.currentThread().getName() + \")\");"], [408, "        }"], [409, "    }"]], "deleted": [[2, " * Copyright (c) 2018 Oracle and/or its affiliates. All rights reserved."], [59, "    private static final String HELIDON_MICROPROFILE_FAULTTOLERANCE = \"io.helidon.microprofile.faulttolerance\";"], [76, "     * A Hystrix command that can be used to open or close a circuit breaker"], [77, "     * by running a succession of passing or failing commands that are part"], [78, "     * of a {@link Runnable}."], [79, "     */"], [80, "    private static class RunnableCommand extends HystrixCommand<Object> {"], [81, ""], [82, "        private final Runnable runnable;"], [83, ""], [84, "        RunnableCommand(String commandKey, Runnable runnable) {"], [85, "            super(Setter.withGroupKey(HystrixCommandGroupKey.Factory.asKey(HELIDON_MICROPROFILE_FAULTTOLERANCE))"], [86, "                        .andCommandKey("], [87, "                            HystrixCommandKey.Factory.asKey(commandKey))"], [88, "                        .andCommandPropertiesDefaults("], [89, "                            HystrixCommandProperties.Setter().withFallbackEnabled(false)));"], [90, "            this.runnable = runnable;"], [91, "        }"], [92, ""], [93, "        @Override"], [94, "        protected Object run() throws Exception {"], [95, "            runnable.run();"], [96, "            return \"\";"], [97, "        }"], [98, "    }"], [99, ""], [100, "    /**"], [121, "                    .andCommandKey("], [123, "                    .andCommandPropertiesDefaults("], [125, "                                                .withFallbackEnabled(false)"], [126, "                                                .withExecutionIsolationStrategy(THREAD))"], [127, "                    .andThreadPoolKey("], [129, "                        ? HystrixThreadPoolKey.Factory.asKey(commandKey)"], [130, "                        : null)"], [131, "                    .andThreadPoolPropertiesDefaults("], [133, "                                                   .withCoreSize("], [134, "                                                       introspector.hasBulkhead()"], [135, "                                                       ? introspector.getBulkhead().value()"], [136, "                                                       : MAX_THREAD_POOL_SIZE)"], [137, "                                                   .withMaximumSize("], [138, "                                                       introspector.hasBulkhead()"], [139, "                                                       ? introspector.getBulkhead().value()"], [140, "                                                       : MAX_THREAD_POOL_SIZE)"], [141, "                                                   .withMaxQueueSize("], [142, "                                                       introspector.hasBulkhead() && introspector.isAsynchronous()"], [143, "                                                       ? introspector.getBulkhead().waitingTaskQueue()"], [144, "                                                       : MAX_THREAD_POOL_QUEUE_SIZE)"], [145, "                                                   .withQueueSizeRejectionThreshold("], [146, "                                                       introspector.hasBulkhead() && introspector.isAsynchronous()"], [147, "                                                       ? introspector.getBulkhead().waitingTaskQueue()"], [148, "                                                       : MAX_THREAD_POOL_QUEUE_SIZE)));"], [162, "                        () -> breakerHelper.getInStateNanos(CircuitBreakerHelper.State.OPEN_MP));"], [166, "                        () -> breakerHelper.getInStateNanos(CircuitBreakerHelper.State.HALF_OPEN_MP));"], [170, "                        () -> breakerHelper.getInStateNanos(CircuitBreakerHelper.State.CLOSED_MP));"], [257, "        // Configure command before execution"], [258, "        introspector.getHystrixProperties()"], [262, "        // Ensure our internal state is consistent with Hystrix"], [263, "        if (introspector.hasCircuitBreaker()) {"], [264, "            breakerHelper.ensureConsistentState();"], [265, "            LOGGER.info(\"Enter: breaker for \" + getCommandKey() + \" in state \" + breakerHelper.getState());"], [266, "        }"], [268, "        // Record state of breaker"], [269, "        boolean wasBreakerOpen = isCircuitBreakerOpen();"], [271, "        // Track invocation in a bulkhead"], [272, "        if (introspector.hasBulkhead()) {"], [273, "            bulkheadHelper.trackInvocation(this);"], [274, "        }"], [276, "        // Execute command"], [277, "        Object result = null;"], [278, "        Throwable throwable = null;"], [279, "        long startNanos = System.nanoTime();"], [280, "        try {"], [281, "            result = super.execute();"], [282, "        } catch (Throwable t) {"], [283, "            throwable = t;"], [284, "        }"], [286, "        executionTime = System.nanoTime() - startNanos;"], [287, "        boolean hasFailed = (throwable != null);"], [289, "        if (introspector.hasCircuitBreaker()) {"], [290, "            // Keep track of failure ratios"], [291, "            breakerHelper.pushResult(throwable == null);"], [292, ""], [293, "            // Query breaker states"], [294, "            boolean breakerWillOpen = false;"], [295, "            boolean isClosedNow = !isCircuitBreakerOpen();"], [296, ""], [297, "            /*"], [298, "             * Special logic for MP circuit breakers to support failOn. If not a"], [299, "             * throwable to fail on, restore underlying breaker and return."], [300, "             */"], [301, "            if (hasFailed) {"], [302, "                final Throwable throwableFinal = throwable;"], [303, "                Class<? extends Throwable>[] throwableClasses = introspector.getCircuitBreaker().failOn();"], [304, "                boolean failOn = Arrays.asList(throwableClasses)"], [305, "                                       .stream()"], [306, "                                       .anyMatch(c -> c.isAssignableFrom(throwableFinal.getClass()));"], [307, "                if (!failOn) {"], [308, "                    restoreBreaker();       // clears Hystrix counters"], [309, "                    updateMetricsAfter(throwable, wasBreakerOpen, isClosedNow, breakerWillOpen);"], [310, "                    throw ExceptionUtil.toWrappedException(throwable);"], [312, "            }"], [314, "            /*"], [315, "             * Special logic for MP circuit breakers to support an arbitrary success"], [316, "             * threshold used to return a breaker back to its CLOSED state. Hystrix"], [317, "             * only supports a threshold of 1 here, so additional logic is required."], [318, "             */"], [319, "            synchronized (breakerHelper.getSyncObject()) {"], [320, "                // If failure ratio exceeded, then switch state to OPEN_MP"], [321, "                if (breakerHelper.getState() == CircuitBreakerHelper.State.CLOSED_MP) {"], [324, "                        breakerWillOpen = true;"], [325, "                        breakerHelper.setState(CircuitBreakerHelper.State.OPEN_MP);"], [326, "                        runTripBreaker();"], [330, "                // If latest run failed, may need to switch state to OPEN_MP"], [332, "                    if (breakerHelper.getState() == CircuitBreakerHelper.State.HALF_OPEN_MP) {"], [333, "                        // If failed and in HALF_OPEN_MP, we need to force breaker to open"], [334, "                        runTripBreaker();"], [335, "                        breakerHelper.setState(CircuitBreakerHelper.State.OPEN_MP);"], [337, "                    updateMetricsAfter(throwable, wasBreakerOpen, isClosedNow, breakerWillOpen);"], [341, "                // Check next state of breaker based on outcome"], [342, "                if (wasBreakerOpen && isClosedNow) {"], [343, "                    // Last called was successful"], [344, "                    breakerHelper.incSuccessCount();"], [346, "                    // We stay in HALF_OPEN_MP until successThreshold is reached"], [347, "                    if (breakerHelper.getSuccessCount() < introspector.getCircuitBreaker().successThreshold()) {"], [348, "                        breakerHelper.setState(CircuitBreakerHelper.State.HALF_OPEN_MP);"], [349, "                    } else {"], [350, "                        breakerHelper.setState(CircuitBreakerHelper.State.CLOSED_MP);"], [354, "            }"], [356, "            updateMetricsAfter(throwable, wasBreakerOpen, isClosedNow, breakerWillOpen);"], [357, "        }"], [359, "        // Untrack invocation in a bulkhead"], [360, "        if (introspector.hasBulkhead()) {"], [361, "            bulkheadHelper.untrackInvocation(this);"], [362, "        }"], [364, "        // Display circuit breaker state at exit"], [365, "        if (introspector.hasCircuitBreaker()) {"], [366, "            LOGGER.info(\"Exit: breaker for \" + getCommandKey() + \" in state \" + breakerHelper.getState());"], [367, "        }"], [369, "        // Outcome of execution"], [370, "        if (throwable != null) {"], [371, "            throw ExceptionUtil.toWrappedException(throwable);"], [372, "        } else {"], [373, "            return result;"], [404, "     * Run a failing command for an entire window plus one to force a circuit breaker"], [405, "     * to open. Unfortunately, there is no access to the underlying circuit breaker"], [406, "     * so this is the only way to control its internal state. Notice the use of"], [407, "     * the same {@code commandKey}."], [408, "     */"], [409, "    private void runTripBreaker() {"], [410, "        if (!isCircuitBreakerOpen()) {"], [411, "            LOGGER.info(\"Attempting to trip circuit breaker for command \" + commandKey);"], [412, "            final int windowSize = introspector.getCircuitBreaker().requestVolumeThreshold();"], [413, "            for (int i = 0; i <= windowSize; i++) {"], [414, "                try {"], [415, "                    new RunnableCommand(commandKey, () -> {"], [416, "                        throw new RuntimeException(\"Oops\");"], [417, "                    }).execute();"], [418, "                } catch (Throwable t) {"], [419, "                    // ignore"], [420, "                }"], [421, "            }"], [422, "            if (!isCircuitBreakerOpen()) {"], [423, "                LOGGER.info(\"Attempt to manually open breaker failed for command \""], [424, "                        + commandKey);"], [425, "            }"], [426, "        }"], [427, "    }"], [428, ""], [429, "    /**"], [430, "     * Run a successful command for an entire window plus one to force a circuit breaker"], [431, "     * to close. Unfortunately, there is no access to the underlying circuit breaker"], [432, "     * so this is the only way to control its internal state. Notice the use of"], [433, "     * the same {@code commandKey}."], [434, "     */"], [435, "    private void restoreBreaker() {"], [436, "        if (isCircuitBreakerOpen()) {"], [437, "            LOGGER.info(\"Attempting to restore circuit breaker for command \" + commandKey);"], [438, "            final int windowSize = introspector.getCircuitBreaker().requestVolumeThreshold();"], [439, "            for (int i = 0; i <= windowSize; i++) {"], [440, "                new RunnableCommand(commandKey, () -> {"], [441, "                }).execute();"], [442, "            }"], [443, "            if (isCircuitBreakerOpen()) {"], [444, "                LOGGER.info(\"Attempt to manually close breaker failed for command \""], [445, "                        + commandKey);"], [446, "            }"], [447, "        }"], [448, "    }"], [449, ""], [450, "    /**"]]}, "num_lines_added": 140, "num_lines_removed": 190}