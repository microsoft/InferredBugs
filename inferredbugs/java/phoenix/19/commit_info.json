{"hash": "4b42f16b20cc4554cbefbbfa4626244c77cbb6ff", "message": "PHOENIX-2892 Scan for pre-warming the block cache for 2ndary index should be removed", "file_num_lines": 28, "diff_parsed": {"added": [], "deleted": [[21, "import java.util.ArrayList;"], [22, "import java.util.HashMap;"], [23, "import java.util.List;"], [24, "import java.util.Map;"], [25, ""], [27, "import org.apache.hadoop.hbase.Cell;"], [29, "import org.apache.hadoop.hbase.client.Scan;"], [31, "import org.apache.hadoop.hbase.io.ImmutableBytesWritable;"], [33, "import org.apache.hadoop.hbase.regionserver.Region;"], [34, "import org.apache.hadoop.hbase.regionserver.RegionScanner;"], [35, "import org.apache.phoenix.compile.ScanRanges;"], [36, "import org.apache.phoenix.filter.SkipScanFilter;"], [39, "import org.apache.phoenix.hbase.index.util.IndexManagementUtil;"], [41, "import org.apache.phoenix.query.KeyRange;"], [42, "import org.apache.phoenix.schema.types.PVarbinary;"], [43, ""], [44, "import com.google.common.collect.Lists;"], [72, "        // The entire purpose of this method impl is to get the existing rows for the"], [73, "        // table rows being indexed into the block cache, as the index maintenance code"], [74, "        // does a point scan per row."], [75, "        List<IndexMaintainer> indexMaintainers = ((PhoenixIndexMetaData)context).getIndexMaintainers();"], [76, "        List<KeyRange> keys = Lists.newArrayListWithExpectedSize(miniBatchOp.size());"], [77, "        Map<ImmutableBytesWritable, IndexMaintainer> maintainers ="], [78, "                new HashMap<ImmutableBytesWritable, IndexMaintainer>();"], [79, "        ImmutableBytesWritable indexTableName = new ImmutableBytesWritable();"], [80, "        for (int i = 0; i < miniBatchOp.size(); i++) {"], [81, "            Mutation m = miniBatchOp.getOperation(i);"], [82, "            keys.add(PVarbinary.INSTANCE.getKeyRange(m.getRow()));"], [83, ""], [84, "            for(IndexMaintainer indexMaintainer: indexMaintainers) {"], [85, "                if (indexMaintainer.isImmutableRows()) continue;"], [86, "                indexTableName.set(indexMaintainer.getIndexTableName());"], [87, "                if (maintainers.get(indexTableName) != null) continue;"], [88, "                maintainers.put(indexTableName, indexMaintainer);"], [89, "            }"], [90, ""], [91, "        }"], [92, "        if (maintainers.isEmpty()) return;"], [93, "        Scan scan = IndexManagementUtil.newLocalStateScan(new ArrayList<IndexMaintainer>(maintainers.values()));"], [94, "        ScanRanges scanRanges = ScanRanges.createPointLookup(keys);"], [95, "        scanRanges.initializeScan(scan);"], [96, "        scan.setFilter(new SkipScanFilter(scanRanges.getSkipScanFilter(),true));"], [97, "        Region region = env.getRegion();"], [98, "        RegionScanner scanner = region.getScanner(scan);"], [99, "        // Run through the scanner using internal nextRaw method"], [100, "        region.startRegionOperation();"], [101, "        try {"], [102, "            synchronized (scanner) {"], [103, "                boolean hasMore;"], [104, "                do {"], [105, "                    List<Cell> results = Lists.newArrayList();"], [106, "                    // Results are potentially returned even when the return value of s.next is"], [107, "                    // false since this is an indication of whether or not there are more values"], [108, "                    // after the ones returned"], [109, "                    hasMore = scanner.nextRaw(results);"], [110, "                } while (hasMore);"], [111, "            }"], [112, "        } finally {"], [113, "            try {"], [114, "                scanner.close();"], [115, "            } finally {"], [116, "                region.closeRegionOperation();"], [117, "            }"], [118, "        }"]]}, "num_lines_added": 0, "num_lines_removed": 64}