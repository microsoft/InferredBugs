{"hash": "5d9572736a991f19121477a0822d4b8bf26b4c69", "message": "PHOENIX-4214 Scans which write should not block region split or close (Vincent Poon)", "file_num_lines": 251, "diff_parsed": {"added": [[21, "import static org.junit.Assert.assertEquals;"], [36, "import java.util.concurrent.TimeUnit;"], [38, "import org.apache.commons.lang.exception.ExceptionUtils;"], [40, "import org.apache.hadoop.hbase.HBaseTestingUtility;"], [41, "import org.apache.hadoop.hbase.HRegionInfo;"], [42, "import org.apache.hadoop.hbase.NotServingRegionException;"], [43, "import org.apache.hadoop.hbase.TableName;"], [44, "import org.apache.hadoop.hbase.Waiter;"], [45, "import org.apache.hadoop.hbase.client.HBaseAdmin;"], [50, "import org.apache.hadoop.hbase.regionserver.HRegionServer;"], [52, "import org.apache.hadoop.hbase.util.Bytes;"], [57, "import org.junit.AfterClass;"], [58, "import org.junit.Before;"], [61, "import org.slf4j.Logger;"], [62, "import org.slf4j.LoggerFactory;"], [68, "    private static final Logger logger = LoggerFactory.getLogger(UpsertSelectOverlappingBatchesIT.class);"], [69, "    private Properties props;"], [70, "    private static volatile String dataTable;"], [71, "    private String index;"], [72, ""], [82, ""], [83, "    @AfterClass"], [84, "    public static void tearDownClass() throws Exception {"], [85, "        getUtility().shutdownMiniCluster();"], [86, "    }"], [87, ""], [117, ""], [118, "    private static class UpsertSelectLooper implements Runnable {"], [119, "        private UpsertSelectRunner runner;"], [120, "        public UpsertSelectLooper(UpsertSelectRunner runner) {"], [121, "            this.runner = runner;"], [122, "        }"], [123, "        @Override"], [124, "        public void run() {"], [125, "            while (true) {"], [126, "                try {"], [127, "                    runner.call();"], [128, "                }"], [129, "                catch (Exception e) {"], [130, "                    if (ExceptionUtils.indexOfThrowable(e, InterruptedException.class) != -1) {"], [131, "                        logger.info(\"Interrupted, exiting\", e);"], [132, "                        Thread.currentThread().interrupt();"], [133, "                        return;"], [134, "                    }"], [135, "                    logger.error(\"Hit exception while writing\", e);"], [136, "                }"], [137, "            }"], [138, "        }};"], [139, ""], [140, "    @Before"], [141, "    public void setup() throws Exception {"], [142, "        SlowBatchRegionObserver.SLOW_MUTATE = false;"], [143, "        props = PropertiesUtil.deepCopy(TEST_PROPERTIES);"], [144, "        dataTable = generateUniqueName();"], [145, "        index = \"IDX_\" + dataTable;"], [146, "        try (Connection conn = driver.connect(url, props)) {"], [147, "            conn.createStatement().execute(\"CREATE TABLE \" + dataTable"], [148, "                    + \" (k INTEGER NOT NULL PRIMARY KEY, v1 VARCHAR, v2 VARCHAR)\");"], [149, "            // create the index and ensure its empty as well"], [150, "            conn.createStatement().execute(\"CREATE INDEX \" + index + \" ON \" + dataTable + \" (v1)\");"], [151, "            PreparedStatement stmt = conn.prepareStatement(\"UPSERT INTO \" + dataTable + \" VALUES(?,?,?)\");"], [152, "            conn.setAutoCommit(false);"], [153, "            for (int i = 0; i < 100; i++) {"], [154, "                stmt.setInt(1, i);"], [155, "                stmt.setString(2, \"v1\" + i);"], [156, "                stmt.setString(3, \"v2\" + i);"], [157, "                stmt.execute();"], [158, "            }"], [159, "            conn.commit();"], [160, "        }"], [161, "    }"], [162, ""], [165, "\t\ttry (Connection conn = driver.connect(url, props)) {"], [166, "\t\t        int numUpsertSelectRunners = 5;"], [167, "\t\t        ExecutorService exec = Executors.newFixedThreadPool(numUpsertSelectRunners);"], [168, "\t\t        CompletionService<Boolean> completionService = new ExecutorCompletionService<Boolean>(exec);"], [169, "\t\t        List<Future<Boolean>> futures = Lists.newArrayListWithExpectedSize(numUpsertSelectRunners);"], [170, "\t\t        // run one UPSERT SELECT for 100 rows (that locks the rows for a long time)"], [171, "\t\t        futures.add(completionService.submit(new UpsertSelectRunner(dataTable, 0, 105, 1)));"], [172, "\t\t        // run four UPSERT SELECTS for 5 rows (that overlap with slow running UPSERT SELECT)"], [173, "\t\t        for (int i = 0; i < 100; i += 25) {"], [174, "\t\t            futures.add(completionService.submit(new UpsertSelectRunner(dataTable, i, i+25, 5)));"], [175, "\t\t        }"], [176, "\t\t        int received = 0;"], [177, "\t\t        while (received < futures.size()) {"], [178, "\t\t            Future<Boolean> resultFuture = completionService.take();"], [179, "\t\t            Boolean result = resultFuture.get();"], [180, "\t\t            received++;"], [181, "\t\t            assertTrue(result);"], [182, "\t\t        }"], [183, "\t\t        exec.shutdownNow();"], [186, ""], [187, "    /**"], [188, "     * Tests that splitting a region is not blocked indefinitely by UPSERT SELECT load"], [189, "     */"], [190, "\t@Test"], [191, "    public void testSplitDuringUpsertSelect() throws Exception {"], [192, "        int numUpsertSelectRunners = 4;"], [193, "        ExecutorService exec = Executors.newFixedThreadPool(numUpsertSelectRunners);"], [194, "        try (Connection conn = driver.connect(url, props)) {"], [195, "            final UpsertSelectRunner upsertSelectRunner ="], [196, "                    new UpsertSelectRunner(dataTable, 0, 105, 1);"], [197, "            // keep running slow upsert selects"], [198, "            SlowBatchRegionObserver.SLOW_MUTATE = true;"], [199, "            for (int i = 0; i < numUpsertSelectRunners; i++) {"], [200, "                exec.submit(new UpsertSelectLooper(upsertSelectRunner));"], [201, "                Thread.sleep(300);"], [202, "            }"], [203, ""], [204, "            // keep trying to split the region"], [205, "            final HBaseTestingUtility utility = getUtility();"], [206, "            final HBaseAdmin admin = utility.getHBaseAdmin();"], [207, "            final TableName dataTN = TableName.valueOf(dataTable);"], [208, "            assertEquals(1, utility.getHBaseCluster().getRegions(dataTN).size());"], [209, "            utility.waitFor(30000L, 1000, new Waiter.Predicate<Exception>() {"], [210, "                @Override"], [211, "                public boolean evaluate() throws Exception {"], [212, "                    try {"], [213, "                        List<HRegionInfo> regions = admin.getTableRegions(dataTN);"], [214, "                        if (regions.size() > 1) {"], [215, "                            logger.info(\"Found region was split\");"], [216, "                            return true;"], [217, "                        }"], [218, "                        if (regions.size() == 0) {"], [219, "                            // This happens when region in transition or closed"], [220, "                            logger.info(\"No region returned\");"], [221, "                            return false;"], [222, "                        }"], [223, "                        ;"], [224, "                        HRegionInfo hRegion = regions.get(0);"], [225, "                        logger.info(\"Attempting to split region\");"], [226, "                        admin.splitRegion(hRegion.getRegionName(), Bytes.toBytes(2));"], [227, "                        return false;"], [228, "                    } catch (NotServingRegionException nsre) {"], [229, "                        // during split"], [230, "                        return false;"], [231, "                    }"], [232, "                }"], [233, "            });"], [234, "        } finally {"], [235, "            SlowBatchRegionObserver.SLOW_MUTATE = false;"], [236, "            exec.shutdownNow();"], [237, "            exec.awaitTermination(60, TimeUnit.SECONDS);"], [238, "        }"], [239, "    }"], [240, ""], [241, "    /**"], [242, "     * Tests that UPSERT SELECT doesn't indefinitely block region closes"], [243, "     */"], [244, "    @Test"], [245, "    public void testRegionCloseDuringUpsertSelect() throws Exception {"], [246, "        int numUpsertSelectRunners = 4;"], [247, "        ExecutorService exec = Executors.newFixedThreadPool(numUpsertSelectRunners);"], [248, "        try (Connection conn = driver.connect(url, props)) {"], [249, "            final UpsertSelectRunner upsertSelectRunner ="], [250, "                    new UpsertSelectRunner(dataTable, 0, 105, 1);"], [251, "            // keep running slow upsert selects"], [252, "            SlowBatchRegionObserver.SLOW_MUTATE = true;"], [253, "            for (int i = 0; i < numUpsertSelectRunners; i++) {"], [254, "                exec.submit(new UpsertSelectLooper(upsertSelectRunner));"], [255, "                Thread.sleep(300);"], [256, "            }"], [257, ""], [258, "            final HBaseTestingUtility utility = getUtility();"], [259, "            // try to close the region while UPSERT SELECTs are happening,"], [260, "            final HRegionServer dataRs = utility.getHBaseCluster().getRegionServer(0);"], [261, "            final HBaseAdmin admin = utility.getHBaseAdmin();"], [262, "            final HRegionInfo dataRegion ="], [263, "                    admin.getTableRegions(TableName.valueOf(dataTable)).get(0);"], [264, "            logger.info(\"Closing data table region\");"], [265, "            admin.closeRegion(dataRs.getServerName(), dataRegion);"], [266, "            // make sure the region is offline"], [267, "            utility.waitFor(30000L, 1000, new Waiter.Predicate<Exception>() {"], [268, "                @Override"], [269, "                public boolean evaluate() throws Exception {"], [270, "                    List<HRegionInfo> onlineRegions ="], [271, "                            admin.getOnlineRegions(dataRs.getServerName());"], [272, "                    for (HRegionInfo onlineRegion : onlineRegions) {"], [273, "                        if (onlineRegion.equals(dataRegion)) {"], [274, "                            logger.info(\"Data region still online\");"], [275, "                            return false;"], [276, "                        }"], [277, "                    }"], [278, "                    logger.info(\"Region is no longer online\");"], [279, "                    return true;"], [280, "                }"], [281, "            });"], [282, "        } finally {"], [283, "            SlowBatchRegionObserver.SLOW_MUTATE = false;"], [284, "            exec.shutdownNow();"], [285, "            exec.awaitTermination(60, TimeUnit.SECONDS);"], [286, "        }"], [287, "    }"], [290, "        public static volatile boolean SLOW_MUTATE = false;"], [294, "            if ((miniBatchOp.size()==100 || SLOW_MUTATE) && c.getEnvironment().getRegionInfo().getTable().getNameAsString().equals(dataTable)) {"]], "deleted": [[53, ""], [63, ""], [92, ""], [94, ""], [97, "\t\tfinal String dataTable = generateUniqueName();"], [98, "\t\tfinal String index = \"IDX_\" + dataTable;"], [99, "\t\t// create the table and ensure its empty"], [100, "\t\tProperties props = PropertiesUtil.deepCopy(TEST_PROPERTIES);"], [101, "\t\tConnection conn = driver.connect(url, props);"], [102, "\t\tconn.createStatement()"], [103, "\t\t\t\t.execute(\"CREATE TABLE \" + dataTable + \" (k INTEGER NOT NULL PRIMARY KEY, v1 VARCHAR, v2 VARCHAR)\");"], [104, "\t\t// create the index and ensure its empty as well"], [105, "\t\tconn.createStatement().execute(\"CREATE INDEX \" + index + \" ON \" + dataTable + \" (v1)\");"], [106, ""], [107, "\t\tconn = DriverManager.getConnection(getUrl(), props);"], [108, "\t\tPreparedStatement stmt = conn.prepareStatement(\"UPSERT INTO \" + dataTable + \" VALUES(?,?,?)\");"], [109, "\t\tconn.setAutoCommit(false);"], [110, "\t\tfor (int i = 0; i < 100; i++) {"], [111, "\t\t\tstmt.setInt(1, i);"], [112, "\t\t\tstmt.setString(2, \"v1\" + i);"], [113, "\t\t\tstmt.setString(3, \"v2\" + i);"], [114, "\t\t\tstmt.execute();"], [115, "\t\t}"], [116, "\t\tconn.commit();"], [117, ""], [118, "\t\tint numUpsertSelectRunners = 5;"], [119, "\t\tExecutorService exec = Executors.newFixedThreadPool(numUpsertSelectRunners);"], [120, "\t\tCompletionService<Boolean> completionService = new ExecutorCompletionService<Boolean>(exec);"], [121, "\t\tList<Future<Boolean>> futures = Lists.newArrayListWithExpectedSize(numUpsertSelectRunners);"], [122, "\t\t// run one UPSERT SELECT for 100 rows (that locks the rows for a long time)"], [123, "\t\tfutures.add(completionService.submit(new UpsertSelectRunner(dataTable, 0, 105, 1)));"], [124, "\t\t// run four UPSERT SELECTS for 5 rows (that overlap with slow running UPSERT SELECT)"], [125, "\t\tfor (int i = 0; i < 100; i += 25) {"], [126, "\t\t\tfutures.add(completionService.submit(new UpsertSelectRunner(dataTable, i, i+25, 5)));"], [127, "\t\t}"], [128, "\t\tint received = 0;"], [129, "\t\twhile (received < futures.size()) {"], [130, "\t\t\tFuture<Boolean> resultFuture = completionService.take();"], [131, "\t\t\tBoolean result = resultFuture.get();"], [132, "\t\t\treceived++;"], [133, "\t\t\tassertTrue(result);"], [135, "\t\texec.shutdownNow();"], [136, "\t\tconn.close();"], [143, "            if (miniBatchOp.size()==100) {"]]}, "num_lines_added": 195, "num_lines_removed": 44}