{"hash": "f00380ef79795a675cfa5b50082147a273ac26f9", "message": "PHOENIX-4214 Scans which write should not block region split or close (Vincent Poon)", "file_num_lines": 253, "diff_parsed": {"added": [[21, "import static org.junit.Assert.assertEquals;"], [36, "import java.util.concurrent.TimeUnit;"], [38, "import org.apache.commons.lang.exception.ExceptionUtils;"], [40, "import org.apache.hadoop.hbase.HBaseTestingUtility;"], [41, "import org.apache.hadoop.hbase.HConstants;"], [42, "import org.apache.hadoop.hbase.HRegionInfo;"], [43, "import org.apache.hadoop.hbase.NotServingRegionException;"], [44, "import org.apache.hadoop.hbase.TableName;"], [45, "import org.apache.hadoop.hbase.Waiter;"], [46, "import org.apache.hadoop.hbase.client.HBaseAdmin;"], [51, "import org.apache.hadoop.hbase.regionserver.HRegionServer;"], [53, "import org.apache.hadoop.hbase.util.Bytes;"], [58, "import org.junit.AfterClass;"], [59, "import org.junit.Before;"], [62, "import org.slf4j.Logger;"], [63, "import org.slf4j.LoggerFactory;"], [69, "    private static final Logger logger = LoggerFactory.getLogger(UpsertSelectOverlappingBatchesIT.class);"], [70, "    private Properties props;"], [71, "    private static volatile String dataTable;"], [72, "    private String index;"], [73, ""], [80, "        setUpTestDriver(new ReadOnlyProps(serverProps.entrySet().iterator()));"], [82, ""], [83, "    @AfterClass"], [84, "    public static void tearDownClass() throws Exception {"], [85, "        SlowBatchRegionObserver.SLOW_MUTATE = false;"], [86, "        getUtility().shutdownMiniCluster();"], [87, "    }"], [88, ""], [118, ""], [119, "    private static class UpsertSelectLooper implements Runnable {"], [120, "        private UpsertSelectRunner runner;"], [121, "        public UpsertSelectLooper(UpsertSelectRunner runner) {"], [122, "            this.runner = runner;"], [123, "        }"], [124, "        @Override"], [125, "        public void run() {"], [126, "            while (true) {"], [127, "                try {"], [128, "                    runner.call();"], [129, "                }"], [130, "                catch (Exception e) {"], [131, "                    if (ExceptionUtils.indexOfThrowable(e, InterruptedException.class) != -1) {"], [132, "                        logger.info(\"Interrupted, exiting\", e);"], [133, "                        Thread.currentThread().interrupt();"], [134, "                        return;"], [135, "                    }"], [136, "                    logger.error(\"Hit exception while writing\", e);"], [137, "                }"], [138, "            }"], [139, "        }};"], [140, ""], [141, "    @Before"], [142, "    public void setup() throws Exception {"], [143, "        SlowBatchRegionObserver.SLOW_MUTATE = false;"], [144, "        props = PropertiesUtil.deepCopy(TEST_PROPERTIES);"], [145, "        props.put(HConstants.HBASE_CLIENT_RETRIES_NUMBER, 2);"], [146, "        dataTable = generateUniqueName();"], [147, "        index = \"IDX_\" + dataTable;"], [148, "        try (Connection conn = driver.connect(url, props)) {"], [149, "            conn.createStatement().execute(\"CREATE TABLE \" + dataTable"], [150, "                    + \" (k INTEGER NOT NULL PRIMARY KEY, v1 VARCHAR, v2 VARCHAR)\");"], [151, "            // create the index and ensure its empty as well"], [152, "            conn.createStatement().execute(\"CREATE INDEX \" + index + \" ON \" + dataTable + \" (v1)\");"], [153, "            PreparedStatement stmt = conn.prepareStatement(\"UPSERT INTO \" + dataTable + \" VALUES(?,?,?)\");"], [154, "            conn.setAutoCommit(false);"], [155, "            for (int i = 0; i < 100; i++) {"], [156, "                stmt.setInt(1, i);"], [157, "                stmt.setString(2, \"v1\" + i);"], [158, "                stmt.setString(3, \"v2\" + i);"], [159, "                stmt.execute();"], [160, "            }"], [161, "            conn.commit();"], [162, "        }"], [163, "    }"], [164, ""], [167, "\t\ttry (Connection conn = driver.connect(url, props)) {"], [168, "\t\t        int numUpsertSelectRunners = 5;"], [169, "\t\t        ExecutorService exec = Executors.newFixedThreadPool(numUpsertSelectRunners);"], [170, "\t\t        CompletionService<Boolean> completionService = new ExecutorCompletionService<Boolean>(exec);"], [171, "\t\t        List<Future<Boolean>> futures = Lists.newArrayListWithExpectedSize(numUpsertSelectRunners);"], [172, "\t\t        // run one UPSERT SELECT for 100 rows (that locks the rows for a long time)"], [173, "\t\t        futures.add(completionService.submit(new UpsertSelectRunner(dataTable, 0, 105, 1)));"], [174, "\t\t        // run four UPSERT SELECTS for 5 rows (that overlap with slow running UPSERT SELECT)"], [175, "\t\t        for (int i = 0; i < 100; i += 25) {"], [176, "\t\t            futures.add(completionService.submit(new UpsertSelectRunner(dataTable, i, i+25, 5)));"], [177, "\t\t        }"], [178, "\t\t        int received = 0;"], [179, "\t\t        while (received < futures.size()) {"], [180, "\t\t            Future<Boolean> resultFuture = completionService.take();"], [181, "\t\t            Boolean result = resultFuture.get();"], [182, "\t\t            received++;"], [183, "\t\t            assertTrue(result);"], [184, "\t\t        }"], [185, "\t\t        exec.shutdownNow();"], [188, ""], [189, "    /**"], [190, "     * Tests that splitting a region is not blocked indefinitely by UPSERT SELECT load"], [191, "     */"], [192, "\t@Test"], [193, "    public void testSplitDuringUpsertSelect() throws Exception {"], [194, "        int numUpsertSelectRunners = 4;"], [195, "        ExecutorService exec = Executors.newFixedThreadPool(numUpsertSelectRunners);"], [196, "        try (Connection conn = driver.connect(url, props)) {"], [197, "            final UpsertSelectRunner upsertSelectRunner ="], [198, "                    new UpsertSelectRunner(dataTable, 0, 105, 1);"], [199, "            // keep running slow upsert selects"], [200, "            SlowBatchRegionObserver.SLOW_MUTATE = true;"], [201, "            for (int i = 0; i < numUpsertSelectRunners; i++) {"], [202, "                exec.submit(new UpsertSelectLooper(upsertSelectRunner));"], [203, "                Thread.sleep(300);"], [204, "            }"], [205, ""], [206, "            // keep trying to split the region"], [207, "            final HBaseTestingUtility utility = getUtility();"], [208, "            final HBaseAdmin admin = utility.getHBaseAdmin();"], [209, "            final TableName dataTN = TableName.valueOf(dataTable);"], [210, "            assertEquals(1, utility.getHBaseCluster().getRegions(dataTN).size());"], [211, "            utility.waitFor(60000L, 1000, new Waiter.Predicate<Exception>() {"], [212, "                @Override"], [213, "                public boolean evaluate() throws Exception {"], [214, "                    try {"], [215, "                        List<HRegionInfo> regions = admin.getTableRegions(dataTN);"], [216, "                        if (regions.size() > 1) {"], [217, "                            logger.info(\"Found region was split\");"], [218, "                            return true;"], [219, "                        }"], [220, "                        if (regions.size() == 0) {"], [221, "                            // This happens when region in transition or closed"], [222, "                            logger.info(\"No region returned\");"], [223, "                            return false;"], [224, "                        }"], [225, "                        ;"], [226, "                        HRegionInfo hRegion = regions.get(0);"], [227, "                        logger.info(\"Attempting to split region\");"], [228, "                        admin.splitRegion(hRegion.getRegionName(), Bytes.toBytes(2));"], [229, "                        return false;"], [230, "                    } catch (NotServingRegionException nsre) {"], [231, "                        // during split"], [232, "                        return false;"], [233, "                    }"], [234, "                }"], [235, "            });"], [236, "        } finally {"], [237, "            SlowBatchRegionObserver.SLOW_MUTATE = false;"], [238, "            exec.shutdownNow();"], [239, "            exec.awaitTermination(60, TimeUnit.SECONDS);"], [240, "        }"], [241, "    }"], [242, ""], [243, "    /**"], [244, "     * Tests that UPSERT SELECT doesn't indefinitely block region closes"], [245, "     */"], [246, "    @Test"], [247, "    public void testRegionCloseDuringUpsertSelect() throws Exception {"], [248, "        int numUpsertSelectRunners = 4;"], [249, "        ExecutorService exec = Executors.newFixedThreadPool(numUpsertSelectRunners);"], [250, "        try (Connection conn = driver.connect(url, props)) {"], [251, "            final UpsertSelectRunner upsertSelectRunner ="], [252, "                    new UpsertSelectRunner(dataTable, 0, 105, 1);"], [253, "            // keep running slow upsert selects"], [254, "            SlowBatchRegionObserver.SLOW_MUTATE = true;"], [255, "            for (int i = 0; i < numUpsertSelectRunners; i++) {"], [256, "                exec.submit(new UpsertSelectLooper(upsertSelectRunner));"], [257, "                Thread.sleep(300);"], [258, "            }"], [259, ""], [260, "            final HBaseTestingUtility utility = getUtility();"], [261, "            // try to close the region while UPSERT SELECTs are happening,"], [262, "            final HRegionServer dataRs = utility.getHBaseCluster().getRegionServer(0);"], [263, "            final HBaseAdmin admin = utility.getHBaseAdmin();"], [264, "            final HRegionInfo dataRegion ="], [265, "                    admin.getTableRegions(TableName.valueOf(dataTable)).get(0);"], [266, "            logger.info(\"Closing data table region\");"], [267, "            admin.closeRegion(dataRs.getServerName(), dataRegion);"], [268, "            // make sure the region is offline"], [269, "            utility.waitFor(60000L, 1000, new Waiter.Predicate<Exception>() {"], [270, "                @Override"], [271, "                public boolean evaluate() throws Exception {"], [272, "                    List<HRegionInfo> onlineRegions ="], [273, "                            admin.getOnlineRegions(dataRs.getServerName());"], [274, "                    for (HRegionInfo onlineRegion : onlineRegions) {"], [275, "                        if (onlineRegion.equals(dataRegion)) {"], [276, "                            logger.info(\"Data region still online\");"], [277, "                            return false;"], [278, "                        }"], [279, "                    }"], [280, "                    logger.info(\"Region is no longer online\");"], [281, "                    return true;"], [282, "                }"], [283, "            });"], [284, "        } finally {"], [285, "            SlowBatchRegionObserver.SLOW_MUTATE = false;"], [286, "            exec.shutdownNow();"], [287, "            exec.awaitTermination(60, TimeUnit.SECONDS);"], [288, "        }"], [289, "    }"], [292, "        public static volatile boolean SLOW_MUTATE = false;"], [296, "            if ((miniBatchOp.size()==100 || SLOW_MUTATE) && c.getEnvironment().getRegionInfo().getTable().getNameAsString().equals(dataTable)) {"]], "deleted": [[53, ""], [60, "        Map<String,String> clientProps = Maps.newHashMapWithExpectedSize(1);"], [61, "        setUpTestDriver(new ReadOnlyProps(serverProps.entrySet().iterator()), new ReadOnlyProps(clientProps.entrySet().iterator()));"], [63, ""], [92, ""], [94, ""], [97, "\t\tfinal String dataTable = generateUniqueName();"], [98, "\t\tfinal String index = \"IDX_\" + dataTable;"], [99, "\t\t// create the table and ensure its empty"], [100, "\t\tProperties props = PropertiesUtil.deepCopy(TEST_PROPERTIES);"], [101, "\t\tConnection conn = driver.connect(url, props);"], [102, "\t\tconn.createStatement()"], [103, "\t\t\t\t.execute(\"CREATE TABLE \" + dataTable + \" (k INTEGER NOT NULL PRIMARY KEY, v1 VARCHAR, v2 VARCHAR)\");"], [104, "\t\t// create the index and ensure its empty as well"], [105, "\t\tconn.createStatement().execute(\"CREATE INDEX \" + index + \" ON \" + dataTable + \" (v1)\");"], [106, ""], [107, "\t\tconn = DriverManager.getConnection(getUrl(), props);"], [108, "\t\tPreparedStatement stmt = conn.prepareStatement(\"UPSERT INTO \" + dataTable + \" VALUES(?,?,?)\");"], [109, "\t\tconn.setAutoCommit(false);"], [110, "\t\tfor (int i = 0; i < 100; i++) {"], [111, "\t\t\tstmt.setInt(1, i);"], [112, "\t\t\tstmt.setString(2, \"v1\" + i);"], [113, "\t\t\tstmt.setString(3, \"v2\" + i);"], [114, "\t\t\tstmt.execute();"], [115, "\t\t}"], [116, "\t\tconn.commit();"], [117, ""], [118, "\t\tint numUpsertSelectRunners = 5;"], [119, "\t\tExecutorService exec = Executors.newFixedThreadPool(numUpsertSelectRunners);"], [120, "\t\tCompletionService<Boolean> completionService = new ExecutorCompletionService<Boolean>(exec);"], [121, "\t\tList<Future<Boolean>> futures = Lists.newArrayListWithExpectedSize(numUpsertSelectRunners);"], [122, "\t\t// run one UPSERT SELECT for 100 rows (that locks the rows for a long time)"], [123, "\t\tfutures.add(completionService.submit(new UpsertSelectRunner(dataTable, 0, 105, 1)));"], [124, "\t\t// run four UPSERT SELECTS for 5 rows (that overlap with slow running UPSERT SELECT)"], [125, "\t\tfor (int i = 0; i < 100; i += 25) {"], [126, "\t\t\tfutures.add(completionService.submit(new UpsertSelectRunner(dataTable, i, i+25, 5)));"], [127, "\t\t}"], [128, "\t\tint received = 0;"], [129, "\t\twhile (received < futures.size()) {"], [130, "\t\t\tFuture<Boolean> resultFuture = completionService.take();"], [131, "\t\t\tBoolean result = resultFuture.get();"], [132, "\t\t\treceived++;"], [133, "\t\t\tassertTrue(result);"], [135, "\t\texec.shutdownNow();"], [136, "\t\tconn.close();"], [143, "            if (miniBatchOp.size()==100) {"]]}, "num_lines_added": 199, "num_lines_removed": 46}