{"hash": "56d135f2a16520c78c0f7418736ce674a97dbf89", "message": "fixed some PR problems (#55), and added INVALID_ENTRY_INDEX", "file_num_lines": 955, "diff_parsed": {"added": [[24, "import static com.oath.oak.Chunk.INVALID_ENTRY_INDEX;"], [25, "import static com.oath.oak.Chunk.INVALID_VALUE;"], [27, "import static com.oath.oak.ValueUtils.ValueResult.MOVED;"], [348, "        int ei;"], [349, "        long oldReference = INVALID_VALUE;"], [354, "        } else {"], [356, "            if (ei == INVALID_ENTRY_INDEX) {"], [366, "                if (oldReference != INVALID_VALUE) {"], [424, "        long oldReference = INVALID_VALUE;"], [436, "            if (ei == INVALID_ENTRY_INDEX) {"], [444, "                Slice oldSlice = c.buildValueSlice(oldReference);"], [445, "                if (oldSlice != null) {"], [449, "                    AbstractMap.SimpleEntry<ValueUtils.ValueResult, V> res = ValueUtils.transform(oldSlice,"], [450, "                            transformer);"], [496, "            } else if (res == MOVED) {"], [518, "        int ei;"], [519, "        long oldReference = INVALID_VALUE;"], [524, "        } else {"], [526, "            if (ei == INVALID_ENTRY_INDEX) {"], [539, "                    } else if (res == MOVED) {"], [598, "                } else if (removeResult.getKey() == MOVED) {"], [624, "            assert lookUp.valueReference != INVALID_VALUE;"], [625, "            Chunk.OpData opData = new Chunk.OpData(Operation.REMOVE, lookUp.entryIndex, INVALID_VALUE,"], [665, "        if (res.getKey() == MOVED) {"], [691, "        if (lookUp == null || lookUp.valueSlice == null || lookUp.entryIndex == INVALID_ENTRY_INDEX) {"], [756, "        if (res == MOVED) {"], [780, "            if (entry.getKey() != MOVED) {"], [797, "            if (result != MOVED) {"], [1178, "            else if (res.getKey() == MOVED) {"], [1246, "            } else if (res == MOVED) {"], [1252, "                } while (ValueUtils.lockRead(serializedValue) == MOVED);"]], "deleted": [[24, "import static com.oath.oak.Chunk.DELETED_VALUE;"], [26, "import static com.oath.oak.ValueUtils.ValueResult.RETRY;"], [347, "        int ei = -1;"], [348, "        long oldReference = DELETED_VALUE;"], [353, "        }"], [354, ""], [355, "        if (ei == -1) {"], [357, "            if (ei == -1) {"], [367, "                if (oldReference != DELETED_VALUE) {"], [425, "        long oldReference = DELETED_VALUE;"], [437, "            if (ei == -1) {"], [445, "                if (oldReference != DELETED_VALUE) {"], [449, "                    AbstractMap.SimpleEntry<ValueUtils.ValueResult, V> res ="], [450, "                            ValueUtils.transform(c.buildValueSlice(oldReference), transformer);"], [496, "            } else if (res == RETRY) {"], [518, "        int ei = -1;"], [519, "        long oldReference = DELETED_VALUE;"], [524, "        }"], [525, ""], [526, "        if (ei == -1) {"], [528, "            if (ei == -1) {"], [541, "                    } else if (res == RETRY) {"], [600, "                } else if (removeResult.getKey() == RETRY) {"], [626, "            assert lookUp.valueReference != DELETED_VALUE;"], [627, "            Chunk.OpData opData = new Chunk.OpData(Operation.REMOVE, lookUp.entryIndex, DELETED_VALUE,"], [667, "        if (res.getKey() == RETRY) {"], [693, "        if (lookUp == null || lookUp.valueSlice == null || lookUp.entryIndex == -1) {"], [758, "        if (res == RETRY) {"], [782, "            if (entry.getKey() != RETRY) {"], [799, "            if (result != RETRY) {"], [1180, "            else if (res.getKey() == RETRY) {"], [1248, "            } else if (res == RETRY) {"], [1254, "                } while (ValueUtils.lockRead(serializedValue) == RETRY);"]]}, "num_lines_added": 31, "num_lines_removed": 33}