{"hash": "e7c76e4f324e74b1e135b2a98f6d7094735c3c65", "message": "continued implementing reconfiguration", "file_num_lines": 355, "diff_parsed": {"added": [[151, "            long endoff = Long.parseLong(segmentN.getAttributes().getNamedItem(\"endoffset\").getNodeValue());"], [157, "            log.info(\"globalepoch {} Segment {} with {} group(s) [{}..{}] grain={}\","], [159, "                    segmentindex, numgroups, startoff, endoff, grain);"], [190, "                grouplist[gindex] = new GroupView(localstartoff, corfunodes, groupepoch, numnodes, gindex);"], [193, "            segmentlist.add(new SegmentView(startoff, numgroups, endoff, grain, grouplist, tokenserver));"], [205, "    <GROUP index=\"0\" groupepoch=\"0\" numnodes=\"1\">"], [208, "    <GROUP index=\"1\" groupepoch=\"0\" numnodes=\"1\">"], [234, "            conf.setAttribute(\"endoffset\", Long.toString(s.endoff));"], [288, "     * We create a new segment which succeeds the current sequence segment-history. The new segments starts at 'startOffset'"], [290, "     * @param startOffset the offset past the highest log-offset reached up to now"], [298, "    public CorfuConfiguration getRemoveUnitProposal(long startOffset, String hostname, int port)"], [313, "                        log.info(\"found unit to remove groupin={} node index={}\", g.gindex, ind);"], [322, "        newC.getActiveSegmentView().setEndoff(startOffset-1);"], [325, "        newseg.startoff = startOffset;"], [333, "     * We create a new segment which succeeds the current sequence segment-history. The new segments starts at 'startOffset+1'"], [335, "     * @param startOffset the highest log-offset reached up to now"], [343, "    public CorfuConfiguration getRemoveGroupProposal(long startOffset, int groupind)"], [348, "        SegmentView s = newC.getActiveSegmentView();"], [351, "        s.setEndoff(startOffset);"], [352, "        s = SegmentView.genRemoveGroup(s, groupind, startOffset);"], [353, "        newC.segmentlist.add(s);"], [359, "     * We create a new segment which succeeds the current sequence segment-history. The new segments starts at 'startOffset+1'"], [361, "     * @param startOffset the highest log-offset reached up to now"], [369, "    public CorfuConfiguration getDeployGroupProposal(long startOffset, Endpoint[] newgroup)"], [373, "        SegmentView s = newC.getActiveSegmentView();"], [375, "        s.setEndoff(startOffset);"], [376, "        s = SegmentView.genAddGroup(s, newgroup, startOffset);"], [399, "     *"], [400, "     *  @throws com.microsoft.corfu.TrimmedCorfuException if 'offset' is out of range for the current segment-list"], [402, "\tEntryLocation getLocationForOffset(long offset) throws CorfuException"], [406, "        if (sv == null) throw new TrimmedCorfuException(\"cannot get location for offset \" + offset);"], [407, ""], [454, "\tpublic SegmentView(long startoff, int numgroups, long endoff, int grain,"], [459, "\t\tthis.endoff = endoff;"], [476, "                cloned.endoff,"], [484, "    static public SegmentView genRemoveGroup(SegmentView current, int groupind, long newoff) {"], [485, "        GroupView[] newgroups = new GroupView[current.numgroups-1];"], [487, "        long groupSealSize = (current.endoff - current.startoff + current.numgroups-1) / current.numgroups;"], [488, "            // groupSealSize is the amount of entries per replica-group which was used up in the current segment"], [489, "            // it is needed in order to compute a relative startoffset of the groups remaining in the next segment"], [490, ""], [491, "        int i = 0;"], [492, "        for (GroupView group : current.groups) {"], [493, "            if (group.gindex == groupind) continue;"], [494, "            newgroups[i] = new GroupView(group);"], [495, "            newgroups[i].localstartoff += groupSealSize;"], [496, "            i++;"], [497, "        }"], [498, "        SegmentView news = new SegmentView(current.startoff,"], [499, "                current.numgroups-1,"], [500, "                current.endoff,"], [501, "                current.grain,"], [502, "                newgroups,"], [503, "                current.tokenserver);"], [504, "        news.startoff = newoff;"], [505, "        return news;"], [508, "    static public SegmentView genAddGroup(SegmentView current, Endpoint[] newgroup, long newoff) {"], [509, "        int newsz = current.numgroups+1;"], [510, "        GroupView[] newgroups = new GroupView[newsz];"], [511, "        System.arraycopy(current.groups, 0, newgroups, 0, newsz-1);"], [512, ""], [513, "        newgroups[current.numgroups] = new GroupView(0 /* TODO */,"], [515, "                current.groups[0].localepoch /* TODO*/,"], [517, "                newsz-1);"], [518, "        SegmentView news = new SegmentView(current.startoff,"], [519, "                newsz,"], [520, "                current.endoff,"], [521, "                current.grain,"], [522, "                newgroups,"], [523, "                current.tokenserver);"], [524, "        news.startoff = newoff;"], [525, "        return news;"], [542, "\tint gindex;"], [545, "\t\t\tint numnodes, int gindex) {"], [551, "\t\tthis.gindex = gindex;"], [555, "        this(cloned.localstartoff, new Endpoint[cloned.numnodes], cloned.localepoch, cloned.numnodes, cloned.gindex);"]], "deleted": [[133, "\t/** Obtain the unit size of the currently active segment"], [134, "\t * (TODO shouldn't this permanent and not change with each segment??)"], [135, "\t * @return disk-size of current segment"], [136, "\t */"], [137, "\tpublic int getUnitsize() { return getActiveSegmentView().disksize; }"], [138, ""], [139, "\t/**"], [140, "\t * Obtain the capacity (in grain-size unit) of the current active segment"], [141, "\t * @return capacity (in grain-size units) of the current active segment"], [142, "\t */"], [143, "\tpublic int getCapacity() { return getActiveSegmentView().disksize * getActiveSegmentView().numgroups; }"], [144, ""], [145, ""], [165, "            int disksize = Integer.parseInt(segmentN.getAttributes().getNamedItem(\"disksize\").getNodeValue());"], [170, "            log.info(\"globalepoch {}Segment {} with {} group(s) [{}..{}] grain={}\","], [172, "                    segmentindex, numgroups, startoff, startoff + disksize, grain);"], [182, "                int groupID = Integer.parseInt(groupN.getAttributes().getNamedItem(\"groupID\").getNodeValue());"], [204, "                grouplist[gindex] = new GroupView(localstartoff, corfunodes, groupepoch, numnodes, groupID);"], [207, "            segmentlist.add(new SegmentView(startoff, numgroups, disksize, grain, grouplist, tokenserver));"], [219, "    <GROUP index=\"0\" groupID=\"1\" groupepoch=\"0\" numnodes=\"1\">"], [222, "    <GROUP index=\"1\" groupID=\"2\" groupepoch=\"0\" numnodes=\"1\">"], [248, "            conf.setAttribute(\"disksize\", Integer.toString(s.disksize));"], [257, "                grp.setAttribute(\"groupID\", Integer.toString(gv.groupid));"], [303, "     * We create a new segment which succeeds the current sequence segment-history. The new segments starts at 'highOffset+1'"], [305, "     * @param highOffset the highest log-offset reached up to now"], [313, "    public CorfuConfiguration getRemoveUnitProposal(long highOffset, String hostname, int port)"], [328, "                        log.info(\"found unit to remove groupID={} node index={}\", g.groupid, ind);"], [337, "        newC.getActiveSegmentView().setEndoff(highOffset);"], [340, "        newseg.startoff = highOffset+1;"], [348, "     * We create a new segment which succeeds the current sequence segment-history. The new segments starts at 'highOffset+1'"], [350, "     * @param highOffset the highest log-offset reached up to now"], [358, "    public CorfuConfiguration getRemoveGroupProposal(long highOffset, int groupind)"], [362, "        newC.getActiveSegmentView().setEndoff(highOffset);"], [364, ""], [365, "        SegmentView s = new SegmentView(newC.getActiveSegmentView());"], [367, "        s.removeGroup(groupind);"], [368, "        s.startoff = highOffset+1;"], [369, "        newC.segmentlist.add(s);"], [376, "     * We create a new segment which succeeds the current sequence segment-history. The new segments starts at 'highOffset+1'"], [378, "     * @param highOffset the highest log-offset reached up to now"], [386, "    public CorfuConfiguration getDeployGroupProposal(long highOffset, Endpoint[] newgroup)"], [389, "        newC.getActiveSegmentView().setEndoff(highOffset);"], [392, "        SegmentView s = new SegmentView(newC.getActiveSegmentView());"], [393, "        s.addGroup(newgroup, globalepoch+1);"], [394, "        s.startoff = highOffset+1;"], [396, ""], [419, "\tEntryLocation getLocationForOffset(long offset)"], [466, "\tint disksize;"], [470, "\tpublic SegmentView(long startoff, int numgroups, int disksize, int grain,"], [475, "\t\tthis.disksize = disksize;"], [492, "                cloned.disksize,"], [500, "    void removeGroup(int groupind) {"], [501, "        GroupView[] tempg = new GroupView[groups.length-1];"], [502, "        if (groupind > 0)"], [503, "            System.arraycopy(groups, 0, tempg, 0, groupind);"], [504, "        if (groupind < groups.length-1)"], [505, "            System.arraycopy(groups, groupind+1, tempg, groupind, groups.length-1-groupind);"], [506, "        groups = tempg;"], [507, "        numgroups--;"], [511, "    void addGroup(Endpoint[] newgroup, int localepoch) {"], [512, "        GroupView[] tempg = new GroupView[groups.length+1];"], [513, "        System.arraycopy(groups, 0, tempg, 0, groups.length);"], [514, "        tempg[groups.length] = new GroupView(0 /* TODO */,"], [516, "                localepoch /* TODO*/,"], [518, "                groups.length);"], [519, "        groups = tempg;"], [536, "\tint groupid;"], [539, "\t\t\tint numnodes, int groupid) {"], [545, "\t\tthis.groupid = groupid;"], [549, "        this(cloned.localstartoff, new Endpoint[cloned.numnodes], cloned.localepoch, cloned.numnodes, cloned.groupid);"]]}, "num_lines_added": 76, "num_lines_removed": 70}