{"hash": "48701cc70fde194c05ecd008fc1015b9d82921d1", "message": "- Generalize unused operation removal and remove a couple of special cases (HOOK, NOT).\n- Add handling for other AST locations that can have unused ops removed (COMMA lhs and FOR increment expressions).\n\nR=acleung\nDELTA=358  (260 added, 80 deleted, 18 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION=197245\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@390 b0f006be-c8cd-11de-a2e8-8d36a3108c74", "file_num_lines": 526, "diff_parsed": {"added": [[50, "        subtree = tryFoldExpr(subtree);"], [51, "        return subtree;"], [75, "   * Try folding EXPR_RESULT nodes by removing useless Ops and expressions."], [76, "   * @return the replacement node, if changed, or the original if not"], [77, "   */"], [78, "  private Node tryFoldExpr(Node subtree) {"], [79, "    if (subtree.getParent().getType() != Token.LABEL) {"], [80, "      Node result = trySimpilifyUnusedResult(subtree.getFirstChild());"], [81, "      if (result == null) {"], [82, "        // If the EXPR_RESULT no longer has any children, remove it as well."], [83, "        subtree.detachFromParent();"], [84, "        subtree = null;"], [85, "      }"], [86, "    }"], [87, "    return subtree;"], [88, "  }"], [89, ""], [90, "  /**"], [91, "   * General cascading unused operation node removal."], [92, "   * @param n The root of the expression to simplify."], [93, "   * @return The replacement node, or null if the node was is not useful."], [94, "   */"], [95, "  private Node trySimpilifyUnusedResult(Node n) {"], [96, "    return trySimpilifyUnusedResult(n, true);"], [97, "  }"], [98, ""], [99, "  /**"], [100, "   * General cascading unused operation node removal."], [101, "   * @param n The root of the expression to simplify."], [102, "   * @param removeUnused If true, the node is removed from the AST if"], [103, "   *     it is not useful, otherwise it replaced with an EMPTY node."], [104, "   * @return The replacement node, or null if the node was is not useful."], [105, "   */"], [106, "  private Node trySimpilifyUnusedResult(Node n, boolean removeUnused) {"], [107, "    Node result = n;"], [108, ""], [109, "    // Simplify the results of conditional expressions"], [110, "    switch (n.getType()) {"], [111, "      case Token.HOOK:"], [112, "        Node trueNode = trySimpilifyUnusedResult(n.getFirstChild().getNext());"], [113, "        Node falseNode = trySimpilifyUnusedResult(n.getLastChild());"], [114, "        // If one or more of the conditional children were removed,"], [115, "        // transform the HOOK to an equivalent operation:"], [116, "        //    x() ? foo() : 1 --> x() && foo()"], [117, "        //    x() ? 1 : foo() --> x() || foo()"], [118, "        //    x() ? 1 : 1 --> x()"], [119, "        //    x ? 1 : 1 --> null"], [120, "        if (trueNode == null && falseNode != null) {"], [121, "          n.setType(Token.OR);"], [122, "          Preconditions.checkState(n.getChildCount() == 2);"], [123, "        } else if (trueNode != null && falseNode == null) {"], [124, "          n.setType(Token.AND);"], [125, "          Preconditions.checkState(n.getChildCount() == 2);"], [126, "        } else if (trueNode == null && falseNode == null) {"], [127, "          result = trySimpilifyUnusedResult(n.getFirstChild());"], [128, "        } else {"], [129, "          // The structure didn't change."], [130, "          result = n;"], [131, "        }"], [132, "        break;"], [133, "      case Token.AND:"], [134, "      case Token.OR:"], [135, "        // Try to remove the second operand from a AND or OR operations:"], [136, "        //    x() || f --> x()"], [137, "        //    x() && f --> x()"], [138, "        Node conditionalResultNode = trySimpilifyUnusedResult("], [139, "            n.getLastChild());"], [140, "        if (conditionalResultNode == null) {"], [141, "          Preconditions.checkState(n.hasOneChild());"], [142, "          // The conditionally executed code was removed, so"], [143, "          // replace the AND/OR with its LHS or remove it if it isn't useful."], [144, "          result = trySimpilifyUnusedResult(n.getFirstChild());"], [145, "        }"], [146, "        break;"], [147, "      case Token.FUNCTION:"], [148, "        // A function expression isn't useful if it isn't used, remove it and"], [149, "        // don't bother to look at its children."], [150, "        result = null;"], [151, "        break;"], [152, "      case Token.COMMA:"], [153, "        // We rewrite other operations as COMMA expressions (which will later"], [154, "        // get split into individual EXPR_RESULT statement, if possible), so"], [155, "        // we special case COMMA (we don't want to rewrite COMMAs as new COMMAs"], [156, "        // nodes."], [157, "        Node left = trySimpilifyUnusedResult(n.getFirstChild());"], [158, "        Node right = trySimpilifyUnusedResult(n.getLastChild());"], [159, "        if (left == null && right == null) {"], [160, "          result = null;"], [161, "        } else if (left == null) {"], [162, "          result = right;"], [163, "        } else if (right == null){"], [164, "          result = left;"], [165, "        } else {"], [166, "          // The structure didn't change."], [167, "          result = n;"], [168, "        }"], [169, "        break;"], [170, "      default:"], [171, "        if (!NodeUtil.nodeTypeMayHaveSideEffects(n)) {"], [172, "          // This is the meat of this function. The node itself doesn't generate"], [173, "          // any side-effects but preserve any side-effects in the children."], [174, "          Node resultList = null;"], [175, "          for (Node next, c = n.getFirstChild(); c != null; c = next) {"], [176, "            next = c.getNext();"], [177, "            c = trySimpilifyUnusedResult(c);"], [178, "            if (c != null) {"], [179, "              c.detachFromParent();"], [180, "              if (resultList == null)  {"], [181, "                // The first side-effect can be used stand-alone."], [182, "                resultList = c;"], [183, "              } else {"], [184, "                // Leave the side-effects in-place, simplifying it to a COMMA"], [185, "                // expression."], [186, "                resultList = new Node(Token.COMMA, resultList, c)"], [187, "                    .copyInformationFrom(c);"], [188, "              }"], [189, "            }"], [190, "          }"], [191, "          result = resultList;"], [192, "        }"], [193, "    }"], [194, ""], [195, "    // Fix up the AST, replace or remove the an unused node (if requested)."], [196, "    if (n != result) {"], [197, "      Node parent = n.getParent();"], [198, "      if (result == null) {"], [199, "        if (removeUnused) {"], [200, "          parent.removeChild(n);"], [201, "        } else {"], [202, "          result = new Node(Token.EMPTY).copyInformationFrom(n);"], [203, "          parent.replaceChild(n, result);"], [204, "        }"], [205, "      } else {"], [206, "        // A new COMMA expression may not have an existing parent."], [207, "        if (result.getParent() != null) {"], [208, "          result.detachFromParent();"], [209, "        }"], [210, "        n.getParent().replaceChild(n, result);"], [211, "      }"], [212, "      reportCodeChange();"], [213, "    }"], [214, ""], [215, "    return result;"], [216, "  }"], [217, ""], [218, "  /**"], [385, "    left = trySimpilifyUnusedResult(left, false);"], [386, "    if (left == null || !mayHaveSideEffects(left)) {"], [421, "        // TODO(johnlenz): determine what this is actually removing. Candidates"], [422, "        //    include: EMPTY nodes, control structures without children"], [423, "        //    (removing infinite loops), empty try blocks.  What else?"], [729, "    // If this is a FOR-IN loop skip it."], [730, "    if (NodeUtil.isForIn(n)) {"], [733, ""], [734, "    Node init = n.getFirstChild();"], [735, "    Node cond = init.getNext();"], [736, "    Node increment = cond.getNext();"], [737, ""], [738, "    if (init.getType() != Token.EMPTY && init.getType() != Token.VAR) {"], [739, "      init = trySimpilifyUnusedResult(init, false);"], [740, "    }"], [741, ""], [742, "    if (increment.getType() != Token.EMPTY) {"], [743, "      increment = trySimpilifyUnusedResult(increment, false);"], [744, "    }"], [745, ""], [746, "    // There is an initializer skip it"]], "deleted": [[50, "        return tryFoldHookExpr(subtree);"], [240, "    if (!mayHaveSideEffects(left)) {"], [526, "   * Transform HOOK (?:) to IF if this allows the removal of useless branches."], [527, "   * @return the replacement node, if changed, or the original if not"], [528, "   */"], [529, "  private Node tryFoldHookExpr(Node n) {"], [530, "    Preconditions.checkState(NodeUtil.isExpressionNode(n));"], [531, "    Node hook = n.getFirstChild();"], [532, "    // Only looking at hooks here."], [533, "    if (hook.getType() != Token.HOOK) {"], [534, "      return n;"], [535, "    }"], [536, ""], [537, "    Node parent = n.getParent();"], [538, "    Preconditions.checkNotNull(parent);"], [539, "    Node cond = hook.getFirstChild();"], [540, "    Node thenBody = cond.getNext();"], [541, "    Node elseBody = thenBody.getNext();"], [542, ""], [543, "    // Try to remove useless conditions and branches."], [544, "    if (!mayHaveSideEffects(thenBody)) {"], [545, "      // x?void 0:y --> if(!x)y"], [546, "      Node ifNode = new Node(Token.IF);"], [547, "      if (cond.getType() == Token.NOT) {"], [548, "        Node expr = cond.getFirstChild();"], [549, "        cond.removeChild(expr);"], [550, "        ifNode.addChildToBack(expr);"], [551, "      } else {"], [552, "        Node not = new Node(Token.NOT).copyInformationFrom(cond);"], [553, "        hook.removeChild(cond);"], [554, "        not.addChildToBack(cond);"], [555, "        ifNode.addChildToBack(not);"], [556, "      }"], [557, ""], [558, "      hook.removeChild(elseBody);"], [559, "      ifNode.addChildToBack("], [560, "          new Node(Token.BLOCK, NodeUtil.newExpr(elseBody))"], [561, "              .copyInformationFrom(elseBody));"], [562, ""], [563, "      parent.replaceChild(n, ifNode);"], [564, "      reportCodeChange();"], [565, "      return ifNode;"], [566, "    } else if (!mayHaveSideEffects(elseBody)) {"], [567, "      // x?y:void 0 --> if(x)y"], [568, "      Node ifNode = new Node(Token.IF);"], [569, "      hook.removeChild(cond);"], [570, "      ifNode.addChildToBack(cond);"], [571, "      hook.removeChild(thenBody);"], [572, ""], [573, "      ifNode.addChildToBack("], [574, "          new Node(Token.BLOCK, NodeUtil.newExpr(thenBody))"], [575, "              .copyInformationFrom(thenBody));"], [576, ""], [577, "      parent.replaceChild(n, ifNode);"], [578, "      reportCodeChange();"], [579, "      return ifNode;"], [580, "    }"], [581, ""], [582, "    return n;"], [583, "  }"], [584, ""], [585, "  /**"], [640, "    // This is not a FOR-IN loop"], [641, "    if (n.getChildCount() != 4) {"], [644, "    // There isn't an initializer"], [649, "    Node cond = NodeUtil.getConditionExpression(n);"]]}, "num_lines_added": 167, "num_lines_removed": 66}