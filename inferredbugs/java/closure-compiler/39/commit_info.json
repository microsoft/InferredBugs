{"hash": "93252fd6ea544d95224e3758576bc1d1ab580b5c", "message": "Don't keep a stack of CFGs during UnreachableCodeElimination.\n\nR=blickly\nDELTA=259  (85 added, 77 deleted, 97 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION=5950\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@2377 b0f006be-c8cd-11de-a2e8-8d36a3108c74", "file_num_lines": 149, "diff_parsed": {"added": [[22, "import com.google.javascript.jscomp.NodeTraversal.AbstractShallowCallback;"], [61, "  public void exitScope(NodeTraversal t) {"], [67, "    ControlFlowGraph<Node> cfg = cfa.getCfg();"], [69, "    new GraphReachability<Node, ControlFlowGraph.Branch>(cfg)"], [70, "        .compute(cfg.getEntry().getValue());"], [72, "    Node root = scope.getRootNode();"], [73, "    if (scope.isLocal()) {"], [74, "      root = root.getLastChild();"], [75, "    }"], [76, "    NodeTraversal.traverse("], [77, "        compiler, root, new EliminationPass(cfg));"], [85, "  private class EliminationPass extends AbstractShallowCallback {"], [86, "    private final ControlFlowGraph<Node> cfg;"], [87, "    private EliminationPass(ControlFlowGraph<Node> cfg) {"], [88, "      this.cfg = cfg;"], [91, "    @Override"], [92, "    public void visit(NodeTraversal t, Node n, Node parent) {"], [93, "      if (parent == null) {"], [94, "        return;"], [95, "      }"], [96, "      if (n.isFunction() || n.isScript()) {"], [97, "        return;"], [98, "      }"], [100, "      DiGraphNode<Node, Branch> gNode = cfg.getDirectedGraphNode(n);"], [101, "      if (gNode == null) { // Not in CFG."], [102, "        return;"], [103, "      }"], [104, "      if (gNode.getAnnotation() != GraphReachability.REACHABLE ||"], [105, "          (removeNoOpStatements && !NodeUtil.mayHaveSideEffects(n, compiler))) {"], [106, "        removeDeadExprStatementSafely(n);"], [107, "        return;"], [108, "      }"], [109, ""], [110, "      tryRemoveUnconditionalBranching(n);"], [111, "    }"], [113, "    /**"], [114, "     * Tries to remove n if it is an unconditional branch node (break, continue,"], [115, "     * or return) and the target of n is the same as the the follow of n."], [116, "     * That is, if removing n preserves the control flow. Also if n targets"], [117, "     * another unconditional branch, this function will recursively try to remove"], [118, "     * the target branch as well. The reason why we want to cascade this removal"], [119, "     * is because we only run this pass once. If we have code such as"], [121, "     * break -> break -> break"], [122, "     *"], [123, "     * where all 3 breaks are useless, then the order of removal matters. When we"], [124, "     * first look at the first break, we see that it branches to the 2nd break."], [125, "     * However, if we remove the last break, the 2nd break becomes useless and"], [126, "     * finally the first break becomes useless as well."], [127, "     *"], [128, "     * @return The target of this jump. If the target is also useless jump,"], [129, "     *     the target of that useless jump recursively."], [131, "    @SuppressWarnings(\"fallthrough\")"], [132, "    private Node tryRemoveUnconditionalBranching(Node n) {"], [133, "      /*"], [134, "       * For each unconditional branching control flow node, check to see"], [135, "       * if the ControlFlowAnalysis.computeFollowNode of that node is same as"], [136, "       * the branching target. If it is, the branch node is safe to be removed."], [137, "       *"], [138, "       * This is not as clever as MinimizeExitPoints because it doesn't do any"], [139, "       * if-else conversion but it handles more complicated switch statements"], [140, "       * much more nicely."], [141, "       */"], [142, ""], [143, "      // If n is null the target is the end of the function, nothing to do."], [144, "      if (n == null) {"], [145, "         return n;"], [146, "      }"], [148, "      DiGraphNode<Node, Branch> gNode = cfg.getDirectedGraphNode(n);"], [150, "      if (gNode == null) {"], [151, "        return n;"], [152, "      }"], [154, "      switch (n.getType()) {"], [155, "        case Token.RETURN:"], [156, "          if (n.hasChildren()) {"], [157, "            break;"], [158, "          }"], [159, "        case Token.BREAK:"], [160, "        case Token.CONTINUE:"], [161, ""], [162, "          // We are looking for a control flow changing statement that always"], [163, "          // branches to the same node. If after removing it control still"], [164, "          // branches to the same node, it is safe to remove."], [165, "          List<DiGraphEdge<Node,Branch>> outEdges = gNode.getOutEdges();"], [166, "          if (outEdges.size() == 1 &&"], [167, "              // If there is a next node, there is no chance this jump is useless."], [168, "              (n.getNext() == null || n.getNext().isFunction())) {"], [169, ""], [170, "            Preconditions.checkState(outEdges.get(0).getValue() == Branch.UNCOND);"], [171, "            Node fallThrough = computeFollowing(n);"], [172, "            Node nextCfgNode = outEdges.get(0).getDestination().getValue();"], [173, "            if (nextCfgNode == fallThrough) {"], [174, "              removeDeadExprStatementSafely(n);"], [175, "              return fallThrough;"], [176, "            }"], [177, "          }"], [178, "      }"], [182, "    private Node computeFollowing(Node n) {"], [183, "      Node next = ControlFlowAnalysis.computeFollowNode(n);"], [184, "      while (next != null && next.isBlock()) {"], [185, "        if (next.hasChildren()) {"], [186, "          next = next.getFirstChild();"], [187, "        } else {"], [188, "          next = computeFollowing(next);"], [191, "      return next;"], [194, "    private void removeDeadExprStatementSafely(Node n) {"], [195, "      Node parent = n.getParent();"], [196, "      if (n.isEmpty() ||"], [197, "          (n.isBlock() && !n.hasChildren())) {"], [198, "        // Not always trivial to remove, let FoldConstants work its magic later."], [199, "        return;"], [200, "      }"], [202, "      // TODO(user): This is a problem with removeNoOpStatements."], [203, "      // Every expression in a FOR-IN header looks side effect free on its own."], [204, "      if (NodeUtil.isForIn(parent)) {"], [206, "      }"], [208, "      switch (n.getType()) {"], [209, "        // Removing an unreachable DO node is messy because it means we still have"], [210, "        // to execute one iteration. If the DO's body has breaks in the middle, it"], [211, "        // can get even more tricky and code size might actually increase."], [212, "        case Token.DO:"], [213, "          return;"], [214, ""], [215, "        case Token.BLOCK:"], [216, "          // BLOCKs are used in several ways including wrapping CATCH"], [217, "          // blocks in TRYs"], [218, "          if (parent.isTry()) {"], [219, "            if (NodeUtil.isTryCatchNodeContainer(n)) {"], [220, "              return;"], [221, "            }"], [223, "          break;"], [225, "        case Token.CATCH:"], [226, "          Node tryNode = parent.getParent();"], [227, "          NodeUtil.maybeAddFinally(tryNode);"], [228, "          break;"], [229, "      }"], [232, "      if (n.isVar() && !n.getFirstChild().hasChildren()) {"], [233, "        // Very Edge case, Consider this:"], [234, "        // File 1: {throw 1}"], [235, "        // File 2: {var x}"], [236, "        // The node var x is unreachable in the global scope."], [237, "        // Before we remove the node, redeclareVarsInsideBranch"], [238, "        // would basically move var x to the beginning of File 2,"], [239, "        // which resulted in zero changes to the AST but triggered"], [240, "        // reportCodeChange()."], [241, "        // Instead, we should just ignore dead variable declarations."], [242, "        return;"], [243, "      }"], [245, "      NodeUtil.redeclareVarsInsideBranch(n);"], [246, "      compiler.reportCodeChange();"], [247, "      if (logger.isLoggable(Level.FINE)) {"], [248, "        logger.fine(\"Removing \" + n.toString());"], [249, "      }"], [251, "      NodeUtil.removeChild(n.getParent(), n);"], [252, "    }"], [254, ""], [255, "  @Override"], [256, "  public void visit(NodeTraversal t, Node n, Node parent) {}"], [257, ""], [258, "  @Override"], [259, "  public void enterScope(NodeTraversal t) {}"]], "deleted": [[29, "import java.util.Deque;"], [30, "import java.util.LinkedList;"], [55, "  Deque<ControlFlowGraph<Node>> cfgStack ="], [56, "      new LinkedList<ControlFlowGraph<Node>>();"], [57, ""], [58, "  ControlFlowGraph<Node> curCfg = null;"], [59, ""], [67, "  public void enterScope(NodeTraversal t) {"], [73, "    cfgStack.push(curCfg);"], [74, "    curCfg = cfa.getCfg();"], [76, "    new GraphReachability<Node, ControlFlowGraph.Branch>(curCfg)"], [77, "        .compute(curCfg.getEntry().getValue());"], [78, "  }"], [80, "  @Override"], [81, "  public void exitScope(NodeTraversal t) {"], [82, "    curCfg = cfgStack.pop();"], [90, "  @Override"], [91, "  public void visit(NodeTraversal t, Node n, Node parent) {"], [92, "    if (parent == null) {"], [93, "      return;"], [94, "    }"], [95, "    if (n.isFunction() || n.isScript()) {"], [96, "      return;"], [99, "    DiGraphNode<Node, Branch> gNode = curCfg.getDirectedGraphNode(n);"], [100, "    if (gNode == null) { // Not in CFG."], [101, "      return;"], [102, "    }"], [103, "    if (gNode.getAnnotation() != GraphReachability.REACHABLE ||"], [104, "        (removeNoOpStatements && !NodeUtil.mayHaveSideEffects(n, compiler))) {"], [105, "      removeDeadExprStatementSafely(n);"], [106, "      return;"], [107, "    }"], [109, "    tryRemoveUnconditionalBranching(n);"], [110, "  }"], [112, "  /**"], [113, "   * Tries to remove n if it is an unconditional branch node (break, continue,"], [114, "   * or return) and the target of n is the same as the the follow of n."], [115, "   * That is, if removing n preserves the control flow. Also if n targets"], [116, "   * another unconditional branch, this function will recursively try to remove"], [117, "   * the target branch as well. The reason why we want to cascade this removal"], [118, "   * is because we only run this pass once. If we have code such as"], [119, "   *"], [120, "   * break -> break -> break"], [121, "   *"], [122, "   * where all 3 breaks are useless, then the order of removal matters. When we"], [123, "   * first look at the first break, we see that it branches to the 2nd break."], [124, "   * However, if we remove the last break, the 2nd break becomes useless and"], [125, "   * finally the first break becomes useless as well."], [126, "   *"], [127, "   * @return The target of this jump. If the target is also useless jump,"], [128, "   *     the target of that useless jump recursively."], [129, "   */"], [130, "  @SuppressWarnings(\"fallthrough\")"], [131, "  private Node tryRemoveUnconditionalBranching(Node n) {"], [132, "    /*"], [133, "     * For each unconditional branching control flow node, check to see"], [134, "     * if the ControlFlowAnalysis.computeFollowNode of that node is same as"], [135, "     * the branching target. If it is, the branch node is safe to be removed."], [137, "     * This is not as clever as MinimizeExitPoints because it doesn't do any"], [138, "     * if-else conversion but it handles more complicated switch statements"], [139, "     * much more nicely."], [142, "    // If n is null the target is the end of the function, nothing to do."], [143, "    if (n == null) {"], [144, "       return n;"], [145, "    }"], [147, "    DiGraphNode<Node, Branch> gNode = curCfg.getDirectedGraphNode(n);"], [149, "    if (gNode == null) {"], [153, "    switch (n.getType()) {"], [154, "      case Token.RETURN:"], [155, "        if (n.hasChildren()) {"], [156, "          break;"], [157, "        }"], [158, "      case Token.BREAK:"], [159, "      case Token.CONTINUE:"], [160, ""], [161, "        // We are looking for a control flow changing statement that always"], [162, "        // branches to the same node. If after removing it control still"], [163, "        // branches to the same node, it is safe to remove."], [164, "        List<DiGraphEdge<Node,Branch>> outEdges = gNode.getOutEdges();"], [165, "        if (outEdges.size() == 1 &&"], [166, "            // If there is a next node, there is no chance this jump is useless."], [167, "            (n.getNext() == null || n.getNext().isFunction())) {"], [168, ""], [169, "          Preconditions.checkState(outEdges.get(0).getValue() == Branch.UNCOND);"], [170, "          Node fallThrough = computeFollowing(n);"], [171, "          Node nextCfgNode = outEdges.get(0).getDestination().getValue();"], [172, "          if (nextCfgNode == fallThrough) {"], [173, "            removeDeadExprStatementSafely(n);"], [174, "            return fallThrough;"], [175, "          }"], [177, "    }"], [178, "    return n;"], [179, "  }"], [180, ""], [181, "  private Node computeFollowing(Node n) {"], [182, "    Node next = ControlFlowAnalysis.computeFollowNode(n);"], [183, "    while (next != null && next.isBlock()) {"], [184, "      if (next.hasChildren()) {"], [185, "        next = next.getFirstChild();"], [186, "      } else {"], [187, "        next = computeFollowing(next);"], [190, "    return next;"], [191, "  }"], [193, "  private void removeDeadExprStatementSafely(Node n) {"], [194, "    Node parent = n.getParent();"], [195, "    if (n.isEmpty() ||"], [196, "        (n.isBlock() && !n.hasChildren())) {"], [197, "      // Not always trivial to remove, let FoldConstants work its magic later."], [198, "      return;"], [199, "    }"], [200, ""], [201, "    // TODO(user): This is a problem with removeNoOpStatements."], [202, "    // Every expression in a FOR-IN header looks side effect free on its own."], [203, "    if (NodeUtil.isForIn(parent)) {"], [204, "      return;"], [205, "    }"], [207, "    switch (n.getType()) {"], [208, "      // Removing an unreachable DO node is messy because it means we still have"], [209, "      // to execute one iteration. If the DO's body has breaks in the middle, it"], [210, "      // can get even more tricky and code size might actually increase."], [211, "      case Token.DO:"], [214, "      case Token.BLOCK:"], [215, "        // BLOCKs are used in several ways including wrapping CATCH"], [216, "        // blocks in TRYs"], [217, "        if (parent.isTry()) {"], [218, "          if (NodeUtil.isTryCatchNodeContainer(n)) {"], [219, "            return;"], [221, "        }"], [222, "        break;"], [224, "      case Token.CATCH:"], [225, "        Node tryNode = parent.getParent();"], [226, "        NodeUtil.maybeAddFinally(tryNode);"], [227, "        break;"], [228, "    }"], [231, "    if (n.isVar() && !n.getFirstChild().hasChildren()) {"], [232, "      // Very Edge case, Consider this:"], [233, "      // File 1: {throw 1}"], [234, "      // File 2: {var x}"], [235, "      // The node var x is unreachable in the global scope."], [236, "      // Before we remove the node, redeclareVarsInsideBranch"], [237, "      // would basically move var x to the beginning of File 2,"], [238, "      // which resulted in zero changes to the AST but triggered"], [239, "      // reportCodeChange()."], [240, "      // Instead, we should just ignore dead variable declarations."], [241, "      return;"], [242, "    }"], [244, "    NodeUtil.redeclareVarsInsideBranch(n);"], [245, "    compiler.reportCodeChange();"], [246, "    if (logger.isLoggable(Level.FINE)) {"], [247, "      logger.fine(\"Removing \" + n.toString());"], [248, "    }"], [250, "    NodeUtil.removeChild(n.getParent(), n);"]]}, "num_lines_added": 160, "num_lines_removed": 152}