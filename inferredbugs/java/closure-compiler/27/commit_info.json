{"hash": "18251df2a0584c8316911593de20fc0fbf0a5cb1", "message": "Always declare a symbol for 'this', even if there are no\nreferences to it.\nThis almost gets the new JS indexer up to feature parity with\nthe old one.\nThis makes some fundamental changes in how \"this\" is represented\nin the SymbolTable codegraph, and I think this should make the\ncode a lot more flexible, so that we can expose \"this\" in\nmany different ways without changes to jscompiler.\n\nR=stevey,acleung\nDELTA=399  (227 added, 75 deleted, 97 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION=3564\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@1533 b0f006be-c8cd-11de-a2e8-8d36a3108c74", "file_num_lines": 767, "diff_parsed": {"added": [[135, "  public List<Reference> getReferenceList(Symbol symbol) {"], [136, "    return ImmutableList.copyOf(symbol.references.values());"], [137, "  }"], [138, ""], [170, "    return declareSymbol(name, null, true, scope, declNode, null);"], [237, "    if (scope.getSymbolForScope() == null) {"], [238, "      scope.setSymbolForScope(findSymbolForScope(scope));"], [240, "    return scope.getSymbolForScope();"], [241, "  }"], [243, "  /**"], [244, "   * Find the symbol associated with the given scope."], [245, "   * Notice that we won't always be able to figure out this association"], [246, "   * dynamically, so sometimes we'll just create the association when we"], [247, "   * create the scope."], [248, "   */"], [249, "  private Symbol findSymbolForScope(SymbolScope scope) {"], [251, "    if (rootNode.getParent() == null) {"], [252, "      return globalScope.getSlot(GLOBAL_THIS);"], [253, "    }"], [254, ""], [496, "  private Symbol addSymbol("], [497, "      String name, JSType type, boolean inferred, SymbolScope scope,"], [498, "      Node declNode) {"], [504, "    return symbol;"], [505, "  }"], [507, "  private Symbol declareSymbol("], [508, "      String name, JSType type, boolean inferred,"], [509, "      SymbolScope scope, Node declNode, JSDocInfo info) {"], [510, "    Symbol symbol = addSymbol(name, type, inferred, scope, declNode);"], [511, "    symbol.setJSDocInfo(info);"], [512, "    symbol.setDeclaration(symbol.defineReferenceAt(declNode));"], [557, "  void fillPropertyScopes() {"], [558, "    // Collect all object symbols."], [559, "    List<Symbol> types = Lists.newArrayList();"], [560, "    for (Symbol sym : getAllSymbols()) {"], [561, "      JSType type = sym.getType();"], [562, "      ObjectType dereferenced = type == null ? null : type.dereference();"], [563, "      if (dereferenced != null) {"], [564, "        types.add(sym);"], [565, "      }"], [566, "    }"], [567, ""], [568, "    // Create a property scope for each symbol, and populate"], [569, "    // it with that symbol's properties."], [570, "    //"], [571, "    // The order of operations here is significant."], [572, "    //"], [573, "    // When we add properties to Foo, we'll remove Foo.prototype from"], [574, "    // the symbol table and replace it with a fresh symbol in Foo's"], [575, "    // property scope. So the symbol for Foo.prototype in"], [576, "    // {@code instances} will be stale."], [577, "    //"], [578, "    // To prevent this, we sort the list by the reverse of the"], [579, "    // default symbol order, which will do the right thing."], [580, "    Collections.sort(types,"], [581, "        Collections.reverseOrder(getNaturalSymbolOrdering()));"], [582, "    for (Symbol s : types) {"], [583, "      createPropertyScopeFor(s);"], [584, "    }"], [585, "  }"], [586, ""], [646, "  /**"], [647, "   * Build a property scope for the given symbol. Any properties of the symbol"], [648, "   * will be added to the property scope."], [649, "   *"], [650, "   * It is important that property scopes are created in order from the leaves"], [651, "   * up to the root, so this should only be called from #fillPropertyScopes."], [652, "   * If you try to create a property scope for a parent before its leaf,"], [653, "   * then the leaf will get cut and re-added to the parent property scope,"], [654, "   * and weird things will happen."], [655, "   */"], [666, "    ObjectType type = s.getType() == null ? null : s.getType().toObjectType();"], [667, "    if (type == null) {"], [668, "      return;"], [669, "    }"], [670, ""], [690, "    s.setPropertyScope(new SymbolScope(null, parentPropertyScope, type, s));"], [713, "        newSym.setPropertyScope(oldProp.propertyScope);"], [755, "          otherScope.getTypeOfThis(),"], [756, "          null);"], [792, "    public Reference defineReferenceAt(Node n) {"], [793, "      Reference result = references.get(n);"], [794, "      if (result == null) {"], [795, "        result = new Reference(this, n);"], [796, "        references.put(n, result);"], [798, "      return result;"], [829, "    void setPropertyScope(SymbolScope scope) {"], [830, "      this.propertyScope = scope;"], [831, "      if (scope != null) {"], [832, "        this.propertyScope.setSymbolForScope(this);"], [833, "      }"], [834, "    }"], [835, ""], [866, "    // The symbol associated with a property scope."], [867, "    private Symbol mySymbol;"], [868, ""], [872, "        JSType typeOfThis,"], [873, "        Symbol mySymbol) {"], [878, "      this.mySymbol = mySymbol;"], [879, "    }"], [880, ""], [881, "    Symbol getSymbolForScope() {"], [882, "      return mySymbol;"], [883, "    }"], [884, ""], [885, "    void setSymbolForScope(Symbol sym) {"], [886, "      this.mySymbol = sym;"], [1004, "      extends NodeTraversal.AbstractScopedCallback"], [1008, "    // The 'this' symbols in the current scope chain."], [1009, "    //"], [1010, "    // If we don't know how to declare 'this' in a scope chain,"], [1011, "    // then null should be on the stack. But this should be a rare"], [1012, "    // occurrence. We should strive to always be able to come up"], [1013, "    // with some symbol for 'this'."], [1014, "    private final List<Symbol> thisStack = Lists.newArrayList();"], [1015, ""], [1029, "    public void enterScope(NodeTraversal t) {"], [1032, "        // Declare the global this at the first input root."], [1033, "        // This is a bizarre place to put it, but we need some"], [1034, "        // location with a real file path (because all symbols"], [1035, "        // must have a path)."], [1036, "        // Note that root.lastChild.firstChild is the first non-extern input."], [1037, "        Node firstInputRoot = t.getScopeRoot().getLastChild().getFirstChild();"], [1038, "        if (firstInputRoot != null) {"], [1039, "          symbol = addSymbol("], [1044, "              firstInputRoot);"], [1045, "          symbol.setDeclaration(new Reference(symbol, firstInputRoot));"], [1054, "          if (propScope != null) {"], [1055, "            // If a function is assigned multiple times, we only want"], [1056, "            // one addressable \"this\" symbol."], [1057, "            symbol = propScope.getOwnSlot(\"this\");"], [1058, "            if (symbol == null) {"], [1059, "              JSType rootType = t.getScopeRoot().getJSType();"], [1060, "              FunctionType fnType = rootType == null"], [1061, "                  ? null : rootType.toMaybeFunctionType();"], [1062, "              JSType type = fnType == null"], [1063, "                  ? null : fnType.getTypeOfThis();"], [1064, "              symbol = addSymbol("], [1065, "                  \"this\","], [1066, "                  type,"], [1067, "                  false /* declared */,"], [1068, "                  scope,"], [1069, "                  t.getScopeRoot());"], [1070, "            }"], [1071, ""], [1072, "            // TODO(nicksantos): It's non-obvious where the declaration of"], [1073, "            // the 'this' symbol should be. Figure this out later."], [1078, "      thisStack.add(symbol);"], [1079, "    }"], [1080, ""], [1081, "    @Override"], [1082, "    public void exitScope(NodeTraversal t) {"], [1083, "      thisStack.remove(thisStack.size() - 1);"], [1084, "    }"], [1085, ""], [1086, "    @Override"], [1087, "    public void visit(NodeTraversal t, Node n, Node parent) {"], [1088, "      if (n.getType() != Token.THIS) {"], [1089, "        return;"], [1090, "      }"], [1091, ""], [1092, "      Symbol symbol = thisStack.get(thisStack.size() - 1);"], [1094, "        Reference ref = symbol.defineReferenceAt(n);"], [1095, "        if (symbol.getDeclaration() == null) {"], [1096, "          symbol.setDeclaration(ref);"], [1097, "        }"], [1160, "      // Source position is a bit mask of line in the top 4 bits, so this"], [1161, "      // is a quick way to compare order without computing absolute position."], [1176, "      if (a.getDeclaration() == null && b.getDeclaration() == null) {"], [1177, "        return a.getName().compareTo(b.getName());"], [1178, "      } else if (a.getDeclaration() == null) {"], [1180, "      } else if (b.getDeclaration() == null) {"], [1181, "        return 1;"], [1184, "      // Make sure that Ctor comes before Ctor.prototype, even though"], [1185, "      // they're on the same node."], [1186, "      if (b.getName().endsWith(\".prototype\") &&"], [1187, "          b.getName().equals(a.getName() + \".prototype\")) {"], [1188, "        return -1;"], [1189, "      } else if (a.getName().endsWith(\".prototype\") &&"], [1190, "          a.getName().equals(b.getName() + \".prototype\")) {"]], "deleted": [[166, "    Symbol symbol = new Symbol(name, null, true, scope);"], [167, "    symbols.put(declNode, name, symbol);"], [168, ""], [169, "    Symbol replacement = scope.ownSymbols.put(name, symbol);"], [170, "    Preconditions.checkState(replacement == null, \"duplicate symbol\");"], [171, ""], [172, "    symbol.setDeclaration(new Reference(symbol, declNode));"], [173, "    return symbol;"], [240, "    if (scope.isPropertyScope()) {"], [241, "      return getSymbolForTypeHelper(scope.getTypeOfThis(), false);"], [486, "  private Symbol declareSymbol("], [487, "      String name, JSType type, boolean inferred,"], [488, "      SymbolScope scope, Node declNode, JSDocInfo info) {"], [490, "    symbol.setJSDocInfo(info);"], [496, "    symbol.setDeclaration(new Reference(symbol, declNode));"], [568, "    // Collect all ctors and interface ctors."], [569, "    // We need to create these lists first, so that we don't end up"], [570, "    // mutating the symbol table while we're creating new symbols."], [571, "    List<Symbol> types = Lists.newArrayList();"], [572, "    List<Symbol> instances = Lists.newArrayList();"], [573, "    for (Symbol sym : getAllSymbols()) {"], [574, "      FunctionType t = sym.getFunctionType();"], [575, "      if (t != null && t.isNominalConstructor()) {"], [576, "        types.add(sym);"], [577, ""], [578, "        Symbol instance = getSymbolForInstancesOf(t);"], [579, "        if (instance != null) {"], [580, "          instances.add(instance);"], [581, "        }"], [582, "      }"], [583, "    }"], [584, ""], [585, "    // Create a property scope for each symbol, and populate"], [586, "    // it with that symbol's properties."], [587, "    //"], [588, "    // The order of operations here is significant."], [589, "    //"], [590, "    // When we add properties to Foo, we'll remove Foo.prototype from"], [591, "    // the symbol table and replace it with a fresh symbol in Foo's"], [592, "    // property scope. So the symbol for Foo.prototype in"], [593, "    // {@code instances} will be stale."], [594, "    //"], [595, "    // To prevent this, we always populate {@code instances} before"], [596, "    // their constructors."], [597, "    for (Symbol s : instances) {"], [598, "      createPropertyScopeFor(s);"], [599, "    }"], [600, ""], [601, "    for (Symbol s : types) {"], [602, "      createPropertyScopeFor(s);"], [603, "    }"], [604, ""], [647, "    ObjectType type = s.getType().toObjectType();"], [667, "    s.propertyScope = new SymbolScope(null, parentPropertyScope, type);"], [690, "        newSym.propertyScope = oldProp.propertyScope;"], [732, "          otherScope.getTypeOfThis());"], [768, "    public void defineReferenceAt(Node n) {"], [769, "      if (!references.containsKey(n)) {"], [770, "        references.put(n, new Reference(this, n));"], [778, "      references.put(ref.getNode(), ref);"], [836, "        JSType typeOfThis) {"], [958, "      extends NodeTraversal.AbstractPostOrderCallback"], [975, "    public void visit(NodeTraversal t, Node n, Node parent) {"], [976, "      if (n.getType() != Token.THIS) {"], [977, "        return;"], [978, "      }"], [979, ""], [982, "        // declare the global this at the first place it's used."], [983, "        if (globalScope.getSlot(GLOBAL_THIS) == null) {"], [984, "          symbol = declareSymbol("], [989, "              n,"], [990, "              null);"], [991, "        } else {"], [992, "          symbol = globalScope.getSlot(GLOBAL_THIS);"], [1000, "          createPropertyScopeFor(scopeSymbol);"], [1001, ""], [1003, "          symbol = propScope.getSlot(\"this\");"], [1004, "          if (symbol == null) {"], [1005, "            JSType type = n.getJSType();"], [1006, "            symbol = declareSymbol("], [1007, "                \"this\","], [1008, "                type,"], [1009, "                type != null && !type.isUnknownType(),"], [1010, "                propScope,"], [1011, "                n,"], [1012, "                null);"], [1018, "        symbol.defineReferenceAt(n);"], [1095, "      if (scopeA.isLexicalScope() && !scopeB.isLexicalScope()) {"], [1099, "      if (scopeB.isLexicalScope() && !scopeA.isLexicalScope()) {"]]}, "num_lines_added": 180, "num_lines_removed": 89}