{"hash": "f6dec3e5798a916fd7862205c58edfea87d8cd43", "message": "Fix to prevent data loss and stuck shards in the event of failed records delivery in Polling readers (#603)\n\n* Fix to prevent data loss and stuck shards in the event of failed records delivery.\r\n\r\n* Review comment fixes\r\n\r\n* Access specifiers fix", "file_num_lines": 422, "diff_parsed": {"added": [[36, "import static software.amazon.kinesis.utils.BlockingUtils.blockUntilRecordsAvailable;"], [48, "import java.util.concurrent.ScheduledExecutorService;"], [49, "import java.util.concurrent.TimeUnit;"], [56, "import io.reactivex.plugins.RxJavaPlugins;"], [83, "import software.amazon.kinesis.retrieval.RecordsPublisher;"], [151, "        ProcessRecordsInput result = blockUntilRecordsAvailable(getRecordsCache::pollNextResultAndUpdatePrefetchCounters, 1000L)"], [152, "                .processRecordsInput();"], [192, "        assertTrue(\"Call Rate is \"+callRate,callRate < MAX_SIZE);"], [221, "        ProcessRecordsInput processRecordsInput = getRecordsCache.pollNextResultAndUpdatePrefetchCounters().processRecordsInput();"], [230, "        ProcessRecordsInput processRecordsInput2 = getRecordsCache.pollNextResultAndUpdatePrefetchCounters().processRecordsInput();"], [241, "        getRecordsCache.pollNextResultAndUpdatePrefetchCounters();"], [247, "        getRecordsCache.pollNextResultAndUpdatePrefetchCounters();"], [260, "        blockUntilRecordsAvailable(() -> getRecordsCache.pollNextResultAndUpdatePrefetchCounters(), 1000L);"], [275, "        RecordsRetrieved records = blockUntilRecordsAvailable(getRecordsCache::pollNextResultAndUpdatePrefetchCounters, 1000);"], [279, "    @Test(timeout = 20000L)"], [293, "        RxJavaPlugins.setErrorHandler(e -> e.printStackTrace());"], [294, ""], [307, "        final int expectedItems = MAX_SIZE * 1000;"], [362, "    @Test(timeout = 20000L)"], [363, "    public void testNoDeadlockOnFullQueueAndLossOfNotification() {"], [364, "        //"], [365, "        // Fixes https://github.com/awslabs/amazon-kinesis-client/issues/602"], [366, "        //"], [367, "        // This test is to verify that the data consumption is not stuck in the case of an failed event delivery"], [368, "        // to the subscriber."], [369, "        GetRecordsResponse response = GetRecordsResponse.builder().records("], [370, "                Record.builder().data(SdkBytes.fromByteArray(new byte[] { 1, 2, 3 })).sequenceNumber(\"123\").build())"], [371, "                .build();"], [372, "        when(getRecordsRetrievalStrategy.getRecords(anyInt())).thenReturn(response);"], [373, ""], [374, "        getRecordsCache.start(sequenceNumber, initialPosition);"], [375, ""], [376, "        //"], [377, "        // Wait for the queue to fill up, and the publisher to block on adding items to the queue."], [378, "        //"], [379, "        log.info(\"Waiting for queue to fill up\");"], [380, "        while (getRecordsCache.getRecordsResultQueue.size() < MAX_SIZE) {"], [381, "            Thread.yield();"], [382, "        }"], [383, ""], [384, "        log.info(\"Queue is currently at {} starting subscriber\", getRecordsCache.getRecordsResultQueue.size());"], [385, "        AtomicInteger receivedItems = new AtomicInteger(0);"], [386, "        final int expectedItems = MAX_SIZE * 100;"], [387, ""], [388, "        Object lock = new Object();"], [389, ""], [390, "        Subscriber<RecordsRetrieved> delegateSubscriber = new Subscriber<RecordsRetrieved>() {"], [391, "            Subscription sub;"], [392, ""], [393, "            @Override"], [394, "            public void onSubscribe(Subscription s) {"], [395, "                sub = s;"], [396, "                s.request(1);"], [397, "            }"], [398, ""], [399, "            @Override"], [400, "            public void onNext(RecordsRetrieved recordsRetrieved) {"], [401, "                receivedItems.incrementAndGet();"], [402, "                if (receivedItems.get() >= expectedItems) {"], [403, "                    synchronized (lock) {"], [404, "                        log.info(\"Notifying waiters\");"], [405, "                        lock.notifyAll();"], [406, "                    }"], [407, "                    sub.cancel();"], [408, "                } else {"], [409, "                    sub.request(1);"], [410, "                }"], [411, "            }"], [412, ""], [413, "            @Override"], [414, "            public void onError(Throwable t) {"], [415, "                log.error(\"Caught error\", t);"], [416, "                throw new RuntimeException(t);"], [417, "            }"], [418, ""], [419, "            @Override"], [420, "            public void onComplete() {"], [421, "                fail(\"onComplete not expected in this test\");"], [422, "            }"], [423, "        };"], [424, ""], [425, "        Subscriber<RecordsRetrieved> subscriber = new LossyNotificationSubscriber(delegateSubscriber, getRecordsCache);"], [426, ""], [427, "        synchronized (lock) {"], [428, "            log.info(\"Awaiting notification\");"], [429, "            Flowable.fromPublisher(getRecordsCache).subscribeOn(Schedulers.computation())"], [430, "                    .observeOn(Schedulers.computation(), true, 8).subscribe(subscriber);"], [431, "            try {"], [432, "                lock.wait();"], [433, "            } catch (InterruptedException e) {"], [434, "                throw new RuntimeException(e);"], [435, "            }"], [436, "        }"], [437, "        verify(getRecordsRetrievalStrategy, atLeast(expectedItems)).getRecords(anyInt());"], [438, "        assertThat(receivedItems.get(), equalTo(expectedItems));"], [439, "    }"], [440, ""], [462, "        RecordsRetrieved lastProcessed = blockUntilRecordsAvailable(getRecordsCache::pollNextResultAndUpdatePrefetchCounters, 1000);"], [463, "        RecordsRetrieved expected = blockUntilRecordsAvailable(getRecordsCache::pollNextResultAndUpdatePrefetchCounters, 1000);"], [468, "        blockUntilRecordsAvailable(getRecordsCache::pollNextResultAndUpdatePrefetchCounters, 1000);"], [469, "        blockUntilRecordsAvailable(getRecordsCache::pollNextResultAndUpdatePrefetchCounters, 1000);"], [478, "        RecordsRetrieved postRestart = blockUntilRecordsAvailable(getRecordsCache::pollNextResultAndUpdatePrefetchCounters, 1000);"], [522, "    private static class LossyNotificationSubscriber extends ShardConsumerNotifyingSubscriber {"], [523, ""], [524, "        private static final int LOSS_EVERY_NTH_RECORD = 100;"], [525, "        private static int recordCounter = 0;"], [526, "        private static final ScheduledExecutorService consumerHealthChecker = Executors.newScheduledThreadPool(1);"], [527, ""], [528, "        public LossyNotificationSubscriber(Subscriber<RecordsRetrieved> delegate, RecordsPublisher recordsPublisher) {"], [529, "            super(delegate, recordsPublisher);"], [530, "        }"], [531, ""], [532, "        @Override"], [533, "        public void onNext(RecordsRetrieved recordsRetrieved) {"], [534, "            log.info(\"Subscriber received onNext\");"], [535, "            if (!(recordCounter % LOSS_EVERY_NTH_RECORD == LOSS_EVERY_NTH_RECORD - 1)) {"], [536, "                getRecordsPublisher().notify(getRecordsDeliveryAck(recordsRetrieved));"], [537, "                getDelegateSubscriber().onNext(recordsRetrieved);"], [538, "            } else {"], [539, "                log.info(\"Record Loss Triggered\");"], [540, "                consumerHealthChecker.schedule(() ->  {"], [541, "                    getRecordsPublisher().restartFrom(recordsRetrieved);"], [542, "                    Flowable.fromPublisher(getRecordsPublisher()).subscribeOn(Schedulers.computation())"], [543, "                            .observeOn(Schedulers.computation(), true, 8).subscribe(this);"], [544, "                }, 1000, TimeUnit.MILLISECONDS);"], [545, "            }"], [546, "            recordCounter++;"], [547, "        }"], [548, "    }"]], "deleted": [[146, "        ProcessRecordsInput result = getRecordsCache.getNextResult().processRecordsInput();"], [186, "        assertTrue(callRate < MAX_SIZE);"], [215, "        ProcessRecordsInput processRecordsInput = getRecordsCache.getNextResult().processRecordsInput();"], [224, "        ProcessRecordsInput processRecordsInput2 = getRecordsCache.getNextResult().processRecordsInput();"], [235, "        getRecordsCache.getNextResult();"], [241, "        getRecordsCache.getNextResult();"], [254, "        getRecordsCache.getNextResult();"], [269, "        RecordsRetrieved records = getRecordsCache.getNextResult();"], [273, "    @Test(timeout = 1000L)"], [299, "        final int expectedItems = MAX_SIZE * 3;"], [375, "        RecordsRetrieved lastProcessed = getRecordsCache.getNextResult();"], [376, "        RecordsRetrieved expected = getRecordsCache.getNextResult();"], [381, "        getRecordsCache.getNextResult();"], [382, "        getRecordsCache.getNextResult();"], [391, "        RecordsRetrieved postRestart = getRecordsCache.getNextResult();"]]}, "num_lines_added": 129, "num_lines_removed": 15}