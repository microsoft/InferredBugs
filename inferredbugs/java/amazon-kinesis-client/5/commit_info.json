{"hash": "2483f8cbf8a14e383f1ed37f556da4c17416888c", "message": "Added cache updating behavior for GetShard (#344)\n\n* Added cache updating behavior for GetShard\r\n\r\nCustomer are occasionally seeing messages about being unable to\r\nretrieve shard information, which is logged as a warning.  This change\r\nwill allow the shard map to be updated even when there is no re-shard\r\noperation.\r\n\r\nThis now triggers a shard list update if there is 1000 cache misses,\r\nor a cache miss occurs when the cache is more than 30 seconds old.\r\nFor Kinesis the updates will use ListShards, and for DynamoDB Streams\r\nit will continue to use DescribeStream.\r\n\r\n* Adjust some logging, and the zeroing of cache misses a bit\r\n\r\nOnly log about cache refresh if it's the thread doing the cache\r\nrefresh.  If after synchronizing the shard is present, accept that\r\nsomeone else loaded the shard map, and move on.\r\n\r\nIf the cache was reloaded, and the shard was found the current thread\r\nwill reset the cache misses.\r\n\r\nThe warnings for the cache miss was using a modulo of 1000 which is\r\nthe maximum value for cache misses, so wasn't to useful.", "file_num_lines": 426, "diff_parsed": {"added": [[2, " *  Copyright 2018 Amazon.com, Inc. or its affiliates. All Rights Reserved."], [18, "import java.time.Duration;"], [19, "import java.time.Instant;"], [20, "import java.time.temporal.ChronoUnit;"], [26, "import java.util.Map;"], [28, "import java.util.concurrent.atomic.AtomicInteger;"], [29, "import java.util.function.Function;"], [30, "import java.util.stream.Collectors;"], [59, "import lombok.AccessLevel;"], [61, "import lombok.Getter;"], [62, "import lombok.Setter;"], [73, "    public static final int MAX_CACHE_MISSES_BEFORE_RELOAD = 1000;"], [74, "    public static final Duration CACHE_MAX_ALLOWED_AGE = Duration.of(30, ChronoUnit.SECONDS);"], [75, "    public static final int CACHE_MISS_WARNING_MODULUS = 250;"], [82, ""], [85, "    @Setter(AccessLevel.PACKAGE)"], [86, "    private volatile Map<String, Shard> cachedShardMap = null;"], [87, "    @Setter(AccessLevel.PACKAGE)"], [88, "    @Getter(AccessLevel.PACKAGE)"], [89, "    private volatile Instant lastCacheUpdateTime = null;"], [90, "    @Setter(AccessLevel.PACKAGE)"], [91, "    @Getter(AccessLevel.PACKAGE)"], [92, "    private AtomicInteger cacheMisses = new AtomicInteger(0);"], [93, ""], [357, "        if (this.cachedShardMap == null) {"], [358, "            synchronized (this) {"], [359, "                if (this.cachedShardMap == null) {"], [360, "                    this.getShardList();"], [361, "                }"], [362, "            }"], [363, "        }"], [364, ""], [365, "        Shard shard = cachedShardMap.get(shardId);"], [366, "        if (shard == null) {"], [367, "            if (cacheMisses.incrementAndGet() > MAX_CACHE_MISSES_BEFORE_RELOAD || cacheNeedsTimeUpdate()) {"], [368, "                synchronized (this) {"], [369, "                    shard = cachedShardMap.get(shardId);"], [370, ""], [371, "                    //"], [372, "                    // If after synchronizing we resolve the shard, it means someone else already got it for us."], [373, "                    //"], [374, "                    if (shard == null) {"], [375, "                        LOG.info(\"To many shard map cache misses or cache is out of date -- forcing a refresh\");"], [376, "                        this.getShardList();"], [377, "                        shard = verifyAndLogShardAfterCacheUpdate(shardId);"], [378, "                        cacheMisses.set(0);"], [379, "                    } else {"], [380, "                        //"], [381, "                        // If someone else got us the shard go ahead and zero cache misses"], [382, "                        //"], [383, "                        cacheMisses.set(0);"], [384, "                    }"], [385, ""], [386, "                }"], [387, "            }"], [390, "        if (shard == null) {"], [391, "            String message = \"Cannot find the shard given the shardId \" + shardId + \".  Cache misses: \" + cacheMisses;"], [392, "            if (cacheMisses.get() % CACHE_MISS_WARNING_MODULUS == 0) {"], [393, "                LOG.warn(message);"], [394, "            } else {"], [395, "                LOG.debug(message);"], [398, "        return shard;"], [399, "    }"], [400, ""], [401, "    private Shard verifyAndLogShardAfterCacheUpdate(String shardId) {"], [402, "        Shard shard = cachedShardMap.get(shardId);"], [403, "        if (shard == null) {"], [404, "            LOG.warn(\"Even after cache refresh shard '\" + shardId + \"' wasn't found.  \""], [405, "                    + \"This could indicate a bigger problem\");"], [406, "        }"], [407, "        return shard;"], [408, "    }"], [409, ""], [410, "    private boolean cacheNeedsTimeUpdate() {"], [411, "        if (lastCacheUpdateTime == null) {"], [412, "            return true;"], [413, "        }"], [414, "        Instant now = Instant.now();"], [415, "        Duration cacheAge = Duration.between(lastCacheUpdateTime, now);"], [416, ""], [417, "        String baseMessage = \"Shard map cache is \" + cacheAge + \" > \" + CACHE_MAX_ALLOWED_AGE + \". \";"], [418, "        if (cacheAge.compareTo(CACHE_MAX_ALLOWED_AGE) > 0) {"], [419, "            LOG.info(baseMessage + \"Age exceeds limit -- Refreshing.\");"], [420, "            return true;"], [421, "        }"], [422, "        LOG.debug(baseMessage + \"Age doesn't exceed limit.\");"], [423, "        return false;"], [471, "        List<Shard> shards = shardIterationState.getShards();"], [472, "        this.cachedShardMap = shards.stream().collect(Collectors.toMap(Shard::getShardId, Function.identity()));"], [473, "        this.lastCacheUpdateTime = Instant.now();"], [474, ""], [476, "        return shards;"]], "deleted": [[2, " *  Copyright 2017 Amazon.com, Inc. or its affiliates. All Rights Reserved."], [24, "import java.util.concurrent.atomic.AtomicReference;"], [70, "    private AtomicReference<List<Shard>> listOfShardsSinceLastGet = new AtomicReference<>();"], [336, "        if (this.listOfShardsSinceLastGet.get() == null) {"], [337, "            //Update this.listOfShardsSinceLastGet as needed."], [338, "            this.getShardList();"], [341, "        for (Shard shard : listOfShardsSinceLastGet.get()) {"], [342, "            if (shard.getShardId().equals(shardId))  {"], [343, "                return shard;"], [346, ""], [347, "        LOG.warn(\"Cannot find the shard given the shardId \" + shardId);"], [348, "        return null;"], [396, "        this.listOfShardsSinceLastGet.set(shardIterationState.getShards());"], [398, "        return listOfShardsSinceLastGet.get();"]]}, "num_lines_added": 92, "num_lines_removed": 14}