{"hash": "bf894beec69afce9e59342aca1d3586f3b99c53f", "message": "Fix POOL-107.\nNarrow synchronisation to where it is needed and ensure that calculations related to pool limits take account of objects we are in the process of making, particularly via the Evictor thread creating minIdle objects.\nThis patch removes a possibility for deadlock (DBCP-44) but introduces the edge case that where (idle==0 && (active + 1)==maxActive && minIdle>0) a pool may appear to be exhausted to a client if the evictor thread is in the process of creating the last object when the client calls borrowObject(). This is really only an issue if the pool is configured with WHEN_EXHAUSTED_FAIL.\nThe patch also aligns synchronisation strategies between GOP and GKOP. This means less synchronisation in GKOP.\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/pool/trunk@762396 13f79535-47bb-0310-9956-ffa450edef68", "file_num_lines": 815, "diff_parsed": {"added": [[963, "                    if ((_maxTotal > 0)"], [964, "                            && (_totalActive + _totalIdle + _totalCreatingIdle >= _maxTotal)) {"], [970, "                    if ((_maxActive < 0 || pool.activeCount + pool.creatingIdleCount < _maxActive) &&"], [971, "                        (_maxTotal < 0 || _totalActive + _totalIdle + _totalCreatingIdle < _maxTotal)) {"], [1326, "        try {"], [1327, "            assertOpen();"], [1328, "            addObjectToPool(key, obj, false);"], [1329, "        } catch (IllegalStateException ex) { // Pool closed"], [1331, "                _factory.destroyObject(key, obj);"], [1332, "            } catch (Exception ex2) {"], [1333, "                // swallow"], [1335, "            throw ex;"], [1576, "    private void ensureMinIdle() throws Exception {"], [1579, "            Object[] keysCopy;"], [1580, "            synchronized(this) {"], [1581, "                // Get the current set of keys"], [1582, "                keysCopy = _poolMap.keySet().toArray();"], [1583, "            }"], [1584, ""], [1588, "            for (int i=0; i < keysCopy.length; i++) {"], [1590, "                ensureMinIdle(keysCopy[i]);"], [1606, "    private void ensureMinIdle(Object key) throws Exception {"], [1608, "        ObjectQueue pool;"], [1609, "        synchronized(this) {"], [1610, "            pool = (ObjectQueue)(_poolMap.get(key));"], [1611, "        }"], [1612, "        if (pool == null) {"], [1613, "            return;"], [1614, "        }"], [1616, "        // this method isn't synchronized so the"], [1617, "        // calculateDeficit is done at the beginning"], [1618, "        // as a loop limit and a second time inside the loop"], [1619, "        // to stop when another thread already returned the"], [1620, "        // needed objects"], [1621, "        int objectDeficit = calculateDefecit(pool, false);"], [1622, ""], [1623, "        for (int i = 0; i < objectDeficit && calculateDefecit(pool, true) > 0; i++) {"], [1624, "            try {"], [1625, "                addObject(key);"], [1626, "            } finally {"], [1627, "                synchronized (this) {"], [1628, "                    pool.decrementCreatingIdleCount();"], [1629, "                    notifyAll();"], [1630, "                }"], [1631, "            }"], [1687, "    private synchronized int calculateDefecit(ObjectQueue pool,"], [1688, "            boolean incrementCreate) {"], [1693, "        objectDefecit = getMinIdle() - pool.queue.size();"], [1695, "            int growLimit = Math.max(0, getMaxActive() - pool.activeCount - pool.queue.size() - pool.creatingIdleCount);"], [1701, "            int growLimit = Math.max(0, getMaxTotal() - getNumActive() - getNumIdle() - _totalCreatingIdle);"], [1705, "        if (incrementCreate && objectDefecit > 0) {"], [1706, "            pool.incrementCreatingIdleCount();"], [1707, "        }"], [1719, "        private int creatingIdleCount = 0;"], [1732, ""], [1733, "        void incrementCreatingIdleCount() {"], [1734, "            _totalCreatingIdle++;"], [1735, "            creatingIdleCount++;"], [1736, "        }"], [1737, ""], [1738, "        void decrementCreatingIdleCount() {"], [1739, "            _totalCreatingIdle--;"], [1740, "            creatingIdleCount--;"], [1741, "        }"], [1742, "}"], [2019, "    /**"], [2020, "     * The total number of idle objects that are in the process of being created"], [2021, "     * but have not yet been added to the pool."], [2022, "     */"], [2023, "    private int _totalCreatingIdle = 0;"], [2024, ""]], "deleted": [[963, "                    if ((_maxTotal > 0) && (_totalActive + _totalIdle >= _maxTotal)) {"], [969, "                    if ((_maxActive < 0 || pool.activeCount < _maxActive) &&"], [970, "                        (_maxTotal < 0 || _totalActive + _totalIdle < _maxTotal)) {"], [1325, "        synchronized (this) {"], [1327, "                assertOpen();"], [1328, "                addObjectToPool(key, obj, false);"], [1329, "            } catch (IllegalStateException ex) { // Pool closed"], [1330, "                try {"], [1331, "                    _factory.destroyObject(key, obj);"], [1332, "                } catch (Exception ex2) {"], [1333, "                    // swallow"], [1334, "                }"], [1335, "                throw ex;"], [1577, "    private synchronized void ensureMinIdle() throws Exception {"], [1578, "        Iterator iterator = _poolMap.keySet().iterator();"], [1579, ""], [1585, "            // Increment idle count + 1"], [1586, "            while (iterator.hasNext()) {"], [1588, "                Object key = iterator.next();"], [1589, "                ensureMinIdle(key);"], [1605, "    private synchronized void ensureMinIdle(Object key) throws Exception {"], [1607, "        int numberToCreate = calculateDefecit(key);"], [1609, "        //Create required pool objects, if none to create, this loop will not be run."], [1610, "        for (int i = 0; i < numberToCreate; i++) {"], [1611, "            addObject(key);"], [1667, "    private int calculateDefecit(Object key) {"], [1672, "        objectDefecit = getMinIdle() - getNumIdle(key);"], [1674, "            int growLimit = Math.max(0, getMaxActive() - getNumActive(key) - getNumIdle(key));"], [1680, "            int growLimit = Math.max(0, getMaxTotal() - getNumActive() - getNumIdle());"], [1707, "    }"]]}, "num_lines_added": 71, "num_lines_removed": 30}