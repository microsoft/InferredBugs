{"hash": "8faaeaf9b5c2aec69beed45f924d24855262aa19", "message": "minor fix.", "file_num_lines": 428, "diff_parsed": {"added": [[172, "        if (!EX_PRECACHE.containsKey(template)) {"], [173, "            EX_PRECACHE.put(template, this.expression = template.toString().toCharArray());"], [174, "            nodes = new TemplateCompiler(this).compileExpression();"], [175, "            Node[] nodes = cloneAll(EX_NODE_CACHE.get(expression));"], [177, "            EX_NODE_CACHE.put(template, nodes);"], [178, "        }"], [179, "        else {"], [180, "            this.expression = EX_PRECACHE.get(template);"], [181, "            try {"], [182, "                this.nodes = cloneAll(EX_NODE_CACHE.get(expression));"], [184, "            catch (NullPointerException e) {"], [185, "                EX_NODE_CACHE.remove(expression);"], [186, "                nodes = new TemplateCompiler(this).compileExpression();"], [187, "                EX_NODE_CACHE.put(expression, cloneAll(nodes));"], [214, "        if (!EX_PRECACHE.containsKey(expression)) {"], [215, "            EX_PRECACHE.put(expression, this.expression = expression.toCharArray());"], [216, "            nodes = new TemplateCompiler(this).compileExpression();"], [217, "            EX_NODE_CACHE.put(expression, nodes);"], [218, "            this.nodes = cloneAll(nodes);"], [219, "        }"], [220, "        else {"], [221, "            this.expression = EX_PRECACHE.get(expression);"], [222, "            try {"], [223, "                this.nodes = cloneAll(EX_NODE_CACHE.get(expression));"], [224, "            }"], [225, "            catch (NullPointerException e) {"], [226, "                EX_NODE_CACHE.remove(expression);"], [232, ""], [277, ""], [342, "        synchronized (Runtime.getRuntime()) {"], [343, ""], [344, "            if (nodes == null) {"], [345, "                return new String(expression);"], [346, "            }"], [347, "            else if (nodes.length == 2) {"], [348, "                /**"], [349, "                 * This is an optimization for property expressions."], [350, "                 */"], [351, "                switch (nodes[0].getToken()) {"], [352, "                    case PROPERTY_EX:"], [353, "                        //noinspection unchecked"], [354, "                        if (!cacheAggressively) {"], [355, "                            char[] seg = new char[expression.length - 3];"], [356, "                            arraycopy(expression, 2, seg, 0, seg.length);"], [357, ""], [358, "                            return MVEL.eval(seg, ctx, tokens);"], [361, "                            String s = new String(expression, 2, expression.length - 3);"], [362, "                            if (!EX_PRECOMP_CACHE.containsKey(s)) {"], [363, "                                synchronized (EX_PRECOMP_CACHE) {"], [364, "                                    EX_PRECOMP_CACHE.put(s, compileExpression(s));"], [365, "                                    return executeExpression(EX_PRECOMP_CACHE.get(s), ctx, tokens);"], [366, "                                }"], [367, "                            }"], [368, "                            else {"], [369, "                                return executeExpression(EX_PRECOMP_CACHE.get(s), ctx, tokens);"], [370, "                            }"], [371, ""], [373, "                    case LITERAL:"], [374, "                        return new String(expression);"], [376, "                }"], [378, "                return new String(expression);"], [381, "            Object register = null;"], [383, "            StringAppender sbuf = new StringAppender(10);"], [384, "            Node currNode = null;"], [386, "            try {"], [387, "                //noinspection unchecked"], [388, "                MVELInterpretedRuntime oParser = new MVELInterpretedRuntime(ctx, tokens);"], [390, "                initStack();"], [391, "                pushAndForward();"], [393, "                while ((currNode = pop()) != null) {"], [394, "                    node = currNode.getNode();"], [396, "                    switch (currNode.getToken()) {"], [397, "                        case LITERAL: {"], [398, "                            sbuf.append(register = new String(expression, currNode.getStartPos(),"], [399, "                                    currNode.getEndPos() - currNode.getStartPos()));"], [400, "                            break;"], [402, "                        case PROPERTY_EX: {"], [403, "                            sbuf.append("], [404, "                                    valueOf(register = oParser.setExpressionArray(getInternalSegment(currNode)).parse())"], [405, "                            );"], [406, "                            break;"], [408, "                        case IF:"], [409, "                        case ELSEIF: {"], [411, "                                if (!((Boolean) oParser.setExpressionArray(getInternalSegment(currNode)).parse())) {"], [412, "                                    exitContext();"], [416, "                                throw new CompileException(\"IF expression does not return a boolean: \" + new String(getSegment(currNode)));"], [418, "                            break;"], [420, "                        case FOREACH: {"], [421, "                            ForeachContext foreachContext = (ForeachContext) currNode.getRegister();"], [422, "                            if (foreachContext.getItererators() == null) {"], [423, "                                try {"], [424, "                                    String[] lists = getForEachSegment(currNode).split(\",\");"], [425, "                                    Iterator[] iters = new Iterator[lists.length];"], [426, "                                    for (int i = 0; i < lists.length; i++) {"], [427, "                                        //noinspection unchecked"], [428, "                                        Object listObject = new MVELInterpretedRuntime(lists[i], ctx, tokens).parse();"], [429, "                                        if (listObject instanceof Object[]) {"], [430, "                                            listObject = Arrays.asList((Object[]) listObject);"], [431, "                                        }"], [432, "                                        iters[i] = ((Collection) listObject).iterator();"], [433, "                                    }"], [434, "                                    foreachContext.setIterators(iters);"], [435, "                                }"], [436, "                                catch (ClassCastException e) {"], [437, "                                    throw new CompileException(\"expression for collections does not return a collections object: \" + new String(getSegment(currNode)));"], [438, "                                }"], [439, "                                catch (NullPointerException e) {"], [440, "                                    throw new CompileException(\"null returned for foreach in expression: \" + (getForEachSegment(currNode)));"], [441, "                                }"], [442, "                            }"], [444, "                            Iterator[] iters = foreachContext.getItererators();"], [445, "                            String[] alias = currNode.getAlias().split(\",\");"], [446, "                            // must trim vars"], [447, "                            for (int i = 0; i < alias.length; i++) {"], [448, "                                alias[i] = alias[i].trim();"], [449, "                            }"], [451, "                            if (iters[0].hasNext()) {"], [452, "                                push();"], [455, "                                for (int i = 0; i < iters.length; i++) {"], [456, "                                    //noinspection unchecked"], [457, "                                    tokens.put(alias[i], iters[i].next());"], [458, "                                }"], [459, "                                if (foreachContext.getCount() != 0) {"], [460, "                                    sbuf.append(foreachContext.getSeperator());"], [461, "                                }"], [462, "                                //noinspection unchecked"], [463, "                                tokens.put(\"i0\", foreachContext.getCount());"], [464, "                                foreachContext.setCount(foreachContext.getCount() + 1);"], [466, "                            else {"], [467, "                                for (int i = 0; i < iters.length; i++) {"], [468, "                                    tokens.remove(alias[i]);"], [469, "                                }"], [470, "                                foreachContext.setIterators(null);"], [471, "                                foreachContext.setCount(0);"], [472, "                                exitContext();"], [474, "                            break;"], [476, "                        case ELSE:"], [477, "                        case END:"], [478, "                            if (stack.isEmpty()) forwardAndPush();"], [479, "                            continue;"], [480, "                        case GOTO:"], [481, "                            pushNode(currNode.getEndNode());"], [482, "                            continue;"], [483, "                        case TERMINUS: {"], [484, "                            if (nodes.length != 2) {"], [485, "                                return sbuf.toString();"], [486, "                            }"], [487, "                            else {"], [488, "                                return register;"], [491, "                        case INCLUDE_BY_REF: {"], [492, "                            IncludeRef includeRef = (IncludeRef) nodes[node].getRegister();"], [494, "                            IncludeRefParam[] params = includeRef.getParams();"], [495, "                            Map<String, Object> vars = new HashMap<String, Object>(params.length * 2);"], [496, "                            for (IncludeRefParam param : params) {"], [497, "                                vars.put(param.getIdentifier(), MVEL.eval(param.getValue(), ctx, tokens));"], [498, "                            }"], [500, "                            if (registry == null) {"], [501, "                                throw new CompileException(\"No TemplateRegistry specified, cannot load template='\" + includeRef.getName() + \"'\");"], [502, "                            }"], [503, "                            String template = registry.getTemplate(includeRef.getName());"], [505, "                            if (template == null) {"], [506, "                                throw new CompileException(\"Template does not exist in the TemplateRegistry, cannot load template='\" + includeRef.getName() + \"'\");"], [507, "                            }"], [509, "                            sbuf.append(TemplateInterpreter.parse(template, ctx, vars, registry));"], [510, "                        }"], [513, "                    forwardAndPush();"], [514, "                }"], [515, "                throw new CompileException(\"expression did not end properly: expected TERMINUS node\");"], [517, "            catch (CompileException e) {"], [518, "                throw e;"], [519, "            }"], [520, "            catch (Exception e) {"], [521, "                if (currNode != null) {"], [522, "                    throw new CompileException(\"problem encountered at node [\" + currNode.getNode() + \"] \""], [523, "                            + currNode.getToken() + \"{\" + currNode.getStartPos() + \",\" + currNode.getEndPos() + \"}: \" + e.getMessage(), e);"], [524, "                }"], [525, "                throw new CompileException(\"unhandled fatal exception (node:\" + node + \")\", e);"]], "deleted": [[172, "        synchronized (Runtime.getRuntime()) {"], [173, ""], [174, "            if (!EX_PRECACHE.containsKey(template)) {"], [175, "                EX_PRECACHE.put(template, this.expression = template.toString().toCharArray());"], [176, "                nodes = new TemplateCompiler(this).compileExpression();"], [177, "                Node[] nodes = cloneAll(EX_NODE_CACHE.get(expression));"], [179, "                EX_NODE_CACHE.put(template, nodes);"], [181, "            else {"], [182, "                this.expression = EX_PRECACHE.get(template);"], [183, "                try {"], [184, "                    this.nodes = cloneAll(EX_NODE_CACHE.get(expression));"], [185, "                }"], [186, "                catch (NullPointerException e) {"], [187, "                    EX_NODE_CACHE.remove(expression);"], [188, "                    nodes = new TemplateCompiler(this).compileExpression();"], [189, "                    EX_NODE_CACHE.put(expression, cloneAll(nodes));"], [190, "                }"], [191, ""], [218, "        synchronized (Runtime.getRuntime()) {"], [219, "            if (!EX_PRECACHE.containsKey(expression)) {"], [220, "                EX_PRECACHE.put(expression, this.expression = expression.toCharArray());"], [225, "            else {"], [226, "                this.expression = EX_PRECACHE.get(expression);"], [227, "                try {"], [228, "                    this.nodes = cloneAll(EX_NODE_CACHE.get(expression));"], [229, "                }"], [230, "                catch (NullPointerException e) {"], [231, "                    EX_NODE_CACHE.remove(expression);"], [232, "                    nodes = new TemplateCompiler(this).compileExpression();"], [233, "                    EX_NODE_CACHE.put(expression, nodes);"], [234, "                    this.nodes = cloneAll(nodes);"], [235, "                }"], [236, "            }"], [346, "        if (nodes == null) {"], [347, "            return new String(expression);"], [348, "        }"], [349, "        else if (nodes.length == 2) {"], [350, "            /**"], [351, "             * This is an optimization for property expressions."], [352, "             */"], [353, "            switch (nodes[0].getToken()) {"], [354, "                case PROPERTY_EX:"], [355, "                    //noinspection unchecked"], [356, "                    if (!cacheAggressively) {"], [357, "                        char[] seg = new char[expression.length - 3];"], [358, "                        arraycopy(expression, 2, seg, 0, seg.length);"], [359, ""], [360, "                        return MVEL.eval(seg, ctx, tokens);"], [361, "                    }"], [362, "                    else {"], [363, "                        String s = new String(expression, 2, expression.length - 3);"], [364, "                        if (!EX_PRECOMP_CACHE.containsKey(s)) {"], [365, "                            synchronized (EX_PRECOMP_CACHE) {"], [366, "                                EX_PRECOMP_CACHE.put(s, compileExpression(s));"], [367, "                                return executeExpression(EX_PRECOMP_CACHE.get(s), ctx, tokens);"], [368, "                            }"], [371, "                            return executeExpression(EX_PRECOMP_CACHE.get(s), ctx, tokens);"], [374, "                    }"], [375, "                case LITERAL:"], [376, "                    return new String(expression);"], [380, "            return new String(expression);"], [381, "        }"], [383, "        Object register = null;"], [385, "        StringAppender sbuf = new StringAppender(10);"], [386, "        Node currNode = null;"], [388, "        try {"], [389, "            //noinspection unchecked"], [390, "            MVELInterpretedRuntime oParser = new MVELInterpretedRuntime(ctx, tokens);"], [392, "            initStack();"], [393, "            pushAndForward();"], [395, "            while ((currNode = pop()) != null) {"], [396, "                node = currNode.getNode();"], [397, ""], [398, "                switch (currNode.getToken()) {"], [399, "                    case LITERAL: {"], [400, "                        sbuf.append(register = new String(expression, currNode.getStartPos(),"], [401, "                                currNode.getEndPos() - currNode.getStartPos()));"], [402, "                        break;"], [403, "                    }"], [404, "                    case PROPERTY_EX: {"], [405, "                        sbuf.append("], [406, "                                valueOf(register = oParser.setExpressionArray(getInternalSegment(currNode)).parse())"], [407, "                        );"], [408, "                        break;"], [409, "                    }"], [410, "                    case IF:"], [411, "                    case ELSEIF: {"], [412, "                        try {"], [413, "                            if (!((Boolean) oParser.setExpressionArray(getInternalSegment(currNode)).parse())) {"], [414, "                                exitContext();"], [415, "                            }"], [417, "                        catch (ClassCastException e) {"], [418, "                            throw new CompileException(\"IF expression does not return a boolean: \" + new String(getSegment(currNode)));"], [420, "                        break;"], [421, "                    }"], [422, "                    case FOREACH: {"], [423, "                        ForeachContext foreachContext = (ForeachContext) currNode.getRegister();"], [424, "                        if (foreachContext.getItererators() == null) {"], [426, "                                String[] lists = getForEachSegment(currNode).split(\",\");"], [427, "                                Iterator[] iters = new Iterator[lists.length];"], [428, "                                for (int i = 0; i < lists.length; i++) {"], [429, "                                    //noinspection unchecked"], [430, "                                    Object listObject = new MVELInterpretedRuntime(lists[i], ctx, tokens).parse();"], [431, "                                    if (listObject instanceof Object[]) {"], [432, "                                        listObject = Arrays.asList((Object[]) listObject);"], [433, "                                    }"], [434, "                                    iters[i] = ((Collection) listObject).iterator();"], [436, "                                foreachContext.setIterators(iters);"], [439, "                                throw new CompileException(\"expression for collections does not return a collections object: \" + new String(getSegment(currNode)));"], [440, "                            }"], [441, "                            catch (NullPointerException e) {"], [442, "                                throw new CompileException(\"null returned for foreach in expression: \" + (getForEachSegment(currNode)));"], [446, "                        Iterator[] iters = foreachContext.getItererators();"], [447, "                        String[] alias = currNode.getAlias().split(\",\");"], [448, "                        // must trim vars"], [449, "                        for (int i = 0; i < alias.length; i++) {"], [450, "                            alias[i] = alias[i].trim();"], [451, "                        }"], [453, "                        if (iters[0].hasNext()) {"], [454, "                            push();"], [456, "                            //noinspection unchecked"], [457, "                            for (int i = 0; i < iters.length; i++) {"], [459, "                                tokens.put(alias[i], iters[i].next());"], [461, "                            if (foreachContext.getCount() != 0) {"], [462, "                                sbuf.append(foreachContext.getSeperator());"], [464, "                            //noinspection unchecked"], [465, "                            tokens.put(\"i0\", foreachContext.getCount());"], [466, "                            foreachContext.setCount(foreachContext.getCount() + 1);"], [468, "                        else {"], [469, "                            for (int i = 0; i < iters.length; i++) {"], [470, "                                tokens.remove(alias[i]);"], [472, "                            foreachContext.setIterators(null);"], [473, "                            foreachContext.setCount(0);"], [474, "                            exitContext();"], [475, "                        }"], [476, "                        break;"], [477, "                    }"], [478, "                    case ELSE:"], [479, "                    case END:"], [480, "                        if (stack.isEmpty()) forwardAndPush();"], [481, "                        continue;"], [482, "                    case GOTO:"], [483, "                        pushNode(currNode.getEndNode());"], [484, "                        continue;"], [485, "                    case TERMINUS: {"], [486, "                        if (nodes.length != 2) {"], [487, "                            return sbuf.toString();"], [488, "                        }"], [489, "                        else {"], [490, "                            return register;"], [492, "                    }"], [493, "                    case INCLUDE_BY_REF: {"], [494, "                        IncludeRef includeRef = (IncludeRef) nodes[node].getRegister();"], [496, "                        IncludeRefParam[] params = includeRef.getParams();"], [497, "                        Map<String, Object> vars = new HashMap<String, Object>(params.length * 2);"], [498, "                        for (IncludeRefParam param : params) {"], [499, "                            vars.put(param.getIdentifier(), MVEL.eval(param.getValue(), ctx, tokens));"], [500, "                        }"], [502, "                        if (registry == null) {"], [503, "                            throw new CompileException(\"No TemplateRegistry specified, cannot load template='\" + includeRef.getName() + \"'\");"], [504, "                        }"], [505, "                        String template = registry.getTemplate(includeRef.getName());"], [507, "                        if (template == null) {"], [508, "                            throw new CompileException(\"Template does not exist in the TemplateRegistry, cannot load template='\" + includeRef.getName() + \"'\");"], [509, "                        }"], [511, "                        sbuf.append(TemplateInterpreter.parse(template, ctx, vars, registry));"], [513, "                }"], [515, "                forwardAndPush();"], [517, "            throw new CompileException(\"expression did not end properly: expected TERMINUS node\");"], [518, "        }"], [519, "        catch (CompileException e) {"], [520, "            throw e;"], [521, "        }"], [522, "        catch (Exception e) {"], [523, "            if (currNode != null) {"], [524, "                throw new CompileException(\"problem encountered at node [\" + currNode.getNode() + \"] \""], [525, "                        + currNode.getToken() + \"{\" + currNode.getStartPos() + \",\" + currNode.getEndPos() + \"}: \" + e.getMessage(), e);"], [527, "            throw new CompileException(\"unhandled fatal exception (node:\" + node + \")\", e);"]]}, "num_lines_added": 177, "num_lines_removed": 178}