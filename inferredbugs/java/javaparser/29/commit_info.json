{"hash": "b9caf94b599d1986eb54c1656bd0304bb2927283", "message": "Spring cleaning", "file_num_lines": 173, "diff_parsed": {"added": [[41, "import java.nio.file.FileVisitResult;"], [42, "import java.nio.file.Files;"], [44, "import java.nio.file.SimpleFileVisitor;"], [45, "import java.nio.file.attribute.BasicFileAttributes;"], [46, "import java.util.ArrayList;"], [50, "import static java.util.Comparator.comparing;"], [53, " * Resolves resolvable nodes from one or more source files, and reports the results."], [54, " * It is mainly intended as an example usage of JavaSymbolSolver."], [60, "    private final TypeSolver typeSolver;"], [62, "    private int successes = 0;"], [63, "    private int failures = 0;"], [68, "    private boolean verbose = false;"], [69, ""], [70, "    public SourceFileInfoExtractor(TypeSolver typeSolver) {"], [71, "        this.typeSolver = typeSolver;"], [72, "    }"], [90, "    public int getSuccesses() {"], [91, "        return successes;"], [98, "    public int getFailures() {"], [99, "        return failures;"], [119, "            Node parentNode = requireParentNode(node);"], [120, "            if (parentNode instanceof ImportDeclaration ||"], [121, "                    parentNode instanceof Expression ||"], [122, "                    parentNode instanceof MethodDeclaration ||"], [123, "                    parentNode instanceof PackageDeclaration) {"], [125, "                return;"], [126, "            }"], [127, "            if (parentNode instanceof Statement ||"], [128, "                    parentNode instanceof VariableDeclarator ||"], [129, "                    parentNode instanceof SwitchEntry) {"], [132, "                    out.println(\"  Line \" + lineNr(node) + \") \" + node + \" ==> \" + ref.describe());"], [133, "                    successes++;"], [139, "                    failures++;"], [149, "            out.println(\"  Line \" + lineNr(node) + \") \" + node + \" ==> \" + toString((MethodCallExpr) node));"], [161, "                System.err.println(\"Error resolving call at L\" + lineNr(node) + \": \" + node);"], [177, "        List<Node> nodes = new ArrayList<>();"], [178, "        node.walk(nodes::add);"], [179, "        nodes.sort(comparing(n -> n.getBegin().get()));"], [184, "        Files.walkFileTree(path, new SimpleFileVisitor<Path>() {"], [185, "            @Override"], [186, "            public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {"], [187, "                if (file.toString().endsWith(\".java\")) {"], [188, "                    if (printFileName) {"], [189, "                        out.println(\"- parsing \" + file.toAbsolutePath());"], [190, "                    }"], [191, "                    CompilationUnit cu = JavaParser.parse(file);"], [192, "                    List<Node> nodes = collectAllNodes(cu);"], [193, "                    nodes.forEach(n -> solve(n));"], [195, "                return FileVisitResult.CONTINUE;"], [197, "        });"], [201, "        Files.walkFileTree(path, new SimpleFileVisitor<Path>() {"], [202, "            @Override"], [203, "            public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {"], [204, "                if (file.toString().endsWith(\".java\")) {"], [205, "                    if (printFileName) {"], [206, "                        out.println(\"- parsing \" + file.toAbsolutePath());"], [207, "                    }"], [208, "                    CompilationUnit cu = JavaParser.parse(file);"], [209, "                    solveMethodCalls(cu);"], [211, "                return FileVisitResult.CONTINUE;"], [213, "        });"], [216, "    private int lineNr(Node node) {"], [217, "        return node.getRange().map(range -> range.begin.line).orElseThrow(IllegalStateException::new);"]], "deleted": [[39, "import java.io.File;"], [43, "import java.util.LinkedList;"], [49, " * It prints information extracted from a source file. It is mainly intended as an example usage of JavaSymbolSolver."], [55, "    private TypeSolver typeSolver;"], [57, "    private int ok = 0;"], [58, "    private int ko = 0;"], [68, "    private boolean verbose = false;"], [69, ""], [74, "    public void clear() {"], [75, "        ok = 0;"], [76, "        ko = 0;"], [77, "        unsupported = 0;"], [78, "    }"], [79, ""], [88, "    public int getOk() {"], [89, "        return ok;"], [90, ""], [97, "    public int getKo() {"], [98, "        return ko;"], [118, "            if ((requireParentNode(node) instanceof ImportDeclaration) || (requireParentNode(node) instanceof Expression)"], [119, "                    || (requireParentNode(node) instanceof MethodDeclaration)"], [120, "                    || (requireParentNode(node) instanceof PackageDeclaration)) {"], [122, "            } else if ((requireParentNode(node) instanceof Statement) ||"], [123, "                    (requireParentNode(node) instanceof VariableDeclarator) ||"], [124, "                    (requireParentNode(node) instanceof SwitchEntry)) {"], [127, "                    out.println(\"  Line \" + node.getRange().get().begin.line + \") \" + node + \" ==> \" + ref.describe());"], [128, "                    ok++;"], [134, "                    ko++;"], [144, "            out.println(\"  Line \" + node.getBegin().get().line + \") \" + node + \" ==> \" + toString((MethodCallExpr) node));"], [156, "                System.err.println(\"Error resolving call at L\" + node.getBegin().get().line + \": \" + node);"], [172, "        List<Node> nodes = new LinkedList<>();"], [173, "        collectAllNodes(node, nodes);"], [174, "        nodes.sort((n1, n2) -> n1.getBegin().get().compareTo(n2.getBegin().get()));"], [178, "    private void collectAllNodes(Node node, List<Node> nodes) {"], [179, "        nodes.add(node);"], [180, "        node.getChildNodes().forEach(c -> collectAllNodes(c, nodes));"], [181, "    }"], [182, ""], [184, "        File file = path.toFile();"], [185, "        if (file.isDirectory()) {"], [186, "            for (File f : file.listFiles()) {"], [187, "                solve(f.toPath());"], [188, "            }"], [189, "        } else {"], [190, "            if (file.getName().endsWith(\".java\")) {"], [191, "                if (printFileName) {"], [192, "                    out.println(\"- parsing \" + file.getAbsolutePath());"], [194, "                CompilationUnit cu = JavaParser.parse(file);"], [195, "                List<Node> nodes = collectAllNodes(cu);"], [196, "                nodes.forEach(n -> solve(n));"], [198, "        }"], [202, "        File file = path.toFile();"], [203, "        if (file.isDirectory()) {"], [204, "            for (File f : file.listFiles()) {"], [205, "                solveMethodCalls(f.toPath());"], [206, "            }"], [207, "        } else {"], [208, "            if (file.getName().endsWith(\".java\")) {"], [209, "                if (printFileName) {"], [210, "                    out.println(\"- parsing \" + file.getAbsolutePath());"], [212, "                CompilationUnit cu = JavaParser.parse(file);"], [213, "                solveMethodCalls(cu);"], [215, "        }"], [218, "    public void setTypeSolver(TypeSolver typeSolver) {"], [219, "        this.typeSolver = typeSolver;"], [221, ""]]}, "num_lines_added": 63, "num_lines_removed": 66}