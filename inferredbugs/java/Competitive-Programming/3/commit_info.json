{"hash": "84dc94ebfe6c8e136490a678d6fa8e6a239595b1", "message": "added egg solver", "file_num_lines": 219, "diff_parsed": {"added": [[8, "/**"], [9, " * Reference: https://www.codechef.com/viewsolution/12879967"], [10, " */"], [19, "    static int vertices[];"], [25, "    static void findAncestorsAtEachLevel() {"], [41, "        while (diff > 0) {"], [48, "            while (i > 0 && DP[i][u] == DP[i][v]) {"], [57, "    static void dfs(final int u, final int par, final int lev, final int[] eulerTour) {"], [73, "            frequency[vertices[idx]]--;"], [74, "            if (frequency[vertices[idx]] == 0) {"], [78, "            frequency[vertices[idx]]++;"], [79, "            if (frequency[vertices[idx]] == 1) {"], [89, "            vertices[idx] = newVal;"], [92, "            vertices[idx] = newVal;"], [104, "        vertices = new int[V + 1];"], [106, "            vertices[i] = in.readInt();"], [110, "            map.putIfAbsent(vertices[i], map.size());"], [111, "            vertices[i] = map.get(vertices[i]);"], [113, "        final int verticesCopy[] = new int[V + 1];"], [114, "        System.arraycopy(vertices, 0, verticesCopy, 0, V + 1);"], [130, "        findAncestorsAtEachLevel();"], [132, "        final Query queries[] = new Query[Q];"], [133, "        final Update updates[] = new Update[Q];"], [135, "            if (in.readInt() == 1) {"], [139, "                if (start[v] > end[u]) {"], [143, "                } else {"], [154, "                map.putIfAbsent(newVal, map.size());"], [156, "                updates[numberOfUpdates++] = new Update(idx, newVal, verticesCopy[idx]);"], [157, "                verticesCopy[idx] = newVal;"], [161, "        Arrays.sort(queries, 0, numberOfQueries, (first, second) -> {"], [162, "            if (first.L / BLOCK_SIZE != second.L / BLOCK_SIZE) {"], [163, "                return first.L / BLOCK_SIZE - second.L / BLOCK_SIZE;"], [164, "            } else if (first.R / BLOCK_SIZE != second.R / BLOCK_SIZE) {"], [165, "                return first.R / BLOCK_SIZE - second.R / BLOCK_SIZE;"], [167, "                return first.updatesTillNow - second.updatesTillNow;"], [173, "        final int[] frequency = new int[map.size()];"], [177, "                final Update update = updates[currentUpdateCount++];"], [178, "                update(update.idx, update.newValue, frequency);"], [181, "                final Update update = updates[--currentUpdateCount];"], [182, "                update(update.idx, update.previousValue, frequency);"], [186, "                visit(eulerTour[moLeft], frequency);"], [189, "                visit(eulerTour[moLeft], frequency);"], [194, "                visit(eulerTour[moRight], frequency);"], [197, "                visit(eulerTour[moRight], frequency);"], [201, "                visit(query.LCA, frequency);"], [205, "                visit(query.LCA, frequency);"], [229, "    final int idx, previousValue, newValue;"], [231, "    public Update(final int idx, final int newValue, final int previousValue) {"], [233, "        this.newValue = newValue;"], [234, "        this.previousValue = previousValue;"]], "deleted": [[9, "    private static final int MAX = 100000;"], [12, "    /* LCA <NlogN , logN> dependency : level , log , V , DP = new int[log(V) + 1][V + 1];, parent (for the first level of DP) */"], [18, "    static int val[];"], [24, "    static void binaryLift() {"], [40, "        while (diff > 0) {        // Bring v to the same level as u"], [47, "            for (; i > 0 && DP[i][u] == DP[i][v]; ) {"], [56, "    static void dfs(int u, int par, int lev, final int[] eulerTour) {"], [72, "            frequency[val[idx]]--;"], [73, "            if (frequency[val[idx]] == 0) {"], [77, "            frequency[val[idx]]++;"], [78, "            if (frequency[val[idx]] == 1) {"], [88, "            val[idx] = newVal;"], [91, "            val[idx] = newVal;"], [103, "        val = new int[V + 1];"], [105, "            val[i] = in.readInt();"], [109, "            if (!map.containsKey(val[i])) {"], [110, "                map.put(val[i], map.size());"], [111, "            }"], [112, "            val[i] = map.get(val[i]);"], [114, "        final int currVal[] = new int[V + 1];"], [115, "        System.arraycopy(val, 0, currVal, 0, V + 1);"], [130, "        final int block[] = new int[2 * (V + 1)];"], [132, "        binaryLift();"], [134, "        final Query queries[] = new Query[MAX];"], [135, "        final Update updates[] = new Update[MAX];"], [137, "            if (in.readInt() == 1) { // Query"], [141, "                if (end[u] < start[v])    // Cousin Nodes"], [142, "                {"], [146, "                } else            // Ancestors"], [147, "                {"], [158, "                if (!map.containsKey(newVal)) {"], [159, "                    map.put(newVal, map.size());"], [160, "                }"], [162, "                updates[numberOfUpdates++] = new Update(idx, newVal, currVal[idx]);"], [163, "                currVal[idx] = newVal;"], [167, "        for (int i = 0; i < block.length; i++) {"], [168, "            block[i] = i / BLOCK_SIZE;"], [169, "        }"], [170, "        Arrays.sort(queries, 0, numberOfQueries, (o1, o2) -> {"], [171, "            if (block[o1.L] != block[o2.L]) {"], [172, "                return block[o1.L] - block[o2.L];"], [173, "            } else if (block[o1.R] != block[o2.R]) {"], [174, "                return block[o1.R] - block[o2.R];"], [176, "                return o1.updatesTillNow - o2.updatesTillNow;"], [182, "        final int[] freq = new int[map.size()];"], [186, "                final Update update = updates[currentUpdateCount];"], [187, "                update(update.idx, update.newVal, freq);"], [188, "                currentUpdateCount++;"], [191, "                currentUpdateCount--;"], [192, "                final Update update = updates[currentUpdateCount];"], [193, "                update(update.idx, update.prevVal, freq);"], [197, "                visit(eulerTour[moLeft], freq);"], [200, "                visit(eulerTour[moLeft], freq);"], [205, "                visit(eulerTour[moRight], freq);"], [208, "                visit(eulerTour[moRight], freq);"], [212, "                visit(query.LCA, freq);"], [216, "                visit(query.LCA, freq);"], [237, ""], [238, "    @Override"], [239, "    public String toString() {"], [240, "        return String.format(\"[L = %d R = %d updatesLess = %d LCA = %d id = %d]\", L, R, updatesTillNow, LCA, id);"], [241, "    }"], [245, "    final int idx, prevVal, newVal;"], [247, "    public Update(final int idx, final int newVal, final int prevVal) {"], [249, "        this.newVal = newVal;"], [250, "        this.prevVal = prevVal;"], [251, "    }"], [252, ""], [253, "    @Override"], [254, "    public String toString() {"], [255, "        return String.format(\"[idx = %d prevVal = %d newVal = %d\", idx, prevVal, newVal);"]]}, "num_lines_added": 50, "num_lines_removed": 71}