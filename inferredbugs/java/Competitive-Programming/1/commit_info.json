{"hash": "45a660bdb736a4039d9f1db150ad549cb7381100", "message": "Sqrt Decomposition implemented", "file_num_lines": 130, "diff_parsed": {"added": [[10, "    private final long blocks[];"], [14, "    private long powers[] = new long[202500];"], [15, "    private long invPowers[] = new long[202500];"], [23, "        this.blocks = new long[sqrt];"], [25, "        Arrays.fill(blocks, 1);"], [29, "            frequencies[i][0] = index + sqrt;"], [30, "            blocks[i] = powers[index + sqrt];"], [36, "        if (a[index] != value) {"], [37, "            int blockIndex = index / sqrt;"], [38, "            while (blockIndex < blocks.length) {"], [39, "                blocks[blockIndex] = ((((((((blocks[blockIndex]"], [40, "                        * invPowers[frequencies[blockIndex][a[index]]])"], [41, "                        % mod)"], [42, "                        * powers[frequencies[blockIndex][a[index]] - 1])"], [43, "                        % mod)"], [44, "                        * invPowers[frequencies[blockIndex][value]])"], [45, "                        % mod)"], [46, "                        * powers[frequencies[blockIndex][value] + 1])"], [47, "                        % mod);"], [48, "                frequencies[blockIndex][a[index]]--;"], [49, "                frequencies[blockIndex][value]++;"], [50, "                blockIndex++;"], [51, "            }"], [52, "            a[index] = value;"], [59, "        final int freq[] = new int[powers.length];"], [60, "        final int queue[] = new int[sqrt];"], [64, "            if (freq[a[blockIndex * sqrt + i]] == 0) {"], [65, "                queue[count++] = a[blockIndex * sqrt + i];"], [67, "            freq[a[blockIndex * sqrt + i]]++;"], [69, "        long result = blockIndex > 0 ? blocks[blockIndex - 1] : 1;"], [70, "        for (int i = 0; i < count; i++) {"], [71, "            final int previous = blockIndex > 0 ? frequencies[blockIndex - 1][queue[i]] : 0;"], [72, "            result = ((((result"], [73, "                    * invPowers[previous])"], [74, "                    % mod)"], [75, "                    * powers[previous + freq[queue[i]]])"], [76, "                    % mod);"], [78, "        return result;"], [83, "            powers[i] = pow(i + 1);"], [84, "            invPowers[i] = BigInteger.valueOf(powers[i]).modInverse(modo).longValue();"], [88, "    public static long pow(int mult) {"], [110, "        final long qs[][] = new long[q][3];"], [117, "                qs[i][1] = inputReader.readLong();"], [120, "        final Map<Long, Integer> mapping = new HashMap<>();"], [121, "        mapping.put(0L, 0);"], [131, "                decomposition.update((int) qs[i][1], mapping.get(qs[i][2]));"], [133, "                stringBuilder.append(decomposition.query((int) qs[i][1])).append('\\n');"]], "deleted": [[10, "    private final BigInteger blocks[];"], [14, "    private BigInteger powers[] = new BigInteger[202500];"], [15, "    private BigInteger invPowers[] = new BigInteger[202500];"], [23, "        this.blocks = new BigInteger[sqrt];"], [25, "        Arrays.fill(blocks, BigInteger.ONE);"], [29, "            if (i > 0) {"], [30, "                blocks[i] = blocks[i - 1];"], [31, "                frequencies[i][0] = frequencies[i - 1][0];"], [32, "            } else {"], [33, "                blocks[i] = BigInteger.ONE;"], [34, "            }"], [35, "            for (int j = 0; j < sqrt; j++) {"], [36, "                blocks[i] = blocks[i]"], [37, "                        .multiply(invPowers[frequencies[i][a[index + j]]])"], [38, "                        .mod(modo)"], [39, "                        .multiply(powers[frequencies[i][a[index + j]] + 1])"], [40, "                        .mod(modo);"], [41, "                ++frequencies[i][a[index + j]];"], [42, "            }"], [48, "        int blockIndex = index / sqrt;"], [49, "        while (blockIndex < blocks.length) {"], [50, "            blocks[blockIndex] = blocks[blockIndex]"], [51, "                    .multiply(invPowers[frequencies[blockIndex][a[index]]])"], [52, "                    .mod(modo)"], [53, "                    .multiply(powers[frequencies[blockIndex][a[index]] - 1])"], [54, "                    .mod(modo)"], [55, "                    .multiply(invPowers[frequencies[blockIndex][value]])"], [56, "                    .mod(modo)"], [57, "                    .multiply(powers[frequencies[blockIndex][value] + 1])"], [58, "                    .mod(modo);"], [59, "            frequencies[blockIndex][a[index]]--;"], [60, "            frequencies[blockIndex][value]++;"], [61, "            blockIndex++;"], [63, "        a[index] = value;"], [69, "        final Map<Integer, Integer> map = new HashMap<>();"], [70, "        final int[][] elements = new int[sqrt][2];"], [74, "            if (!map.containsKey(a[blockIndex * sqrt + i])) {"], [75, "                map.put(a[blockIndex * sqrt + i], count);"], [76, "                elements[count][0] = a[blockIndex * sqrt + i];"], [77, "                count++;"], [79, "            elements[map.get(a[blockIndex * sqrt + i])][1]++;"], [81, "        BigInteger result = blockIndex > 0 ? blocks[blockIndex - 1] : BigInteger.ONE;"], [82, "        for (final Map.Entry<Integer, Integer> entry : map.entrySet()) {"], [83, "            final int previous = blockIndex > 0 ? frequencies[blockIndex - 1][entry.getKey()] : 0;"], [84, "            result = result"], [85, "                    .multiply(invPowers[previous])"], [86, "                    .mod(modo)"], [87, "                    .multiply(powers[previous + elements[entry.getValue()][1]])"], [88, "                    .mod(modo);"], [90, "        return result.longValue();"], [95, "            powers[i] = BigInteger.valueOf(pow(i + 1));"], [96, "            invPowers[i] = powers[i].modInverse(modo);"], [100, "    private long pow(int mult) {"], [122, "        final int qs[][] = new int[q][3];"], [129, "                qs[i][1] = inputReader.readInt();"], [132, "        final Map<Integer, Integer> mapping = new HashMap<>();"], [133, "        mapping.put(0, 0);"], [143, "                decomposition.update(qs[i][1], mapping.get(qs[i][2]));"], [145, "                stringBuilder.append(decomposition.query(qs[i][1])).append('\\n');"]]}, "num_lines_added": 47, "num_lines_removed": 59}