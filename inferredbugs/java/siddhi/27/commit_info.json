{"hash": "0d45490fa3801dc0af7f0b9e4a972a61e10c4200", "message": "Kslack - locking changes by Miyuru", "file_num_lines": 251, "diff_parsed": {"added": [[37, "import java.util.concurrent.atomic.AtomicBoolean;"], [83, "        lock.lock();"], [110, "                        long timeDifference = greatestTimestamp - minTimestamp;"], [112, "                        if (timeDifference > k) {"], [113, "                            if (timeDifference < MAX_K) {"], [114, "                                k = timeDifference;"], [133, "                        entryIterator = expiredEventTreeMap.entrySet().iterator();"], [149, "                    if(expiredEventTreeMap.size() > 0) {"], [150, "                        TreeMap<Long, ArrayList<StreamEvent>> expiredEventTreeMapSnapShot = expiredEventTreeMap;"], [151, "                        expiredEventTreeMap = new TreeMap<Long, ArrayList<StreamEvent>>();"], [152, "                        onTimerEvent(expiredEventTreeMapSnapShot, nextProcessor);"], [153, "                        lastScheduledTimestamp = lastScheduledTimestamp + TIMER_DURATION;"], [154, "                        scheduler.notifyAt(lastScheduledTimestamp);"], [155, "                    }"], [162, "            //This happens due to user specifying an invalid field index."], [166, "        lock.unlock();"], [289, "        if(TIMER_DURATION != -1l && scheduler != null) {"], [299, "        if (lastScheduledTimestamp < 0) {"], [311, "        Iterator<Map.Entry<Long, ArrayList<StreamEvent>>> entryIterator = treeMap.entrySet().iterator();"], [312, "        ComplexEventChunk<StreamEvent> complexEventChunk = new ComplexEventChunk<StreamEvent>(false);"], [313, ""], [314, "        while (entryIterator.hasNext()) {"], [315, "            ArrayList<StreamEvent> timeEventList = entryIterator.next().getValue();"], [316, ""], [317, "            for (StreamEvent aTimeEventList : timeEventList) {"], [318, "                complexEventChunk.add(aTimeEventList);"], [321, "        nextProcessor.process(complexEventChunk);"]], "deleted": [[84, ""], [85, ""], [108, ""], [112, "                        if ((greatestTimestamp - minTimestamp) > k) {"], [113, "                            if ((greatestTimestamp - minTimestamp) < MAX_K) {"], [114, "                                k = greatestTimestamp - minTimestamp;"], [120, "                        lock.lock();"], [134, "                        entryIterator =  expiredEventTreeMap.entrySet().iterator();"], [148, "                        lock.unlock();"], [151, "                    onTimerEvent(expiredEventTreeMap, nextProcessor);"], [152, "                    lastScheduledTimestamp = lastScheduledTimestamp + TIMER_DURATION;"], [153, "                    scheduler.notifyAt(lastScheduledTimestamp);"], [160, "//            This happens due to user specifying an invalid field index."], [164, ""], [287, "        if(TIMER_DURATION != -1l && scheduler != null && lastScheduledTimestamp < 0) {"], [297, "        if (TIMER_DURATION > 0 && lastScheduledTimestamp < 0) {"], [309, "        if((expiredEventTreeMap != null) && (expiredEventTreeMap.keySet().size() != 0)) {"], [310, "            lock.lock();"], [311, "            Iterator<Map.Entry<Long, ArrayList<StreamEvent>>> entryIterator = expiredEventTreeMap.entrySet().iterator();"], [312, "            ComplexEventChunk<StreamEvent> complexEventChunk = new ComplexEventChunk<StreamEvent>(false);"], [313, ""], [314, "            while (entryIterator.hasNext()) {"], [315, "                Map.Entry<Long, ArrayList<StreamEvent>> entry = entryIterator.next();"], [316, "                entryIterator.remove();"], [317, "                ArrayList<StreamEvent> timeEventList = entry.getValue();"], [318, ""], [319, "                for (StreamEvent aTimeEventList : timeEventList) {"], [320, "                    complexEventChunk.add(aTimeEventList);"], [321, "                }"], [323, "            lock.unlock();"], [324, "            nextProcessor.process(complexEventChunk);"]]}, "num_lines_added": 27, "num_lines_removed": 31}