{"hash": "f1346cea5d7f6d4af0613e08bad2335a8b15756d", "message": "Use device tree to properly nest Windows USB (#186)", "file_num_lines": 121, "diff_parsed": {"added": [[26, "import org.slf4j.Logger;"], [27, "import org.slf4j.LoggerFactory;"], [28, ""], [29, "import com.sun.jna.Native;"], [30, "import com.sun.jna.platform.win32.SetupApi;"], [31, "import com.sun.jna.platform.win32.SetupApi.SP_DEVINFO_DATA;"], [32, "import com.sun.jna.platform.win32.WinNT;"], [33, "import com.sun.jna.platform.win32.WinNT.HANDLE;"], [34, "import com.sun.jna.ptr.IntByReference;"], [35, "import com.sun.jna.ptr.NativeLongByReference;"], [36, ""], [39, "import oshi.jna.platform.windows.Cfgmgr32;"], [47, "    private static final Logger LOG = LoggerFactory.getLogger(WindowsUsbDevice.class);"], [48, ""], [86, "        // Get serial # for disk drives or other physical media"], [98, "        // Build the device tree. Start with the USB Controllers"], [99, "        // and recurse downward to devices as needed"], [100, "        usbMap = WmiUtil.selectStringsFrom(null, \"Win32_USBController\", \"PNPDeviceID\", null);"], [101, "        List<UsbDevice> controllerDevices = new ArrayList<UsbDevice>();"], [102, "        for (String controllerDeviceId : usbMap.get(\"PNPDeviceID\")) {"], [103, "            putChildrenInDeviceTree(controllerDeviceId, 0);"], [104, "            controllerDevices.add(getDeviceAndChildren(controllerDeviceId));"], [105, "        }"], [106, "        return controllerDevices.toArray(new UsbDevice[controllerDevices.size()]);"], [107, "    }"], [108, ""], [109, "    /**"], [110, "     * Navigates the Device Tree to place all children PNPDeviceIDs into the map"], [111, "     * for the specified deviceID. Recursively adds children's children, etc."], [112, "     *"], [113, "     * @param deviceId"], [114, "     *            The device to add respective children to the map"], [115, "     * @param devInst"], [116, "     *            The device instance (devnode handle), if known. If set to 0,"], [117, "     *            the code will search for a match."], [118, "     */"], [119, "    private static void putChildrenInDeviceTree(String deviceId, int devInst) {"], [120, "        // If no devInst provided, find it by matching deviceId"], [121, "        if (devInst == 0) {"], [122, "            // Get a handle to the device with this deviceId"], [123, "            // Start with all classes"], [124, "            HANDLE hinfoSet = SetupApi.INSTANCE.SetupDiGetClassDevs(null, null, null, SetupApi.DIGCF_ALLCLASSES);"], [125, "            if (hinfoSet == WinNT.INVALID_HANDLE_VALUE) {"], [126, "                LOG.error(\"Invalid handle value for {}. Error code: {}\", deviceId, Native.getLastError());"], [127, "                return;"], [129, "            // Iterate to find matching parent"], [130, "            SP_DEVINFO_DATA dinfo = new SP_DEVINFO_DATA();"], [131, "            dinfo.cbSize = dinfo.size();"], [132, "            int i = 0;"], [133, "            while (SetupApi.INSTANCE.SetupDiEnumDeviceInfo(hinfoSet, i++, dinfo)) {"], [134, "                if (deviceId.equals(getDeviceId(dinfo.DevInst))) {"], [135, "                    devInst = dinfo.DevInst;"], [136, "                    break;"], [139, "        }"], [140, "        if (devInst == 0) {"], [141, "            LOG.error(\"Unable to find a devnode handle for {}.\", deviceId);"], [142, "            return;"], [143, "        }"], [144, "        // Now iterate the children. Call CM_Get_Child to get first child"], [145, "        IntByReference child = new IntByReference();"], [146, "        if (0 == Cfgmgr32.INSTANCE.CM_Get_Child(child, devInst, 0)) {"], [147, "            // Add first child to a list"], [148, "            List<String> childList = new ArrayList<>();"], [149, "            String childId = getDeviceId(child.getValue());"], [150, "            childList.add(childId);"], [151, "            hubMap.put(deviceId, childList);"], [152, "            putChildrenInDeviceTree(childId, child.getValue());"], [153, "            // Find any other children"], [154, "            IntByReference sibling = new IntByReference();"], [155, "            while (0 == Cfgmgr32.INSTANCE.CM_Get_Sibling(sibling, child.getValue(), 0)) {"], [156, "                // Add to the list"], [157, "                String siblingId = getDeviceId(sibling.getValue());"], [158, "                hubMap.get(deviceId).add(siblingId);"], [159, "                putChildrenInDeviceTree(siblingId, sibling.getValue());"], [160, "                // Make this sibling the new child to find other siblings"], [161, "                child = sibling;"], [164, "    }"], [166, "    /**"], [167, "     * Gets the device id for a devnode"], [168, "     *"], [169, "     * @param devInst"], [170, "     *            the handle to the devnode"], [171, "     * @return The PNPDeviceID"], [172, "     */"], [173, "    private static String getDeviceId(int devInst) {"], [174, "        NativeLongByReference ulLen = new NativeLongByReference();"], [175, "        if (0 != Cfgmgr32.INSTANCE.CM_Get_Device_ID_Size(ulLen, devInst, 0)) {"], [176, "            LOG.error(\"Couldn't get device string for device instance {}\", devInst);"], [177, "            return \"\";"], [179, "        // Add 1 for null terminator"], [180, "        int size = ulLen.getValue().intValue() + 1;"], [181, "        char[] buffer = new char[size];"], [182, "        if (0 != Cfgmgr32.INSTANCE.CM_Get_Device_ID(devInst, buffer, size, 0)) {"], [183, "            LOG.error(\"Couldn't get device string for device instance {} with size {}\", devInst, size);"], [184, "            return \"\";"], [185, "        }"], [186, "        return new String(buffer).trim();"]], "deleted": [[28, "import oshi.util.ExecutingCommand;"], [71, "            String serialNumber = \"\";"], [72, "            // PNPDeviceID: USB\\VID_203A&PID_FFF9&MI_00\\6&18C4CF61&0&0000"], [73, "            // Split by \\ to get bus type (USB), VendorID/ProductID, other info"], [74, "            // As a temporary hack for a serial number, use last \\-split field"], [75, "            // using 2nd &-split field if 4 fields"], [76, "            String[] idSplit = pnpDeviceID.split(\"\\\\\\\\\");"], [77, "            if (idSplit.length > 2) {"], [78, "                idSplit = idSplit[2].split(\"&\");"], [79, "                if (idSplit.length > 3) {"], [80, "                    serialNumber = idSplit[1];"], [81, "                }"], [82, "            }"], [83, "            if (serialNumber.length() > 0) {"], [84, "                serialMap.put(pnpDeviceID, serialNumber);"], [85, "            }"], [88, "        // Disk drives or other physical media have a better way of getting"], [89, "        // serial number. Grab these and overwrite the temporary serial number"], [90, "        // assigned above if necessary"], [102, "        // Some USB Devices are hubs to which other devices connect. Knowing"], [103, "        // which ones are hubs will help later when walking the device tree"], [104, "        usbMap = WmiUtil.selectStringsFrom(null, \"Win32_USBHub\", \"PNPDeviceID\", null);"], [105, "        List<String> usbHubs = usbMap.get(\"PNPDeviceID\");"], [106, ""], [107, "        // Now build the hub map linking USB devices with their parent hub."], [108, "        // At the top of the device tree are USB Controllers. All USB hubs and"], [109, "        // devices descend from these. Because this query returns pointers it's"], [110, "        // just not practical to try to query via COM so we use a command line"], [111, "        // in order to get USB devices in a text format"], [112, "        ArrayList<String> links = ExecutingCommand"], [113, "                .runNative(\"wmic path Win32_USBControllerDevice GET Antecedent,Dependent\");"], [114, "        // This iteration actually walks the device tree in order so while the"], [115, "        // antecedent of all USB devices is its controller, we know that if a"], [116, "        // device is not a hub that the last hub listed is its parent"], [117, "        // Devices with PNPDeviceID containing \"ROOTHUB\" are special and will be"], [118, "        // parents of the next item(s)"], [119, "        // This won't id chained hubs (other than the root hub) but is a quick"], [120, "        // hack rather than walking the entire device tree using the SetupDI API"], [121, "        // and good enough since exactly how a USB device is connected is"], [122, "        // theoretically transparent to the user"], [123, "        hubMap.clear();"], [124, "        String currentHub = null;"], [125, "        String rootHub = null;"], [126, "        for (String s : links) {"], [127, "            String[] split = s.split(\"\\\\s+\");"], [128, "            if (split.length < 2) {"], [129, "                continue;"], [130, "            }"], [131, "            String antecedent = getId(split[0]);"], [132, "            String dependent = getId(split[1]);"], [133, "            // Ensure initial defaults are sane if something goes wrong"], [134, "            if (currentHub == null || rootHub == null) {"], [135, "                currentHub = antecedent;"], [136, "                rootHub = antecedent;"], [138, "            String parent;"], [139, "            if (dependent.contains(\"ROOT_HUB\")) {"], [140, "                // This is a root hub, assign controller as parent;"], [141, "                parent = antecedent;"], [142, "                rootHub = dependent;"], [143, "                currentHub = dependent;"], [144, "            } else if (usbHubs.contains(dependent)) {"], [145, "                // This is a hub, assign parent as root hub"], [146, "                if (rootHub == null) {"], [147, "                    rootHub = antecedent;"], [149, "                parent = rootHub;"], [150, "                currentHub = dependent;"], [151, "            } else {"], [152, "                // This is not a hub, assign parent as previous hub"], [153, "                if (currentHub == null) {"], [154, "                    currentHub = antecedent;"], [155, "                }"], [156, "                parent = currentHub;"], [158, "            // Finally add the parent/child linkage to the map"], [159, "            if (!hubMap.containsKey(parent)) {"], [160, "                hubMap.put(parent, new ArrayList<String>());"], [162, "            hubMap.get(parent).add(dependent);"], [165, "        // Finally we simply get the device IDs of the USB Controllers. These"], [166, "        // will recurse downward to devices as needed"], [167, "        usbMap = WmiUtil.selectStringsFrom(null, \"Win32_USBController\", \"PNPDeviceID\", null);"], [168, "        List<UsbDevice> controllerDevices = new ArrayList<UsbDevice>();"], [169, "        for (String controllerDeviceID : usbMap.get(\"PNPDeviceID\")) {"], [170, "            controllerDevices.add(getDeviceAndChildren(controllerDeviceID));"], [172, "        return controllerDevices.toArray(new UsbDevice[controllerDevices.size()]);"], [192, ""], [193, "    /**"], [194, "     * Parses DeviceID from CIM_USBController text"], [195, "     *"], [196, "     * @param string"], [197, "     *            Text of form (stuff)DeviceID=\"(ID)\""], [198, "     * @return The parsed device ID"], [199, "     */"], [200, "    private static String getId(String s) {"], [201, "        String[] split = s.split(\"\\\"\");"], [202, "        return split.length < 2 ? \"\" : split[1];"], [203, "    }"]]}, "num_lines_added": 97, "num_lines_removed": 95}