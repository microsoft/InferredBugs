{"hash": "18c984a3c2532220ab53e87d57db2340753cd958", "message": "Better parsing of Windows USB device tree", "file_num_lines": 114, "diff_parsed": {"added": [[28, "import oshi.util.ExecutingCommand;"], [40, "    /*"], [41, "     * Maps to store information using PNPDeviceID as the key"], [42, "     */"], [43, "    private static Map<String, String> nameMap = new HashMap<>();"], [44, "    private static Map<String, String> vendorMap = new HashMap<>();"], [45, "    private static Map<String, String> serialMap = new HashMap<>();"], [46, "    private static Map<String, List<String>> hubMap = new HashMap<>();"], [47, ""], [52, "        // Start by collecting information for all PNP devices. While in theory"], [53, "        // these could be individually queried with a WHERE clause, grabbing"], [54, "        // them all up front incurs minimal memory overhead in exchange for"], [55, "        // faster access later"], [57, "        // Clear maps"], [58, "        nameMap.clear();"], [59, "        vendorMap.clear();"], [60, "        serialMap.clear();"], [62, "        // Query Win32_PnPEntity to populate the maps"], [72, "            // PNPDeviceID: USB\\VID_203A&PID_FFF9&MI_00\\6&18C4CF61&0&0000"], [73, "            // Split by \\ to get bus type (USB), VendorID/ProductID, other info"], [74, "            // As a temporary hack for a serial number, use last \\-split field"], [75, "            // using 2nd &-split field if 4 fields"], [88, "        // Disk drives or other physical media have a better way of getting"], [89, "        // serial number. Grab these and overwrite the temporary serial number"], [90, "        // assigned above if necessary"], [102, "        // Some USB Devices are hubs to which other devices connect. Knowing"], [103, "        // which ones are hubs will help later when walking the device tree"], [105, "        List<String> usbHubs = usbMap.get(\"PNPDeviceID\");"], [106, ""], [107, "        // Now build the hub map linking USB devices with their parent hub."], [108, "        // At the top of the device tree are USB Controllers. All USB hubs and"], [109, "        // devices descend from these. Because this query returns pointers it's"], [110, "        // just not practical to try to query via COM so we use a command line"], [111, "        // in order to get USB devices in a text format"], [112, "        ArrayList<String> links = ExecutingCommand"], [113, "                .runNative(\"wmic path Win32_USBControllerDevice GET Antecedent,Dependent\");"], [114, "        // This iteration actually walks the device tree in order so while the"], [115, "        // antecedent of all USB devices is its controller, we know that if a"], [116, "        // device is not a hub that the last hub listed is its parent"], [117, "        // Devices with PNPDeviceID containing \"ROOTHUB\" are special and will be"], [118, "        // parents of the next item(s)"], [119, "        // This won't id chained hubs (other than the root hub) but is a quick"], [120, "        // hack rather than walking the entire device tree using the SetupDI API"], [121, "        // and good enough since exactly how a USB device is connected is"], [122, "        // theoretically transparent to the user"], [123, "        hubMap.clear();"], [124, "        String currentHub = null;"], [125, "        String rootHub = null;"], [126, "        for (String s : links) {"], [127, "            String[] split = s.split(\"\\\\s+\");"], [128, "            if (split.length < 2) {"], [129, "                continue;"], [130, "            }"], [131, "            String antecedent = getId(split[0]);"], [132, "            String dependent = getId(split[1]);"], [133, "            // Ensure initial defaults are sane if something goes wrong"], [134, "            if (currentHub == null || rootHub == null) {"], [135, "                currentHub = antecedent;"], [136, "                rootHub = antecedent;"], [137, "            }"], [138, "            String parent;"], [139, "            if (dependent.contains(\"ROOT_HUB\")) {"], [140, "                // This is a root hub, assign controller as parent;"], [141, "                parent = antecedent;"], [142, "                rootHub = dependent;"], [143, "                currentHub = dependent;"], [144, "            } else if (usbHubs.contains(dependent)) {"], [145, "                // This is a hub, assign parent as root hub"], [146, "                if (rootHub == null) {"], [147, "                    rootHub = antecedent;"], [148, "                }"], [149, "                parent = rootHub;"], [150, "                currentHub = dependent;"], [151, "            } else {"], [152, "                // This is not a hub, assign parent as previous hub"], [153, "                if (currentHub == null) {"], [154, "                    currentHub = antecedent;"], [155, "                }"], [156, "                parent = currentHub;"], [157, "            }"], [158, "            // Finally add the parent/child linkage to the map"], [159, "            if (!hubMap.containsKey(parent)) {"], [160, "                hubMap.put(parent, new ArrayList<String>());"], [162, "            hubMap.get(parent).add(dependent);"], [165, "        // Finally we simply get the device IDs of the USB Controllers. These"], [166, "        // will recurse downward to devices as needed"], [167, "        usbMap = WmiUtil.selectStringsFrom(null, \"Win32_USBController\", \"PNPDeviceID\", null);"], [168, "        List<UsbDevice> controllerDevices = new ArrayList<UsbDevice>();"], [169, "        for (String controllerDeviceID : usbMap.get(\"PNPDeviceID\")) {"], [170, "            controllerDevices.add(getDeviceAndChildren(controllerDeviceID));"], [171, "        }"], [172, "        return controllerDevices.toArray(new UsbDevice[controllerDevices.size()]);"], [173, "    }"], [174, ""], [175, "    /**"], [176, "     * Recursively creates WindowsUsbDevices by fetching information from maps"], [177, "     * to populate fields"], [178, "     *"], [179, "     * @param hubDeviceID"], [180, "     *            The PNPdeviceID of this device."], [181, "     * @return A WindowsUsbDevice corresponding to this deviceID"], [182, "     */"], [183, "    private static WindowsUsbDevice getDeviceAndChildren(String hubDeviceID) {"], [184, "        List<String> pnpDeviceIDs = hubMap.getOrDefault(hubDeviceID, new ArrayList<>());"], [185, "        List<WindowsUsbDevice> usbDevices = new ArrayList<>();"], [187, "            usbDevices.add(getDeviceAndChildren(pnpDeviceID));"], [189, "        return new WindowsUsbDevice(nameMap.getOrDefault(hubDeviceID, \"\"), vendorMap.getOrDefault(hubDeviceID, \"\"),"], [190, "                serialMap.getOrDefault(hubDeviceID, \"\"), usbDevices.toArray(new UsbDevice[usbDevices.size()]));"], [191, "    }"], [193, "    /**"], [194, "     * Parses DeviceID from CIM_USBController text"], [195, "     *"], [196, "     * @param string"], [197, "     *            Text of form (stuff)DeviceID=\"(ID)\""], [198, "     * @return The parsed device ID"], [199, "     */"], [200, "    private static String getId(String s) {"], [201, "        String[] split = s.split(\"\\\"\");"], [202, "        return split.length < 2 ? \"\" : split[1];"]], "deleted": [[25, "import java.util.stream.Collectors;"], [44, "        List<UsbDevice> usbDevices = new ArrayList<UsbDevice>();"], [46, "        // Store map of pnpID to name, Manufacturer, serial"], [47, "        Map<String, String> nameMap = new HashMap<>();"], [48, "        Map<String, String> vendorMap = new HashMap<>();"], [49, "        Map<String, String> serialMap = new HashMap<>();"], [60, "            // Format: USB\\VID_203A&PID_FFF9&MI_00\\6&18C4CF61&0&0000"], [61, "            // Split by \\ to get bus type (USB), VendorID/ProductID/Model"], [62, "            // Last field contains Serial # in hex as 2nd split by"], [63, "            // ampersands"], [76, "        // Get serial # of disk drives (may overwrite previous, that's OK)"], [88, "        // Finally, prepare final list for output"], [89, "        // Start with controllers"], [90, "        usbMap = WmiUtil.selectStringsFrom(null, \"Win32_USBController\", \"PNPDeviceID\", null);"], [91, "        List<String> pnpDeviceIDs = usbMap.get(\"PNPDeviceID\");"], [92, "        // Add any hubs"], [94, "        pnpDeviceIDs.addAll(usbMap.get(\"PNPDeviceID\"));"], [95, "        // Add any stray USB devices in the list"], [96, "        for (String pnpDeviceID : nameMap.keySet().stream().sorted().collect(Collectors.toList())) {"], [97, "            if (pnpDeviceID.startsWith(\"USB\\\\\") && !pnpDeviceIDs.contains(pnpDeviceID)) {"], [98, "                pnpDeviceIDs.add(pnpDeviceID);"], [103, "            usbDevices.add("], [104, "                    new WindowsUsbDevice(nameMap.getOrDefault(pnpDeviceID, \"\"), vendorMap.getOrDefault(pnpDeviceID, \"\"),"], [105, "                            serialMap.getOrDefault(pnpDeviceID, \"\"), new WindowsUsbDevice[0]));"], [108, "        return usbDevices.toArray(new UsbDevice[usbDevices.size()]);"]]}, "num_lines_added": 119, "num_lines_removed": 25}