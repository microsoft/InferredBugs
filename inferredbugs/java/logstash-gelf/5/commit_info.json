{"hash": "9976077b30e5e6486bf9bcc34d3b502d96c4a5cd", "message": "Add constant write backoff in GelfTCPSender #248\n\nfor cases when a sender cannot write any bytes to the socket channel several times. Limit the time to stay in such mode.\nstop attempts to send a message in case of InterruptedException.\n\nOriginal pull request: #249", "file_num_lines": 176, "diff_parsed": {"added": [[26, "    public static final String WRITE_BACKOFF_TIME = \"writeBackoffTime\";"], [27, "    public static final String WRITE_BACKOFF_THRESHOLD = \"writeBackoffThreshold\";"], [28, "    public static final String MAX_WRITE_BACKOFF_TIME = \"maxWriteBackoffTime\";"], [35, "    private final int writeBackoffThreshold;"], [36, "    private final int maxWriteBackoffTimeMs;"], [37, "    private final BackOff backoff;"], [38, ""], [74, "        this(host, port, connectTimeoutMs, readTimeoutMs, deliveryAttempts, keepAlive,"], [75, "                new ConstantBackOff(50), 10, connectTimeoutMs, errorReporter);"], [76, "    }"], [77, ""], [78, "    /**"], [79, "     * @param host the host, must not be {@literal null}."], [80, "     * @param port the port."], [81, "     * @param connectTimeoutMs connection timeout, in {@link TimeUnit#MILLISECONDS}."], [82, "     * @param readTimeoutMs read timeout, in {@link TimeUnit#MILLISECONDS}."], [83, "     * @param deliveryAttempts number of delivery attempts."], [84, "     * @param keepAlive {@literal true} to enable TCP keep-alive."], [85, "     * @param backoff Backoff strategy to activate if a socket sender buffer is full and several attempts to write to the socket are unsuccessful due to it."], [86, "     * @param writeBackoffThreshold attempts to write to a socket before a backoff will be activated."], [87, "     * @param maxWriteBackoffTimeMs Maximum time spent for awaiting during a backoff for a single message send operation."], [88, "     * @param errorReporter the error reporter, must not be {@literal null}."], [89, "     * @throws IOException in case of I/O errors"], [90, "     */"], [91, "    public GelfTCPSender(String host, int port, int connectTimeoutMs, int readTimeoutMs, int deliveryAttempts,"], [92, "                         boolean keepAlive,"], [93, "                         BackOff backoff, int writeBackoffThreshold, int maxWriteBackoffTimeMs,"], [94, "                         ErrorReporter errorReporter) throws IOException {"], [95, ""], [103, "        this.backoff = backoff;"], [104, "        this.writeBackoffThreshold = writeBackoffThreshold;"], [105, "        this.maxWriteBackoffTimeMs = maxWriteBackoffTimeMs;"], [106, ""], [146, "                try {"], [147, "                    synchronized (ioLock) {"], [148, "                        write(buffer);"], [149, "                    }"], [150, "                } catch (InterruptedException e) {"], [151, "                    reportError(e.getMessage(), new IOException(\"Cannot send data to \" + getHost() + \":\" + getPort(), e));"], [152, "                    Thread.currentThread().interrupt();"], [153, "                    return false;"], [171, "    protected void write(ByteBuffer buffer) throws IOException, InterruptedException {"], [172, "        int nothingWrittenTimesInRow = 0;"], [173, "        int totalSleepTimeMs = 0;"], [174, "        BackOffExecution backoffExecution = null;"], [184, "            if (written == 0) {"], [185, "                if (backoffExecution == null) {"], [186, "                    backoffExecution = backoff.start();"], [187, "                }"], [188, "                nothingWrittenTimesInRow++;"], [189, "                if (nothingWrittenTimesInRow > writeBackoffThreshold) {"], [190, "                    if (totalSleepTimeMs > maxWriteBackoffTimeMs) {"], [191, "                        Closer.close(channel());"], [192, "                        throw new SocketException(\"Cannot write buffer to channel, no progress in writing\");"], [193, "                    }"], [194, "                    totalSleepTimeMs += sleep(backoffExecution.nextBackOff());"], [195, "                }"], [196, "            } else { // written > 0"], [197, "                nothingWrittenTimesInRow = 0;"], [198, "            }"], [199, "        }"], [200, "    }"], [201, ""], [202, "    private static long sleep(long millis) throws InterruptedException {"], [203, "        long startTime = System.nanoTime();"], [204, "        Thread.sleep(millis);"], [205, "        long sleepTimeMs = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startTime);"], [206, "        if (sleepTimeMs < 0) {"], [207, "            sleepTimeMs = 0;"], [209, "        return sleepTimeMs;"]], "deleted": [[113, "                synchronized (ioLock) {"], [114, "                    write(buffer);"], [132, "    protected void write(ByteBuffer buffer) throws IOException {"]]}, "num_lines_added": 70, "num_lines_removed": 3}