{"hash": "3b7c991b32dd5d6ff76298f27ac9ed9e22bb2e83", "message": "Refine the ZkHelixManager.disconnect() method so it won't be blocked when the ZK connection breaks. (#1149)\n\nThe issue was that if ZkHelixManager.disconnect() is called when the ZK connection is not synConnected, the disconnect() call will hang and never return. This usually blocks Helix users' code when they try to clean up and finalize after ZK connection becomes unrecoverable.\r\nThis PR introduces a temporary thread to finish the cleanup work which relies on the ZK connection (or application code). This thread will be interrupted if ZK connection breaks before or during the disconnect process.", "file_num_lines": 1069, "diff_parsed": {"added": [[32, "import java.util.concurrent.atomic.AtomicBoolean;"], [93, "import org.apache.helix.zookeeper.datamodel.serializer.ChainedPathZkSerializer;"], [94, "import org.apache.helix.zookeeper.datamodel.serializer.ZNRecordSerializer;"], [820, "      if (!cleanupCallbackHandlers()) {"], [821, "        LOG.warn("], [822, "            \"The callback handler cleanup has been cleanly done. \""], [823, "                + \"Some callback handlers might not be reset properly. \""], [824, "                + \"Continue to finish the other Helix Mananger disconnect tasks.\");"], [861, "  /**"], [862, "   * The callback handler cleanup operations that require an active ZkClient connection."], [863, "   * If ZkClient is not connected, Helix Manager shall skip the cleanup."], [864, "   *"], [865, "   * @return true if the cleanup has been done successfully."], [866, "   */"], [867, "  private boolean cleanupCallbackHandlers() {"], [868, "    AtomicBoolean cleanupDone = new AtomicBoolean(false);"], [869, ""], [870, "    if (_zkclient.waitUntilConnected(_waitForConnectedTimeout, TimeUnit.MILLISECONDS)) {"], [871, "      // Create a separate thread for executing cleanup task to avoid forever retry."], [872, "      Thread cleanupThread = new Thread(String"], [873, "          .format(\"Cleanup thread for %s-%s-%s\", _clusterName, _instanceName, _instanceType)) {"], [874, "        @Override"], [875, "        public void run() {"], [876, "          // TODO reset user defined handlers only"], [877, "          resetHandlers(true);"], [878, ""], [879, "          if (_leaderElectionHandler != null) {"], [880, "            _leaderElectionHandler.reset(true);"], [881, "          }"], [882, ""], [883, "          ParticipantManager participantManager = _participantManager;"], [884, "          if (participantManager != null) {"], [885, "            participantManager.disconnect();"], [886, "          }"], [887, ""], [888, "          cleanupDone.set(true);"], [889, "        }"], [890, "      };"], [891, ""], [892, "      // Define the state listener to terminate the cleanup thread when the ZkConnection breaks."], [893, "      IZkStateListener stateListener = new IZkStateListener() {"], [894, "        @Override"], [895, "        public void handleStateChanged(KeeperState state) {"], [896, "          // If the connection breaks during the cleanup , then stop the cleanup thread."], [897, "          if (state != KeeperState.SyncConnected) {"], [898, "            cleanupThread.interrupt();"], [899, "          }"], [900, "        }"], [901, ""], [902, "        @Override"], [903, "        public void handleNewSession(String sessionId) {"], [904, "          // nothing"], [905, "        }"], [906, ""], [907, "        @Override"], [908, "        public void handleSessionEstablishmentError(Throwable error) {"], [909, "          // nothing"], [910, "        }"], [911, "      };"], [912, ""], [913, "      cleanupThread.start();"], [914, "      try {"], [915, "        // Subscribe and check the connection status one more time to ensure the thread is running"], [916, "        // with an active ZkConnection."], [917, "        _zkclient.subscribeStateChanges(stateListener);"], [918, "        if (!_zkclient.waitUntilConnected(0, TimeUnit.MILLISECONDS)) {"], [919, "          cleanupThread.interrupt();"], [920, "        }"], [921, ""], [922, "        try {"], [923, "          cleanupThread.join();"], [924, "        } catch (InterruptedException ex) {"], [925, "          cleanupThread.interrupt();"], [926, "        }"], [927, "      } finally {"], [928, "        _zkclient.unsubscribeStateChanges(stateListener);"], [929, "      }"], [930, "    } else {"], [931, "      LOG.warn("], [932, "          \"ZkClient is not connected to the Zookeeper. Skip the cleanup work that requires accessing Zookeeper.\");"], [933, "    }"], [934, ""], [935, "    return cleanupDone.get();"], [936, "  }"], [937, ""]], "deleted": [[35, ""], [103, "import org.apache.helix.zookeeper.datamodel.serializer.ChainedPathZkSerializer;"], [104, "import org.apache.helix.zookeeper.datamodel.serializer.ZNRecordSerializer;"], [820, "      // TODO reset user defined handlers only"], [821, "      // TODO Fix the issue that when connection disconnected, reset handlers will be blocked. -- JJ"], [822, "      // This is because reset logic contains ZK operations."], [823, "      resetHandlers(true);"], [824, ""], [825, "      if (_leaderElectionHandler != null) {"], [826, "        _leaderElectionHandler.reset(true);"], [828, ""], [839, "      ParticipantManager participantManager = _participantManager;"], [840, "      if (participantManager != null) {"], [841, "        participantManager.disconnect();"], [842, "      }"], [843, ""]]}, "num_lines_added": 85, "num_lines_removed": 16}