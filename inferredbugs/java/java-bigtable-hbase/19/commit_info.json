{"hash": "222e620f64e5e0bbc40637dc478cc24e0e02dbd6", "message": "Adding tracing spans to BigtableTable and AbstractRetryingOperation. (#1506)\n\n* Adding tracing spans to BigtableTable and AbstractRetryingOperation.\r\n\r\n* Using opencensus' GrpcStatus Util. Reverting BigtableTable.getScanner().", "file_num_lines": 241, "diff_parsed": {"added": [[25, ""], [37, "import com.google.common.collect.ImmutableMap;"], [47, "import io.grpc.Status.Code;"], [48, "import io.opencensus.common.NonThrowingCloseable;"], [49, "import io.opencensus.contrib.grpc.util.StatusConverter;"], [50, "import io.opencensus.trace.Annotation;"], [51, "import io.opencensus.trace.AttributeValue;"], [52, "import io.opencensus.trace.EndSpanOptions;"], [53, "import io.opencensus.trace.Span;"], [54, "import io.opencensus.trace.Tracer;"], [55, "import io.opencensus.trace.Tracing;"], [65, "  private static final Tracer TRACER = Tracing.getTracer();"], [71, "  private static String makeSpanName(String prefix, String fullMethodName) {"], [72, "    return prefix + \".\" + fullMethodName.replace('/', '.');"], [73, "  }"], [74, ""], [118, "  protected final Span operationSpan;"], [119, ""], [144, "    String spanName = makeSpanName(\"Operation\", rpc.getMethodDescriptor().getFullMethodName());"], [145, "    operationSpan = TRACER.spanBuilder(spanName).setRecordEvents(true).startSpan();"], [151, "    try (NonThrowingCloseable s = TRACER.withSpan(operationSpan)) {"], [152, "      synchronized (callLock) {"], [153, "        call = null;"], [154, "      }"], [155, "      rpcTimerContext.close();"], [156, "      // OK"], [157, "      if (status.isOk()) {"], [158, "        if (onOK(trailers)) {"], [159, "          finalizeStats(status);"], [160, "        }"], [161, "      } else {"], [162, "        onError(status, trailers);"], [163, "      }"], [165, "  }"], [167, "  protected void finalizeStats(Status status) {"], [168, "    operationTimerContext.close();"], [169, "    if (operationSpan != null) {"], [170, "      io.opencensus.trace.Status ocensusStatus = StatusConverter.fromGrpcStatus(status);"], [171, "      operationSpan.end(EndSpanOptions.builder().setStatus(ocensusStatus).build());"], [181, "      finalizeStats(status);"], [186, "    if (!retryOptions.enableRetries() || !retryOptions.isRetryable(code)"], [187, "    // Unauthenticated is special because the request never made it to"], [188, "    // to the server, so all requests are retryable"], [191, "      finalizeStats(status);"], [205, "      LOG.info(\"Retrying failed call. Failure #%d, got: %s on channel %s\", status.getCause(),"], [206, "        failedCount, status, channelId);"], [212, "    operationSpan.addAnnotation(\"exhaustedRetries\");"], [214, "    finalizeStats(status);"], [220, "    operationSpan.addAnnotation(\"retryWithBackoff\","], [221, "      ImmutableMap.of(\"backoff\", AttributeValue.longAttributeValue(nextBackOff)));"], [268, "    try (NonThrowingCloseable s = TRACER.withSpan(operationSpan)) {"], [269, "      rpcTimerContext = rpc.getRpcMetrics().timeRpc();"], [270, "      operationSpan.addAnnotation(Annotation.fromDescriptionAndAttributes(\"rpcStart\","], [271, "        ImmutableMap.of(\"attempt\", AttributeValue.longAttributeValue(failedCount))));"], [272, "      Metadata metadata = new Metadata();"], [273, "      metadata.merge(originalMetadata);"], [274, "      synchronized (callLock) {"], [275, "        // There's a subtle race condition in RetryingStreamOperation which requires a separate"], [276, "        // newCall/start split. The call variable needs to be set before onMessage() happens; that"], [277, "        // usually will occur, but some unit tests broke with a merged newCall and start."], [278, "        call = rpc.newCall(getCallOptions());"], [279, "        rpc.start(getRetryRequest(), this, metadata, call);"], [280, "      }"]], "deleted": [[18, "import io.grpc.Status.Code;"], [132, "    synchronized (callLock) {"], [133, "      call = null;"], [135, "    rpcTimerContext.close();"], [137, "    // OK"], [138, "    if (status.isOk()) {"], [139, "      if (onOK(trailers)) {"], [140, "        operationTimerContext.close();"], [141, "      }"], [142, "    } else {"], [143, "      onError(status, trailers);"], [153, "      operationTimerContext.close();"], [158, "    if (!retryOptions.enableRetries()"], [159, "        || !retryOptions.isRetryable(code)"], [160, "        // Unauthenticated is special because the request never made it to"], [161, "        // to the server, so all requests are retryable"], [164, "      operationTimerContext.close();"], [178, "      LOG.info(\"Retrying failed call. Failure #%d, got: %s on channel %s\","], [179, "          status.getCause(), failedCount, status, channelId);"], [186, "    operationTimerContext.close();"], [238, "    rpcTimerContext = rpc.getRpcMetrics().timeRpc();"], [239, "    Metadata metadata = new Metadata();"], [240, "    metadata.merge(originalMetadata);"], [241, "    synchronized (callLock) {"], [242, "      // There's a subtle race condition in RetryingStreamOperation which requires a separate"], [243, "      // newCall/start split. The call variable needs to be set before onMessage() happens; that"], [244, "      // usually will occur, but some unit tests broke with a merged newCall and start."], [245, "      call = rpc.newCall(getCallOptions());"], [246, "      rpc.start(getRetryRequest(), this, metadata, call);"]]}, "num_lines_added": 63, "num_lines_removed": 29}