{"hash": "d9e71ba259571eca02299976b3749695b4e831be", "message": "Adding tests for RefreshingOAuth2CredentialsInterceptor (#1722)\n\n- Making more methods private and using other methods in RefreshingOAuth2CredentialsInterceptorTest.\r\n- Moving variables to be more consistent.", "file_num_lines": 256, "diff_parsed": {"added": [[20, "import static org.mockito.Matchers.eq;"], [21, "import static org.mockito.Matchers.same;"], [23, "import static org.mockito.Mockito.verify;"], [27, "import com.google.bigtable.v2.BigtableGrpc;"], [28, "import com.google.bigtable.v2.ReadRowsRequest;"], [29, "import com.google.bigtable.v2.ReadRowsResponse;"], [36, ""], [46, ""], [47, "import io.grpc.*;"], [55, "import org.mockito.ArgumentCaptor;"], [63, "/**"], [64, " * Tests for {@link RefreshingOAuth2CredentialsInterceptor}"], [65, " */"], [84, "  private OAuth2Credentials mockCredentials;"], [85, ""], [86, "  @Mock"], [87, "  private Channel mockChannel;"], [88, ""], [89, "  @Mock"], [90, "  private ClientCall mockClientCall;"], [91, ""], [92, "  @Mock"], [93, "  private ClientCall.Listener mockListener;"], [99, "    when(mockChannel.newCall(any(MethodDescriptor.class), any(CallOptions.class)))"], [100, "        .thenReturn(mockClientCall);"], [114, "    Mockito.when(mockCredentials.refreshAccessToken()).thenReturn("], [115, "        new AccessToken(\"\", new Date(HeaderCacheElement.TOKEN_STALENESS_MS + 1)));"], [116, "    underTest = new RefreshingOAuth2CredentialsInterceptor(executorService, mockCredentials);"], [117, "    Assert.assertEquals(CacheState.Expired, underTest.getCacheState());"], [118, "    underTest.getHeaderSafe();"], [119, "    Assert.assertNotEquals(CacheState.Exception, underTest.getCacheState());"], [120, "    Assert.assertEquals(CacheState.Good, underTest.getCacheState());"], [125, "  /**"], [126, "   * Basic test to make sure that the interceptor works properly"], [127, "   */"], [128, "  public void testIntercept() throws IOException {"], [129, "    initialize(HeaderCacheElement.TOKEN_STALENESS_MS + 1);"], [130, "    initializeCall(CallOptions.DEFAULT);"], [131, "  }"], [132, ""], [133, "  @Test"], [134, "  /**"], [135, "   * Test to make sure that the interceptor revokes credentials if an RPC receives an UNAUTHENTICATED status."], [136, "   */"], [137, "  public void testInvalid() throws IOException {"], [138, "    long expiration = HeaderCacheElement.TOKEN_STALENESS_MS + 1;"], [139, "    initialize(expiration);"], [140, "    ClientCall.Listener listener = initializeCall(CallOptions.DEFAULT);"], [141, "    listener.onClose(Status.UNAUTHENTICATED, new Metadata());"], [142, "    Assert.assertEquals(CacheState.Expired, underTest.getCacheState());"], [143, "  }"], [144, ""], [145, "  private ClientCall.Listener initializeCall(CallOptions callOptions) throws IOException {"], [146, "    ClientCall<ReadRowsRequest, ReadRowsResponse> call = underTest.interceptCall("], [147, "        BigtableGrpc.METHOD_READ_ROWS,"], [148, "        callOptions,"], [149, "        mockChannel);"], [150, "    Metadata metadata = new Metadata();"], [151, "    call.start(mockListener, metadata);"], [152, "    Assert.assertEquals(underTest.getHeaderSafe().header,"], [153, "        metadata.get(RefreshingOAuth2CredentialsInterceptor.AUTHORIZATION_HEADER_KEY));"], [154, ""], [155, "    ArgumentCaptor<ClientCall.Listener> listenerCaptor = ArgumentCaptor.forClass(ClientCall.Listener.class);"], [156, "    verify(mockClientCall, times(1))"], [157, "        .start(listenerCaptor.capture(), same(metadata));"], [158, ""], [159, "    call.request(1);"], [160, "    call.sendMessage(ReadRowsRequest.getDefaultInstance());"], [161, ""], [162, "    verify(mockClientCall, times(1))"], [163, "        .request(eq(1));"], [164, "    verify(mockClientCall, times(1))"], [165, "        .sendMessage(same(ReadRowsRequest.getDefaultInstance()));"], [166, ""], [167, "    return listenerCaptor.getValue();"], [168, "  }"], [169, ""], [170, "  @Test"], [172, "    Mockito.when(mockCredentials.refreshAccessToken()).thenReturn("], [175, "        mockCredentials);"], [176, "    underTest.getHeaderSafe();"], [177, "    Assert.assertEquals(CacheState.Good, underTest.getCacheState());"], [186, "    underTest = new RefreshingOAuth2CredentialsInterceptor(mockExecutor, mockCredentials);"], [194, "    Assert.assertEquals(CacheState.Good, underTest.getCacheState());"], [197, "    Assert.assertEquals(CacheState.Stale, underTest.getCacheState());"], [201, "    Assert.assertEquals(CacheState.Expired, underTest.getCacheState());"], [205, "  public void testNullExpiration() throws Exception {"], [207, "    Mockito.when(mockCredentials.refreshAccessToken()).thenReturn("], [208, "        new AccessToken(\"\", null));"], [209, "    underTest = new RefreshingOAuth2CredentialsInterceptor(executorService, mockCredentials);"], [210, "    underTest.asyncRefresh().get(100, TimeUnit.MILLISECONDS);"], [211, "    Assert.assertEquals(CacheState.Good, underTest.getCacheState());"], [215, "    Assert.assertEquals(CacheState.Good, underTest.getCacheState());"], [220, "    underTest = new RefreshingOAuth2CredentialsInterceptor(executorService, mockCredentials);"], [225, "    Mockito.when(mockCredentials.refreshAccessToken())"], [240, "    Mockito.verify(mockCredentials, times(2)).refreshAccessToken();"], [245, "    underTest = new RefreshingOAuth2CredentialsInterceptor(executorService, mockCredentials);"], [253, "    Mockito.when(mockCredentials.refreshAccessToken())"], [281, "    Mockito.verify(mockCredentials, times(2)).refreshAccessToken();"], [284, "  @Test(timeout = 30000)"], [311, "    // mockCredentials.refreshAccessToken() will get called asynchronously and will wait until the"], [314, "    Mockito.when(mockCredentials.refreshAccessToken()).thenAnswer(answer);"], [317, "        new RefreshingOAuth2CredentialsInterceptor(executorService, mockCredentials);"], [321, "    Assert.assertEquals(CacheState.Expired, underTest.getCacheState());"], [326, "    Assert.assertEquals(CacheState.Stale, underTest.getCacheState());"], [337, "    for (int i = 0; i < 100; i++) {"], [347, "  private static class FutureAnswer<T> implements Answer<T> {"], [361, "      future = SettableFuture.create();"], [380, "    Mockito.when(mockCredentials.refreshAccessToken()).thenReturn("], [382, "    underTest = new RefreshingOAuth2CredentialsInterceptor(executorService, mockCredentials);"], [383, "    underTest.getHeaderSafe();"]], "deleted": [[71, "  private OAuth2Credentials credentials;"], [90, "    initialize(HeaderCacheElement.TOKEN_STALENESS_MS + 1);"], [91, "    Assert.assertEquals(CacheState.Good, underTest.headerCache.getCacheState());"], [97, "    Mockito.when(credentials.refreshAccessToken()).thenReturn("], [100, "        credentials);"], [101, "    underTest.syncRefresh();"], [102, "    Assert.assertEquals(CacheState.Good, underTest.headerCache.getCacheState());"], [111, "    underTest = new RefreshingOAuth2CredentialsInterceptor(mockExecutor, credentials);"], [119, "    Assert.assertEquals(CacheState.Good, underTest.headerCache.getCacheState());"], [122, "    Assert.assertEquals(CacheState.Stale, underTest.headerCache.getCacheState());"], [126, "    Assert.assertEquals(CacheState.Expired, underTest.headerCache.getCacheState());"], [130, "  public void testNullExpiration() {"], [132, "    HeaderCacheElement element = new HeaderCacheElement(new AccessToken(\"\", null));"], [133, "    Assert.assertEquals(CacheState.Good, element.getCacheState());"], [137, "    Assert.assertEquals(CacheState.Good, element.getCacheState());"], [142, "    underTest = new RefreshingOAuth2CredentialsInterceptor(executorService, credentials);"], [147, "    Mockito.when(credentials.refreshAccessToken())"], [162, "    Mockito.verify(credentials, times(2)).refreshAccessToken();"], [167, "    underTest = new RefreshingOAuth2CredentialsInterceptor(executorService, credentials);"], [175, "    Mockito.when(credentials.refreshAccessToken())"], [203, "    Mockito.verify(credentials, times(2)).refreshAccessToken();"], [206, "  @Test(timeout=30000)"], [233, "    // credentials.refreshAccessToken() will get called asynchronously and will wait until the"], [236, "    Mockito.when(credentials.refreshAccessToken()).thenAnswer(answer);"], [239, "        new RefreshingOAuth2CredentialsInterceptor(executorService, credentials);"], [243, "    Assert.assertEquals(CacheState.Expired, underTest.headerCache.getCacheState());"], [248, "    Assert.assertEquals(CacheState.Stale, underTest.headerCache.getCacheState());"], [259, "    for (int i = 0; i < 10; i++) {"], [269, "  private static class FutureAnswer<T> implements Answer<T>{"], [283, "      future = SettableFuture.create();;"], [298, "    // Wait for no more than a second to make sure that the call to underTest.syncRefresh()"], [299, "    // completes properly.  If a second passes without syncRefresh() completing, future.get(..)"], [300, "    // will throw a TimeoutException."], [305, "    Mockito.when(credentials.refreshAccessToken()).thenReturn("], [307, "    underTest = new RefreshingOAuth2CredentialsInterceptor(executorService, credentials);"], [308, "    underTest.syncRefresh();"]]}, "num_lines_added": 111, "num_lines_removed": 36}