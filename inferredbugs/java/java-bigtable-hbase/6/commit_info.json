{"hash": "cb4046901a5ad36a994bf41090670a53b777c2f1", "message": "Shortening the locked portions of ReconnectingChannel.", "file_num_lines": 197, "diff_parsed": {"added": [[7, " *"], [9, " *"], [23, "import io.grpc.internal.ManagedChannelImpl;"], [28, "import java.util.concurrent.ScheduledExecutorService;"], [29, "import java.util.concurrent.TimeUnit;"], [30, "import java.util.concurrent.atomic.AtomicBoolean;"], [45, "  public static final long CHANNEL_TERMINATE_WAIT_MS = 500;"], [46, "  public static final long ACTIVE_REQUEST_START_WAIT_MS = 10;"], [47, ""], [48, "  /** This executor is used to refresh {@link Channel}s and shutdown &amp; await termination of"], [49, "   * old ones. The work done on these threads should be minimal"], [50, "   * as long as we don't perform a {@link ManagedChannelImpl#shutdownNow()}. As"], [51, "   * a result, allow there to be an unbounded number of shutdowns."], [52, "   * It is not expected to happen often, but there are cases where"], [53, "   * shutdown will never complete and we don't want to take up a thread"], [54, "   * that could be used to indicate that a {@link ClientCall} is completed. In such cases, the call"], [55, "   * would finish when {@link ReconnectingChannel#close()} is called."], [56, "   */"], [57, "  protected final ScheduledExecutorService refreshExecutor;"], [60, "   * Creates a new {@link Channel} and a way to close it, probably through {@link"], [61, "   * ManagedChannelImpl#shutdown()}."], [64, "    /**"], [65, "     * Creates a new {@link Channel}."], [66, "     */"], [68, ""], [69, "    /**"], [70, "     * {@link Channel} does not expose a shutdown mechanism.  Default behavior will use"], [71, "     * {@link ManagedChannelImpl#shutdown()} to close the {@link Channel}."], [72, "     */"], [76, "  /**"], [77, "   * Wraps a {@link Channel} and makes sure that when a {@link Channel#newCall(MethodDescriptor,"], [78, "   * CallOptions)} creates a {@link ClientCall}, the delegate doesn't"], [79, "   * close the {@link Channel} until {@link ClientCall#start(io.grpc.ClientCall.Listener, Metadata)}"], [80, "   * is called, when it's safe to call {@link ManagedChannelImpl#shutdown()}."], [81, "   */"], [82, "  private static class ChannelWrapper {"], [83, "    final Factory factory;"], [84, "    final Channel channel;"], [85, "    final AtomicInteger activeRequests = new AtomicInteger();"], [86, "    final AtomicBoolean isClosing = new AtomicBoolean(false);"], [87, ""], [88, "    public ChannelWrapper(Factory factory) throws IOException {"], [89, "      this.factory = factory;"], [90, "      this.channel = factory.createChannel();"], [91, "    }"], [92, ""], [93, "    void addActiveRequest(){"], [94, "      activeRequests.incrementAndGet();"], [95, "    }"], [96, ""], [97, "    void completeActiveRequest() {"], [98, "      int count = activeRequests.decrementAndGet();"], [99, "      if (count == 0 && isClosing.get()) {"], [100, "        synchronized (this) {"], [101, "          notify();"], [102, "        }"], [103, "      }"], [104, "    }"], [105, ""], [106, "    synchronized void close() throws IOException {"], [107, "      isClosing.set(true);"], [108, "      try {"], [109, "        while (activeRequests.get() > 0) {"], [110, "          wait(ACTIVE_REQUEST_START_WAIT_MS);"], [111, "        }"], [112, "      } catch (InterruptedException e) {"], [113, "        Thread.interrupted();"], [114, "        return;"], [115, "      }"], [116, "      factory.createClosable(channel).close();"], [117, "    }"], [118, ""], [119, "    <RequestT, ResponseT> ClientCall<RequestT, ResponseT> start("], [120, "        MethodDescriptor<RequestT, ResponseT> methodDescriptor, CallOptions callOptions,"], [121, "        io.grpc.ClientCall.Listener<ResponseT> responseListener, Metadata headers) {"], [122, "      ClientCall<RequestT, ResponseT> callDelegate = null;"], [123, "      try {"], [124, "        callDelegate = channel.newCall(methodDescriptor, callOptions);"], [125, "        callDelegate.start(responseListener, headers);"], [126, "      } finally {"], [127, "        completeActiveRequest();"], [128, "      }"], [129, "      return callDelegate;"], [130, "    }"], [131, "  }"], [132, ""], [133, "  /**"], [134, "   * This class makes sure that the underlying {@link ChannelWrapper} is available and the freshest"], [135, "   * delegate is used.  It prevents an older {@link Channel} delegate from closing between {@link"], [136, "   * Channel#newCall(MethodDescriptor, CallOptions)} and {@link"], [137, "   * ClientCall#start(io.grpc.ClientCall.Listener, Metadata)}."], [138, "   */"], [145, "    public DelayingCall("], [146, "        MethodDescriptor<RequestT, ResponseT> methodDescriptor, CallOptions callOptions) {"], [154, "      callDelegate ="], [155, "          getDelegateForRequest().start(methodDescriptor, callOptions, responseListener, headers);"], [184, "  private final long maxRefreshMs;"], [186, "  private final String authority;"], [187, ""], [188, "  private ChannelWrapper delegate;"], [189, ""], [190, "  /**"], [191, "   * @param maxRefreshMs  The maximum amount of time before the channel should be discarded in ms."], [192, "   * @param connectionFactory Creates a Channel and a way to close it."], [193, "   * @throws IOException on channel creation. The SSLContext creation would be the likely culprit."], [194, "   */"], [195, "  public ReconnectingChannel(long maxRefreshMs, Factory connectionFactory) throws IOException {"], [196, "    this(maxRefreshMs, connectionFactory,"], [197, "        Executors.newScheduledThreadPool("], [198, "            2,"], [199, "            new ThreadFactoryBuilder()"], [200, "                .setNameFormat(\"reconnection-async-close-%s\")"], [201, "                .setDaemon(true)"], [202, "                .build()));"], [203, "  }"], [205, "  /**"], [206, "   * @param maxRefreshMs  The maximum amount of time before the channel should be discarded in ms."], [207, "   * @param connectionFactory Creates a Channel and a way to close it."], [208, "   * @param executorService Manages the creation of new Channels and closing ofthe old ones."], [209, "   * @throws IOException on channel creation. The SSLContext creation would be the likely culprit."], [210, "   */"], [211, "  @VisibleForTesting"], [212, "  ReconnectingChannel("], [213, "      long maxRefreshMs,"], [214, "      Factory connectionFactory,"], [215, "      ScheduledExecutorService executorService) throws IOException {"], [216, "    Preconditions.checkArgument(maxRefreshMs >= 0L, \"maxRefreshMs cannot be less than 0.\");"], [217, "    this.maxRefreshMs = maxRefreshMs;"], [219, "    this.delegate = new ChannelWrapper(factory);"], [220, "    this.authority = delegate.channel.authority();"], [221, "    this.refreshExecutor = executorService;"], [222, "    if (maxRefreshMs > 0) {"], [223, "      double randomizedPercentage = 1D - (.05D * Math.random());"], [224, "      long delay = (long) (this.maxRefreshMs * randomizedPercentage);"], [225, "      Runnable refreshRunanable = new Runnable() {"], [226, "        @Override"], [227, "        public void run() {"], [228, "          ChannelWrapper oldDelegate = delegate;"], [229, "          try {"], [230, "            setDelegate(new ChannelWrapper(factory));"], [231, "          } catch (IOException e) {"], [232, "            throw new IllegalStateException(\"Channel cannot create a new delegate\", e);"], [233, "          }"], [234, "          if(oldDelegate != null) {"], [235, "            try {"], [236, "              oldDelegate.close();"], [237, "            } catch (IOException e) {"], [238, "              log.log(Level.INFO, \"Could not close a recycled delegate\", e);"], [239, "            }"], [240, "          }"], [241, "        }"], [242, "      };"], [243, "      refreshExecutor.scheduleAtFixedRate(refreshRunanable, delay, delay, TimeUnit.MILLISECONDS);"], [244, "    }"], [247, "  /**"], [248, "   * Creates a new call on a fresh Channel."], [249, "   */"], [256, "  /**"], [257, "   * Closes the currently fresh channel, and any channels that may have been discarded, but are not"], [258, "   * yet closed."], [259, "   */"], [262, "    ChannelWrapper toClose = getDelegateForClose();"], [263, "    if (toClose != null) {"], [264, "      toClose.close();"], [266, "    refreshExecutor.shutdown();"], [267, "    while (!refreshExecutor.isTerminated()) {"], [268, "      try {"], [269, "        refreshExecutor.awaitTermination(CHANNEL_TERMINATE_WAIT_MS, TimeUnit.MILLISECONDS);"], [270, "      } catch (InterruptedException e) {"], [271, "        Thread.interrupted();"], [272, "        break;"], [277, "  private synchronized ChannelWrapper getDelegateForRequest() {"], [278, "    Preconditions.checkState(delegate != null, \"Channel is closed\");"], [279, "    delegate.addActiveRequest();"], [280, "    return delegate;"], [283, "  private synchronized ChannelWrapper getDelegateForClose(){"], [284, "    ChannelWrapper toClose = delegate;"], [285, "    this.delegate = null;"], [286, "    return toClose;"], [289, "  private synchronized void setDelegate(ChannelWrapper newDelegate) {"], [290, "    this.delegate = newDelegate;"], [295, "    return authority;"]], "deleted": [[7, " *"], [9, " *"], [26, "import java.util.concurrent.ExecutorService;"], [42, "  public static final long CHANNEL_TERMINATE_WAIT_MS = 5000;"], [43, ""], [44, "  // This executor is used to shutdown & await termination of"], [45, "  // grpc connections. The work done on these threads should be minimal"], [46, "  // as long as we don't perform a shutdownNow() call (or similar). As"], [47, "  // a result, allow there to be an unbounded number of these."], [48, "  // It is not expected to happen often, but there are cases where"], [49, "  // shutdown will never complete and we don't want to take up a thread"], [50, "  // that could be used to indicate that a Call is completed (and would"], [51, "  // then finish client shutdown)."], [52, "  protected final ExecutorService closeExecutor ="], [53, "      Executors.newCachedThreadPool("], [54, "          new ThreadFactoryBuilder()"], [55, "              .setNameFormat(\"reconnection-async-close-%s\")"], [56, "              .setDaemon(true)"], [57, "              .build());"], [60, "   * Creates a fresh CloseableChannel."], [73, "    public DelayingCall(MethodDescriptor<RequestT, ResponseT> methodDescriptor, CallOptions callOptions) {"], [81, "      synchronized (ReconnectingChannel.this) {"], [82, "        Preconditions.checkState(delegate != null, \"Channel is closed\");"], [83, "        if (requiresRefresh()) {"], [84, "          try {"], [85, "              // Startup should be non-blocking and async."], [86, "              Channel oldDelegate = delegate;"], [87, "              delegate = factory.createChannel();"], [88, "              nextRefresh = calculateNewRefreshTime();"], [89, "              asyncClose(oldDelegate);"], [90, "          } catch (IOException e) {"], [91, "            throw new IllegalStateException(\"Channel cannot create a new call\", e);"], [92, "          }"], [93, "        }"], [94, "        callDelegate = delegate.newCall(methodDescriptor, callOptions);"], [95, "        callDelegate.start(responseListener, headers);"], [96, "      }"], [123, ""], [126, "  // We can't do a newCall on a closed delegate.  This will ensure that refreshes don't"], [127, "  // allow a closed delegate to perform a newCall.  Once closed is called, all existing"], [128, "  // calls will complete before the delegate shuts down."], [129, "  private final AtomicInteger closingAsynchronously = new AtomicInteger(0);"], [130, ""], [131, "  private final long maxRefreshTime;"], [134, "  // nextRefresh and delegate need to be protected by delegateLock."], [135, "  private long nextRefresh;"], [136, "  private Channel delegate;"], [137, ""], [138, "  public ReconnectingChannel("], [139, "      long maxRefreshTime,"], [140, "      Factory connectionFactory) throws IOException {"], [141, "    Preconditions.checkArgument(maxRefreshTime >= 0L, \"maxRefreshTime cannot be less than 0.\");"], [142, "    this.maxRefreshTime = maxRefreshTime;"], [143, "    this.delegate = connectionFactory.createChannel();"], [144, "    this.nextRefresh = calculateNewRefreshTime();"], [156, "    Channel toClose = null;"], [157, ""], [158, "    synchronized(this) {"], [159, "      toClose = delegate;"], [160, "      delegate = null;"], [162, "    final Channel channel = toClose;"], [163, "    if (channel != null) {"], [164, "      factory.createClosable(channel).close();"], [165, "    }"], [166, "    synchronized (closingAsynchronously) {"], [167, "      while (closingAsynchronously.get() > 0) {"], [168, "        try {"], [169, "          closingAsynchronously.wait(CHANNEL_TERMINATE_WAIT_MS);"], [170, "        } catch (InterruptedException e){"], [171, "          throw new IOException(\"Could not close all channels.\", e);"], [172, "        }"], [175, "    closeExecutor.shutdownNow();"], [178, "  private void asyncClose(final Channel channel) {"], [179, "    closingAsynchronously.incrementAndGet();"], [180, "    closeExecutor.execute(new Runnable() {"], [181, "      @Override"], [182, "      public void run() {"], [183, "        try {"], [184, "          factory.createClosable(channel).close();"], [185, "        } catch (IOException e) {"], [186, "          log.log(Level.INFO, \"Could not close a recycled delegate\", e);"], [187, "        } finally {"], [188, "          closingAsynchronously.decrementAndGet();"], [189, "          synchronized (closingAsynchronously) {"], [190, "            closingAsynchronously.notify();"], [191, "          }"], [192, "        }"], [193, "      }"], [194, "    });"], [197, "  @VisibleForTesting"], [198, "  boolean requiresRefresh() {"], [199, "    return delegate != null && maxRefreshTime > 0 && System.currentTimeMillis() > nextRefresh;"], [202, "  private long calculateNewRefreshTime() {"], [203, "    // Set the timeout. Use a random variability to reduce jetteriness when this Channel is part of"], [204, "    // a pool."], [205, "    double randomizedPercentage = 1D - (.05D * Math.random());"], [206, "    long randomizedEnd = (long) (this.maxRefreshTime * randomizedPercentage);"], [207, "    return (randomizedEnd + System.currentTimeMillis());"], [212, "    return delegate.authority();"]]}, "num_lines_added": 182, "num_lines_removed": 99}