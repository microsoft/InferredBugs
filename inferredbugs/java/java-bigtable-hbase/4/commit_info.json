{"hash": "5621a3da56021bcae5825f406f7499ca9c4c68ab", "message": "Fixing a problem in RefreshingOAuth2CredentialsInterceptorTest.", "file_num_lines": 136, "diff_parsed": {"added": [[14, "import java.util.concurrent.ExecutionException;"], [148, "    syncCall(lock, syncRefreshCallable);"], [164, "    syncCall(lock, syncRefreshCallable);"], [165, "    Assert.assertFalse(underTest.isRefreshing.get());"], [166, "  }"], [167, ""], [168, "  private void syncCall(final Object lock, Callable<Void> syncRefreshCallable)"], [169, "      throws InterruptedException, ExecutionException, TimeoutException {"], [170, "    Future<Void> future;"], [172, "    unlock(lock, future);"], [174, "    // Wait for no more than a second to make sure that the call to underTest.syncRefresh()"], [175, "    // completes properly.  If a second passes without syncRefresh() completing, future.get(..)"], [176, "    // will throw a TimeoutException."], [177, "    future.get(1, TimeUnit.SECONDS);"], [178, "  }"], [179, ""], [180, "  private void unlock(final Object lock, Future<Void> future) throws InterruptedException,"], [181, "      ExecutionException {"], [182, "    // let the Thread running syncRefreshCallable() have a turn so that it can initiate the call"], [183, "    // to refreshAccessToken()."], [184, "    try {"], [185, "      future.get(100, TimeUnit.MILLISECONDS);"], [186, "    } catch (TimeoutException ignored) {"], [187, "    }"], [188, ""]], "deleted": [[147, "    Future<Void> future = executorService.submit(syncRefreshCallable);"], [148, ""], [149, "    // let the Thread running syncRefreshCallable() have a turn so that it can initiate the call"], [150, "    // to refreshAccessToken()."], [151, "    Thread.yield();"], [152, "    synchronized(lock) {"], [153, "      lock.notifyAll();"], [154, "    }"], [155, ""], [156, "    // Try to get the access token, which should be calculated at this point.  There's"], [157, "    // a possibility that some hanging occurs in the test code.  If the operation times out"], [158, "    // so timeout after 1 second, this will throw a TimeoutException."], [159, "    future.get(1, TimeUnit.SECONDS);"], [176, "    // Let the asyncRefreshes do their thing."], [177, "    Thread.yield();"], [186, "      // Release the lock so that all of the async refreshing can complete."], [189, "    // Wait for no more than a second to make sure that the call to underTest.syncRefresh()"], [190, "    // completes properly.  If a second passes without syncRefresh() completing, future.get(..)"], [191, "    // will throw a TimeoutException."], [192, "    future.get(1, TimeUnit.SECONDS);"], [193, "    Assert.assertFalse(underTest.isRefreshing.get());"]]}, "num_lines_added": 25, "num_lines_removed": 21}