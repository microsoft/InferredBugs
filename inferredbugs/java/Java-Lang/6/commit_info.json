{"hash": "6ba276eeadc0e15fcb8fe9669709dc6c8f4bf144", "message": "JLANGX-11 fix", "file_num_lines": 120, "diff_parsed": {"added": [[25, "import java.util.ArrayList;"], [51, "        this.blocks = new ArrayList<VanillaMappedBlocks>();"], [59, "        return sliceAt(this.address, size, -1);"], [62, "    public synchronized VanillaMappedBuffer sliceOf(long size, long index) throws IOException {"], [63, "        return sliceAt(this.address, size, index);"], [67, "        return sliceAt(address, size, -1);"], [70, "    public synchronized VanillaMappedBuffer sliceAt(long address, long size, long index) throws IOException {"], [78, "        return new VanillaMappedBuffer(buffer,index);"], [89, "    public synchronized VanillaMappedBlocks blocks(final long size) throws IOException {"], [90, "        final List<VanillaMappedBuffer> buffers = new ArrayList<VanillaMappedBuffer>();"], [93, "            public synchronized VanillaMappedBuffer acquire(long index) throws IOException {"], [97, "                    if(buffers.get(i).index() == index && !buffers.get(i).unmapped()) {"], [101, "                    } else if(buffers.get(i).refCount() <= 0 || buffers.get(i).unmapped()) {"], [102, "                        // if not unmapped and not used (reference count <= 0)"], [103, "                        // unmap it and clean id up"], [113, "                    mb = VanillaMappedFile.this.sliceAt(index * size,size,index);"], [121, "            public synchronized void close() throws IOException {"], [125, ""], [126, "                buffers.clear();"], [139, "    public long size() {"], [140, "        try {"], [141, "            return this.channel.size();"], [142, "        } catch (IOException e) {"], [143, "            return 0;"], [144, "        }"]], "deleted": [[25, "import java.util.LinkedList;"], [51, "        this.blocks = new LinkedList<VanillaMappedBlocks>();"], [59, "        return sliceAtWithId(this.address, size, -1);"], [62, "    public synchronized VanillaMappedBuffer sliceOfWithId(long size, long id) throws IOException {"], [63, "        return sliceAtWithId(this.address, size, id);"], [67, "        return sliceAtWithId(address, size, -1);"], [70, "    public synchronized VanillaMappedBuffer sliceAtWithId(long address, long size, long id) throws IOException {"], [78, "        return new VanillaMappedBuffer(buffer,id);"], [89, "    public VanillaMappedBlocks blocks(final long size) throws IOException {"], [90, "        final List<VanillaMappedBuffer> buffers = new LinkedList<VanillaMappedBuffer>();"], [93, "            public VanillaMappedBuffer acquire(long index) throws IOException {"], [97, "                    if(buffers.get(i).id() == index && !buffers.get(i).unmapped()) {"], [101, "                    } else if(buffers.get(i).refCount() <= 0) {"], [102, "                        // if unmapped and not used (reference count <= 0) unmap"], [103, "                        // it and clean id up"], [113, "                    mb = VanillaMappedFile.this.sliceAtWithId(index * size,size,index);"], [121, "            public void close() throws IOException {"], [137, "    public long size() throws IOException {"], [138, "        return this.channel.size();"]]}, "num_lines_added": 25, "num_lines_removed": 19}