{"hash": "1fb4e5b859ad0526980d311aa6b5298e8f472072", "message": "now tracker side uses torrents repository class instead concurrent map", "file_num_lines": 184, "diff_parsed": {"added": [[79, "\tprivate final TorrentsRepository myTorrentsRepository;"], [86, "\tpublic TrackerRequestProcessor(TorrentsRepository torrentsRepository) {"], [87, "\t\tthis(torrentsRepository, new AddressChecker() {"], [95, "\tpublic TrackerRequestProcessor(TorrentsRepository torrentsRepository, AddressChecker addressChecker) {"], [96, "\t\tmyTorrentsRepository = torrentsRepository;"], [131, ""], [132, "\t\tif (event == null) {"], [133, "\t\t\tevent = AnnounceRequestMessage.RequestEvent.NONE;"], [135, "\t\tTrackedTorrent torrent = myTorrentsRepository.getTorrent(announceRequest.getHexInfoHash());"], [137, "\t\t// The requested torrent must be announced by the tracker if and only if myAcceptForeignTorrents is false"], [138, "\t\tif (!this.myAcceptForeignTorrents && torrent == null) {"], [139, "\t\t\tlogger.warn(\"Requested torrent hash was: {}\", announceRequest.getHexInfoHash());"], [140, "\t\t\tserveError(Status.BAD_REQUEST, ErrorMessage.FailureReason.UNKNOWN_TORRENT, requestHandler);"], [144, "\t\tfinal boolean isSeeder = (event == AnnounceRequestMessage.RequestEvent.COMPLETED)"], [145, "\t\t\t\t\t\t|| (announceRequest.getLeft() == 0);"], [146, ""], [147, "\t\tif (myAddressChecker.isBadAddress(announceRequest.getIp())) {"], [148, "\t\t\tif (torrent == null) {"], [149, "\t\t\t\twriteEmptyResponse(announceRequest, requestHandler);"], [150, "\t\t\t} else {"], [151, "\t\t\t\twriteAnnounceResponse(torrent, null, isSeeder, requestHandler);"], [152, "\t\t\t}"], [156, "\t\tfinal Peer peer = new Peer(announceRequest.getIp(), announceRequest.getPort());"], [157, ""], [159, "\t\t\ttorrent = myTorrentsRepository.putIfAbsentAndUpdate(announceRequest.getHexInfoHash(), new TrackedTorrent(announceRequest.getInfoHash()),event,"], [160, "\t\t\t\t\t\t\tByteBuffer.wrap(announceRequest.getPeerId()),"], [161, "\t\t\t\t\t\t\tannounceRequest.getHexPeerId(),"], [162, "\t\t\t\t\t\t\tannounceRequest.getIp(),"], [163, "\t\t\t\t\t\t\tannounceRequest.getPort(),"], [164, "\t\t\t\t\t\t\tannounceRequest.getUploaded(),"], [165, "\t\t\t\t\t\t\tannounceRequest.getDownloaded(),"], [166, "\t\t\t\t\t\t\tannounceRequest.getLeft());"], [174, "    writeAnnounceResponse(torrent, peer, isSeeder, requestHandler);"], [175, "\t}"], [176, ""], [177, "\tprivate void writeEmptyResponse(HTTPAnnounceRequestMessage announceRequest, RequestHandler requestHandler) throws IOException {"], [178, "\t\tHTTPAnnounceResponseMessage announceResponse;"], [179, "\t\ttry {"], [180, "\t\t\tannounceResponse = HTTPAnnounceResponseMessage.craft("], [181, "\t\t\t\t\t\t\tmyAnnounceInterval,"], [182, "\t\t\t\t\t\t\t0,"], [183, "\t\t\t\t\t\t\t0,"], [184, "\t\t\t\t\t\t\tCollections.<Peer>emptyList(),"], [185, "\t\t\t\t\t\t\tannounceRequest.getHexInfoHash());"], [186, "\t\t\trequestHandler.serveResponse(Status.OK.getCode(), Status.OK.getDescription(), announceResponse.getData());"], [187, "\t\t} catch (Exception e) {"], [188, "\t\t\tserveError(Status.INTERNAL_SERVER_ERROR, e.getMessage(), requestHandler);"], [189, "\t\t}"], [200, "  private void writeAnnounceResponse(TrackedTorrent torrent, Peer peer, boolean isSeeder, RequestHandler requestHandler) throws IOException {"]], "deleted": [[21, "import com.turn.ttorrent.common.PeerUID;"], [35, "import java.net.InetAddress;"], [36, "import java.net.InetSocketAddress;"], [38, "import java.net.UnknownHostException;"], [89, "\tpublic TrackerRequestProcessor() {"], [90, "\t\tthis(new AddressChecker() {"], [98, "\tpublic TrackerRequestProcessor(AddressChecker addressChecker) {"], [132, "    // The requested torrent must be announced by the tracker if and only if myAcceptForeignTorrents is false"], [133, "    final ConcurrentMap<String, TrackedTorrent> torrentsMap = requestHandler.getTorrentsMap();"], [134, "    TrackedTorrent torrent = torrentsMap.get(announceRequest.getHexInfoHash());"], [135, "    if (!this.myAcceptForeignTorrents && torrent == null) {"], [136, "      logger.warn(\"Requested torrent hash was: {}\", announceRequest.getHexInfoHash());"], [137, "      serveError(Status.BAD_REQUEST, ErrorMessage.FailureReason.UNKNOWN_TORRENT, requestHandler);"], [138, "      return;"], [139, "    }"], [140, ""], [141, "    if (torrent == null) {"], [142, "      torrent = new TrackedTorrent(announceRequest.getInfoHash());"], [143, "      TrackedTorrent oldTorrent = requestHandler.getTorrentsMap().putIfAbsent(torrent.getHexInfoHash(), torrent);"], [144, "      if (oldTorrent != null) {"], [145, "        torrent = oldTorrent;"], [146, "      }"], [147, "    }"], [148, ""], [150, "\t\tPeerUID peerUID = new PeerUID(new InetSocketAddress(announceRequest.getIp(), announceRequest.getPort()), announceRequest.getHexInfoHash());"], [151, ""], [152, "\t\t// When no event is specified, it's a periodic update while the client"], [153, "\t\t// is operating. If we don't have a peer for this announce, it means"], [154, "\t\t// the tracker restarted while the client was running. Consider this"], [155, "\t\t// announce request as a 'started' event."], [156, "\t\tif ((event == null ||"], [157, "\t\t\t\tAnnounceRequestMessage.RequestEvent.NONE.equals(event)) &&"], [158, "\t\t\ttorrent.getPeer(peerUID) == null) {"], [159, "\t\t\tevent = AnnounceRequestMessage.RequestEvent.STARTED;"], [162, "\t\tif (myAddressChecker.isBadAddress(announceRequest.getIp())) {"], [163, "\t\t\twriteAnnounceResponse(torrent, null, requestHandler);"], [167, "    if (event != null && torrent.getPeer(peerUID) == null &&"], [168, "  \t\t\tAnnounceRequestMessage.RequestEvent.STOPPED.equals(event)) {"], [169, "      writeAnnounceResponse(torrent, null, requestHandler);"], [170, "      return;"], [171, "    }"], [172, ""], [173, "\t\t// If an event other than 'started' is specified and we also haven't"], [174, "\t\t// seen the peer on this torrent before, something went wrong. A"], [175, "\t\t// previous 'started' announce request should have been made by the"], [176, "\t\t// client that would have had us register that peer on the torrent this"], [177, "\t\t// request refers to."], [178, "\t\tif (event != null && torrent.getPeer(peerUID) == null &&"], [179, "\t\t\t!(AnnounceRequestMessage.RequestEvent.STARTED.equals(event) ||"], [180, "        AnnounceRequestMessage.RequestEvent.COMPLETED.equals(event))) {"], [181, "      serveError(Status.BAD_REQUEST, ErrorMessage.FailureReason.INVALID_EVENT, requestHandler);"], [185, "\t\t// Update the torrent according to the announce event"], [186, "\t\tTrackedPeer peer = null;"], [188, "\t\t\tpeer = torrent.update(event,"], [189, "\t\t\t\tByteBuffer.wrap(announceRequest.getPeerId()),"], [190, "\t\t\t\tannounceRequest.getHexPeerId(),"], [191, "\t\t\t\tannounceRequest.getIp(),"], [192, "\t\t\t\tannounceRequest.getPort(),"], [193, "\t\t\t\tannounceRequest.getUploaded(),"], [194, "\t\t\t\tannounceRequest.getDownloaded(),"], [195, "\t\t\t\tannounceRequest.getLeft());"], [203, "    writeAnnounceResponse(torrent, peer, requestHandler);"], [214, "  private void writeAnnounceResponse(TrackedTorrent torrent, TrackedPeer peer, RequestHandler requestHandler) throws IOException {"], [217, "      final boolean isSeeder = peer != null && peer.isCompleted();"], [345, ""], [346, "    ConcurrentMap<String, TrackedTorrent> getTorrentsMap();"]]}, "num_lines_added": 49, "num_lines_removed": 66}