{"hash": "35b2303d038228c8cbb23336e0da608125ebaa62", "message": "add possibility to set files information in metadata by hashes, file paths and file lengths", "file_num_lines": 303, "diff_parsed": {"added": [[22, "import com.turn.ttorrent.common.TorrentLoggerFactory;"], [23, "import com.turn.ttorrent.common.TorrentMetadata;"], [24, "import com.turn.ttorrent.common.TorrentParser;"], [26, "import org.jetbrains.annotations.Nullable;"], [34, "@SuppressWarnings({\"unused\", \"WeakerAccess\"})"], [58, "  private List<String> filesPaths = new ArrayList<String>();"], [59, "  @Nullable"], [60, "  private HashingResult hashingResult = null;"], [61, "  @NotNull"], [62, "  private List<DataSourceHolder> dataSources = new ArrayList<DataSourceHolder>();"], [198, "    checkHashingResultIsNotSet();"], [199, "    filesPaths.add(path);"], [200, "    dataSources.add(new StreamBasedHolderImpl(dataSource, closeAfterBuild));"], [221, "    checkHashingResultIsNotSet();"], [222, "    filesPaths.add(path);"], [223, "    dataSources.add(new FileSourceHolder(source));"], [227, "  private void checkHashingResultIsNotSet() {"], [228, "    if (hashingResult != null) {"], [229, "      throw new IllegalStateException(\"Unable to add new source when hashes are set manually\");"], [230, "    }"], [231, "  }"], [232, ""], [238, "    return addFile(source, source.getName());"], [239, "  }"], [240, ""], [241, "  /**"], [242, "   * allow to create information about files via speicified hashes, files paths and files lengths."], [243, "   * Using of this method is not compatible with using source-based methods"], [244, "   * ({@link #addFile(File)}, {@link #addDataSource(InputStream, String, boolean)}, etc"], [245, "   * because it's not possible to calculate concat this hashes and calculated hashes."], [246, "   * each byte array in hashes list should have {{@link Constants#PIECE_HASH_SIZE}} length"], [247, "   *"], [248, "   * @param hashes       list of files hashes in same order as files in files paths list"], [249, "   * @param filesPaths   list of files paths"], [250, "   * @param filesLengths list of files lengths in same order as files in files paths list"], [251, "   */"], [252, "  public MetadataBuilder setFilesInfo(@NotNull List<byte[]> hashes,"], [253, "                                      @NotNull List<String> filesPaths,"], [254, "                                      @NotNull List<Long> filesLengths) {"], [255, "    if (dataSources.size() != 0) {"], [256, "      throw new IllegalStateException(\"Unable to add hashes-based files info. Some data sources already added\");"], [257, "    }"], [258, "    this.filesPaths.clear();"], [259, "    this.filesPaths.addAll(filesPaths);"], [260, "    this.hashingResult = new HashingResult(hashes, filesLengths);"], [297, "    ByteArrayOutputStream out = new ByteArrayOutputStream();"], [298, "    BEncoder.bencode(buildBEP(), out);"], [299, "    return out.toByteArray();"], [325, "    if (filesPaths.size() == 0) {"], [328, "    final boolean isSingleMode = filesPaths.size() == 1 && directoryName.isEmpty();"], [334, "        name = filesPaths.get(0);"], [351, "    HashingResult hashingResult = this.hashingResult == null ?"], [352, "            piecesHashesCalculator.calculateHashes(dataSources, pieceLength) :"], [353, "            this.hashingResult;"], [374, "    for (int i = 0; i < filesPaths.size(); i++) {"], [377, "      String fullPath = filesPaths.get(i);"], [379, "      for (String path : fullPath.replace(\"\\\\\", \"/\").split(\"/\")) {"], [424, "    for (DataSourceHolder sourceHolder : dataSources) {"], [439, "  private static class FileSourceHolder implements DataSourceHolder {"], [440, "    @Nullable"], [441, "    private FileInputStream fis;"], [442, "    @NotNull"], [443, "    private final File source;"], [444, ""], [445, "    public FileSourceHolder(@NotNull File source) {"], [446, "      this.source = source;"], [447, "    }"], [448, ""], [449, "    @Override"], [450, "    public InputStream getStream() throws IOException {"], [451, "      if (fis == null) {"], [452, "        fis = new FileInputStream(source);"], [453, "      }"], [454, "      return fis;"], [455, "    }"], [456, ""], [457, "    @Override"], [458, "    public void close() throws IOException {"], [459, "      if (fis != null) {"], [460, "        fis.close();"], [461, "      }"], [462, "    }"], [463, ""], [464, "    @Override"], [465, "    public String toString() {"], [466, "      return \"Data source for file stream \" + fis;"], [467, "    }"], [468, "  }"], [469, ""], [470, "  private static class StreamBasedHolderImpl implements DataSourceHolder {"], [471, "    private final InputStream source;"], [472, "    private final boolean closeAfterBuild;"], [473, ""], [474, "    public StreamBasedHolderImpl(InputStream source, boolean closeAfterBuild) {"], [475, "      this.source = source;"], [476, "      this.closeAfterBuild = closeAfterBuild;"], [477, "    }"], [478, ""], [479, "    @Override"], [480, "    public InputStream getStream() {"], [481, "      return source;"], [482, "    }"], [483, ""], [484, "    @Override"], [485, "    public void close() throws IOException {"], [486, "      if (closeAfterBuild) {"], [487, "        source.close();"], [488, "      }"], [489, "    }"], [490, ""], [491, "    @Override"], [492, "    public String toString() {"], [493, "      return \"Data source for user's stream \" + source;"], [494, "    }"], [495, "  }"], [496, ""]], "deleted": [[22, "import com.turn.ttorrent.common.*;"], [36, "  private final TimeService timeService;"], [37, ""], [56, "  private List<Source> sources = new ArrayList<Source>();"], [66, "  public MetadataBuilder() {"], [67, "    this(new SystemTimeService());"], [68, "  }"], [69, ""], [70, "  public MetadataBuilder(TimeService timeService) {"], [71, "    this.timeService = timeService;"], [72, "  }"], [73, ""], [200, "    sources.add(new Source(dataSource, path, closeAfterBuild));"], [221, "    sources.add(new Source(source, path));"], [230, "    sources.add(new Source(source));"], [267, "    ByteArrayOutputStream baos = new ByteArrayOutputStream();"], [268, "    BEncoder.bencode(buildBEP(), baos);"], [269, "    return baos.toByteArray();"], [295, "    if (sources.size() == 0) {"], [298, "    final boolean isSingleMode = sources.size() == 1 && directoryName.isEmpty();"], [304, "        name = sources.get(0).getPath();"], [321, "    HashingResult hashingResult = piecesHashesCalculator.calculateHashes(mapSources(sources), pieceLength);"], [342, "    for (int i = 0; i < sources.size(); i++) {"], [345, "      Source source = sources.get(i);"], [347, "      for (String path : source.getPath().replace(\"\\\\\", \"/\").split(\"/\")) {"], [365, "  private List<DataSourceHolder> mapSources(List<Source> sources) {"], [366, "    List<DataSourceHolder> result = new ArrayList<DataSourceHolder>();"], [367, "    for (Source source : sources) {"], [368, "      result.add(source.getSourceHolder());"], [369, "    }"], [370, "    return result;"], [371, "  }"], [372, ""], [400, "    for (Source source : sources) {"], [401, "      DataSourceHolder sourceHolder = source.getSourceHolder();"]]}, "num_lines_added": 116, "num_lines_removed": 35}