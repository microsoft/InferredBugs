{"hash": "4b2bb2a99ed3776d344d52de02cd1f8e435a8c02", "message": "Torrent file creator and loading from file\n\nAdd a main() function to the Torrent class as an entry point for\ncreating torrent files with a configurable announce URL.\n\nAdd a load() function to create a Torrent instance directly from a\ntorrent file.\n\nSigned-off-by: David Giffin <david@etsy.com>\nAcked-by: Maxime Petazzoni <mpetazzoni@turn.com>", "file_num_lines": 260, "diff_parsed": {"added": [[27, "import java.io.FileOutputStream;"], [32, "import java.net.URL;"], [37, "import java.util.LinkedList;"], [38, "import java.util.List;"], [41, "import java.util.concurrent.Callable;"], [42, "import java.util.concurrent.ExecutionException;"], [43, "import java.util.concurrent.ExecutorService;"], [44, "import java.util.concurrent.Executors;"], [45, "import java.util.concurrent.Future;"], [46, ""], [47, "import org.apache.log4j.BasicConfigurator;"], [48, "import org.apache.log4j.ConsoleAppender;"], [49, "import org.apache.log4j.PatternLayout;"], [227, "\t/** Determine how many threads to use for the piece hashing."], [228, "\t *"], [229, "\t * <p>"], [230, "\t * If the environment variable TTORRENT_HASHING_THREADS is set to an"], [231, "\t * integer value greater than 0, its value will be used. Otherwise, it"], [232, "\t * defaults to the number of processors detected by the Java Runtime."], [233, "\t * </p>"], [234, "\t *"], [235, "\t * @return How many threads to use for concurrent piece hashing."], [236, "\t */"], [237, "\tprotected static int getHashingThreadsCount() {"], [238, "\t\tString threads = System.getenv(\"TTORRENT_HASHING_THREADS\");"], [239, ""], [240, "\t\tif (threads != null) {"], [241, "\t\t\ttry {"], [242, "\t\t\t\tint count = Integer.parseInt(threads);"], [243, "\t\t\t\tif (count > 0) {"], [244, "\t\t\t\t\treturn count;"], [245, "\t\t\t\t}"], [246, "\t\t\t} catch (NumberFormatException nfe) {"], [247, "\t\t\t\t// Pass"], [248, "\t\t\t}"], [249, "\t\t}"], [250, ""], [251, "\t\treturn Runtime.getRuntime().availableProcessors();"], [252, "\t}"], [253, ""], [268, "\tpublic static Torrent create(File source, URL announce,"], [269, "\t\tString createdBy)"], [270, "\t\tthrows NoSuchAlgorithmException, InterruptedException, IOException {"], [274, "\t\ttorrent.put(\"announce\", new BEValue(announce.toString()));"], [291, "\t/** A {@link Callable} to hash a data chunk."], [292, "\t *"], [293, "\t * @author mpetazzoni"], [294, "\t */"], [295, "\tprivate static class CallableChunkHasher implements Callable<String> {"], [296, ""], [297, "\t\tprivate final MessageDigest md;"], [298, "\t\tprivate final byte[] data;"], [299, "\t\tprivate final int length;"], [300, ""], [301, "\t\tCallableChunkHasher(byte[] data, int length)"], [302, "\t\t\tthrows NoSuchAlgorithmException {"], [303, "\t\t\tthis.md = MessageDigest.getInstance(\"SHA-1\");"], [304, "\t\t\tthis.data = data;"], [305, "\t\t\tthis.length = length;"], [306, "\t\t}"], [307, ""], [308, "\t\t@Override"], [309, "\t\tpublic String call() throws UnsupportedEncodingException {"], [310, "\t\t\tthis.md.reset();"], [311, "\t\t\tthis.md.update(this.data, 0, this.length);"], [312, "\t\t\treturn new String(md.digest(), Torrent.BYTE_ENCODING);"], [313, "\t\t}"], [314, "\t}"], [315, ""], [331, "\t\tthrows NoSuchAlgorithmException, InterruptedException, IOException {"], [333, "\t\tExecutorService executor = Executors.newFixedThreadPool("], [334, "\t\t\tgetHashingThreadsCount());"], [335, "\t\tList<Future<String>> results = new LinkedList<Future<String>>();"], [337, "\t\tint pieces = 0;"], [340, "\t\tlogger.info(\"Analyzing local data for {} with {} threads...\","], [341, "\t\t\tsource.getName(), getHashingThreadsCount());"], [342, "\t\tlong start = System.nanoTime();"], [343, "\t\tInputStream is = new BufferedInputStream(new FileInputStream(source));"], [345, "\t\t\tresults.add(executor.submit(new CallableChunkHasher(data, read)));"], [346, "\t\t\tpieces++;"], [350, "\t\t// Request orderly executor shutdown and wait for hashing tasks to"], [351, "\t\t// complete."], [352, "\t\texecutor.shutdown();"], [353, "\t\twhile (!executor.isTerminated()) {"], [354, "\t\t\tThread.sleep(10);"], [355, "\t\t}"], [356, "\t\tlong elapsed = System.nanoTime() - start;"], [357, ""], [358, "\t\tStringBuffer hashes = new StringBuffer();"], [359, "\t\ttry {"], [360, "\t\t\tfor (Future<String> chunk : results) {"], [361, "\t\t\t\thashes.append(chunk.get());"], [362, "\t\t\t}"], [363, "\t\t} catch (ExecutionException ee) {"], [364, "\t\t\tthrow new IOException(\"Error while hashing the torrent data!\", ee);"], [365, "\t\t}"], [366, ""], [367, "\t\tint expectedPieces = new Double(Math.ceil((double)source.length() /"], [369, "\t\tlogger.info(\"Hashed {} ({} bytes) in {} pieces ({} expected) in {}ms.\","], [373, "\t\t\t\tpieces,"], [374, "\t\t\t\texpectedPieces,"], [375, "\t\t\t\tString.format(\"%.1f\", elapsed/1024.0/1024.0),"], [378, "\t\treturn hashes.toString();"], [379, "\t}"], [380, ""], [381, "\t/** Load a torrent from the given torrent file."], [382, "\t *"], [383, "\t * <p>"], [384, "\t * This method assumes we are not a seeder and that local data needs to be"], [385, "\t * validated."], [386, "\t * </p>"], [387, "\t *"], [388, "\t * @param torrent The abstract {@link File} object representing the"], [389, "\t * <tt>.torrent</tt> file to load."], [390, "\t * @throws IOException When the torrent file cannot be read."], [391, "\t */"], [392, "\tpublic static Torrent load(File torrent) throws IOException {"], [393, "\t\treturn Torrent.load(torrent, false);"], [394, "\t}"], [395, ""], [396, "\t/** Load a torrent from the given torrent file."], [397, "\t *"], [398, "\t * @param torrent The abstract {@link File} object representing the"], [399, "\t * <tt>.torrent</tt> file to load."], [400, "\t * @param seeder Whether we are a seeder for this torrent or not (disables"], [401, "\t * local data validation)."], [402, "\t * @throws IOException When the torrent file cannot be read."], [403, "\t */"], [404, "\tpublic static Torrent load(File torrent, boolean seeder)"], [405, "\t\tthrows IOException {"], [406, "\t\tFileInputStream fis = new FileInputStream(torrent);"], [407, "\t\tbyte[] data = new byte[(int)torrent.length()];"], [408, "\t\tfis.read(data);"], [409, "\t\tfis.close();"], [410, "\t\treturn new Torrent(data, false);"], [411, "\t}"], [412, ""], [413, "\t/** Save this torrent meta-info structure into a .torrent file."], [414, "\t *"], [415, "\t * @param output The file to write to."], [416, "\t * @throws IOException If an I/O error occurs while writing the file."], [417, "\t */"], [418, "\tpublic void save(File output) throws IOException {"], [419, "\t\tFileOutputStream fos = new FileOutputStream(output);"], [420, "\t\tfos.write(this.getEncoded());"], [421, "\t\tfos.close();"], [422, "\t\tlogger.info(\"Wrote torrent file {}.\", output.getAbsolutePath());"], [423, "\t}"], [424, ""], [425, "\t/** Torrent creator."], [426, "\t *"], [427, "\t * <p>"], [428, "\t * You can use the {@code main()} function of this {@link Torrent} class to"], [429, "\t * create torrent files. See usage for details."], [430, "\t * </p>"], [431, "\t */"], [432, "\tpublic static void main(String[] args) {"], [433, "\t\tBasicConfigurator.configure(new ConsoleAppender("], [434, "\t\t\tnew PatternLayout(\"%d [%-25t] %-5p: %m%n\")));"], [435, ""], [436, "\t\tif (args.length < 3) {"], [437, "\t\t\tSystem.err.println(\"usage: Torrent <torrent> <announce url> <file>\");"], [438, "\t\t\tSystem.exit(1);"], [439, "\t\t}"], [440, ""], [441, "\t\ttry {"], [442, "\t\t\tFile outfile = new File(args[0]);"], [443, "\t\t\tif (!outfile.canWrite()) {"], [444, "\t\t\t\tthrow new IllegalArgumentException("], [445, "\t\t\t\t\t\"Cannot write to destination file \" +"], [446, "\t\t\t\t\toutfile.getName() + \" !\");"], [447, "\t\t\t}"], [448, ""], [449, "\t\t\tURL announce = new URL(args[1]);"], [450, "\t\t\tFile source = new File(args[2]);"], [451, "\t\t\tif (!source.exists() || !source.canRead()) {"], [452, "\t\t\t\tthrow new IllegalArgumentException("], [453, "\t\t\t\t\t\"Cannot access source file or directory \" +"], [454, "\t\t\t\t\tsource.getName());"], [455, "\t\t\t}"], [456, ""], [457, "\t\t\tTorrent torrent = Torrent.create(source, announce,"], [458, "\t\t\t\tString.format(\"%s (ttorrent)\", System.getProperty(\"user.name\")));"], [459, "\t\t\ttorrent.save(outfile);"], [460, ""], [461, "\t\t\tif (torrent.getHexInfoHash().equals("], [462, "\t\t\t\tTorrent.load(outfile).getHexInfoHash())) {"], [463, "\t\t\t\tlogger.info(\"Validated created torrent file (hash: {}).\","], [464, "\t\t\t\t\ttorrent.getHexInfoHash());"], [465, "\t\t\t}"], [466, "\t\t} catch (Exception e) {"], [467, "\t\t\tlogger.error(\"{}\", e.getMessage(), e);"], [468, "\t\t\tSystem.exit(2);"], [469, "\t\t}"]], "deleted": [[228, "\tpublic static Torrent create(File source, String announce,"], [229, "\t\tString createdBy) throws NoSuchAlgorithmException, IOException {"], [233, "\t\ttorrent.put(\"announce\", new BEValue(announce));"], [265, "\t\tthrows NoSuchAlgorithmException, IOException {"], [266, "\t\tlong start = System.nanoTime();"], [267, "\t\tlong hashTime = 0L;"], [269, "\t\tMessageDigest md = MessageDigest.getInstance(\"SHA-1\");"], [270, "\t\tInputStream is = new BufferedInputStream(new FileInputStream(source));"], [271, "\t\tStringBuffer pieces = new StringBuffer();"], [276, "\t\t\tmd.reset();"], [277, "\t\t\tmd.update(data, 0, read);"], [278, ""], [279, "\t\t\tlong hashStart = System.nanoTime();"], [280, "\t\t\tpieces.append(new String(md.digest(), Torrent.BYTE_ENCODING));"], [281, "\t\t\thashTime += (System.nanoTime() - hashStart);"], [285, "\t\tint n_pieces = new Double(Math.ceil((double)source.length() /"], [287, "\t\tlogger.info(\"Hashed {} ({} bytes) in {} pieces (total: {}ms, \" +"], [288, "\t\t\t\"{}ms hashing).\","], [292, "\t\t\t\tn_pieces,"], [293, "\t\t\t\tString.format(\"%.1f\", (System.nanoTime() - start) / 1024),"], [294, "\t\t\t\tString.format(\"%.1f\", hashTime / 1024),"], [297, "\t\treturn pieces.toString();"]]}, "num_lines_added": 194, "num_lines_removed": 22}