{"hash": "35760259e877e5eacc280f102d0e0aad736efe3d", "message": "Revert \"Module-Local storage for attaching data to a module at run-time\"\n\nThis reverts commit 627add90793466b47adada45c69f6c7cfff4a4a4.", "file_num_lines": 667, "diff_parsed": {"added": [], "deleted": [[42, "import java.util.concurrent.ConcurrentMap;"], [45, "import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;"], [175, "    private volatile ConcurrentMap<Object, Object> moduleLocalMap = null;"], [176, ""], [177, "    private static final AtomicReferenceFieldUpdater<Module, ConcurrentMap> moduleLocalMapUpdater = AtomicReferenceFieldUpdater.newUpdater(Module.class, ConcurrentMap.class, \"moduleLocalMap\");"], [178, ""], [1081, ""], [1082, "    // Module-local support"], [1083, ""], [1084, "    boolean containsModuleLocal(final Object key) {"], [1085, "        final ConcurrentMap<Object, Object> map = moduleLocalMap;"], [1086, "        return map != null && map.containsKey(key);"], [1087, "    }"], [1088, ""], [1089, "    <T> T getModuleLocal(final ModuleLocal<T> key) {"], [1090, "        final ConcurrentMap<Object, Object> map = moduleLocalMap;"], [1091, "        return map == null ? null : (T) map.get(key);"], [1092, "    }"], [1093, ""], [1094, "    <T> T putModuleLocal(final ModuleLocal.Ref key, T value) {"], [1095, "        return (T) getMapForPut().put(key, value);"], [1096, "    }"], [1097, ""], [1098, "    <T> T putModuleLocalIfAbsent(final ModuleLocal.Ref key, T value) {"], [1099, "        return (T) getMapForPut().putIfAbsent(key, value);"], [1100, "    }"], [1101, ""], [1102, "    <T> T removeModuleLocal(final Object key) {"], [1103, "        final ConcurrentMap<Object, Object> map = moduleLocalMap;"], [1104, "        return map == null ? null : (T) map.remove(key);"], [1105, "    }"], [1106, ""], [1107, "    boolean removeModuleLocal(final Object key, Object expectedValue) {"], [1108, "        final ConcurrentMap<Object, Object> map = moduleLocalMap;"], [1109, "        return map != null && map.remove(key, expectedValue);"], [1110, "    }"], [1111, ""], [1112, "    <T> T replaceModuleLocal(final ModuleLocal<T> key, T newValue) {"], [1113, "        final ConcurrentMap<Object, Object> map = moduleLocalMap;"], [1114, "        return map == null ? null : (T) map.replace(key, newValue);"], [1115, "    }"], [1116, ""], [1117, "    <T> boolean replaceModuleLocal(final ModuleLocal<T> key, T expectedValue, T updateValue) {"], [1118, "        final ConcurrentMap<Object, Object> map = moduleLocalMap;"], [1119, "        return map != null && map.replace(key, expectedValue, updateValue);"], [1120, "    }"], [1121, ""], [1122, "    private ConcurrentMap<Object, Object> getMapForPut() {"], [1123, "        ConcurrentMap<Object, Object> map;"], [1124, "        do {"], [1125, "            map = moduleLocalMap;"], [1126, "            if (map != null) return map;"], [1127, "        } while (! moduleLocalMapUpdater.compareAndSet(this, null, map = new UnlockedReadHashMap<Object, Object>()));"], [1128, "        return map;"], [1129, "    }"]]}, "num_lines_added": 0, "num_lines_removed": 55}