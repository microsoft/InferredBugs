{"hash": "c0bf4a33dbeaf93871fe4f6217cc118ba859d6e7", "message": "BLOCK2 Option for clients", "file_num_lines": 163, "diff_parsed": {"added": [[27, "import com.google.common.util.concurrent.ThreadFactoryBuilder;"], [31, "import de.uniluebeck.itm.spitfire.nCoap.message.options.InvalidOptionException;"], [32, "import de.uniluebeck.itm.spitfire.nCoap.message.options.OptionRegistry;"], [52, "    private static ScheduledExecutorService executorService = Executors.newScheduledThreadPool("], [53, "            1,"], [54, "            new ThreadFactoryBuilder().setNameFormat(\"OutgoingMessageReliability-Thread %d\").build()"], [55, "    );"], [59, "    private final HashBasedTable<InetSocketAddress, Integer, ScheduledFuture[]> waitingForACK = HashBasedTable.create();"], [88, "        if(!(me.getMessage() instanceof CoapMessage)) {"], [89, "            ctx.sendUpstream(me);"], [90, "            return;"], [91, "        }"], [93, "        CoapMessage coapMessage = (CoapMessage) me.getMessage();"], [94, "        InetSocketAddress remoteAddress = (InetSocketAddress) me.getRemoteAddress();"], [96, "        log.debug(\"Incoming \" + coapMessage.getMessageType() +"], [97, "                \" (MsgID \" + coapMessage.getMessageID() +"], [98, "                \", MsgHash \" + coapMessage.hashCode() +"], [99, "                \", Block \" + coapMessage.getBlockNumber(OptionRegistry.OptionName.BLOCK_2) +"], [100, "                \", Sender \" + remoteAddress + \").\");"], [102, "        if (coapMessage.getMessageType() == MsgType.ACK || coapMessage.getMessageType() == MsgType.RST) {"], [104, "            //Look up remaining retransmissions"], [105, "            ScheduledFuture[] futures;"], [106, "            synchronized(getClass()){"], [107, "                futures =  waitingForACK.remove(me.getRemoteAddress(), coapMessage.getMessageID());"], [108, "            }"], [110, "            //Cancel remaining retransmissions"], [111, "            if(futures != null){"], [112, "                log.debug(\"Open CON found (MsgID \" + coapMessage.getMessageID() +"], [113, "                    \", Rcpt \" + remoteAddress + \"). CANCEL RETRANSMISSIONS!\");"], [115, "                int canceledRetransmissions = 0;"], [116, "                for(ScheduledFuture future : futures){"], [117, "                    if(future.cancel(false)){"], [118, "                        canceledRetransmissions++;"], [121, ""], [122, "                log.debug(canceledRetransmissions + \" retransmissions canceled for MsgID \" +"], [123, "                        coapMessage.getMessageID() + \".\");"], [124, "            }"], [125, "            else{"], [126, "                log.debug(\"No open CON found (MsgID \" + coapMessage.getMessageID() +"], [127, "                        \", Rcpt \" + remoteAddress + \"). IGNORE!\");"], [128, "                me.getFuture().setSuccess();"], [129, "                return;"], [153, "        log.debug(\"Outgoing \" + coapMessage.getMessageType() + \" (MsgID \" + coapMessage.getMessageID() +"], [154, "                \", MsgHash \" + Integer.toHexString(coapMessage.hashCode()) + \", Rcpt \" + me.getRemoteAddress() +"], [155, "                \", Block \" + coapMessage.getBlockNumber(OptionRegistry.OptionName.BLOCK_2) + \").\");"], [163, "                if(!waitingForACK.contains(me.getRemoteAddress(), coapMessage.getMessageID())){"], [164, "                    MessageRetransmissionScheduler scheduler ="], [165, "                            new MessageRetransmissionScheduler((InetSocketAddress) me.getRemoteAddress(), coapMessage);"], [166, ""], [167, "                    executorService.schedule(scheduler, 0, TimeUnit.MILLISECONDS);"], [175, "    private class MessageRetransmissionScheduler implements Runnable{"], [176, ""], [177, "        private final Random RANDOM = new Random(System.currentTimeMillis());"], [178, "        private static final int MAX_RETRANSMITS = 4;"], [179, "        private final int TIMEOUT_MILLIS = 2000;"], [184, "        public MessageRetransmissionScheduler(InetSocketAddress rcptAddress, CoapMessage coapMessage){"], [191, "            synchronized (OutgoingMessageReliabilityHandler.getInstance().getClass()){"], [193, "                //Schedule retransmissions"], [194, "                ScheduledFuture[] futures = new ScheduledFuture[MAX_RETRANSMITS];"], [196, "                int delay = 0;"], [197, "                for(int i = 0; i < MAX_RETRANSMITS; i++){"], [198, "                    delay += (int)(Math.pow(2, i) * TIMEOUT_MILLIS * (1 + RANDOM.nextDouble() * 0.3));"], [200, "                    MessageRetransmitter messageRetransmitter"], [201, "                            = new MessageRetransmitter(rcptAddress, coapMessage, i+1);"], [203, "                    futures[i] = executorService.schedule(messageRetransmitter, delay, TimeUnit.MILLISECONDS);"], [205, "                    log.debug(\"Scheduled in \" + delay + \" millis {}\", messageRetransmitter);"], [206, "                }"], [208, "                waitingForACK.put(rcptAddress, coapMessage.getMessageID(), futures);"], [209, "            }"], [210, "        }"], [211, "    }"], [212, "    private class MessageRetransmitter implements Runnable {"], [214, "        private Logger log = LoggerFactory.getLogger(OutgoingMessageReliabilityHandler.class.getName());"], [216, "        private final DatagramChannel DATAGRAM_CHANNEL = CoapClientDatagramChannelFactory.getInstance().getChannel();"], [217, ""], [218, "        private InetSocketAddress rcptAddress;"], [219, "        private CoapMessage coapMessage;"], [220, "        private int retransmitNo;"], [221, ""], [222, "        public MessageRetransmitter(InetSocketAddress rcptAddress, CoapMessage coapMessage, int retransmitNo){"], [223, "            this.rcptAddress = rcptAddress;"], [224, "            this.retransmitNo = retransmitNo;"], [225, "            this.coapMessage = coapMessage;"], [226, "        }"], [227, ""], [228, "        @Override"], [229, "        public void run() {"], [230, "            log.info(\"BEGIN {}\", this);"], [231, ""], [232, "            synchronized (OutgoingMessageReliabilityHandler.getInstance().getClass()){"], [233, ""], [234, "                ChannelFuture future = Channels.future(DATAGRAM_CHANNEL);"], [235, ""], [236, "                future.addListener(new ChannelFutureListener() {"], [237, "                    @Override"], [238, "                    public void operationComplete(ChannelFuture future) throws Exception {"], [239, "                    log.info(\"Retransmition completed {}\", MessageRetransmitter.this);"], [241, "                });"], [242, ""], [243, "                Channels.write(DATAGRAM_CHANNEL.getPipeline().getContext(\"OutgoingMessageReliabilityHandler\"),"], [244, "                        future,"], [245, "                        coapMessage,"], [246, "                        rcptAddress);"], [248, "        }"], [249, ""], [250, "        @Override"], [251, "        public String toString() {"], [252, "            try {"], [253, "                return \"MessageRetransmitter {\" +"], [254, "                        \"retransmitNo \" + retransmitNo +"], [255, "                        \", MsgID \" + coapMessage.getMessageID() +"], [256, "                        \", MsgHash \" + Integer.toHexString(coapMessage.hashCode()) +"], [257, "                        \", Block \" + coapMessage.getBlockNumber(OptionRegistry.OptionName.BLOCK_2) +"], [258, "                        \", Hashcode \" + Integer.toHexString(MessageRetransmitter.this.hashCode()) + \"}\";"], [259, "            } catch (InvalidOptionException e) {"], [260, "                return null;"]], "deleted": [[28, "import de.uniluebeck.itm.spitfire.nCoap.communication.internal.InternalAcknowledgementMessage;"], [29, "import de.uniluebeck.itm.spitfire.nCoap.communication.internal.InternalErrorMessage;"], [31, "import de.uniluebeck.itm.spitfire.nCoap.message.header.Code;"], [33, "import de.uniluebeck.itm.spitfire.nCoap.toolbox.ByteArrayWrapper;"], [53, "    private static int TIMEOUT_MILLIS = 2000;"], [54, "    private static int MAX_RETRANSMITS = 4;"], [55, "    private static Random random = new Random(System.currentTimeMillis());"], [56, ""], [57, ""], [58, "    private static ScheduledExecutorService executorService = Executors.newScheduledThreadPool(10);"], [62, "    private final HashBasedTable<InetSocketAddress, Integer, byte[]> openOutgoingConMsg = HashBasedTable.create();"], [91, "        if(me.getMessage() instanceof CoapMessage) {"], [92, ""], [93, "            CoapMessage coapMessage = (CoapMessage) me.getMessage();"], [94, "            InetSocketAddress remoteAddress = (InetSocketAddress) me.getRemoteAddress();"], [96, "            if (coapMessage.getMessageType() == MsgType.ACK || coapMessage.getMessageType() == MsgType.RST) {"], [98, "                log.debug(\"Incoming \" + coapMessage.getMessageType() +"], [99, "                            \" message with ID \" + coapMessage.getMessageID() + \" from remote address \" + remoteAddress);"], [101, "                byte[] removedToken;"], [102, "                synchronized(getClass()){"], [103, "                    removedToken =  openOutgoingConMsg.remove(me.getRemoteAddress(), coapMessage.getMessageID());"], [104, "                }"], [106, "                if(removedToken != null){"], [107, "                    log.debug(\" Matching not yet confirmed message found (\" +"], [108, "                                \" remote address: \" + remoteAddress + \", message ID \" + coapMessage.getMessageID() +"], [109, "                                \" ).\");"], [111, "                    //Set token option for incoming empty ACK"], [112, "                    if(coapMessage.getMessageType() == MsgType.ACK && coapMessage.getCode() == Code.EMPTY){"], [113, "                        InternalAcknowledgementMessage ack ="], [114, "                                new InternalAcknowledgementMessage(new ByteArrayWrapper(removedToken));"], [116, "                        MessageEvent emptyAckReceived = new UpstreamMessageEvent(ctx.getChannel(), ack, remoteAddress);"], [117, "                        ctx.sendUpstream(emptyAckReceived);"], [118, "                        return;"], [144, "        log.debug(\"Handle downstream event for message with ID \" +"], [145, "                coapMessage.getMessageID() + \" for \" + me.getRemoteAddress() );"], [153, "                if(!openOutgoingConMsg.contains(me.getRemoteAddress(), coapMessage.getMessageID())){"], [154, ""], [155, "                    synchronized (getClass()){"], [156, "                        openOutgoingConMsg.put((InetSocketAddress) me.getRemoteAddress(),"], [157, "                                                           coapMessage.getMessageID(),"], [158, "                                                           coapMessage.getToken());"], [159, "                        //Schedule first retransmission"], [160, "                        MessageRetransmitter messageRetransmitter"], [161, "                                = new MessageRetransmitter((InetSocketAddress) me.getRemoteAddress(), coapMessage);"], [162, ""], [163, "                        int delay = (int) (TIMEOUT_MILLIS * messageRetransmitter.randomFactor);"], [164, "                        executorService.schedule(messageRetransmitter, delay, TimeUnit.MILLISECONDS);"], [165, ""], [166, "                        log.debug(\"First retransmit for \" +"], [167, "                                    coapMessage.getMessageType() + \" message with ID \" + coapMessage.getMessageID() +"], [168, "                                    \" to be confirmed by \" +  me.getRemoteAddress() + \" scheduled with a delay of \" +"], [169, "                                    delay + \" millis.\");"], [170, "                    }"], [178, "    //Private class to handle the retransmission of confirmable message using a thread scheduler"], [179, "    private class MessageRetransmitter implements Runnable {"], [181, "        private DatagramChannel datagramChannel = CoapClientDatagramChannelFactory.getInstance().getChannel();"], [184, "        private double randomFactor;"], [185, "        private int retransmitionNumber;"], [187, "        public MessageRetransmitter(InetSocketAddress rcptAddress, CoapMessage coapMessage, int retransmissionNumber){"], [190, "            this.randomFactor = 1 + random.nextDouble() * 0.5;"], [191, "            this.retransmitionNumber = retransmissionNumber;"], [192, "        }"], [193, ""], [194, "        public MessageRetransmitter(InetSocketAddress rcptAddress, CoapMessage coapMessage){"], [195, "            this(rcptAddress, coapMessage, 1);"], [200, "            log.debug(\"Start!\");"], [201, "            //Retransmit message if it's not yet confirmed"], [202, "            if(openOutgoingConMsg.contains(rcptAddress, coapMessage.getMessageID())){"], [204, "                //Remove message from the list of messages to be confirmed"], [205, "                if(retransmitionNumber > MAX_RETRANSMITS){"], [207, "                    byte[] removedToken;"], [208, "                    synchronized (getClass()){"], [209, "                        removedToken = openOutgoingConMsg.remove(rcptAddress, coapMessage.getMessageID());"], [210, "                    }"], [212, "                    if(removedToken != null){"], [213, "                        log.debug(\"Message with ID \" + coapMessage.getMessageID() +"], [214, "                                \" for recipient \" + rcptAddress + \" reached the maximum number of retransmits.\");"], [215, "                    }"], [217, "                    //Send internal error message to the application"], [218, "                    String errorMessage = \"Despite \" + MAX_RETRANSMITS + \" retransmits of the message with ID \" +"], [219, "                            coapMessage.getMessageID() + \" there was no response received from \" +"], [220, "                            rcptAddress + \". Request timed out.\";"], [222, "                    log.error(errorMessage);"], [224, "                    UpstreamMessageEvent ume = new UpstreamMessageEvent(datagramChannel,"], [225, "                                        new InternalErrorMessage(errorMessage, removedToken), rcptAddress);"], [227, "                    datagramChannel.getPipeline().getContext(\"OutgoingMessageReliabilityHandler\").sendUpstream(ume);"], [228, "                    log.debug(\"Finished!\");"], [229, "                    return;"], [230, "                }"], [232, "                //Schedule the next retransmit"], [233, "                else{"], [234, "                    ChannelFuture future = Channels.future(datagramChannel);"], [235, ""], [236, "                    future.addListener(new ChannelFutureListener() {"], [237, "                        @Override"], [238, "                        public void operationComplete(ChannelFuture future) throws Exception {"], [239, "                            log.debug(\"Retransmit no \" + retransmitionNumber + \" for message \" +"], [240, "                                    \"with ID \" + coapMessage.getMessageID() + \" for recipient \" + rcptAddress +"], [241, "                                    \" finished.\");"], [242, "                        }"], [243, "                    });"], [244, ""], [245, "                    Channels.write(datagramChannel.getPipeline().getContext(\"OutgoingMessageReliabilityHandler\"),"], [246, "                                   future,"], [247, "                                   coapMessage,"], [248, "                                   rcptAddress);"], [249, ""], [250, "                    //Schedule the next retransmission, resp. removal from list of messages to be confirmed"], [251, "                    int delay = (int)(Math.pow(2, retransmitionNumber) * TIMEOUT_MILLIS * randomFactor);"], [252, "                    MessageRetransmitter retransmitter ="], [253, "                            new MessageRetransmitter(rcptAddress, coapMessage, retransmitionNumber + 1);"], [254, ""], [255, "                    executorService.schedule(retransmitter, delay, TimeUnit.MILLISECONDS);"], [256, ""], [257, ""], [258, "                    if(retransmitionNumber + 1 <= MAX_RETRANSMITS){"], [259, "                        log.debug(\"Retransmit no \" + (retransmitionNumber + 1) + \" for \" +"], [260, "                                coapMessage.getMessageType() + \" message with ID \" + coapMessage.getMessageID() +"], [261, "                                \" to be confirmed by \" +  rcptAddress + \" scheduled with a delay of \" +"], [262, "                                delay + \" millis.\");"], [263, "                    }"], [264, "                    else{"], [265, "                        log.debug(\"Removal of \" + coapMessage.getMessageType() +"], [266, "                                \" message with ID \" + coapMessage.getMessageID() + \" to be confirmed by \" +"], [267, "                                rcptAddress + \" from the list of messages to be confirmed scheduled with a delay \" +"], [268, "                                \"of \" + delay + \" millis.\");"], [270, "                }"], [272, "            else{"], [273, "                log.error(\"Finished!\");"]]}, "num_lines_added": 116, "num_lines_removed": 129}