{"hash": "fb0e6c2abadcaad21364c32837fe2f67bb86fff2", "message": "clean up for blockwise branch", "file_num_lines": 20, "diff_parsed": {"added": [[3, "import org.jboss.netty.channel.ChannelHandlerContext;"], [4, "import org.jboss.netty.channel.MessageEvent;"], [5, "import org.jboss.netty.channel.SimpleChannelHandler;"], [27, "    public void writeRequested(ChannelHandlerContext ctx, MessageEvent me) throws Exception {"], [28, "        super.writeRequested(ctx, me);"], [32, "    public void messageReceived(ChannelHandlerContext ctx, MessageEvent me) throws Exception {"], [33, "        super.messageReceived(ctx, me);"]], "deleted": [[3, "import de.uniluebeck.itm.spitfire.nCoap.message.CoapMessage;"], [4, "import de.uniluebeck.itm.spitfire.nCoap.message.CoapRequest;"], [5, "import de.uniluebeck.itm.spitfire.nCoap.message.CoapResponse;"], [6, "import de.uniluebeck.itm.spitfire.nCoap.message.MessageDoesNotAllowPayloadException;"], [7, "import de.uniluebeck.itm.spitfire.nCoap.message.header.InvalidHeaderException;"], [8, "import de.uniluebeck.itm.spitfire.nCoap.message.header.MsgType;"], [9, "import de.uniluebeck.itm.spitfire.nCoap.message.options.InvalidOptionException;"], [10, "import de.uniluebeck.itm.spitfire.nCoap.message.options.ToManyOptionsException;"], [11, "import de.uniluebeck.itm.spitfire.nCoap.toolbox.ByteArrayWrapper;"], [12, "import org.jboss.netty.buffer.ChannelBuffer;"], [13, "import org.jboss.netty.buffer.ChannelBuffers;"], [14, "import org.jboss.netty.channel.*;"], [15, "import org.slf4j.Logger;"], [16, "import org.slf4j.LoggerFactory;"], [17, ""], [18, "import java.util.HashMap;"], [19, ""], [20, "import static de.uniluebeck.itm.spitfire.nCoap.message.options.OptionRegistry.OptionName.BLOCK_2;"], [31, "    private static Logger log = LoggerFactory.getLogger(BlockwiseTransferHandler.class.getName());"], [32, ""], [33, "    private Object incompleteResponseMonitor = new Object();"], [34, "    private Object incompleteRequestMonitor = new Object();"], [35, ""], [36, "    private HashMap<ByteArrayWrapper, BlockwiseTransfer> incompleteResponsePayload ="], [37, "            new HashMap<ByteArrayWrapper, BlockwiseTransfer>();"], [38, ""], [39, "    private HashMap<ByteArrayWrapper, ChannelBuffer> incompleteRequestPayload ="], [40, "            new HashMap<ByteArrayWrapper, ChannelBuffer>();"], [41, ""], [53, "    public void writeRequested(ChannelHandlerContext ctx, MessageEvent me){"], [54, "        if(!(me.getMessage() instanceof CoapMessage)){"], [55, "            ctx.sendDownstream(me);"], [56, "            return;"], [57, "        }"], [58, ""], [59, "        if(me.getMessage() instanceof CoapRequest){"], [60, "            CoapRequest request = (CoapRequest) me.getMessage();"], [61, "            byte[] token = request.getToken();"], [62, ""], [63, "            //There was no ResponseCallback attached to the response and thus there is no token"], [64, "            if(token.length == 0){"], [65, "                ctx.sendDownstream(me);"], [66, "                return;"], [67, "            }"], [68, ""], [69, "            BlockwiseTransfer transfer ="], [70, "                    new BlockwiseTransfer(request, ChannelBuffers.dynamicBuffer());"], [71, ""], [72, "            synchronized (incompleteResponseMonitor){"], [73, "                incompleteResponsePayload.put(new ByteArrayWrapper(token), transfer);"], [74, "            }"], [75, ""], [76, "            ctx.sendDownstream(me);"], [77, ""], [78, "            //TODO handle blockwise transfer for outgoing requests with payload"], [79, ""], [80, "        }"], [81, "        else{"], [82, "            //TODO handle blockwise transfer for outgoing responses with payload"], [83, "            ctx.sendDownstream(me);"], [84, "        }"], [85, ""], [86, ""], [90, "    public void messageReceived(ChannelHandlerContext ctx, MessageEvent me){"], [91, "        if(!(me.getMessage() instanceof CoapMessage)){"], [92, "            ctx.sendUpstream(me);"], [93, "            return;"], [94, "        }"], [95, ""], [96, "        CoapMessage coapMessage = (CoapMessage) me.getMessage();"], [97, "        if(coapMessage.getCode().isError() || coapMessage.getMessageType().equals(MsgType.RST)){"], [98, "            errorMessageReceived(ctx, me);"], [99, "            return;"], [100, "        }"], [101, ""], [102, "        if(me.getMessage() instanceof CoapResponse){"], [103, "            CoapResponse response = (CoapResponse) me.getMessage();"], [104, ""], [105, "            final byte[] token = response.getToken();"], [106, ""], [107, "            BlockwiseTransfer transfer;"], [108, "            //Add latest received payload to already received payload"], [109, "            synchronized (incompleteResponseMonitor){"], [110, "                transfer = incompleteResponsePayload.get(new ByteArrayWrapper(token));"], [111, "                if(transfer != null){"], [112, "                    try {"], [113, "                        if(response.getBlockNumber(BLOCK_2) == transfer.getNextBlockNumber()){"], [114, "                            log.debug(\"Received response (Token: \" + (new ByteArrayWrapper(token).toHexString()) +"], [115, "                                      \" , Block: \" + response.getBlockNumber(BLOCK_2) + \"), \");"], [116, ""], [117, "                            if (log.isDebugEnabled()){"], [118, "                                //Copy Payload"], [119, "                                ChannelBuffer payloadCopy = ChannelBuffers.copiedBuffer(response.getPayload());"], [120, "                                byte[] bytes = new byte[payloadCopy.readableBytes()];"], [121, "                                payloadCopy.getBytes(0, bytes);"], [122, "                                log.debug(\"Payload Hex: \" + new ByteArrayWrapper(bytes).toHexString());"], [123, "                            }"], [124, ""], [125, "                            transfer.getPartialPayload()"], [126, "                                    .writeBytes(response.getPayload(), 0, response.getPayload().readableBytes());"], [127, "                            transfer.setNextBlockNumber(transfer.getNextBlockNumber() + 1);"], [128, "                        }"], [129, "                        else{"], [130, "                            log.debug(\"Received unexpected response (Token: \" + (new ByteArrayWrapper(token).toHexString()) +"], [131, "                                   \" , Block: \" + response.getBlockNumber(BLOCK_2) + \"). IGNORE!\");"], [132, "                            me.getFuture().setSuccess();"], [133, "                            return;"], [134, "                        }"], [135, "                    }"], [136, "                    catch (InvalidOptionException e) {"], [137, "                        log.error(\"This should never happen!\", e);"], [138, "                    }"], [139, "                }"], [140, "            }"], [141, ""], [142, "            //Check whether payload of the response is complete"], [143, "            if(transfer != null){"], [144, "                try {"], [145, "                    if(response.isLastBlock(BLOCK_2)){"], [146, ""], [147, "                        //Send response with complete payload to application"], [148, "                        log.debug(\"Block \" + response.getBlockNumber(BLOCK_2) + \" for response with token \" +"], [149, "                                new ByteArrayWrapper(token).toHexString() +"], [150, "                                \"  received. Payload complete. Forward to client application.\");"], [151, ""], [152, "                        response.getOptionList().removeAllOptions(BLOCK_2);"], [153, ""], [154, "                        response.setPayload(transfer.getPartialPayload());"], [155, "                        MessageEvent event = new UpstreamMessageEvent(me.getChannel(), response, me.getRemoteAddress());"], [156, "                        ctx.sendUpstream(event);"], [157, ""], [158, "                        synchronized (incompleteResponseMonitor){"], [159, "                            if(incompleteResponsePayload.remove(new ByteArrayWrapper(token)) == null){"], [160, "                                log.error(\"This should never happen! No incomplete payload found for token \" +"], [161, "                                    new ByteArrayWrapper(token).toHexString());"], [162, "                            }"], [163, "                            else{"], [164, "                                log.debug(\"Deleted not anymore incomplete payload for token \" +"], [165, "                                        new ByteArrayWrapper(token).toHexString() + \" from list\");"], [166, "                            }"], [167, "                        }"], [168, "                        return;"], [169, ""], [170, "                    }"], [171, "                    else{"], [172, "                        final long receivedBlockNumber = response.getBlockNumber(BLOCK_2);"], [173, ""], [174, "                        log.debug(\"Block \" + receivedBlockNumber + \" for response with token \" +"], [175, "                                new ByteArrayWrapper(token).toHexString() +"], [176, "                                \"  received. Payload (still) incomplete.\");"], [177, ""], [178, "                        CoapRequest nextCoapRequest = (CoapRequest) transfer.getCoapMessage();"], [179, "                        nextCoapRequest.setMessageID(-1);"], [180, "                        nextCoapRequest.setBlockOption(BLOCK_2, receivedBlockNumber + 1,"], [181, "                                                       false, response.getMaxBlocksizeForResponse());"], [182, ""], [183, ""], [184, "                        ChannelFuture future = Channels.future(me.getChannel());"], [185, ""], [186, "                        future.addListener(new ChannelFutureListener() {"], [187, "                            @Override"], [188, "                            public void operationComplete(ChannelFuture future) throws Exception {"], [189, "                                log.debug(\"Request for block \" + (receivedBlockNumber + 1) + \" for token \" +"], [190, "                                    new ByteArrayWrapper(token).toHexString() + \" sent succesfully.\");"], [191, ""], [192, "                            }"], [193, "                        });"], [194, "                        MessageEvent event = new DownstreamMessageEvent(me.getChannel(),"], [195, "                                future, nextCoapRequest, me.getRemoteAddress());"], [196, ""], [197, "                        log.debug(\"Send request for block \" + (receivedBlockNumber + 1) + \" for token \" +"], [198, "                                new ByteArrayWrapper(token).toHexString() + \".\");"], [199, ""], [200, "                        ctx.sendDownstream(event);"], [201, "                        return;"], [202, "                    }"], [203, "                }"], [204, "                catch (InvalidOptionException e) {"], [205, "                    log.error(\"This should never happen!\", e);"], [206, "                }"], [207, "                catch (MessageDoesNotAllowPayloadException e) {"], [208, "                    log.error(\"This should never happen!\", e);"], [209, "                }"], [210, "                catch (ToManyOptionsException e){"], [211, "                    log.error(\"This should never happen!\", e);"], [212, "                }"], [213, "                catch (InvalidHeaderException e) {"], [214, "                    log.error(\"This should never happen!\", e);"], [215, "                }"], [216, "            }"], [217, "        }"], [218, ""], [219, "        ctx.sendUpstream(me);"], [220, "    }"], [221, ""], [222, "    private void errorMessageReceived(ChannelHandlerContext ctx, MessageEvent me){"], [223, "        CoapMessage coapMessage = (CoapMessage) me.getMessage();"], [224, "        synchronized (incompleteResponseMonitor){"], [225, "            incompleteResponsePayload.remove(coapMessage.getToken());"], [226, "        }"], [227, "        ctx.sendUpstream(me);"], [228, "    }"], [229, ""], [230, "    private class BlockwiseTransfer {"], [231, ""], [232, "        private CoapMessage coapMessage;"], [233, "        private ChannelBuffer partialPayload;"], [234, "        private int nextBlockNumber = 0;"], [235, ""], [236, "        public BlockwiseTransfer(CoapMessage coapMessage, ChannelBuffer partialPayload){"], [237, "           this.coapMessage = coapMessage;"], [238, "           this.partialPayload = partialPayload;"], [239, "        }"], [240, ""], [241, "        public CoapMessage getCoapMessage() throws InvalidHeaderException {"], [242, "            return coapMessage;"], [243, "        }"], [244, ""], [245, "        public ChannelBuffer getPartialPayload() {"], [246, "            return partialPayload;"], [247, "        }"], [248, ""], [249, "        public void setNextBlockNumber(int nextBlockNumber){"], [250, "            this.nextBlockNumber = nextBlockNumber;"], [251, "        }"], [252, ""], [253, "        public int getNextBlockNumber(){"], [254, "            return this.nextBlockNumber;"], [255, "        }"]]}, "num_lines_added": 7, "num_lines_removed": 229}