{"hash": "0a80fb022ccf6443c706fc2d211857cecdb7c224", "message": "Support binding of a whole core for hyper-threaded systems. AffinityLock.acquireCore()", "file_num_lines": 200, "diff_parsed": {"added": [[44, "    private static AffinityLock[][] CORES; // set by cpuLayout()"], [53, "                cpuLayout(VanillaCpuLayout.fromCpuInfo());"], [60, "        synchronized (AffinityLock.class) {"], [61, "            AffinityLock.cpuLayout = cpuLayout;"], [62, "            int cores = cpuLayout.sockets() * cpuLayout.coresPerSocket();"], [63, "            int threads = cpuLayout.threadPerCore();"], [64, "            CORES = new AffinityLock[cores][threads];"], [65, "            for (AffinityLock al : LOCKS) {"], [66, "                final int id = al.id;"], [67, "                int core = coreForId(id);"], [68, "                CORES[core][cpuLayout.threadId(id)] = al;"], [69, "            }"], [70, "        }"], [71, "    }"], [72, ""], [73, "    private static int coreForId(int id) {"], [74, "        return cpuLayout.socketId(id) * cpuLayout.coresPerSocket() + cpuLayout.coreId(id);"], [92, "    public static AffinityLock acquireCore() {"], [93, "        return acquireCore(true);"], [94, "    }"], [95, ""], [97, "        return acquireLock(bind, -1, AffinityStrategies.ANY);"], [98, "    }"], [99, ""], [100, "    public static AffinityLock acquireCore(boolean bind) {"], [101, "        return acquireCore(bind, -1, AffinityStrategies.ANY);"], [110, "                        al.assignCurrentThread(bind, false);"], [121, "    private static AffinityLock acquireCore(boolean bind, int cpuId, AffinityStrategy... strategies) {"], [122, "        synchronized (AffinityLock.class) {"], [123, "            for (AffinityStrategy strategy : strategies) {"], [124, "                LOOP:"], [125, "                for (int i = CORES.length - 1; i > 0; i--) {"], [126, "                    AffinityLock[] als = CORES[i];"], [127, "                    for (AffinityLock al : als) {"], [128, "                        if (!al.canReserve() || !strategy.matches(cpuId, i))"], [129, "                            continue LOOP;"], [130, "                    }"], [131, "                    final AffinityLock al = als[0];"], [132, "                    al.assignCurrentThread(bind, true);"], [133, "                    return al;"], [134, "                }"], [135, "            }"], [136, "        }"], [137, "        if (LOGGER.isLoggable(Level.WARNING))"], [138, "            LOGGER.warning(\"No reservable Core for \" + Thread.currentThread());"], [139, "        return acquireLock(bind, cpuId, strategies);"], [140, "    }"], [141, ""], [178, "    private void assignCurrentThread(boolean bind, boolean wholeCore) {"], [181, "            bind(wholeCore);"], [185, "        bind(false);"], [186, "    }"], [187, ""], [188, "    public void bind(boolean wholeCore) {"], [189, "        if (bound && assignedThread != null && assignedThread.isAlive())"], [190, "            throw new IllegalStateException(\"cpu \" + id + \" already bound to \" + assignedThread);"], [191, ""], [192, "        if (wholeCore) {"], [193, "            int core = coreForId(id);"], [194, "            for (AffinityLock al : CORES[core]) {"], [195, "                if (bound && al.assignedThread != null && al.assignedThread.isAlive()) {"], [196, "                    LOGGER.severe(\"cpu \" + al.id + \" already bound to \" + al.assignedThread);"], [197, "                } else {"], [198, "                    al.bound = true;"], [199, "                    al.assignedThread = Thread.currentThread();"], [200, "                }"], [201, "            }"], [202, "            if (LOGGER.isLoggable(Level.INFO)) {"], [203, "                StringBuilder sb = new StringBuilder().append(\"Assigning core \").append(core);"], [204, "                String sep = \": cpus \";"], [205, "                for (AffinityLock al : CORES[core]) {"], [206, "                    sb.append(sep).append(al.id);"], [207, "                    sep = \", \";"], [208, "                }"], [209, "                sb.append(\" to \").append(assignedThread);"], [210, "                LOGGER.info(sb.toString());"], [211, "            }"], [212, "        } else {"], [213, "            bound = true;"], [214, "            assignedThread = Thread.currentThread();"], [215, "            if (LOGGER.isLoggable(Level.INFO))"], [216, "                LOGGER.info(\"Assigning cpu \" + id + \" to \" + assignedThread);"], [217, "        }"], [237, "            for (AffinityLock al : LOCKS) {"], [238, "                Thread at = al.assignedThread;"], [239, "                if (at == t) {"], [240, "                    if (LOGGER.isLoggable(Level.INFO))"], [241, "                        LOGGER.info(\"Releasing cpu \" + al.id + \" from \" + t);"], [242, "                    al.assignedThread = null;"], [243, "                    al.bound = false;"], [244, "                } else if (at != null && !at.isAlive()) {"], [245, "                    LOGGER.warning(\"Releasing cpu \" + al.id + \" from \" + t + \" as it is not alive.\");"], [246, "                    al.assignedThread = null;"], [247, "                    al.bound = false;"], [248, "                }"], [249, "            }"]], "deleted": [[52, "                cpuLayout = VanillaCpuLayout.fromCpuInfo();"], [59, "        AffinityLock.cpuLayout = cpuLayout;"], [78, "        return acquireLock(bind, 0, AffinityStrategies.ANY);"], [87, "                        al.assignCurrentThread(bind);"], [134, "    private void assignCurrentThread(boolean bind) {"], [137, "            bind();"], [141, "        if (bound) throw new IllegalStateException(\"Already bound to \" + assignedThread);"], [142, "        bound = true;"], [143, "        assignedThread = Thread.currentThread();"], [145, "        if (LOGGER.isLoggable(Level.INFO))"], [146, "            LOGGER.info(\"Assigning cpu \" + id + \" to \" + assignedThread);"], [163, "        if (this == NONE) return;"], [164, ""], [166, ""], [168, "            if (assignedThread != t)"], [169, "                throw new IllegalStateException(\"Cannot release lock \" + id + \" assigned to \" + assignedThread);"], [170, "            if (LOGGER.isLoggable(Level.INFO))"], [171, "                LOGGER.info(\"Releasing cpu \" + id + \" from \" + t);"], [172, "            assignedThread = null;"], [173, "            bound = false;"]]}, "num_lines_added": 96, "num_lines_removed": 20}