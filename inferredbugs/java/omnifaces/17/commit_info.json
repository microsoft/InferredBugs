{"hash": "b597fccf69c188278af86b2f59ca72390a2b66fb", "message": "#17: minor javadoc improvements; refactored Socket#apply() method", "file_num_lines": 133, "diff_parsed": {"added": [[59, " * artifact via <code>&#64;</code>{@link Push} annotation."], [109, " * use the <strong><code>port</code></strong> attribute to explicitly specify the port."], [115, " * auto-reconnect at increasing intervals when the connection is closed/aborted as result of e.g. a network error or"], [116, " * server restart. It will not auto-reconnect when the very first connection attempt already fails. The web socket will"], [117, " * be implicitly closed once the document is unloaded (e.g. navigating away, close of browser window/tab, etc)."], [122, " * In WAR side, you can inject <strong>{@link PushContext}</strong> via <strong><code>&#64;</code>{@link Push}</strong>"], [123, " * annotation on the given channel name in any CDI/container managed artifact such as <code>@Named</code>,"], [124, " * <code>@WebServlet</code>, etc wherever you'd like to send a push message and then invoke"], [125, " * <strong>{@link PushContext#send(Object)}</strong> with any Java object representing the push message."], [159, " * By default the web socket is <code>application</code> scoped, i.e. any view/session throughout the web application"], [160, " * having the same web socket channel open will receive the same push message. The push message can be sent by all users"], [161, " * and the application itself. This is useful for application-wide feedback triggered by site itself such as real time"], [162, " * updates of a certain page (e.g. site-wide statistics, top100 lists, stock updates, etc)."], [164, " * The optional <strong><code>scope</code></strong> attribute can be set to <code>session</code> to restrict the push"], [165, " * messages to all views in the current user session only. The push message can only be sent by the user itself and not"], [166, " * by the application. This is useful for session-wide feedback triggered by user itself (e.g. as result of asynchronous"], [167, " * tasks triggered by user specific action)."], [172, " * The <code>scope</code> attribute can also be set to <code>view</code> to restrict the push messages to the current"], [173, " * view only. The push message will not show up in other views in the same session even if it's the same URL. The push"], [174, " * message can only be sent by the user itself and not by the application. This is useful for view-wide feedback"], [175, " * triggered by user itself (e.g. progress bar tied to a user specific action on current view)."], [185, " * and can also be sent by other users and the application itself. The value of the <code>user</code> attribute must at"], [186, " * least implement {@link Serializable} and have a low memory footprint, so putting entire user entity is not"], [187, " * recommended."], [209, " * <strong>{@link PushContext#send(Object, Serializable)}</strong>. The push message can be sent by all users and the"], [210, " * application itself. This is useful for user-specific feedback triggered by other users (e.g. chat, admin messages,"], [211, " * etc) or by application's background tasks (e.g. notifications, event listeners, etc)."], [311, " * socket in client side. This will be invoked on the very first connection attempt, regardless of whether it will be"], [312, " * successful or not. This will not be invoked when the web socket auto-reconnects a broken connection after the first"], [313, " * successful connection."], [329, " * close of a web socket. This will be invoked when the very first connection attempt fails, or the maximum reconnect"], [330, " * attempts has exceeded, or the server has returned close reason code <code>1000</code> or <code>1008</code> (policy"], [331, " * violated, which usually only happens when the channel name is unknown, or the session has expired). This will not be"], [332, " * invoked when the web socket can make an auto-reconnect attempt on a broken connection after the first successful"], [333, " * connection."], [350, " * is simply not <a href=\"http://caniuse.com/websockets\">supported</a> by the client. If this is <code>1000</code>,"], [351, " * then it was normally closed. Else if this is not <code>1000</code>, then there may be an error. See also"], [361, " * or view has expired. In case of a session scoped socket you could take the opportunity to let JavaScript show a"], [362, " * \"Session expired\" message and/or immediately redirect to the login page via <code>window.location</code>. In case of"], [363, " * a view scoped socket the handling depends on the reason of the view expiration. A view can be expired when the"], [364, " * associated session has expired, but it can also be expired as result of (accidental) navigation or rebuild, or when"], [365, " * the JSF \"views per session\" configuration setting is set relatively low and the client has many views (windows/tabs)"], [366, " * open in the same session. You might take the opportunity to let JavaScript reload the page."], [372, " * <strong><code>&#64;</code>{@link Opened}</strong> qualifier. When a web socket has been closed, a new CDI"], [373, " * {@link SocketEvent} will be fired with <strong><code>&#64;</code>{@link Closed}</strong> qualifier. They can only be"], [374, " * observed and collected in an application scoped CDI bean as below. A request scoped one is useless and a view/session"], [375, " * scoped one wouldn't work as there's no means of a HTTP request anywhere at that moment."], [390, " *         CloseCode code = event.getCloseCode(); // Returns close reason code."], [397, " * You could take the opportunity to send another push message to an application scoped socket, e.g. \"User X has been"], [398, " * logged in\" (or out) when a session scoped socket is opened (or closed)."], [480, " * insuitable as it is not allowed to use WAR (front end) frameworks and libraries like JSF and OmniFaces in EAR/EJB"], [483, " * Finally just <code>&#64;</code>{@link Observes} it in some request or application scoped CDI managed bean in WAR and"], [484, " * delegate to {@link PushContext} as below."], [538, " * <p>"], [539, " * Which is invoked in WAR as below."], [550, " * Note that OmniFaces own {@link Callback} interfaces are insuitable as it is not allowed to use WAR (front end)"], [645, "\t * valid, then register it in {@link SocketChannelManager} and get the channel ID, then subcribe the"], [646, "\t * {@link SocketFacesListener}."], [664, "\t\tInteger portNumber = getObject(context, port, Integer.class);"], [665, "\t\tString channelName = getChannelName(context, channel);"], [666, "\t\tString channelId = getChannelId(context, channelName, scope, user);"], [667, "\t\tString functions = getString(context, onopen) + \",\" + onmessage.getValue(context) + \",\" + getString(context, onclose);"], [668, "\t\tValueExpression connectedExpression = getValueExpression(context, connected, Boolean.class);"], [669, ""], [670, "\t\tSystemEventListener listener = new SocketFacesListener(portNumber, channelName, channelId, functions, connectedExpression);"], [671, "\t\tsubscribeToViewEvent(PostAddToViewEvent.class, listener);"], [672, "\t\tsubscribeToViewEvent(PreRenderViewEvent.class, listener);"], [673, "\t}"], [674, ""], [675, "\tprivate static String getChannelName(FaceletContext context, TagAttribute channel) {"], [682, "\t\treturn channelName;"], [683, "\t}"], [684, ""], [685, "\tprivate static String getChannelId(FaceletContext context, String channelName, TagAttribute scope, TagAttribute user) {"], [707, "\t\treturn channelId;"]], "deleted": [[59, " * artifact via {@link Push} annotation."], [109, " * use the <code>port</code> attribute to explicitly specify the port."], [115, " * auto-reconnect at increasing intervals when the connection is unintentionally closed/aborted as result of e.g. a"], [116, " * timeout or a network error. It will not auto-reconnect when the very first connection attempt already fails. The web"], [117, " * socket will be implicitly closed once the document is unloaded (e.g. navigating away, close of browser window/tab,"], [118, " * etc)."], [123, " * In WAR side, you can inject <strong>{@link PushContext}</strong> via <strong>{@link Push}</strong> annotation on the"], [124, " * given channel name in any CDI/container managed artifact such as <code>@Named</code>, <code>@WebServlet</code>, etc"], [125, " * wherever you'd like to send a push message and then invoke <strong>{@link PushContext#send(Object)}</strong> with any"], [126, " * Java object representing the push message."], [160, " * By default the web socket is <strong><code>application</code></strong> scoped, i.e. any view/session throughout the"], [161, " * web application having the same web socket channel open will receive the same push message. The push message can be"], [162, " * sent by all users and the application itself. This is useful for application-wide feedback triggered by site itself"], [163, " * such as real time updates of a certain page (e.g. site-wide statistics, top100 lists, stock updates, etc)."], [165, " * The optional <strong><code>scope</code></strong> attribute can be set to <strong><code>session</code></strong> to"], [166, " * restrict the push messages to all views in the current user session only. The push message can only be sent by the"], [167, " * user itself and not by the application. This is useful for session-wide feedback triggered by user itself (e.g. as"], [168, " * result of asynchronous tasks triggered by user specific action)."], [173, " * The <code>scope</code> attribute can also be set to <strong><code>view</code></strong> to restrict the push messages"], [174, " * to the current view only. The push message will not show up in other views in the same session even if it's the same"], [175, " * URL. The push message can only be sent by the user itself and not by the application. This is useful for view-wide"], [176, " * feedback triggered by user itself (e.g. progress bar tied to a user specific action on current view)."], [186, " * and can be sent by other users and the application itself. The value of the <code>user</code> attribute must at least"], [187, " * implement {@link Serializable} and have a low memory footprint, so putting entire user entity is not recommended."], [209, " * <strong>{@link PushContext#send(Object, Serializable)}</strong>. The push message can be sent by the user itself,"], [210, " * other users, and even the application itself. This is useful for user-specific feedback triggered by other users"], [211, " * (e.g. chat, admin messages, etc) or by application's background tasks (e.g. notifications, event listeners, etc)."], [311, " * socket in client side. This will not be invoked when the web socket auto-reconnects a broken connection after the"], [312, " * first succesful connection."], [328, " * close of a web socket. This will not be invoked when the web socket auto-reconnects a broken connection after the"], [329, " * first succesful connection. This will only be invoked when the very first connection attempt fails, or the maximum"], [330, " * reconnect attempts has exceeded, or the server has returned close reason code <code>1008</code> (policy violated)."], [347, " * is simply not supported by the client. If this is <code>1000</code>, then it was normally closed. Else if this is not"], [348, " * <code>1000</code>, then there may be an error. See also"], [358, " * or view has expired. In case of a session scoped socket you could take the opportunity to show a \"Session expired\""], [359, " * message and/or immediately redirect to the login page via <code>window.location</code>. In case of a view scoped"], [360, " * socket this is quite rare as it actually means \"View expired\" while the page is still open, but it could happen if"], [361, " * the JSF \"views per session\" configuration setting is set relatively low. You might take the opportunity to reload"], [362, " * the page."], [368, " * <strong>{@link Opened}</strong> qualifier. When a web socket has been closed, a new CDI {@link SocketEvent} will be"], [369, " * fired with <strong>{@link Closed}</strong> qualifier. They can only be observed and collected in an application"], [370, " * scoped CDI bean as below. A request scoped one is useless and a view/session scoped one wouldn't work as there's no"], [371, " * means of a HTTP request anywhere at that moment."], [386, " *         CloseReason reason = event.getCloseReason(); // Returns close reason."], [393, " * You could even use it to send another push message to an application scoped socket, e.g. \"User X has been logged in\""], [394, " * (or out) when a session scoped socket is opened (or closed)."], [476, " * insuitable as you're not supposed to use WAR (front end) frameworks and libraries like JSF and OmniFaces in EAR/EJB"], [479, " * Finally just {@link Observes} it in some request or application scoped CDI managed bean in WAR and delegate to"], [480, " * {@link PushContext} as below."], [544, " * Note that OmniFaces own {@link Callback} interfaces are insuitable as you're not supposed to use WAR (front end)"], [639, "\t * valid, then subcribe the {@link SocketFacesListener}."], [684, "\t\tInteger portNumber = getObject(context, port, Integer.class);"], [685, "\t\tString onopenFunction = getString(context, onopen);"], [686, "\t\tString onmessageFunction = onmessage.getValue(context);"], [687, "\t\tString oncloseFunction = getString(context, onclose);"], [688, "\t\tString functions = onopenFunction + \",\" + onmessageFunction + \",\" + oncloseFunction;"], [689, "\t\tValueExpression connectedExpression = getValueExpression(context, connected, Boolean.class);"], [690, ""], [691, "\t\tSystemEventListener listener = new SocketFacesListener(portNumber, channelName, channelId, functions, connectedExpression);"], [692, "\t\tsubscribeToViewEvent(PostAddToViewEvent.class, listener);"], [693, "\t\tsubscribeToViewEvent(PreRenderViewEvent.class, listener);"]]}, "num_lines_added": 75, "num_lines_removed": 61}