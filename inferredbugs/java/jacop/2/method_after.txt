    void generateConstraints(SimpleNode constraintWithAnnotations, Tables table, Options opt) throws FailException {

	this.opt = opt;

// 	if (!storeLevelIncreased) {
// 	    System.out.println("1. Level="+store.level);
// 	    store.setLevel(store.level + 1);
// 	    storeLevelIncreased = true;
// 	    System.out.println("2. Level="+store.level);
// 	}

	if (debug)
	    constraintWithAnnotations.dump("");

	// default consistency - bounds
 	boundsConsistency = true; 
 	domainConsistency = false;
	definedVar = null;

	dictionary = table;
 	// this.zero = table.zero; 
	// this.one = table.one; 

	int numberChildren = constraintWithAnnotations.jjtGetNumChildren();
// 	System.out.println ("numberChildren = "+numberChildren);
	if (numberChildren > 1 )
	    parseAnnotations(constraintWithAnnotations);

	SimpleNode node = (SimpleNode)constraintWithAnnotations.jjtGetChild(0);

//  	node.dump("=> ");

	// Predicates
	if (node.getId() == JJTCONSTELEM) {

	    p = ((ASTConstElem)node).getName();

	    if (p.startsWith("int2float")) {

		ASTScalarFlatExpr p1 = (ASTScalarFlatExpr)node.jjtGetChild(0);
		ASTScalarFlatExpr p2 = (ASTScalarFlatExpr)node.jjtGetChild(1);

		pose(new XeqP(getVariable(p1), getFloatVariable(p2)));
	    }

	    else if (p.startsWith("float_") ) {
		int operation = comparisonPredicate(p, 6);

		// node.dump("");
		// System.out.println(p + " op = " + operation);

		// float_eq*, float_ne*, float_lt*, float_gt*, float_le*, and float_ge*
		if ( operation != -1) {
		    float_comparison(operation, node, 8);
		}

		// float_lin_* (eq, ne, lt, gt, le, ge)
		else if (p.startsWith("lin_", 6)) {
		    operation = comparisonPredicate(p, 10);
		    float_lin_relation(operation, node);
		} 

		else if (p.startsWith("plus", 6)) {

		    ASTScalarFlatExpr p1 = (ASTScalarFlatExpr)node.jjtGetChild(0);
		    ASTScalarFlatExpr p2 = (ASTScalarFlatExpr)node.jjtGetChild(1);
		    ASTScalarFlatExpr p3 = (ASTScalarFlatExpr)node.jjtGetChild(2);

		    if (p1.getType() == 5) {// p1 int
		    	pose(new PplusCeqR(getFloatVariable(p2), getFloat(p1), getFloatVariable(p3)));
		    }
		    else if (p2.getType() == 5) {// p2 int
		    	pose(new PplusCeqR(getFloatVariable(p1), getFloat(p2), getFloatVariable(p3)));
		    }
		    else
			pose(new PplusQeqR(getFloatVariable(p1), getFloatVariable(p2), getFloatVariable(p3)));

		} else if (p.startsWith("times", 6)) {

		    ASTScalarFlatExpr p1 = (ASTScalarFlatExpr)node.jjtGetChild(0);
		    ASTScalarFlatExpr p2 = (ASTScalarFlatExpr)node.jjtGetChild(1);
		    ASTScalarFlatExpr p3 = (ASTScalarFlatExpr)node.jjtGetChild(2);

		    if (p1.getType() == 5) {// p1 float
			pose(new PmulCeqR(getFloatVariable(p2), getFloat(p1), getFloatVariable(p3)));
		    }
		    else if (p2.getType() == 5) {// p2 float
			pose(new PmulCeqR(getFloatVariable(p1), getFloat(p2), getFloatVariable(p3)));
		    }
		    else
			pose(new PmulQeqR(getFloatVariable(p1), getFloatVariable(p2), getFloatVariable(p3)));

		} else if (p.startsWith("div", 6)) {

		    ASTScalarFlatExpr p1 = (ASTScalarFlatExpr)node.jjtGetChild(0);
		    ASTScalarFlatExpr p2 = (ASTScalarFlatExpr)node.jjtGetChild(1);
		    ASTScalarFlatExpr p3 = (ASTScalarFlatExpr)node.jjtGetChild(2);

		    pose(new PdivQeqR(getFloatVariable(p1), getFloatVariable(p2), getFloatVariable(p3)));
		}
		else if (p.startsWith("abs", 6)) {
		    ASTScalarFlatExpr p1 = (ASTScalarFlatExpr)node.jjtGetChild(0);
		    ASTScalarFlatExpr p2 = (ASTScalarFlatExpr)node.jjtGetChild(1);

		    pose(new AbsPeqR(getFloatVariable(p1), getFloatVariable(p2)));
		}
		else if (p.startsWith("sqrt", 6)) {
		    ASTScalarFlatExpr p1 = (ASTScalarFlatExpr)node.jjtGetChild(0);
		    ASTScalarFlatExpr p2 = (ASTScalarFlatExpr)node.jjtGetChild(1);

		    pose(new SqrtPeqR(getFloatVariable(p1), getFloatVariable(p2)));
		}
		else if (p.startsWith("sin", 6)) {
		    ASTScalarFlatExpr p1 = (ASTScalarFlatExpr)node.jjtGetChild(0);
		    ASTScalarFlatExpr p2 = (ASTScalarFlatExpr)node.jjtGetChild(1);

		    pose(new SinPeqR(getFloatVariable(p1), getFloatVariable(p2)));
		}
		else if (p.startsWith("cos", 6)) {
		    ASTScalarFlatExpr p1 = (ASTScalarFlatExpr)node.jjtGetChild(0);
		    ASTScalarFlatExpr p2 = (ASTScalarFlatExpr)node.jjtGetChild(1);

		    pose(new CosPeqR(getFloatVariable(p1), getFloatVariable(p2)));
		}
		else if (p.startsWith("asin", 6)) {
		    ASTScalarFlatExpr p1 = (ASTScalarFlatExpr)node.jjtGetChild(0);
		    ASTScalarFlatExpr p2 = (ASTScalarFlatExpr)node.jjtGetChild(1);

		    pose(new AsinPeqR(getFloatVariable(p1), getFloatVariable(p2)));
		}
		else if (p.startsWith("acos", 6)) {
		    ASTScalarFlatExpr p1 = (ASTScalarFlatExpr)node.jjtGetChild(0);
		    ASTScalarFlatExpr p2 = (ASTScalarFlatExpr)node.jjtGetChild(1);

		    pose(new AcosPeqR(getFloatVariable(p1), getFloatVariable(p2)));
		}
		else if (p.startsWith("tan", 6)) {
		    ASTScalarFlatExpr p1 = (ASTScalarFlatExpr)node.jjtGetChild(0);
		    ASTScalarFlatExpr p2 = (ASTScalarFlatExpr)node.jjtGetChild(1);

		    pose(new TanPeqR(getFloatVariable(p1), getFloatVariable(p2)));
		}
		else if (p.startsWith("atan", 6)) {
		    ASTScalarFlatExpr p1 = (ASTScalarFlatExpr)node.jjtGetChild(0);
		    ASTScalarFlatExpr p2 = (ASTScalarFlatExpr)node.jjtGetChild(1);

		    pose(new AtanPeqR(getFloatVariable(p1), getFloatVariable(p2)));
		}
		else if (p.startsWith("exp", 6)) {
		    ASTScalarFlatExpr p1 = (ASTScalarFlatExpr)node.jjtGetChild(0);
		    ASTScalarFlatExpr p2 = (ASTScalarFlatExpr)node.jjtGetChild(1);

		    pose(new ExpPeqR(getFloatVariable(p1), getFloatVariable(p2)));
		}
		else if (p.startsWith("ln", 6)) {
		    ASTScalarFlatExpr p1 = (ASTScalarFlatExpr)node.jjtGetChild(0);
		    ASTScalarFlatExpr p2 = (ASTScalarFlatExpr)node.jjtGetChild(1);

		    pose(new LnPeqR(getFloatVariable(p1), getFloatVariable(p2)));
		}
		else if (p.startsWith("min", 6)) {
		    ASTScalarFlatExpr p1 = (ASTScalarFlatExpr)node.jjtGetChild(0);
		    ASTScalarFlatExpr p2 = (ASTScalarFlatExpr)node.jjtGetChild(1);
		    ASTScalarFlatExpr p3 = (ASTScalarFlatExpr)node.jjtGetChild(2);

		    FloatVar v1 = getFloatVariable(p1);
		    FloatVar v2 = getFloatVariable(p2);
		    FloatVar v3 = getFloatVariable(p3);

		    pose(new org.jacop.floats.constraints.Min(new FloatVar[] {v1, v2}, v3));
		    // 1.
		    // pose(new IfThenElse(new PlteqQ(v1,v2), new PeqQ(v1,v3), new PeqQ(v2,v3)));
		    // 2.
		    // pose(new IfThen(new PltQ(v1,v2), new PeqQ(v1,v3)));
		    // pose(new IfThen(new PltQ(v2,v1), new PeqQ(v2,v3)));
		}
		else if (p.startsWith("max", 6)) {
		    ASTScalarFlatExpr p1 = (ASTScalarFlatExpr)node.jjtGetChild(0);
		    ASTScalarFlatExpr p2 = (ASTScalarFlatExpr)node.jjtGetChild(1);
		    ASTScalarFlatExpr p3 = (ASTScalarFlatExpr)node.jjtGetChild(2);

		    FloatVar v1 = getFloatVariable(p1);
		    FloatVar v2 = getFloatVariable(p2);
		    FloatVar v3 = getFloatVariable(p3);

		    pose(new org.jacop.floats.constraints.Max(new FloatVar[] {v1, v2}, v3));

		    // 1.
		    // pose(new IfThenElse(new PltQ(v2,v1), new PeqQ(v1,v3), new PeqQ(v2,v3)));
		    // 2.
		    // pose(new IfThen(new PltQ(v2,v1), new PeqQ(v1,v3)));
		    // pose(new IfThen(new PltQ(v1,v2), new PeqQ(v2,v3)));
		}
		else {
		    System.err.println("%% ERROR: JaCoP does not implement this constraints on floats");
		    System.exit(0);
		}

	    }
	    // int_* predicates
	    else if (p.startsWith("int_") ) {
		int operation = comparisonPredicate(p, 4);
		// 	    System.out.println(p + " op = " + operation);

		if (p.startsWith("negate", 4)) {
		    int_negate(node);
		}

		// int_eq*, int_ne*, int_lt*, int_gt*, int_le*, and int_ge*
		else if ( operation != -1) {
		    int_comparison(operation, node, 6);
		}

		// int_lin_* (eq, ne, lt, gt, le, ge)
		else if (p.startsWith("lin_", 4)) {
		    operation = comparisonPredicate(p, 8);
		    int_lin_relation(operation, node);
		}

		else if (p.startsWith("plus", 4)) {

		    ASTScalarFlatExpr p1 = (ASTScalarFlatExpr)node.jjtGetChild(0);
		    ASTScalarFlatExpr p2 = (ASTScalarFlatExpr)node.jjtGetChild(1);
		    ASTScalarFlatExpr p3 = (ASTScalarFlatExpr)node.jjtGetChild(2);

		    if (p1.getType() == 0) {// p1 int
			pose(new XplusCeqZ(getVariable(p2), getInt(p1), getVariable(p3)));
		    }
		    else if (p2.getType() == 0) {// p2 int
			pose(new XplusCeqZ(getVariable(p1), getInt(p2), getVariable(p3)));
		    }
		    else if (p3.getType() == 0) {// p3 int
			pose(new XplusYeqC(getVariable(p1), getVariable(p2), getInt(p3)));
		    }
		    else
			pose(new XplusYeqZ(getVariable(p1), getVariable(p2), getVariable(p3)));
		}

		else if (p.startsWith("minus", 4)) {
		    // p1 - p2 = p3 <=> p2 + p3 = p1
		    ASTScalarFlatExpr p1 = (ASTScalarFlatExpr)node.jjtGetChild(0);
		    ASTScalarFlatExpr p2 = (ASTScalarFlatExpr)node.jjtGetChild(1);
		    ASTScalarFlatExpr p3 = (ASTScalarFlatExpr)node.jjtGetChild(2);

		    if (p2.getType() == 0) {// p2 int
			pose(new XplusCeqZ(getVariable(p3), getInt(p2), getVariable(p1)));
		    }
		    else if (p3.getType() == 0) {// p3 int
			pose(new XplusCeqZ(getVariable(p2), getInt(p3), getVariable(p1)));
		    }
		    else if (p3.getType() == 0) {// p1 int
			pose(new XplusYeqC(getVariable(p2), getVariable(p3), getInt(p1)));
		    }
		    else
			pose(new XplusYeqZ(getVariable(p2), getVariable(p3), getVariable(p1)));
		}
		else if (p.startsWith("times", 4)) {
		    // 		    node.dump("");

		    ASTScalarFlatExpr p1 = (ASTScalarFlatExpr)node.jjtGetChild(0);
		    ASTScalarFlatExpr p2 = (ASTScalarFlatExpr)node.jjtGetChild(1);
		    ASTScalarFlatExpr p3 = (ASTScalarFlatExpr)node.jjtGetChild(2);

		    if (p1.getType() == 0) {// p1 int
			pose(new XmulCeqZ(getVariable(p2), getInt(p1), getVariable(p3)));
		    }
		    else if (p2.getType() == 0) {// p2 int
			pose(new XmulCeqZ(getVariable(p1), getInt(p2), getVariable(p3)));
		    }
		    else if (p3.getType() == 0) {// p3 int
			pose(new XmulYeqC(getVariable(p1), getVariable(p2), getInt(p3)));
		    }
		    else {
			IntVar v1 = getVariable(p1), v2 = getVariable(p2), v3 = getVariable(p3);
			if (v1.min() >= 0 && v1.max() <= 1 && v2.min() >= 0 && v2.max() <= 1 && v3.min() >= 0 && v3.max() <= 1) 
			    pose(new AndBoolSimple(v1, v2, v3));
			else
			    pose(new XmulYeqZ(v1, v2, v3));
		    }
		}
		else if (p.startsWith("div", 4)) {
		    // p1/p2 = p3
		    ASTScalarFlatExpr p1 = (ASTScalarFlatExpr)node.jjtGetChild(0);
		    ASTScalarFlatExpr p2 = (ASTScalarFlatExpr)node.jjtGetChild(1);
		    ASTScalarFlatExpr p3 = (ASTScalarFlatExpr)node.jjtGetChild(2);

		    IntVar v1 = getVariable(p1);
		    IntVar v2 = getVariable(p2);
		    IntVar v3 = getVariable(p3);

		    pose(new XdivYeqZ(v1, v2, v3));

		}
		else if (p.startsWith("mod", 4)) {
		    ASTScalarFlatExpr p1 = (ASTScalarFlatExpr)node.jjtGetChild(0);
		    ASTScalarFlatExpr p2 = (ASTScalarFlatExpr)node.jjtGetChild(1);
		    ASTScalarFlatExpr p3 = (ASTScalarFlatExpr)node.jjtGetChild(2);

		    IntVar v1 = getVariable(p1);
		    IntVar v2 = getVariable(p2);
		    IntVar v3 = getVariable(p3);

		    pose(new XmodYeqZ(v1, v2, v3));

		}
		else if (p.startsWith("min", 4)) {
		    ASTScalarFlatExpr p1 = (ASTScalarFlatExpr)node.jjtGetChild(0);
		    ASTScalarFlatExpr p2 = (ASTScalarFlatExpr)node.jjtGetChild(1);
		    ASTScalarFlatExpr p3 = (ASTScalarFlatExpr)node.jjtGetChild(2);

		    IntVar v1 = getVariable(p1);
		    IntVar v2 = getVariable(p2);
		    IntVar v3 = getVariable(p3);

		    // pose(new IfThen(new XlteqY(v1,v2), new XeqY(v1,v3)));
		    // pose(new IfThen(new XlteqY(v2,v1), new XeqY(v2,v3)));

		    if (v1 == v2)
		    	pose(new XeqY(v1, v3));
		    else
		    	pose(new org.jacop.constraints.Min(new IntVar[] {v1, v2}, v3));

		}
		else if (p.startsWith("max", 4)) {
		    ASTScalarFlatExpr p1 = (ASTScalarFlatExpr)node.jjtGetChild(0);
		    ASTScalarFlatExpr p2 = (ASTScalarFlatExpr)node.jjtGetChild(1);
		    ASTScalarFlatExpr p3 = (ASTScalarFlatExpr)node.jjtGetChild(2);

		    IntVar v1 = getVariable(p1);
		    IntVar v2 = getVariable(p2);
		    IntVar v3 = getVariable(p3);


		    // pose(new IfThen(new XgteqY(v1,v2), new XeqY(v1,v3)));
		    // pose(new IfThen(new XgteqY(v2,v1), new XeqY(v2,v3)));

		    if (  v1.singleton() && v2.singleton() ) {
			int max = java.lang.Math.max(v1.value(), v2.value());
			v3.domain.in(store.level, v3, max, max);
		    }
		    else if (v1.singleton() && v1.value() >= v2.max() ) {
			int max = v1.value();
			v3.domain.in(store.level, v3, max, max);
		    }
		    else if (v2.singleton() && v2.value() >= v1.max() ) {
			int max = v2.value();
			v3.domain.in(store.level, v3, max, max);
		    } 
		    else if (v1.min() >= v2.max() )
			pose(new XeqY(v1, v3));
		    else if (v2.min() >= v1.max() )
			pose(new XeqY(v2, v3));
		    else if (v1 == v2)
		    	pose(new XeqY(v1, v3));
		    else
		    	pose(new org.jacop.constraints.Max(new IntVar[] {v1, v2}, v3));

		}
		else if (p.startsWith("abs", 4)) {
		    ASTScalarFlatExpr p1 = (ASTScalarFlatExpr)node.jjtGetChild(0);
		    ASTScalarFlatExpr p2 = (ASTScalarFlatExpr)node.jjtGetChild(1);

		    IntVar v1 = getVariable(p1);
		    IntVar v2 = getVariable(p2);

		    if (boundsConsistency)
		    	pose(new AbsXeqY(v1, v2));
		    else
			pose(new AbsXeqY(v1, v2, true));

		}
		else if (p.startsWith("pow", 4)) {
		    ASTScalarFlatExpr p1 = (ASTScalarFlatExpr)node.jjtGetChild(0);
		    ASTScalarFlatExpr p2 = (ASTScalarFlatExpr)node.jjtGetChild(1);
		    ASTScalarFlatExpr p3 = (ASTScalarFlatExpr)node.jjtGetChild(2);

		    IntVar v1 = getVariable(p1);
		    IntVar v2 = getVariable(p2);
		    IntVar v3 = getVariable(p3);

		    pose(new XexpYeqZ(v1, v2, v3));
		}
		else
		    System.out.println("TODO: "+p);
	    }

	    // array_* predicates
	    else if (p.startsWith("array_") ) {
		if (p.startsWith("bool_", 6)) {
		    if (p.startsWith("and", 11)) {
			//  			node.dump("");

			IntVar[] a1 = getVarArray((SimpleNode)node.jjtGetChild(0));
			IntVar v = getVariable((ASTScalarFlatExpr)node.jjtGetChild(1));

			if (opt.useSat())
			    sat.generate_and(a1, v);
			else
			    pose(new AndBool(a1, v));
		    }
		    else if (p.startsWith("or", 11)) {
			//   			node.dump("");

			IntVar[] a1 = getVarArray((SimpleNode)node.jjtGetChild(0));
			IntVar v = getVariable((ASTScalarFlatExpr)node.jjtGetChild(1));

			if (opt.useSat())
			    sat.generate_or(a1, v);
			else
			    pose(new OrBool(a1, v));
		    }
		    else if (p.startsWith("xor", 11)) {

			SimpleNode p1 = (SimpleNode)node.jjtGetChild(0);
			IntVar[] a1 = getVarArray(p1);

			if (opt.useSat())
			    sat.generate_xor(a1, dictionary.getConstant(1)); // one);
			else
			    pose(new XorBool(a1, dictionary.getConstant(1))); // one));

		    }
		    else if (p.startsWith("element", 11)) {
			// array_bool_element
			generateIntElementConstraint(node);
		    }
		    else
			System.err.println("%% ERROR: Not expected constraint : "+p);
		}
		else if (p.startsWith("var_bool_element", 6) ) {
		    // array_var_bool_element
		    generateVarElementConstraint(node);
		    // 		    generateElementConstraint(p, 0);
		}
		else if (p.startsWith("var_int_element", 6) ) {
		    // array_var_int_element
		    generateVarElementConstraint(node);
		    // 		    generateElementConstraint(p, 1);
		}
		else if (p.startsWith("int_element", 6)) {
		    // array_int_element
		    generateIntElementConstraint(node);
		}
		else if (p.startsWith("var_set_element", 6) ) {
		    // array_var_set_element
		    generateVarSetElementConstraint(node);
		}
		else if (p.startsWith("set_element", 6)) {
		    // array_set_element
		    generateSetElementConstraint(node);
		} 
		else if (p.startsWith("float_element", 6)) {
		    generateFloatElementConstraint(node);
		}
		else
		    System.out.println("TODO: "+p);
	    }

	    // bool_* predicates
	    else if (p.startsWith("bool_") ) {

		int operation = comparisonPredicate(p, 5);

		// bool_left_imp
		// a <- b <-> r
		//-------------
		// 0 <- 0 <-> 1
		// 0 <- 1 <-> 0
		// 1 <- 0 <-> 1
		// 1 <- 1 <-> 1
		if (p.startsWith("left_imp", 5)) {

		    IntVar v1 = getVariable((ASTScalarFlatExpr)node.jjtGetChild(0));
		    IntVar v2 = getVariable((ASTScalarFlatExpr)node.jjtGetChild(1));
		    IntVar v3 = getVariable((ASTScalarFlatExpr)node.jjtGetChild(2));

		    if (opt.useSat())
			sat.generate_implication_reif(v2, v1, v3);
		    else
			pose(new IfThenBool(v2, v1, v3));
		} 
		else if ( operation != -1) {
		    // bool_eq*, bool_ne*, bool_lt*, bool_gt*, bool_le*, and bool_ge*
		    if (opt.useSat()) {
			if  (p.startsWith("eq_reif", 5) ) {

			    IntVar v1 = getVariable((ASTScalarFlatExpr)node.jjtGetChild(0));
			    IntVar v2 = getVariable((ASTScalarFlatExpr)node.jjtGetChild(1));
			    IntVar v3 = getVariable((ASTScalarFlatExpr)node.jjtGetChild(2));
			
			    sat.generate_eq_reif(v1, v2, v3);
			}
			else if  (p.startsWith("ne_reif", 5) ) {

			    IntVar v1 = getVariable((ASTScalarFlatExpr)node.jjtGetChild(0));
			    IntVar v2 = getVariable((ASTScalarFlatExpr)node.jjtGetChild(1));
			    IntVar v3 = getVariable((ASTScalarFlatExpr)node.jjtGetChild(2));
			
			    sat.generate_neq_reif(v1, v2, v3);
			}
			else if  (p.startsWith("le_reif", 5) ) {

			    IntVar a = getVariable((ASTScalarFlatExpr)node.jjtGetChild(0));
			    IntVar b = getVariable((ASTScalarFlatExpr)node.jjtGetChild(1));
			    IntVar c = getVariable((ASTScalarFlatExpr)node.jjtGetChild(2));

			    sat.generate_le_reif(a, b, c);
			}
			else if  (p.startsWith("lt_reif", 5) ) {

			    IntVar a = getVariable((ASTScalarFlatExpr)node.jjtGetChild(0));
			    IntVar b = getVariable((ASTScalarFlatExpr)node.jjtGetChild(1));
			    IntVar c = getVariable((ASTScalarFlatExpr)node.jjtGetChild(2));

			    sat.generate_lt_reif(a, b, c);
			}
			else if  (p.startsWith("eq", 5) ) {

			    IntVar a = getVariable((ASTScalarFlatExpr)node.jjtGetChild(0));
			    IntVar b = getVariable((ASTScalarFlatExpr)node.jjtGetChild(1));

			    sat.generate_eq(a, b);
			}
			else if  (p.startsWith("ne", 5) ) {

			    IntVar a = getVariable((ASTScalarFlatExpr)node.jjtGetChild(0));
			    IntVar b = getVariable((ASTScalarFlatExpr)node.jjtGetChild(1));

			    sat.generate_not(a, b);
			}
			else if  (p.startsWith("le", 5) ) {

			    IntVar a = getVariable((ASTScalarFlatExpr)node.jjtGetChild(0));
			    IntVar b = getVariable((ASTScalarFlatExpr)node.jjtGetChild(1));

			    sat.generate_le(a, b);
			}
			else if  (p.startsWith("lt", 5) ) {

			    IntVar a = getVariable((ASTScalarFlatExpr)node.jjtGetChild(0));
			    IntVar b = getVariable((ASTScalarFlatExpr)node.jjtGetChild(1));

			    sat.generate_lt(a, b);
			}
		    }
		    else {
			int_comparison(operation, node, 7);
		    }
		}
		// bool_or
		else if (p.startsWith("or", 5)) {

		    IntVar v1 = getVariable((ASTScalarFlatExpr)node.jjtGetChild(0));
		    IntVar v2 = getVariable((ASTScalarFlatExpr)node.jjtGetChild(1));
		    IntVar v3 = getVariable((ASTScalarFlatExpr)node.jjtGetChild(2));

		    if (opt.useSat())
			sat.generate_or(new IntVar[] {v1, v2}, v3);
		    else
			pose(new OrBoolSimple(v1, v2, v3));
		}
		// bool_and
		else if (p.startsWith("and", 5)) {

		    ASTScalarFlatExpr p1 = (ASTScalarFlatExpr)node.jjtGetChild(0);
		    ASTScalarFlatExpr p2 = (ASTScalarFlatExpr)node.jjtGetChild(1);
		    ASTScalarFlatExpr p3 = (ASTScalarFlatExpr)node.jjtGetChild(2);

		    IntVar v1 = getVariable(p1);
		    IntVar v2 = getVariable(p2);
		    IntVar v3 = getVariable(p3);

		    if (opt.useSat())
			sat.generate_and(new IntVar[] {v1, v2}, v3);
		    else
			pose(new AndBoolSimple(v1, v2, v3));
		}
		// bool_xor
		else if (p.startsWith("xor", 5)) {

		    ASTScalarFlatExpr p1 = (ASTScalarFlatExpr)node.jjtGetChild(0);
		    ASTScalarFlatExpr p2 = (ASTScalarFlatExpr)node.jjtGetChild(1);
		    ASTScalarFlatExpr p3 = (ASTScalarFlatExpr)node.jjtGetChild(2);

		    IntVar v1 = getVariable(p1);
		    IntVar v2 = getVariable(p2);
		    IntVar v3 = getVariable(p3);

		    if (opt.useSat())
			sat.generate_neq_reif(v1, v2, v3);
		    else
			pose(new XorBool(new IntVar[] {v1, v2}, v3));
		}
		// bool_not
		else if (p.startsWith("not", 5)) {

		    ASTScalarFlatExpr p1 = (ASTScalarFlatExpr)node.jjtGetChild(0);
		    ASTScalarFlatExpr p2 = (ASTScalarFlatExpr)node.jjtGetChild(1);

		    IntVar v1 = getVariable(p1);
		    IntVar v2 = getVariable(p2);

		    if (opt.useSat())
			sat.generate_not(v1, v2);
		    else
			pose(new XneqY(v1, v2));
		}
		// bool_right_imp
		// a -> b <-> r
		//-------------
		// 0 -> 0 <-> 1
		// 0 -> 1 <-> 1
		// 1 -> 0 <-> 0
		// 1 -> 1 <-> 1
		else if (p.startsWith("right_imp", 5)) {
		    // 		    node.dump("");
		    ASTScalarFlatExpr p1 = (ASTScalarFlatExpr)node.jjtGetChild(0);
		    ASTScalarFlatExpr p2 = (ASTScalarFlatExpr)node.jjtGetChild(1);
		    ASTScalarFlatExpr p3 = (ASTScalarFlatExpr)node.jjtGetChild(2);

		    IntVar v1 = getVariable(p1);
		    IntVar v2 = getVariable(p2);
		    IntVar v3 = getVariable(p3);

		    if (opt.useSat())
			sat.generate_implication_reif(v1, v2, v3);
		    else
			pose(new IfThenBool(v1, v2, v3));
		}
		// bool_clause([x1,..., xm], [y1,..., yn]) ===>
		// x1 \/ ... \/ xm \/ not y1 \/ ... \/ not yn
		else if (p.startsWith("clause", 5)) {

		    IntVar[] a1 = getVarArray((SimpleNode)node.jjtGetChild(0));
		    IntVar[] a2 = getVarArray((SimpleNode)node.jjtGetChild(1));

		    if (a1.length == 0 && a2.length == 0 )
			return;

		    if (opt.useSat()) {
			if (p.startsWith("_reif", 11)) { // reified
			    IntVar r = getVariable((ASTScalarFlatExpr)node.jjtGetChild(2));
			    sat.generate_clause_reif(a1, a2, r);
			}
			else
			    sat.generate_clause(a1, a2);
		    }
		    else { // not SAT generation, use CP constraints
			ArrayList<IntVar> a1reduced = new ArrayList<IntVar>();
			for (int i = 0; i < a1.length; i++) 
			    if (a1[i].max() != 0)
				a1reduced.add(a1[i]);
			ArrayList<IntVar> a2reduced = new ArrayList<IntVar>();
			for (int i = 0; i < a2.length; i++) 
			    if (a2[i].min() != 1)
				a2reduced.add(a2[i]);
			if (a1reduced.size() == 0 && a2reduced.size() == 0 )
			    throw store.failException;

			PrimitiveConstraint c;
			if (a1reduced.size() == 0)
			    c = new AndBool(a2reduced, dictionary.getConstant(0)); // zero);
			else if (a2reduced.size() == 0)
			    c = new OrBool(a1reduced, dictionary.getConstant(1)); // one);
			else if (a1reduced.size() == 1 && a2reduced.size() == 1)
			    if (a1reduced.get(0).min() == 1)
				return;
			    else
				c = new XlteqY(a2reduced.get(0), a1reduced.get(0));
			else
			    c = new BoolClause(a1reduced, a2reduced);

		    // bool_clause_reif/3 defined in redefinitions-2.0.
			if (p.startsWith("_reif", 11)) {
			    IntVar r = getVariable((ASTScalarFlatExpr)node.jjtGetChild(2));
			    pose(new Reified(c, r));		    }
			else
			    pose(c);
		    }
		}
		// bool_lin_* (eq, ne, lt, gt, le, ge)
		else if (p.startsWith("lin_", 5)) {

		    operation = comparisonPredicate(p, 9);
		    int_lin_relation(operation, node);
		}
		else
		    System.out.println("TODO: "+p);
		// 		<-------------
	    }

	    // set_* predicates
	    else if (p.startsWith("set_") ) {

		if (p.startsWith("eq", 4)) {

		    SetVar v1 = getSetVariable(node, 0);
		    SetVar v2 = getSetVariable(node, 1);

		    PrimitiveConstraint c = new org.jacop.set.constraints.AeqB(v1, v2);

		    if (p.startsWith("_reif", 6)) {
			IntVar v3 = getVariable((ASTScalarFlatExpr)node.jjtGetChild(2));

			pose(new Reified(c, v3));
		    }
		    else
			pose(c);

		}
		else if (p.startsWith("ne", 4)) {

		    SetVar v1 = getSetVariable(node, 0);
		    SetVar v2 = getSetVariable(node, 1);

		    PrimitiveConstraint c = new Not(new org.jacop.set.constraints.AeqB(v1, v2));

		    if (p.startsWith("_reif", 6)) {
			IntVar v3 = getVariable((ASTScalarFlatExpr)node.jjtGetChild(2));

			pose(new Reified(c, v3));
		    }
		    else
			pose(c);
		}
		else if (p.startsWith("lt", 4)) {

		    if (p.startsWith("_reif", 6)) {
			System.err.println("%% set_lt_reif with list of set variables is not avaible in org.jacop.set");
			System.exit(0);
		    }

		    SetVar v1 = getSetVariable(node, 0);
		    SetVar v2 = getSetVariable(node, 1);

		    pose(new Lex(v1, v2));
		}
		else if (p.startsWith("gt", 4)) {

		    if (p.startsWith("_reif", 6)) {
			System.err.println("%% set_gt_reif with list of set variables is not avaible in org.jacop.set");
			System.exit(0);
		    }

		    SetVar v1 = getSetVariable(node, 0);
		    SetVar v2 = getSetVariable(node, 1);

		    pose(new Lex(v2, v1));
		}
		else if (p.startsWith("le", 4)) {

		    if (p.startsWith("_reif", 6)) {
			System.err.println("%% set_le_reif with list of set variables is not avaible in org.jacop.set");
			System.exit(0);
		    }

		    SetVar v1 = getSetVariable(node, 0);
		    SetVar v2 = getSetVariable(node, 1);

		    pose(new Lex(v1, v2, false));

		}
		else if (p.startsWith("ge", 4))  {

		    if (p.startsWith("_reif", 6)) {
			System.err.println("%% set_ge_reif with list of set variables is not avaible in org.jacop.set");
			System.exit(0);
		    }

		    SetVar v1 = getSetVariable(node, 0);
		    SetVar v2 = getSetVariable(node, 1);

		    pose(new Lex(v2, v1, false));

		}

		else  if (p.startsWith("intersect", 4)) {

		    SetVar v1 = getSetVariable(node, 0);
		    SetVar v2 = getSetVariable(node, 1);
		    SetVar v3 = getSetVariable(node, 2);

		    pose(new AintersectBeqC(v1, v2, v3));
		}
		else if (p.startsWith("card", 4)) {

		    SetVar v1 = getSetVariable(node, 0);
		    IntVar v2 = getVariable((ASTScalarFlatExpr)node.jjtGetChild(1));

		    if (v2.singleton()) {
			v1.domain.inCardinality(store.level, v1, v2.min(), v2.max());

			if (debug)
			    System.out.println ("Cardinality of set " + v1 + " = " + v2);

		    }
		    else
			pose(new CardAeqX(v1, v2));
		}
		else if (p.startsWith("in", 4)) {

		    PrimitiveConstraint c;

		    ASTScalarFlatExpr p1 = (ASTScalarFlatExpr)node.jjtGetChild(0);
		    SimpleNode v1Type = (SimpleNode)node.jjtGetChild(1);
		    if (v1Type.getId() == JJTSETLITERAL) {
			IntDomain d = getSetLiteral(node, 1);
			IntVar v1 = getVariable(p1);
			if (p.startsWith("_reif", 6)) 
			    // if (opt.useSat()) {  // it can be moved to SAT solver but it is slow in the current implementation
			    // 	IntVar v3 = getVariable((ASTScalarFlatExpr)node.jjtGetChild(2));
			    // 	sat.generate_inSet_reif(v1, d, v3);
			    // 	return;
			    // }
			    // else
				c = new org.jacop.constraints.In(v1, d);
			else { 
			    v1.domain.in(store.level, v1, d);
			    return;
			}
		    }
		    else {
			SetVar v2 = getSetVariable(node, 1);

			if (p1.getType() == 0) { // p1 int
			    int i1 = getInt(p1);
			    c = new EinA(i1, v2);
			}
			else { // p1 var
			    IntVar v1 = getVariable(p1);
			    c = new XinA(v1, v2);
			}
		    }
		    // FIXME, include AinB here? 

		    if (p.startsWith("_reif", 6)) {
			IntVar v3 = getVariable((ASTScalarFlatExpr)node.jjtGetChild(2));

			pose(new Reified(c, v3));
		    }
		    else
			pose(c);

		}
		else if (p.startsWith("subset", 4)) {

		    SetVar v1 = getSetVariable(node, 0);
		    SetVar v2 = getSetVariable(node, 1);

		    PrimitiveConstraint c = new AinB(v1, v2);
		    if (p.startsWith("_reif", 10)) {
			IntVar v3 = getVariable((ASTScalarFlatExpr)node.jjtGetChild(2));

			pose(new Reified(c, v3));
		    }
		    else
			pose(c);
		}
		else if (p.startsWith("superset", 4)) {

		    SetVar v1 = getSetVariable(node, 0);
		    SetVar v2 = getSetVariable(node, 1);

		    PrimitiveConstraint c = new AinB(v2, v1);
		    if (p.startsWith("_reif", 12)) {
			IntVar v3 = getVariable((ASTScalarFlatExpr)node.jjtGetChild(2));

			pose(new Reified(c, v3));
		    }
		    else
			pose(c);
		}
		else if (p.startsWith("union", 4)) {

		    SetVar v1 = getSetVariable(node, 0);
		    SetVar v2 = getSetVariable(node, 1);
		    SetVar v3 = getSetVariable(node, 2);

		    pose(new AunionBeqC(v1, v2, v3));
		}
		else if (p.startsWith("diff", 4)) {

		    SetVar v1 = getSetVariable(node, 0);
		    SetVar v2 = getSetVariable(node, 1);
		    SetVar v3 = getSetVariable(node, 2);

		    pose(new AdiffBeqC(v1, v2, v3));
		}
		else if (p.startsWith("symdiff", 4)) {

		    SetVar v1 = getSetVariable(node, 0);
		    SetVar v2 = getSetVariable(node, 1);
		    SetVar v3 = getSetVariable(node, 2);

		    SetVar t1 = new SetVar(store, new BoundSetDomain(IntDomain.MinInt, IntDomain.MaxInt));
		    SetVar t2 = new SetVar(store, new BoundSetDomain(IntDomain.MinInt, IntDomain.MaxInt));
		    
		    pose(new AdiffBeqC(v1, v2, t1));
		    
		    pose(new AdiffBeqC(v2, v1, t2));

		    pose(new AunionBeqC(t1, t2, v3));
		}
		else
		    System.out.println("TODO: "+p);
	    }
	    // bool2int and int2bool coercion operations
	    else if (p.equals("bool2int") || p.equals("int2bool") ) {
		// 		node.dump("");

		ASTScalarFlatExpr p1 = (ASTScalarFlatExpr)node.jjtGetChild(0);
		ASTScalarFlatExpr p2 = (ASTScalarFlatExpr)node.jjtGetChild(1);

		// if (opt.useSat()) // it can be moved to SAT solver but it is slow in the current implementation
		//     sat.generate_eq(getVariable(p1), getVariable(p2));
		// else

		pose(new XeqY(getVariable(p1), getVariable(p2)));
	    }
	    // ========== JaCoP constraints ==================>>
	    else if (p.startsWith("jacop_"))
		if (p.startsWith("cumulative", 6)) {

		    IntVar[] s = getVarArray((SimpleNode)node.jjtGetChild(0));
		    IntVar[] d = getVarArray((SimpleNode)node.jjtGetChild(1));
		    IntVar[] r = getVarArray((SimpleNode)node.jjtGetChild(2));
		    IntVar b = getVariable((ASTScalarFlatExpr)node.jjtGetChild(3));

		    if (s.length > 200)
			// for large number of taks (>200)
			// edge-finding is not used
			pose(new Cumulative(s, d, r, b, false, true, false));
		    else
			pose(new Cumulative(s, d, r, b, true, true, false));

		}
		else if (p.startsWith("circuit", 6)) {
		    IntVar[] v = getVarArray((SimpleNode)node.jjtGetChild(0));

		    pose(new Circuit(v));

		    if ( domainConsistency && ! opt.getBoundConsistency())  // we add additional implied constraint if domain consistency is required
			parameterListForAlldistincts.add(v);

		}
		else if (p.startsWith("subcircuit", 6)) {
		    IntVar[] v = getVarArray((SimpleNode)node.jjtGetChild(0));

		    pose(new Subcircuit(v));
		}
		else if (p.startsWith("alldiff", 6)) {
		    IntVar[] v = getVarArray((SimpleNode)node.jjtGetChild(0));

		    IntervalDomain dom = new IntervalDomain();
		    for (IntVar var : v)
			dom = (IntervalDomain)dom.union( var.dom() );
 		    if (v.length <= 100) { // && v.length == dom.getSize()) {
			// we do not not pose Alldistinct directly because of possible inconsistency with its 
			// intiallization; we collect all vectors and pose it at the end when all constraints are posed
			// pose(new Alldistinct(v));

			if (boundsConsistency || opt.getBoundConsistency()) {
			    pose(new Alldiff(v));
  			    // System.out.println("Alldiff imposed");
			}
			else { // domain consistency
			    parameterListForAlldistincts.add(v);

    			    // System.out.println("Alldistinct imposed on " + java.util.Arrays.asList(v));
			}
		    }
		    else {
			pose(new Alldiff(v));
			//			System.out.println("Alldiff imposed");
		    }
		}
		else if (p.startsWith("alldistinct", 6)) {
		    IntVar[] v = getVarArray((SimpleNode)node.jjtGetChild(0));
		    // we do not not pose Alldistinct directly because of possible inconsistency with its 
		    // intiallization; we collect all vectors and pose it at the end when all constraints are posed

// 		    pose(new Alldistinct(v));
		    parameterListForAlldistincts.add(v);
//  		    System.out.println("Alldistinct imposed "+ java.util.Arrays.asList(v));
		}
		else if (p.startsWith("among_var", 6)) {
		    IntVar[] x = getVarArray((SimpleNode)node.jjtGetChild(0));
		    IntVar[] s = getVarArray((SimpleNode)node.jjtGetChild(1));
		    IntVar v = getVariable((ASTScalarFlatExpr)node.jjtGetChild(2));

		    // we do not not pose AmongVar directly because of possible inconsistency with its 
		    // intiallization; we collect all constraints and pose them at the end when all other constraints are posed

		    // ---- KK, 2015-10-17
		    // among must not have duplicated variables there
		    // could be constants that have the same value and
		    // are duplicated.
		    IntVar[] xx = new IntVar[x.length];
		    HashSet<IntVar> varSet = new HashSet<IntVar>();
		    for (int i = 0; i < x.length; i++) {
			if (varSet.contains(x[i]) && x[i].singleton())
			    xx[i] = new IntVar(store, x[i].min(), x[i].max());
			else {
			    xx[i] = x[i];
			    varSet.add(x[i]);
			}
		    }
		    IntVar[] ss = new IntVar[s.length];
		    varSet = new HashSet<IntVar>();
		    for (int i = 0; i < s.length; i++) {
			if (varSet.contains(s[i]) && s[i].singleton())
			    ss[i] = new IntVar(store, s[i].min(), s[i].max());
			else {
			    ss[i] = s[i];
			    varSet.add(s[i]);
			}
		    }
		    IntVar vv;
		    if (varSet.contains(v) && v.singleton())
			vv = new IntVar(store, v.min(), v.max());
		    else
			vv = v;
		    //----


		    delayedConstraints.add(new AmongVar(xx, ss, vv));
// 		    pose(new AmongVar(x, s, v));
		}
		else if (p.startsWith("among", 6)) {
		    IntVar[] x = getVarArray((SimpleNode)node.jjtGetChild(0));
		    IntDomain s = getSetLiteral(node, 1);
		    IntVar v = getVariable((ASTScalarFlatExpr)node.jjtGetChild(2));

		    // ---- KK, 2015-10-17
		    // among must not have duplicated variables. In x vecor
		    // could be constants that have the same value and
		    // are duplicated.
		    IntVar[] xx = new IntVar[x.length];
		    HashSet<IntVar> varSet = new HashSet<IntVar>();
		    for (int i = 0; i < x.length; i++) {
			if (varSet.contains(x[i]) && x[i].singleton())
			    xx[i] = new IntVar(store, x[i].min(), x[i].max());
			else {
			    xx[i] = x[i];
			    varSet.add(x[i]);
			}
		    }
		    IntVar vv;
		    if (varSet.contains(v) && v.singleton())
			vv = new IntVar(store, v.min(), v.max());
		    else
			vv = v;
		    //----

		    IntervalDomain setImpl = new IntervalDomain();
		    for (ValueEnumeration e = s.valueEnumeration(); e.hasMoreElements();) {
			int val = e.nextElement();

			setImpl.unionAdapt(new IntervalDomain(val, val));
		    }

		    pose(new Among(xx, setImpl, vv));

		    // }
		}
		else if (p.startsWith("gcc", 6)) {
		    IntVar[] x = getVarArray((SimpleNode)node.jjtGetChild(0));
		    IntVar[] c = getVarArray((SimpleNode)node.jjtGetChild(1));
		    int index_min = getInt((ASTScalarFlatExpr)node.jjtGetChild(2));
		    int index_max = index_min + c.length - 1;

		    for (int i=0; i<x.length; i++) {
			if (index_min>x[i].max() || index_max<x[i].min()) {
			    System.err.println("%% ERROR: gcc domain error in variable " + x[i]);
			    System.exit(0);
			}
			if (index_min>x[i].min() && index_min<x[i].max()) 
			    x[i].domain.inMin(store.level, x[i], index_min);
			if (index_max<x[i].max() && index_max>x[i].min())
			    x[i].domain.inMax(store.level, x[i], index_max);
		    }
		    // 		    System.out.println("c = " + Arrays.asList(x));

		    // =========> remove all non-existing-values counters
		    IntDomain gcc_dom = new IntervalDomain();
		    for (IntVar v : x)
			gcc_dom = gcc_dom.union( v.dom() );
		    ArrayList<Var> c_list = new ArrayList<Var>();
		    for (int i=0; i<c.length; i++)
			if ( gcc_dom.contains(i+index_min ) )
			    c_list.add(c[i]);
			else
			    pose(new XeqC(c[i], 0));
		    IntVar[] c_array = new IntVar[c_list.size()];
		    c_array = c_list.toArray(c_array);
		    // =========>

		    pose(new GCC(x, c_array));
		}
		else if (p.startsWith("global_cardinality_closed", 6)) {
		    IntVar[] x = getVarArray((SimpleNode)node.jjtGetChild(0));
		    int[] cover = getIntArray((SimpleNode)node.jjtGetChild(1));
		    IntVar[] counter = getVarArray((SimpleNode)node.jjtGetChild(2));

		    IntDomain gcc_dom = new IntervalDomain();
		    for (int e : cover)
			gcc_dom = gcc_dom.union( e );		    
		    for (IntVar v : x)
			v.domain.in(store.level, v, gcc_dom);

		    pose( new GCC(x, counter));
		}
		else if (p.startsWith("global_cardinality_low_up_closed", 6)) {
		    IntVar[] x = getVarArray((SimpleNode)node.jjtGetChild(0));
		    int[] cover = getIntArray((SimpleNode)node.jjtGetChild(1));
		    int[] low = getIntArray((SimpleNode)node.jjtGetChild(2));
		    int[] up = getIntArray((SimpleNode)node.jjtGetChild(3));

		    IntDomain gcc_dom = new IntervalDomain();
		    for (int e : cover)
			gcc_dom = gcc_dom.union( e );		    
		    for (IntVar v : x)
			v.domain.in(store.level, v, gcc_dom);

		    IntVar[] counter = new IntVar[low.length];
		    for (int i = 0; i < counter.length; i++)
			counter[i] = new IntVar(store, "counter"+i, low[i], up[i]);

		    pose( new GCC(x, counter));
		}
		else if (p.startsWith("diff2_strict", 6)) {
		    IntVar[] x = getVarArray((SimpleNode)node.jjtGetChild(0));
		    IntVar[] y = getVarArray((SimpleNode)node.jjtGetChild(1));
		    IntVar[] lx = getVarArray((SimpleNode)node.jjtGetChild(2));
		    IntVar[] ly = getVarArray((SimpleNode)node.jjtGetChild(3));

		    pose(new Disjoint(x, y, lx, ly));
		}
		else if (p.startsWith("diff2", 6)) {
		    IntVar[] v = getVarArray((SimpleNode)node.jjtGetChild(0));

		    IntVar[][] r = new IntVar[v.length/4][4];
		    for (int i=0; i<r.length; i++)
			for (int j=0; j<4; j++)
			    r[i][j] = v[4*i+j];

		    pose(new Diff2(r));
		}
		else if (p.startsWith("list_diff2", 6)) {
		    IntVar[] x = getVarArray((SimpleNode)node.jjtGetChild(0));
		    IntVar[] y = getVarArray((SimpleNode)node.jjtGetChild(1));
		    IntVar[] lx = getVarArray((SimpleNode)node.jjtGetChild(2));
		    IntVar[] ly = getVarArray((SimpleNode)node.jjtGetChild(3));

		    pose(new Diff2(x, y, lx, ly));
		}
		else if (p.startsWith("count", 6)) {
		    IntVar[] x = getVarArray((SimpleNode)node.jjtGetChild(0));
		    int y = getInt((ASTScalarFlatExpr)node.jjtGetChild(1));
		    IntVar c = getVariable((ASTScalarFlatExpr)node.jjtGetChild(2));

		    pose(new Count(x, c, y));

		    // pose(new Among(x, new IntervalDomain(y,y), c));
		}
		else if (p.startsWith("nvalue", 6)) {
		    IntVar n = getVariable((ASTScalarFlatExpr)node.jjtGetChild(0));
		    IntVar[] x = getVarArray((SimpleNode)node.jjtGetChild(1));

		    pose(new Values(x, n));
		}
 		else if (p.startsWith("minimum_arg_int", 6)) {
		    IntVar[] x = getVarArray((SimpleNode)node.jjtGetChild(0));
		    IntVar index = getVariable((ASTScalarFlatExpr)node.jjtGetChild(1));

		    pose(new org.jacop.constraints.ArgMin(x, index));

		}
		else if (p.startsWith("minimum", 6)) {
		    IntVar n = getVariable((ASTScalarFlatExpr)node.jjtGetChild(0));
		    IntVar[] x = getVarArray((SimpleNode)node.jjtGetChild(1));

		    pose(new org.jacop.constraints.Min(x, n));
		}
 		else if (p.startsWith("maximum_arg_int", 6)) {
		    IntVar[] x = getVarArray((SimpleNode)node.jjtGetChild(0));
		    IntVar index = getVariable((ASTScalarFlatExpr)node.jjtGetChild(1));

		    pose(new org.jacop.constraints.ArgMax(x, index));

		}
		else if (p.startsWith("maximum", 6)) {
		    IntVar n = getVariable((ASTScalarFlatExpr)node.jjtGetChild(0));
		    IntVar[] x = getVarArray((SimpleNode)node.jjtGetChild(1));

		    pose(new org.jacop.constraints.Max(x, n));
		}
		else if (p.startsWith("table_int", 6) ||
			 p.startsWith("table_bool", 6)) { 
		    IntVar[] v = getVarArray((SimpleNode)node.jjtGetChild(0));
		    int size = v.length;

		    int[] tbl = getIntArray((SimpleNode)node.jjtGetChild(1));
		    int[][] t = new int[tbl.length/size][size];
		    for (int i=0; i<t.length; i++)
			for (int j=0; j<size; j++)
			    t[i][j] = tbl[size*i+j];

		    // we do not not pose ExtensionalSupportMDD directly because of possible inconsistency with its 
		    // intiallization; we collect all constraints and pose them at the end when all other constraints are posed

		    delayedConstraints.add(new ExtensionalSupportMDD(v, t));
 		    //pose(new ExtensionalSupportMDD(v, t));
		}
		else if (p.startsWith("assignment", 6)) {
		    IntVar[] f = getVarArray((SimpleNode)node.jjtGetChild(0));
		    IntVar[] invf = getVarArray((SimpleNode)node.jjtGetChild(1));
		    int index_f = getInt((ASTScalarFlatExpr)node.jjtGetChild(2));
		    int index_invf = getInt((ASTScalarFlatExpr)node.jjtGetChild(3));

		    // we do not not pose Assignment directly because of possible inconsistency with its 
		    // intiallization; we collect all constraints and pose them at the end when all other constraints are posed

		    if ( domainConsistency && !opt.getBoundConsistency())  // we add additional implied constraint if domain consistency is required
			parameterListForAlldistincts.add(f);

		    delayedConstraints.add(new Assignment(f, invf, index_f, index_invf));

// 		    pose(new Assignment(f, invf, index_f, index_invf));
		}
		else if (p.startsWith("regular", 6)) {

		    IntVar[] x = getVarArray((SimpleNode)node.jjtGetChild(0));
		    int Q = getInt((ASTScalarFlatExpr)node.jjtGetChild(1));
		    int S = getInt((ASTScalarFlatExpr)node.jjtGetChild(2));
		    int[] d = getIntArray((SimpleNode)node.jjtGetChild(3));
		    int q0 = getInt((ASTScalarFlatExpr)node.jjtGetChild(4));
		    IntDomain F = getSetLiteral(node, 5);
		    int minIndex = getInt((ASTScalarFlatExpr)node.jjtGetChild(6));

		    /* it seems that it is does not needed since mapping in Regular
		       is only used to queue variables and identify them; constant variables 
		       will never be queued

		    // regular must not have duplicated variables. In x vecor
		    // could be constants that have the same value and
		    // are duplicated.
		    IntVar[] xx = new IntVar[x.length];
		    HashSet<IntVar> varSet = new HashSet<IntVar>();
		    for (int i = 0; i < x.length; i++) {
			if (varSet.contains(x[i]) && x[i].singleton())
			    xx[i] = new IntVar(store, x[i].min(), x[i].max());
			else {
			    xx[i] = x[i];
			    varSet.add(xx[i]);
			}
		    }
		    //----
		    */

		    // Build DFA
		    FSM dfa = new FSM();
		    FSMState[] s = new FSMState[Q]; 
		    for (int i=0; i<s.length; i++) { 
			s[i] = new FSMState(); 
			dfa.allStates.add(s[i]); 
		    } 
		    dfa.initState = s[q0 - 1]; 
		    ValueEnumeration final_states = F.valueEnumeration(); //new SetValueEnumeration(F);
		    while (final_states.hasMoreElements())
			dfa.finalStates.add(s[final_states.nextElement()-1]); 

		    //  		    System.out.println("init state: "+ dfa.initState+", "+ F + "  final states: "+dfa.finalStates +",  first state: "+ s[0]);

		    for (int i=0; i<Q; i++) {
			//  			System.out.print(i+": ");
			for (int j=0; j<S; j++)
			    if (d[i*S+j] != 0) {
				s[i].transitions.add(new FSMTransition(new IntervalDomain(j+minIndex,j+minIndex), s[d[i*S+j]-minIndex])); 
				//   				System.out.print("("+(int)(j+minIndex)+") -> "+ (int)(d[i*S+j]-minIndex)+", ");
			    }
			//    			System.out.println();
		    }

		    pose(new Regular(dfa, x));

		    //  		    System.out.println(dfa+"\n");
		    //   		    System.out.println("Regular("+Arrays.asList(x)+", "+Q+", "+
		    //  				       S+", "+Arrays.asList(d)+", "+q0+", "+
		    //  				       dfa.finalStates+", "+minIndex+")");
		}
		else if (p.startsWith("knapsack", 6)) {
		    int[] weights = getIntArray((SimpleNode)node.jjtGetChild(0));
		    int[] profits = getIntArray((SimpleNode)node.jjtGetChild(1));
		    IntVar W = getVariable((ASTScalarFlatExpr)node.jjtGetChild(2));
		    IntVar P = getVariable((ASTScalarFlatExpr)node.jjtGetChild(3));
		    IntVar[] x = getVarArray((SimpleNode)node.jjtGetChild(4));

//   		    System.out.println("Knapsack("+
// 				       java.util.Arrays.toString(weights) +
// 				       ", "+ java.util.Arrays.toString(profits) +
// 				       ", "+ W +
// 				       ", "+ P +
// 				       ", " + java.util.Arrays.asList(x) +")");

 		    pose(new Knapsack(profits, weights, x, W, P));
		}
		else if (p.startsWith("sequence", 6)) { // implements jacop_sequence
		    IntVar[] x = getVarArray((SimpleNode)node.jjtGetChild(0));
		    IntDomain u = getSetLiteral(node, 1);
		    int q = getInt((ASTScalarFlatExpr)node.jjtGetChild(2));
		    int min = getInt((ASTScalarFlatExpr)node.jjtGetChild(3));
		    int max = getInt((ASTScalarFlatExpr)node.jjtGetChild(4));

		    IntervalDomain setImpl = new IntervalDomain();
		    for(int i = 0; true ;i++) {
		    	Interval val = u.getInterval(i);
		    	if (val != null)
		    		setImpl.unionAdapt(val);
		    	else
		    		break;
		    }

		    DecomposedConstraint c = new Sequence(x, setImpl, q, min, max);
// 		    System.out.println("sequence("+java.util.Arrays.asList(x)+", "+
// 				       u+", "+q+", "+", "+min+", "+max);
		    store.imposeDecomposition(c);
		}
 		else if (p.startsWith("stretch", 6)) {
		    int[] values = getIntArray((SimpleNode)node.jjtGetChild(0));
		    int[] min = getIntArray((SimpleNode)node.jjtGetChild(1));
		    int[] max = getIntArray((SimpleNode)node.jjtGetChild(2));
 		    IntVar[] x = getVarArray((SimpleNode)node.jjtGetChild(3));
//  		    System.out.println("Stretch("+java.util.Arrays.asList(values) +
// 				       ", " + java.util.Arrays.asList(min) +
// 				       ", " + java.util.Arrays.asList(max) +
// 				       ", "+ java.util.Arrays.asList(x)+")");   

		    DecomposedConstraint c = new Stretch(values, min, max, x);

		    store.imposeDecomposition(c);
 		}
 		else if (p.startsWith("disjoint", 6)) {

		    SetVar v1 = getSetVariable(node, 0);
		    SetVar v2 = getSetVariable(node, 1);

		    pose(new AdisjointB(v1, v2));
		}
	    // 		else if (p.startsWith("sequence", 6)) {
	    // 		    Variable[] x = getVarArray((SimpleNode)node.jjtGetChild(0));
	    // 		    Set u = getSetLiteral((SimpleNode)node, 1);
	    // 		    int q = getInt((ASTScalarFlatExpr)node.jjtGetChild(2));
	    // 		    int min = getInt((ASTScalarFlatExpr)node.jjtGetChild(3));
	    // 		    int max = getInt((ASTScalarFlatExpr)node.jjtGetChild(4));

	    //  		    DecomposedConstraint c = new Sequence(x, u, q, min, max);
	    // 		    System.out.println("sequence("+Arrays.asList(x)+", "+
	    // 				       u+", "+q+", "+", "+min+", "+max);
	    //   		    store.imposeDecomposition(c);
	    // 		}
 		else if (p.startsWith("network", 6)) {
		    int[] arc = getIntArray((SimpleNode)node.jjtGetChild(0));
		    IntVar[] flow = getVarArray((SimpleNode)node.jjtGetChild(1));
		    IntVar[] weight = getVarArray((SimpleNode)node.jjtGetChild(2));
		    int[] balance = getIntArray((SimpleNode)node.jjtGetChild(3));
		    IntVar cost = getVariable((ASTScalarFlatExpr)node.jjtGetChild(4));

  		    // System.out.println("NetworkFlow("+ arc +
 		    // 		       ", " + java.util.Arrays.asList(flow) +
 		    // 		       ", " + java.util.Arrays.asList(weight) +
 		    // 		       ", "+ balance +
		    // 		       ", "+ cost +")");   

		    NetworkBuilder net = new NetworkBuilder();

		    Node[] netNode = new Node[balance.length];
		    for (int i = 0; i < balance.length; i++) 
			netNode[i] = net.addNode("n_"+i, balance[i]);

		    for (int i = 0; i < flow.length; i++) {
			net.addArc(netNode[arc[2*i]-1], netNode[arc[2*i+1]-1], weight[i], flow[i]);
		    }

		    net.setCostVariable(cost);

 		    pose(new NetworkFlow(net));

		} 
		else if (p.startsWith("lex_less_int", 6) || p.startsWith("lex_less_bool", 6)) {
		    IntVar[] x = getVarArray((SimpleNode)node.jjtGetChild(0));
		    IntVar[] y = getVarArray((SimpleNode)node.jjtGetChild(1));

		    // System.out.println ("lex_less_int: x.length = " + x.length +  " y.length = " + y.length);
		    pose(new LexOrder(x, y, true));

		    // 	DecomposedConstraint c = new org.jacop.constraints.Lex(new IntVar[][] {x, y}, true);
		    // 	store.imposeDecomposition(c);

		}
		else if (p.startsWith("lex_lesseq_int", 6) || p.startsWith("lex_lesseq_bool", 6)) {
		    IntVar[] x = getVarArray((SimpleNode)node.jjtGetChild(0));
		    IntVar[] y = getVarArray((SimpleNode)node.jjtGetChild(1));

		    // System.out.println ("lex_lesseq_int: x.length = " + x.length +  " y.length = " + y.length);

		    pose(new LexOrder(x, y, false));

		    // 	DecomposedConstraint c = new org.jacop.constraints.Lex(new IntVar[][] {x, y});
		    // 	store.imposeDecomposition(c);
		    
		}
 		else if (p.startsWith("bin_packing", 6)) {
		    IntVar[] bin = getVarArray((SimpleNode)node.jjtGetChild(0));
		    IntVar[] capacity = getVarArray((SimpleNode)node.jjtGetChild(1));
		    int[] w = getIntArray((SimpleNode)node.jjtGetChild(2));

		    // ---- KK, 2015-10-18
		    // bin_packing must not have duplicated variables. on x vecor
		    // could be constants that have the same value and
		    // are duplicated.
		    IntVar[] binx = new IntVar[bin.length];
		    HashSet<IntVar> varSet = new HashSet<IntVar>();
		    for (int i = 0; i < bin.length; i++) {
			if (varSet.contains(bin[i]) && bin[i].singleton())
			    binx[i] = new IntVar(store, bin[i].min(), bin[i].max());
			else {
			    binx[i] = bin[i];
			    varSet.add(bin[i]);
			}
		    }
		    
   		    pose( new org.jacop.constraints.binpacking.Binpacking(binx, capacity, w) );
//   		    Constraint binPack = new org.jacop.constraints.binpacking.Binpacking(bin, capacity, w);
//   		    delayedConstraints.add(binPack);
		}
		else if (p.startsWith("float_maximum", 6)) {
		    FloatVar p2 = getFloatVariable((ASTScalarFlatExpr)node.jjtGetChild(1));
		    FloatVar[] p1 = getFloatVarArray((SimpleNode)node.jjtGetChild(0));

		    pose(new org.jacop.floats.constraints.Max(p1, p2));
		}
		else if (p.startsWith("float_minimum", 6)) {
		    FloatVar p2 = getFloatVariable((ASTScalarFlatExpr)node.jjtGetChild(1));
		    FloatVar[] p1 = getFloatVarArray((SimpleNode)node.jjtGetChild(0));

		    pose(new org.jacop.floats.constraints.Min(p1, p2));
		}
 		else if (p.startsWith("geost", 6)) {

		    int dim = getInt((ASTScalarFlatExpr)node.jjtGetChild(0));
		    int[] rect_size = getIntArray((SimpleNode)node.jjtGetChild(1));
		    int[] rect_offset = getIntArray((SimpleNode)node.jjtGetChild(2));
		    IntDomain[] shape =  getSetArray((SimpleNode)node.jjtGetChild(3));
		    IntVar[] x = getVarArray((SimpleNode)node.jjtGetChild(4));
		    IntVar[] kind = getVarArray((SimpleNode)node.jjtGetChild(5));

		    // System.out.println("dim = " + dim);
		    // System.out.print("rect_size = [");
		    // for (int i = 0; i < rect_size.length; i++) 
		    // 	System.out.print(" " + rect_size[i]);
		    // System.out.print("]\nrect_offset = [");
		    // for (int i = 0; i < rect_offset.length; i++) 
		    // 	System.out.print(" " + rect_offset[i]);
		    // System.out.println("]\nshape = " + java.util.Arrays.asList(shape));
		    // System.out.println("x = " + java.util.Arrays.asList(x));
		    // System.out.println("kind = " + java.util.Arrays.asList(kind));
		    // System.out.println("===================");


		    ArrayList<Shape> shapes = new ArrayList<Shape>(); 

		    // dummy shape to have right indexes for kind (starting from 1)
		    ArrayList<DBox> dummy = new ArrayList<DBox>();
		    int[] offsetDummy = new int[dim];
		    int[] sizeDummy = new int[dim];
		    for (int k = 0; k < dim; k++) {
			offsetDummy[k] = 0;
			sizeDummy[k] = 1;
		    }
		    dummy.add(new DBox(offsetDummy, sizeDummy));
		    shapes.add( new Shape(0, dummy));

		    // create all shapes (starting with id=1)
		    for (int i = 0; i < shape.length; i++) {
			ArrayList<DBox> shape_i = new ArrayList<DBox>();

			for (ValueEnumeration e = shape[i].valueEnumeration(); e.hasMoreElements();) {
			    int j = e.nextElement();

			    int[] offset = new int[dim];
			    int[] size = new int[dim];

			    for (int k = 0; k < dim; k++) {
				offset[k] = rect_offset[(j-1)*dim+k];
				size[k] = rect_size[(j-1)*dim+k];
			    }
			    shape_i.add(new DBox(offset, size));

			}
			shapes.add( new Shape((i+1), shape_i) );
		    }		    

		    // for (int i = 0; i < shapes.size(); i++) 
		    // 	System.out.println("*** " + shapes.get(i));

		    ArrayList<GeostObject> objects = new ArrayList<GeostObject>(); 

		    for (int i = 0; i < kind.length; i++) {

			IntVar[] coords = new IntVar[dim]; 

			for (int k = 0; k < dim; k++) 
			    coords[k] = x[i*dim+k];

			// System.out.println("coords = " + java.util.Arrays.asList(coords));

			IntVar start = new IntVar(store, "start["+i+"]", 0,0); 
			IntVar duration = new IntVar(store, "duration["+i+"]", 1,1); 
			IntVar end = new IntVar(store, "end["+i+"]", 1, 1); 
			GeostObject obj = new GeostObject(i, coords, kind[i], start, duration, end); 
			objects.add(obj);
		    }

		    // System.out.println("===========");
		    // for (int i = 0; i < objects.size(); i++) 
		    // 	System.out.println(objects.get(i));
		    // System.out.println("===========");

		    ArrayList<ExternalConstraint> constraints = new ArrayList<ExternalConstraint>(); 
		    int[] dimensions = new int[dim+1]; 
		    for (int i = 0; i < dim+1; i++) 
			dimensions[i] = i;

		    NonOverlapping constraint1 = new NonOverlapping(objects, dimensions); 
		    constraints.add(constraint1); 

		    if (p.startsWith("geost_bb", 6)) {

			int[] lb = getIntArray((SimpleNode)node.jjtGetChild(6));
			int[] ub = getIntArray((SimpleNode)node.jjtGetChild(7));

			// System.out.print("[");
			// for (int i = 0; i < lb.length; i++) 
			// 	System.out.print(" " + lb[i]);
			// System.out.print("]\n[");
			// for (int i = 0; i < ub.length; i++) 
			// 	System.out.print(" " + ub[i]);
			// System.out.println("]");

			InArea constraint2 = new InArea(new DBox(lb, ub), null); 
			constraints.add(constraint2);
		    }

   		    pose( new Geost(objects, constraints, shapes) );
		}
		else
		    System.err.println("%% ERROR: Constraint "+p+" not supported.");
	    // >>========== JaCoP constraints ==================
	    else
		System.err.println("%% ERROR: Constraint "+p+" not supported.");
	}
    }