{"hash": "7f7ece8f617d9c2e8860bf148868fd39f59b2532", "message": "remove fallback for batch status fetching\n\nWhen the bulk jobStatus method was first added to the API (back in\ncommit b1d345f), a fallback was added in case the bulk query failed to\nloop over the list of jobs and fetch the status of each individually.\n\nAssuming this fallback was added to handle having a newer CLI version\ntalking to a version of the master that didn't have this API yet, I\nthink it is safe to remove this logic at this point.", "file_num_lines": 134, "diff_parsed": {"added": [[104, "    final Map<JobId, JobStatus> jobStatuses = getJobStatuses(client, jobs, deployed);"], [106, "    final Set<JobId> sortedJobIds = Sets.newTreeSet(jobStatuses.keySet());"], [114, "          if (jobStatuses.containsKey(entry.getKey())) {"], [128, ""], [133, "          final JobStatus status = jobStatuses.get(jobId);"], [145, "  private Map<JobId, JobStatus> getJobStatuses("], [146, "      final HeliosClient client,"], [147, "      final Map<JobId, Job> jobs,"], [148, "      final boolean deployed)"], [149, "      throws InterruptedException, ExecutionException {"], [150, ""], [151, "    final Map<JobId, JobStatus> jobStatuses = client.jobStatuses(jobs.keySet()).get();"], [152, ""], [153, "    // maybe filter on deployed jobs"], [154, "    final Map<JobId, JobStatus> filteredJobStatuses = Maps.newHashMap();"], [155, "    if (!deployed) {"], [156, "      filteredJobStatuses.putAll(jobStatuses);"], [157, "    } else {"], [158, "      for (final Entry<JobId, JobStatus> e : jobStatuses.entrySet()) {"], [159, "        if (!e.getValue().getDeployments().isEmpty()) {"], [160, "          filteredJobStatuses.put(e.getKey(), e.getValue());"], [161, "        }"], [162, "      }"], [163, "    }"], [164, "    return filteredJobStatuses;"], [165, "  }"], [166, ""]], "deleted": [[33, "import com.google.common.util.concurrent.ListenableFuture;"], [105, "    final Map<JobId, ListenableFuture<JobStatus>> oldFutures ="], [106, "        JobStatusFetcher.getJobsStatuses(client, jobs.keySet());"], [108, "    final Map<JobId, ListenableFuture<JobStatus>> futures = Maps.newHashMap();"], [109, ""], [110, "    // maybe filter on deployed jobs"], [111, "    if (!deployed) {"], [112, "      futures.putAll(oldFutures);"], [113, "    } else {"], [114, "      for (final Entry<JobId, ListenableFuture<JobStatus>> e : oldFutures.entrySet()) {"], [115, "        if (!e.getValue().get().getDeployments().isEmpty()) {"], [116, "          futures.put(e.getKey(), e.getValue());"], [117, "        }"], [118, "      }"], [119, "    }"], [120, ""], [121, "    final Set<JobId> sortedJobIds = Sets.newTreeSet(futures.keySet());"], [129, "          if (futures.containsKey(entry.getKey())) {"], [143, ""], [148, "          final JobStatus status = futures.get(jobId).get();"]]}, "num_lines_added": 27, "num_lines_removed": 20}