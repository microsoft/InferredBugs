{"hash": "0d3c7456c886d509c4dec69dd064837d56fa8739", "message": "Attempt to fix up some test flakiness.\n\n- Greatly increase timeout on PollingWatchService tests. The timeout shouldn't matter unless something's terribly wrong, so it should be ok to make it long.\n- Try to ensure that asynchronous close tests for JimfsFileChannel are working as expected by being more careful in ensuring that all threads start blocking properly. Also switch to using Truth instead of assertTrue so that we'll get error messages that are actually helpful if the tests still fail.\n-------------\nCreated by MOE: http://code.google.com/p/moe-java\nMOE_MIGRATED_REVID=72748113", "file_num_lines": 669, "diff_parsed": {"added": [[23, "import static com.google.common.truth.Truth.assertThat;"], [38, "import com.google.common.util.concurrent.SettableFuture;"], [670, "  public void testAsynchronousClose() throws Exception {"], [678, "    CountDownLatch latch = new CountDownLatch(BLOCKING_OP_COUNT);"], [679, "    List<Future<?>> futures = queueAllBlockingOperations(channel, executor, latch);"], [681, "    // wait for all the threads to have started running"], [682, "    latch.await();"], [683, "    // then ensure time for operations to start blocking"], [684, "    Uninterruptibles.sleepUninterruptibly(20, MILLISECONDS);"], [686, "    // close channel on this thread"], [689, "    // the blocking operations are running on different threads, so they all get"], [690, "    // AsynchronousCloseException"], [696, "        assertThat(expected.getCause()).named(\"blocking thread exception\")"], [697, "            .isA(AsynchronousCloseException.class);"], [703, "  public void testCloseByInterrupt() throws Exception {"], [711, "    final CountDownLatch threadStartLatch = new CountDownLatch(1);"], [712, "    final SettableFuture<Throwable> interruptException = SettableFuture.create();"], [722, "        threadStartLatch.countDown();"], [725, "          interruptException.set(null);"], [733, "    // let the thread start running"], [734, "    threadStartLatch.await();"], [735, "    // then ensure time for thread to start blocking on the write lock"], [736, "    Uninterruptibles.sleepUninterruptibly(10, MILLISECONDS);"], [738, "    CountDownLatch blockingStartLatch = new CountDownLatch(BLOCKING_OP_COUNT);"], [739, "    List<Future<?>> futures = queueAllBlockingOperations(channel, executor, blockingStartLatch);"], [741, "    // wait for all blocking threads to start"], [742, "    blockingStartLatch.await();"], [743, "    // then ensure time for the operations to start blocking"], [744, "    Uninterruptibles.sleepUninterruptibly(20, MILLISECONDS);"], [751, "    // get the exception that caused the interrupted operation to terminate"], [752, "    assertThat(interruptException.get(200, MILLISECONDS))"], [753, "        .named(\"interrupted thread exception\")"], [754, "        .isA(ClosedByInterruptException.class);"], [756, "    // check that each other thread got AsynchronousCloseException (since the interrupt, on a"], [757, "    // different thread, closed the channel)"], [763, "        assertThat(expected.getCause()).named(\"blocking thread exception\")"], [764, "            .isA(AsynchronousCloseException.class);"], [769, "  private static final int BLOCKING_OP_COUNT = 10;"], [770, ""], [771, "  /**"], [772, "   * Queues blocking operations on the channel in separate threads using the given executor."], [773, "   * The given latch should have a count of BLOCKING_OP_COUNT to allow the caller wants to wait for"], [774, "   * all threads to start executing."], [775, "   */"], [777, "      final FileChannel channel, ExecutorService executor, final CountDownLatch startLatch) {"], [784, "        startLatch.countDown();"], [793, "        startLatch.countDown();"], [802, "        startLatch.countDown();"], [811, "        startLatch.countDown();"], [820, "        startLatch.countDown();"], [829, "        startLatch.countDown();"], [838, "        startLatch.countDown();"], [847, "        startLatch.countDown();"], [856, "        startLatch.countDown();"], [865, "        startLatch.countDown();"]], "deleted": [[668, "  public void testAsynchronousClose() throws IOException, InterruptedException {"], [676, "    List<Future<?>> futures = queueAllBlockingOperations(channel, executor);"], [678, "    // ensure time for operations to start blocking"], [679, "    Uninterruptibles.sleepUninterruptibly(10, MILLISECONDS);"], [688, "        assertTrue(expected.getCause() instanceof AsynchronousCloseException);"], [694, "  public void testCloseByInterrupt() throws IOException, InterruptedException {"], [702, "    final CountDownLatch latch = new CountDownLatch(1);"], [703, "    final AtomicReference<Throwable> interruptException = new AtomicReference<>();"], [715, "          latch.countDown();"], [718, "          latch.countDown();"], [724, "    // ensure time for thread to start blocking on the write lock"], [725, "    Uninterruptibles.sleepUninterruptibly(5, MILLISECONDS);"], [727, "    List<Future<?>> futures = queueAllBlockingOperations(channel, executor);"], [729, "    // ensure time for operations to start blocking"], [730, "    Uninterruptibles.sleepUninterruptibly(10, MILLISECONDS);"], [737, "    latch.await();"], [738, "    assertTrue(interruptException.get() instanceof ClosedByInterruptException);"], [745, "        assertTrue(expected.getCause() instanceof AsynchronousCloseException);"], [751, "      final FileChannel channel, ExecutorService executor) {"]]}, "num_lines_added": 55, "num_lines_removed": 19}