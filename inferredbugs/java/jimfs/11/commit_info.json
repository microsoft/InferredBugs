{"hash": "3992dc14d0e7964fad0100afc8452a286fb1a9e1", "message": "Fix flakiness in JimfsAsynchronousFileChannelTest.\n\nThe tests are racy, and I don't have a good way to fix that. This change just makes the (much) rarer case where the race ends with the channel being closed before the read/write operations get to the point where they check that the channel is open also pass the test. Unfortunately it doesn't differentiate between that case happening once in a thousand times and happening every time (which would be a problem).\n\nAlso simplify a bunch of stuff using SettableFuture.\n-------------\nCreated by MOE: https://github.com/google/moe\nMOE_MIGRATED_REVID=112606151", "file_num_lines": 169, "diff_parsed": {"added": [[21, "import static com.google.common.truth.Truth.assertThat;"], [25, "import static java.util.concurrent.TimeUnit.SECONDS;"], [34, "import com.google.common.util.concurrent.SettableFuture;"], [101, "  public void testClosedChannel() throws Throwable {"], [119, "  public void testAsyncClose_write() throws Throwable {"], [128, "      // future-returning write"], [131, "      // completion handler write"], [132, "      SettableFuture<Integer> completionHandlerFuture = SettableFuture.create();"], [133, "      channel.write(ByteBuffer.allocate(10), 0, null, setFuture(completionHandlerFuture));"], [134, ""], [135, "      // Despite this 10ms sleep to allow plenty of time, it's possible, though very rare, for a"], [136, "      // race to cause the channel to be closed before the asynchronous calls get to the initial"], [137, "      // check that the channel is open, causing ClosedChannelException to be thrown rather than"], [138, "      // AsynchronousCloseException. This is not a problem in practice, just a quirk of how these"], [139, "      // tests work and that we don't have a way of waiting for the operations to get past that"], [140, "      // check."], [145, "      assertAsynchronousClose(future);"], [146, "      assertAsynchronousClose(completionHandlerFuture);"], [153, "  public void testAsyncClose_read() throws Throwable {"], [162, "      // future-returning read"], [165, "      // completion handler read"], [166, "      SettableFuture<Integer> completionHandlerFuture = SettableFuture.create();"], [167, "      channel.read(ByteBuffer.allocate(10), 0, null, setFuture(completionHandlerFuture));"], [168, ""], [169, "      // Despite this 10ms sleep to allow plenty of time, it's possible, though very rare, for a"], [170, "      // race to cause the channel to be closed before the asynchronous calls get to the initial"], [171, "      // check that the channel is open, causing ClosedChannelException to be thrown rather than"], [172, "      // AsynchronousCloseException. This is not a problem in practice, just a quirk of how these"], [173, "      // tests work and that we don't have a way of waiting for the operations to get past that"], [174, "      // check."], [179, "      assertAsynchronousClose(future);"], [180, "      assertAsynchronousClose(completionHandlerFuture);"], [191, ""], [192, "    SettableFuture<Integer> future = SettableFuture.create();"], [193, "    channel.read(buf, 0, null, setFuture(future));"], [194, ""], [195, "    assertThat(future.get(10, SECONDS)).isEqualTo(10);"], [203, "    SettableFuture<Integer> future = SettableFuture.create();"], [204, "    asyncChannel.write(buf, 0, null, setFuture(future));"], [205, ""], [206, "    assertThat(future.get(10, SECONDS)).isEqualTo(10);"], [213, "    SettableFuture<FileLock> future = SettableFuture.create();"], [214, "    channel.lock(0, 10, true, null, setFuture(future));"], [215, ""], [216, "    assertNotNull(future.get(10, SECONDS));"], [217, "  }"], [218, ""], [219, "  /**"], [220, "   * Returns a {@code CompletionHandler} that sets the appropriate result or exception on the given"], [221, "   * {@code future} on completion."], [222, "   */"], [223, "  private static <T> CompletionHandler<T, Object> setFuture(final SettableFuture<T> future) {"], [224, "    return new CompletionHandler<T, Object>() {"], [225, "        @Override"], [226, "        public void completed(T result, Object attachment) {"], [227, "          future.set(result);"], [228, "        }"], [229, ""], [230, "        @Override"], [231, "        public void failed(Throwable exc, Object attachment) {"], [232, "          future.setException(exc);"], [233, "        }"], [234, "      };"], [235, "  }"], [236, ""], [237, "  /**"], [238, "   * Assert that the future fails, with the failure caused by {@code ClosedChannelException}."], [239, "   */"], [240, "  private static void assertClosed(Future<?> future) throws Throwable {"], [241, "    try {"], [242, "      future.get(10, SECONDS);"], [243, "      fail(\"ChannelClosedException was not thrown\");"], [244, "    } catch (ExecutionException expected) {"], [245, "      assertThat(expected.getCause()).isInstanceOf(ClosedChannelException.class);"], [249, "  /**"], [250, "   * Assert that the future fails, with the failure caused by either"], [251, "   * {@code AsynchronousCloseException} or (rarely) {@code ClosedChannelException}."], [252, "   */"], [253, "  private static void assertAsynchronousClose(Future<?> future) throws Throwable {"], [255, "      future.get(10, SECONDS);"], [256, "      fail(\"no exception was thrown\");"], [258, "      Throwable t = expected.getCause();"], [259, "      if (!(t instanceof AsynchronousCloseException || t instanceof ClosedChannelException)) {"], [260, "        fail(\"expected AsynchronousCloseException (or in rare cases ClosedChannelException): \""], [261, "            + \"got \" + t);"], [262, "      }"]], "deleted": [[28, "import static org.junit.Assert.assertTrue;"], [47, "import java.util.concurrent.CountDownLatch;"], [52, "import java.util.concurrent.atomic.AtomicBoolean;"], [53, "import java.util.concurrent.atomic.AtomicInteger;"], [54, "import java.util.concurrent.atomic.AtomicReference;"], [103, "  public void testClosedChannel() throws IOException, InterruptedException {"], [121, "  public void testAsyncClose_write() throws IOException, InterruptedException {"], [132, "      final CountDownLatch handlerLatch = new CountDownLatch(1);"], [133, "      final AtomicBoolean gotAsyncCloseException = new AtomicBoolean(false);"], [134, "      channel.write("], [135, "          ByteBuffer.allocate(10), 0, null,"], [136, "          new CompletionHandler<Integer, Object>() {"], [137, "            @Override"], [138, "            public void completed(Integer result, Object attachment) {"], [139, "              handlerLatch.countDown();"], [140, "            }"], [141, ""], [142, "            @Override"], [143, "            public void failed(Throwable exc, Object attachment) {"], [144, "              gotAsyncCloseException.set(exc instanceof AsynchronousCloseException);"], [145, "              handlerLatch.countDown();"], [146, "            }"], [147, "          });"], [148, ""], [149, "      // give enough time to ensure both writes start blocking"], [154, "      try {"], [155, "        future.get();"], [156, "        fail();"], [157, "      } catch (ExecutionException expected) {"], [158, "        assertTrue(expected.getCause() instanceof AsynchronousCloseException);"], [159, "      }"], [160, ""], [161, "      handlerLatch.await();"], [162, ""], [163, "      assertTrue(gotAsyncCloseException.get());"], [170, "  public void testAsyncClose_read() throws IOException, InterruptedException {"], [181, "      final CountDownLatch handlerLatch = new CountDownLatch(1);"], [182, "      final AtomicBoolean gotAsyncCloseException = new AtomicBoolean(false);"], [183, "      channel.read("], [184, "          ByteBuffer.allocate(10), 0, null,"], [185, "          new CompletionHandler<Integer, Object>() {"], [186, "            @Override"], [187, "            public void completed(Integer result, Object attachment) {"], [188, "              handlerLatch.countDown();"], [189, "            }"], [190, ""], [191, "            @Override"], [192, "            public void failed(Throwable exc, Object attachment) {"], [193, "              gotAsyncCloseException.set(exc instanceof AsynchronousCloseException);"], [194, "              handlerLatch.countDown();"], [195, "            }"], [196, "          });"], [197, ""], [198, "      // give enough time to ensure both reads start blocking"], [203, "      try {"], [204, "        future.get();"], [205, "        fail();"], [206, "      } catch (ExecutionException expected) {"], [207, "        assertTrue(expected.getCause() instanceof AsynchronousCloseException);"], [208, "      }"], [209, ""], [210, "      handlerLatch.await();"], [211, ""], [212, "      assertTrue(gotAsyncCloseException.get());"], [223, "    final AtomicInteger resultHolder = new AtomicInteger(-1);"], [224, "    final AtomicReference<Throwable> exceptionHolder = new AtomicReference<>();"], [225, "    final CountDownLatch completionLatch = new CountDownLatch(1);"], [226, "    channel.read("], [227, "        buf, 0, null,"], [228, "        new CompletionHandler<Integer, Object>() {"], [229, "          @Override"], [230, "          public void completed(Integer result, Object attachment) {"], [231, "            resultHolder.set(result);"], [232, "            completionLatch.countDown();"], [233, "          }"], [234, ""], [235, "          @Override"], [236, "          public void failed(Throwable exc, Object attachment) {"], [237, "            exceptionHolder.set(exc);"], [238, "            completionLatch.countDown();"], [239, "          }"], [240, "        });"], [241, ""], [242, "    completionLatch.await();"], [243, "    Throwable exception = exceptionHolder.get();"], [244, "    if (exception != null) {"], [245, "      throw exception;"], [246, "    } else {"], [247, "      assertEquals(10, resultHolder.get());"], [248, "    }"], [256, "    final AtomicInteger resultHolder = new AtomicInteger(-1);"], [257, "    final AtomicReference<Throwable> exceptionHolder = new AtomicReference<>();"], [258, "    final CountDownLatch completionLatch = new CountDownLatch(1);"], [259, "    asyncChannel.write("], [260, "        buf, 0, null,"], [261, "        new CompletionHandler<Integer, Object>() {"], [262, "          @Override"], [263, "          public void completed(Integer result, Object attachment) {"], [264, "            resultHolder.set(result);"], [265, "            completionLatch.countDown();"], [266, "          }"], [267, ""], [268, "          @Override"], [269, "          public void failed(Throwable exc, Object attachment) {"], [270, "            exceptionHolder.set(exc);"], [271, "            completionLatch.countDown();"], [272, "          }"], [273, "        });"], [274, ""], [275, "    completionLatch.await();"], [276, "    Throwable exception = exceptionHolder.get();"], [277, "    if (exception != null) {"], [278, "      throw exception;"], [279, "    } else {"], [280, "      assertEquals(10, resultHolder.get());"], [281, "    }"], [288, "    final AtomicReference<FileLock> lockHolder = new AtomicReference<>();"], [289, "    final AtomicReference<Throwable> exceptionHolder = new AtomicReference<>();"], [290, "    final CountDownLatch completionLatch = new CountDownLatch(1);"], [291, "    channel.lock("], [292, "        0, 10, true, null,"], [293, "        new CompletionHandler<FileLock, Object>() {"], [294, "          @Override"], [295, "          public void completed(FileLock result, Object attachment) {"], [296, "            lockHolder.set(result);"], [297, "            completionLatch.countDown();"], [298, "          }"], [299, ""], [300, "          @Override"], [301, "          public void failed(Throwable exc, Object attachment) {"], [302, "            exceptionHolder.set(exc);"], [303, "            completionLatch.countDown();"], [304, "          }"], [305, "        });"], [306, ""], [307, "    completionLatch.await();"], [308, "    Throwable exception = exceptionHolder.get();"], [309, "    if (exception != null) {"], [310, "      throw exception;"], [311, "    } else {"], [312, "      assertNotNull(lockHolder.get());"], [316, "  private static void assertClosed(Future<?> future) throws InterruptedException {"], [318, "      future.get();"], [319, "      fail();"], [321, "      assertTrue(expected.getCause() instanceof ClosedChannelException);"]]}, "num_lines_added": 86, "num_lines_removed": 145}