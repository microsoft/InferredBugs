{"hash": "47abd1e71511a4abac62c6557242d36dc5bd548a", "message": "Pure iterative DFS implemented. Old DFS renamed to RLDepthFirstSeaarch.", "file_num_lines": 87, "diff_parsed": {"added": [[2, " * Copyright 2013 CITIUS <http://citius.usc.es>, University of Santiago de Compostela."], [4, " *    Licensed under the Apache License, Version 2.0 (the \"License\");"], [5, " *    you may not use this file except in compliance with the License."], [6, " *    You may obtain a copy of the License at"], [8, " *        http://www.apache.org/licenses/LICENSE-2.0"], [10, " *    Unless required by applicable law or agreed to in writing, software"], [11, " *    distributed under the License is distributed on an \"AS IS\" BASIS,"], [12, " *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied."], [13, " *    See the License for the specific language governing permissions and"], [14, " *    limitations under the License."], [19, ""], [32, " * Iterative implementation of the Depth First Search (DFS) algorithm"], [33, " * (left to right) using a {@link Stack}. DFS algorithm does not guarantee"], [34, " * to obtain the best solution."], [38, " * @param <S> state type."], [43, "    // Mark states visited to avoid cycles"], [50, "     * Creates a new iterative depth first search algorithm."], [51, "     *"], [52, "     * @param initialState state used as root of the exploration."], [53, "     * @param successors function to generate the successors of a state."], [54, "     * @param factory component to generate node instances from states."], [67, "     * {@link es.usc.citius.lab.hipster.node.impl.SimpleNode} is used in this case."], [68, "     *"], [87, "        if (next == null){"], [88, "            // Compute next"], [89, "            next = nextUnvisited();"], [90, "            if (next == null) return false;"], [92, "        return true;"], [95, "    public Node<S> next(){"], [96, "        if (next != null){"], [97, "            Node<S> e = next;"], [98, "            next = nextUnvisited();"], [99, "            return e;"], [100, "        } else {"], [101, "            return nextUnvisited();"], [106, "     * Compute the next unvisited node. If there are no"], [107, "     * unvisited nodes, return null."], [108, "     *"], [109, "     * @return next unvisited node or null."], [111, "    private Node<S> nextUnvisited(){"], [112, "        Node<S> next;"], [113, "        // Perform backtrack (skipping all visited nodes in the stack)"], [114, "        do {"], [115, "            next = processNext();"], [116, "        } while(next!=null && visited.containsKey(next.transition().to()));"], [117, ""], [118, "        if (next != null){"], [119, "            // Mark as visited"], [120, "            visited.put(next.transition().to(), next);"], [122, ""], [123, "        return next;"], [126, "    /**"], [127, "     * Calculate the next node (if the stack is not empty) and expand next"], [128, "     * unvisited successors."], [129, "     *"], [130, "     * @return next processed node (can be a visited node) or null."], [131, "     */"], [132, "    private Node<S> processNext() {"], [133, "        // Take the next (unvisited) node from the stack but don't remove it"], [134, "        if (stack.isEmpty()) return null;"], [135, "        Node<S> current = stack.peek();"], [138, "        // Mark as visited"], [139, "        //visited.put(currentState, current);"], [141, "        Node<S> toStack = null;"], [142, "        boolean completed = true;"], [148, "                // Select the neighbor to stack"], [149, "                if (toStack==null){"], [150, "                    toStack = successorNode;"], [151, "                } else {"], [152, "                    // This neighbor is unexplored, thus the current"], [153, "                    // node is still not fully processed and"], [154, "                    // will be eventually expanded again to retrieve the"], [155, "                    // next successors."], [156, "                    completed = false;"], [157, "                    break;"], [158, "                }"], [161, "        // If this node is processed (no more successors) remove from stack"], [162, "        if (completed) stack.pop();"], [163, "        // Push the new successor to expand next."], [164, "        if (toStack != null) stack.push(toStack);"]], "deleted": [[2, " * Copyright 2013 Centro de Investigaci\u00f3n en Tecnolox\u00edas da Informaci\u00f3n (CITIUS)."], [4, " * Licensed under the Apache License, Version 2.0 (the \"License\");"], [5, " * you may not use this file except in compliance with the License."], [6, " * You may obtain a copy of the License at"], [8, " *      http://www.apache.org/licenses/LICENSE-2.0"], [10, " * Unless required by applicable law or agreed to in writing, software"], [11, " * distributed under the License is distributed on an \"AS IS\" BASIS,"], [12, " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied."], [13, " * See the License for the specific language governing permissions and"], [14, " * limitations under the License."], [31, " * Implementation of the Depth-First-Search (DFS) algorithm using"], [32, " * a {@link Stack} as the underlying data structure."], [34, " * @param <S> class defining the state"], [35, " *"], [48, "     * Constructor for DFS using a custom node factory."], [49, "     *"], [50, "     * @param initialState state used as root of the exploration"], [51, "     * @param successors function to generate the successors of a state"], [52, "     * @param factory component to generate node instances from states"], [65, "     * {@link SimpleNode} is used in this case."], [66, "     *"], [81, "        next = initialNode;"], [84, "    /**"], [85, "     * Returns true if there are unvisited nodes in the graph."], [86, "     */"], [89, "        // If there is a valid next, return true"], [90, "        if (this.next != null){"], [91, "            return true;"], [92, "        } else {"], [93, "            // If next is not calculated, compute the next valid"], [94, "            Node<S> next = popNextUnvisitedNode();"], [95, "            this.next = next;"], [96, "            return next != null;"], [100, "    /**"], [101, "     * Returns the next unvisited node of the graph."], [102, "     *"], [103, "     * @return next node to visit"], [104, "     */"], [105, "    private Node<S> popNextUnvisitedNode(){"], [106, "        if (!stack.isEmpty()){"], [107, "            Node<S> next = stack.pop();"], [108, "            // Pop nodes if visited"], [109, "            while(visited.containsKey(next.transition().to())){"], [110, "                if (!stack.isEmpty()){"], [111, "                    next = stack.pop();"], [112, "                } else {"], [113, "                    return null;"], [114, "                }"], [115, "            }"], [116, "            return next;"], [118, "        return null;"], [122, "     * Returns the current unvisited node of the graph."], [123, "     *"], [124, "     * @return current node"], [126, "    private Node<S> popUnvisited(){"], [127, "        if (this.next != null){"], [128, "            Node<S> next = this.next;"], [129, "            // Put next to null to indicate that"], [130, "            // this node was consumed. Next call"], [131, "            // to hasNext has to compute the next"], [132, "            // node beforehand to check if there is"], [133, "            // another one valid."], [134, "            this.next = null;"], [135, "            return next;"], [136, "        } else {"], [137, "            this.next = popNextUnvisitedNode();"], [138, "            return this.next;"], [142, "    public Node<S> next() {"], [143, "        // Take the next node from the stack."], [144, "        Node<S> current = popUnvisited();"], [153, "                this.stack.push(successorNode);"], [156, "        this.visited.put(currentState, current);"], [160, "    /**"], [161, "     * Unsupported operation."], [162, "     */"]]}, "num_lines_added": 80, "num_lines_removed": 75}