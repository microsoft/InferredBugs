{"hash": "5ebae02ea2dbf7b15103f75c9e26c27ae15f0484", "message": "TextRank: fixed tests.", "file_num_lines": 799, "diff_parsed": {"added": [[70, "            //+ \"OPTIONAL MATCH (to)-[:COMPOUND|AMOD]-(to2:TagOccurrence)-[:TAG_OCCURRENCE_TAG]->(t2:Tag)\\n\" // new"], [73, "            + \"collect(t2.value) as rel_tags, collect(to2.startPosition) as rel_tos,  collect(to2.endPosition) as rel_toe, labels(node) as labels\\n\""], [83, "    private final boolean expandNEs;"], [91, "    private final List<String> forbiddenNEs;"], [101, "            boolean cleanSingleWordKeyword,"], [108, "            List<String> admittedPOSs,"], [109, "            List<String> forbiddenNEs) {"], [117, "        this.expandNEs = false; // TO DO"], [125, "        this.forbiddenNEs = forbiddenNEs;"], [225, "            List<String> pos1 = next.get(\"pos1\") != null ? Arrays.asList((String[]) next.get(\"pos1\")) : new ArrayList<>();"], [226, "            List<String> pos2 = next.get(\"pos2\") != null ? Arrays.asList((String[]) next.get(\"pos2\")) : new ArrayList<>();"], [237, "            // for logging purposses and for `expandNamedEntities()`"], [242, "        Map<Long, List<Pair<Long, Long>>> neExp;"], [243, "        if (expandNEs) {"], [244, "            // process named entities: split them into individual tokens by calling ga.nlp.annotate(), assign them IDs and create co-occurrences"], [245, "            neExp = expandNamedEntities();"], [246, "            neExpanded = neExp.entrySet().stream()"], [247, "                            .collect(Collectors.toMap( Map.Entry::getKey, e -> e.getValue().stream().map(p -> p.second()).collect(Collectors.toList()) ));"], [248, "        } else"], [249, "            neExp = new HashMap<>();"], [259, "            if (expandNEs) {"], [260, "                if (neExp.containsKey(tag1)) {"], [261, "                    if (neVisited == 0L || neVisited != tag1.longValue()) {"], [262, "                        connectTagsInNE(results, neExp.get(tag1), tag1Start);"], [263, "                        neVisited = 0L;"], [264, "                    }"], [265, "                    tag1Start += neExp.get(tag1).get( neExp.get(tag1).size() - 1 ).first().intValue();"], [266, "                    tag1 = neExp.get(tag1).get( neExp.get(tag1).size() - 1 ).second();"], [269, "                if (neExp.containsKey(tag2)) {"], [270, "                    connectTagsInNE(results, neExp.get(tag2), tag2Start);"], [271, "                    neVisited = tag2;"], [272, "                    tag2 = neExp.get(tag2).get(0).second();"], [273, "                } else"], [274, "                    neVisited = 0L;"], [275, "            }"], [345, "                if (idToValue.get(valueL).trim().split(\" \").length < 2)"], [347, "                String str = idToValue.get(valueL).trim().toLowerCase();"], [363, "                        List<Long> lId = idToValue.entrySet().stream().filter(en -> en.getValue().equals(val) || en.getValue().equalsIgnoreCase(val)).map(Map.Entry::getKey).collect(Collectors.toList());"], [364, "                        List<Long> lIdNew = newIdsToVal.entrySet().stream().filter(en -> en.getValue().equals(val) || en.getValue().equalsIgnoreCase(val)).map(Map.Entry::getKey).collect(Collectors.toList());"], [407, "        List<Long> wrongNEs = new ArrayList<>();"], [413, ""], [414, "                // remove stopwords"], [415, "                if (removeStopWords && stopWords.contains(((String) next.get(\"tag\")).split(\"_\")[0]))"], [416, "                    continue;"], [417, "                // remove stop-NEs"], [418, "                if (iterableToList((Iterable<String>) next.get(\"labels\")).stream().anyMatch(el -> forbiddenNEs.contains(el))) {"], [419, "                    wrongNEs.add(tagId);"], [420, "                    continue;"], [421, "                }"], [422, ""], [434, "                } else { // new"], [435, "                    keywordMap.get(tagId).update(item); // new"], [437, "                //System.out.println(\" Adding for \" + item.getValue() + \": \" + item.getRelatedTags());"], [455, "            List<Long> relTagIDs = getRelTagsIntoDepth(keywordOccurrence.get(), keywordsOccurrences); // TO DO: revisit this"], [456, "            relTagIDs.retainAll(topThird); // keep only those that are among top 1/3"], [469, "                        if (nextKeyword != null && nextKeyword.getValue().equalsIgnoreCase(item.getKey())) {"], [470, "                            String newCurrValue = currValue.get().trim().split(\"_\")[0] + \" \" + item.getKey();"], [488, "        if (expandNEs) {"], [489, "            // add named entities that contain at least some of the top 1/3 of words"], [490, "            for (Long key: neExpanded.keySet()) {"], [491, "                if (neExpanded.get(key).stream().filter(v -> topThird.contains(v)).count() == 0)"], [492, "                    continue;"], [493, "                if (wrongNEs.contains(key))"], [494, "                    continue;"], [495, "                String keystr = idToValue.get(key).toLowerCase() + \"_en\"; // + lang; // TO DO"], [496, "                addToResults(keystr, pageRanks.containsKey(key) ? pageRanks.get(key) : 0, results, 1);"], [497, "            }"], [529, "            List<String> merged = new ArrayList<>(keywords.get(ccEntry).getRelatedTags()); // new"], [531, "            //System.out.println(\"    co-occurring tag = \" + idToValue.get(ccEntry) + \", related tags = \" + keywords.get(ccEntry).getRelatedTags().stream().collect(Collectors.joining(\", \")));"], [579, "    private List<Long> getRelTagsIntoDepth(KeywordExtractedItem kwOccurrence, List<KeywordExtractedItem> kwOccurrences) {"], [580, "        Map<String, Long> valToId = idToValue.entrySet().stream().collect(Collectors.toMap(Map.Entry::getValue, Map.Entry::getKey));"], [581, "        List<String> relTags = kwOccurrence.getRelatedTags();"], [582, "        kwOccurrences.stream()"], [583, "            .filter(el -> relTags.contains(el.getValue().split(\"_\")[0]))"], [584, "            .forEach(el -> {"], [585, "                relTags.addAll(el.getRelatedTags());"], [586, "                //System.out.println(\"  ADDING (\" + el.getValue() + \"): \" + el.getRelatedTags() + \", size = \" + el.getRelatedTags().size());"], [587, "            });"], [588, "        return relTags.stream().map(el -> valToId.get(el)).collect(Collectors.toList());"], [589, "    }"], [590, ""], [742, "    private Map<String, Keyword> cleanSingleWordKeyword(Map<String, Keyword> results) {"], [749, "                        //&& entry.getValue().getMeanRelevance() < innerEntry.getValue().getMeanRelevance() // new"], [752, "                    //if ( !( Math.abs(entry.getValue().getRelevance() - innerEntry.getValue().getRelevance()) < (0.10 * innerEntry.getValue().getWordsCount()) * entry.getValue().getRelevance() ) )//|| entry.getValue().getWordsCount() == 1 )"], [753, "                    //    newResults.remove(entry.getKey());"], [754, "                    /*if ( Math.abs(entry.getValue().getRelevance() - innerEntry.getValue().getRelevance()) < (0.05 * innerEntry.getValue().getWordsCount()) * entry.getValue().getRelevance() )"], [755, "                        newResults.remove(innerEntry.getKey());"], [756, "                    if (entry.getValue().getWordsCount() == 1)"], [757, "                        newResults.remove(entry.getKey());*/"], [766, "        private static final String[] STOP_WORDS = {\"new\", \"old\", \"large\", \"big\", \"vast\", \"small\", \"many\", \"few\", \"good\", \"better\", \"best\", \"bad\", \"worse\", \"worst\"};"], [768, "        private static final String[] FORBIDDEN_NES = {\"NER_Date\", \"NER_Number\", \"NER_Duration\", \"NER_Ordinal\"};"], [794, "        private List<String> forbiddenNEs = Arrays.asList(FORBIDDEN_NES);"], [816, "                    admittedPOSs,"], [817, "                    forbiddenNEs);"], [871, "        public Builder setForbiddenNEs(List<String> forbiddenNEs) {"], [872, "            this.forbiddenNEs = forbiddenNEs;"], [873, "            return this;"], [874, "        }"], [875, ""], [972, ""], [973, "        public void update(KeywordExtractedItem item) {"], [974, "            this.relatedTags.addAll(item.getRelatedTags());"], [975, "            this.relTagStartingPoints.addAll(item.getRelTagStartingPoints());"], [976, "            this.relTagEndingPoints.addAll(item.getRelTagEndingPoints());"], [977, "        }"]], "deleted": [[72, "            + \"collect(t2.value) as rel_tags, collect(to2.startPosition) as rel_tos,  collect(to2.endPosition) as rel_toe\\n\""], [98, "            boolean cleanSingleWordKeyword,"], [105, "            List<String> admittedPOSs) {"], [219, "            List<String> pos1 = Arrays.asList((String[]) next.get(\"pos1\"));"], [220, "            List<String> pos2 = Arrays.asList((String[]) next.get(\"pos2\"));"], [231, "            // for logging purposses and for `handleNamedEntities()`"], [236, "        Map<Long, List<Pair<Long, Long>>> neExp = expandNamedEntities();"], [237, "        neExpanded = neExp.entrySet().stream()"], [238, "                        .collect(Collectors.toMap( Map.Entry::getKey, e -> e.getValue().stream().map(p -> p.second()).collect(Collectors.toList()) ));"], [248, "            if (neExp.containsKey(tag1)) {"], [249, "                if (neVisited == 0L || neVisited != tag1.longValue()) {"], [250, "                    connectTagsInNE(results, neExp.get(tag1), tag1Start);"], [251, "                    neVisited = 0L;"], [253, "                tag1Start += neExp.get(tag1).get( neExp.get(tag1).size() - 1 ).first().intValue();"], [254, "                tag1 = neExp.get(tag1).get( neExp.get(tag1).size() - 1 ).second();"], [255, "            }"], [257, "            if (neExp.containsKey(tag2)) {"], [258, "                connectTagsInNE(results, neExp.get(tag2), tag2Start);"], [259, "                neVisited = tag2;"], [260, "                tag2 = neExp.get(tag2).get(0).second();"], [261, "            } else"], [262, "                neVisited = 0L;"], [323, "        parameters.put(\"textProcessor\", \"com.graphaware.nlp.processor.stanford.StanfordTextProcessor\");"], [333, "                if (idToValue.get(valueL).split(\" \").length < 2)"], [335, "                String str = idToValue.get(valueL).toLowerCase();"], [351, "                        List<Long> lId = idToValue.entrySet().stream().filter(en -> en.getValue().equals(val) || en.getValue().toLowerCase().equals(val)).map(Map.Entry::getKey).collect(Collectors.toList());"], [352, "                        List<Long> lIdNew = newIdsToVal.entrySet().stream().filter(en -> en.getValue().equals(val) || en.getValue().toLowerCase().equals(val)).map(Map.Entry::getKey).collect(Collectors.toList());"], [422, "        Map<String, Long> valToId = idToValue.entrySet().stream().collect(Collectors.toMap(Map.Entry::getValue, Map.Entry::getKey));"], [423, ""], [431, "            List<Long> relTagIDs = keywordOccurrence.get().getRelatedTags().stream().map(el -> valToId.get(el)).collect(Collectors.toList()); // new"], [432, "            relTagIDs.retainAll(topThird); // new"], [445, "                        if (nextKeyword != null && nextKeyword.value.equalsIgnoreCase(item.getKey())) {"], [446, "                            String newCurrValue = currValue.get().split(\"_\")[0] + \" \" + item.getKey();"], [464, "        // add named entities that contain at least some of the top 1/3 of words"], [465, "        for (Long key: neExpanded.keySet()) {"], [466, "            if (neExpanded.get(key).stream().filter(v -> topThird.contains(v)).count() == 0)"], [467, "                continue;"], [468, "            String keystr = idToValue.get(key) + \"_en\"; // + lang;"], [469, "            addToResults(keystr, pageRanks.containsKey(key) ? pageRanks.get(key) : 0, results, 1);"], [501, "            List<String> merged = new ArrayList<>(keywords.get(tagId).getRelatedTags()); // new"], [503, "            //System.out.println(\"    related tag = \" + idToValue.get(ccEntry) + \", related tags = \" + keywords.get(tagId).getRelatedTags().stream().collect(Collectors.joining(\", \")));"], [702, "    private Map<String, Keyword>  cleanSingleWordKeyword(Map<String, Keyword> results) {"], [719, "        private static final String[] STOP_WORDS = {\"new\", \"old\", \"large\", \"big\", \"vast\", \"small\", \"many\", \"few\", \"best\", \"worst\"};"], [747, "        ;"], [768, "                    admittedPOSs);"]]}, "num_lines_added": 105, "num_lines_removed": 45}