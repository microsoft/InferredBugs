{"hash": "78c9076dd96865bc1bf3c93cfe30289b6314278d", "message": "Add streaming 2i operations/results", "file_num_lines": 552, "diff_parsed": {"added": [[19, "import com.basho.riak.client.core.StreamingFutureOperation;"], [24, "import com.basho.riak.protobuf.RiakMessageCodes;"], [30, "import java.util.Collection;"], [32, "import java.util.concurrent.BlockingQueue;"], [33, "import java.util.concurrent.LinkedBlockingQueue;"], [42, "        extends StreamingFutureOperation<SecondaryIndexQueryOperation.Response,"], [43, "        Object, SecondaryIndexQueryOperation.Query>"], [47, "    private final BlockingQueue<Response> responseQueue;"], [48, ""], [52, "        // Decide if we should release results as they come in (stream), or gather them all until the operation is"], [53, "        // done (not stream)."], [54, "        super(builder.streamResults);"], [55, ""], [60, "        this.responseQueue = new LinkedBlockingQueue<>();"], [69, "        final boolean isIndexBodyResp = rawResponse != null &&"], [70, "                                        !rawResponse.isEmpty() &&"], [71, "                                        objectIsIndexBodyResp(rawResponse.get(0));"], [72, ""], [75, "            convertSingleResponse(responseBuilder, isIndexBodyResp, o);"], [76, "        }"], [78, "        return responseBuilder.build();"], [79, "    }"], [81, "    private boolean objectIsIndexBodyResp(Object o)"], [82, "    {"], [83, "        return o instanceof RiakKvPB.RpbIndexBodyResp;"], [84, "    }"], [86, "    private void convertSingleResponse(Response.Builder responseBuilder, boolean isIndexBodyResp, Object o)"], [87, "    {"], [88, "        if (isIndexBodyResp)"], [89, "        {"], [90, "            convertIndexBodyResp(responseBuilder, o);"], [91, "        }"], [92, "        else"], [93, "        {"], [94, "            convertIndexResp(responseBuilder, o);"], [95, "        }"], [96, "    }"], [98, "    private void convertIndexBodyResp(Response.Builder responseBuilder, Object o)"], [99, "    {"], [100, "        assert pbReq.getReturnBody();"], [101, "        final RiakKvPB.RpbIndexBodyResp bodyResp = (RiakKvPB.RpbIndexBodyResp)o;"], [102, "        convertBodies(responseBuilder, bodyResp);"], [104, "        if (bodyResp.hasContinuation())"], [105, "        {"], [106, "            responseBuilder.withContinuation("], [107, "                    BinaryValue.unsafeCreate(bodyResp.getContinuation().toByteArray()));"], [108, "        }"], [109, "    }"], [110, ""], [111, ""], [112, "    private void convertIndexResp(Response.Builder responseBuilder, Object o)"], [113, "    {"], [114, "        final RiakKvPB.RpbIndexResp pbEntry = (RiakKvPB.RpbIndexResp) o;"], [115, ""], [116, "        /**"], [117, "         * The 2i API is inconsistent on the Riak side. If it's not"], [118, "         * a range query, return_terms is ignored it only returns the"], [119, "         * list of object keys and you have to have"], [120, "         * preserved the index key if you want to return it to the user"], [121, "         * with the results."], [122, "         *"], [123, "         * Also, the $key index queries just ignore return_terms altogether."], [124, "         */"], [125, ""], [126, "        if (pbReq.getReturnTerms() && !query.indexName.toString().equalsIgnoreCase(IndexNames.KEY))"], [127, "        {"], [128, "            convertTerms(responseBuilder, pbEntry);"], [129, "        }"], [130, "        else"], [131, "        {"], [132, "            convertKeys(responseBuilder, pbEntry);"], [133, "        }"], [134, ""], [135, "        if (pbEntry.hasContinuation())"], [136, "        {"], [137, "            responseBuilder.withContinuation("], [138, "                    BinaryValue.unsafeCreate(pbEntry.getContinuation().toByteArray()));"], [234, "    @Override"], [235, "    protected void processStreamingChunk(Object rawResponseChunk)"], [236, "    {"], [237, "        SecondaryIndexQueryOperation.Response.Builder responseBuilder ="], [238, "                new SecondaryIndexQueryOperation.Response.Builder();"], [239, ""], [240, "        final boolean bodyResp = objectIsIndexBodyResp(rawResponseChunk);"], [241, ""], [242, "        convertSingleResponse(responseBuilder, bodyResp, rawResponseChunk);"], [243, ""], [244, "        final Response response = responseBuilder.build();"], [245, ""], [246, "        if (response.hasContinuation())"], [247, "        {"], [248, "            // Return the continuation in the normal fashion as well"], [249, "            final RiakKvPB.RpbIndexResp continuationOnlyResponse ="], [250, "                    RiakKvPB.RpbIndexResp.newBuilder().setContinuation("], [251, "                    ByteString.copyFrom(response.getContinuation().unsafeGetValue()))"], [252, "                                         .build();"], [253, ""], [254, "            processBatchMessage(continuationOnlyResponse);"], [255, "        }"], [256, ""], [257, "        this.responseQueue.add(response);"], [258, "    }"], [259, ""], [260, "    @Override"], [261, "    public BlockingQueue<Response> getResultsQueue()"], [262, "    {"], [263, "        return this.responseQueue;"], [264, "    }"], [265, ""], [273, "        private boolean streamResults = false;"], [359, "         * Set the streamResults flag."], [360, "         * <p>"], [361, "         * If unset or false, the entire result set will be available through the {@link ListKeysOperation#get()}"], [362, "         * method once the operation is complete."], [363, "         * <p>"], [364, "         * If set to true, results will be pushed to the queue available through the"], [365, "         * {@link ListKeysOperation#getResultsQueue()}"], [366, "         * method as soon as they are available."], [367, "         *"], [368, "         * @param streamResults whether to stream results to {@link ListKeysOperation#get()}(false), or"], [369, "         *                      {@link ListKeysOperation#getResultsQueue()}(true)"], [370, "         * @return A reference to this object."], [371, "         */"], [372, "        public Builder streamResults(boolean streamResults)"], [373, "        {"], [374, "            this.streamResults = streamResults;"], [375, "            return this;"], [376, "        }"], [377, ""], [378, "        /**"], [832, "            Builder addAllEntries(Collection<? extends Entry> entries)"], [833, "            {"], [834, "                entryList.addAll(entries);"], [835, "                return this;"], [836, "            }"], [837, ""]], "deleted": [[18, "import com.basho.riak.client.core.FutureOperation;"], [23, "import com.basho.riak.protobuf.RiakMessageCodes;"], [28, "import org.slf4j.Logger;"], [29, "import org.slf4j.LoggerFactory;"], [41, "        extends FutureOperation<SecondaryIndexQueryOperation.Response, Object, SecondaryIndexQueryOperation.Query>"], [43, "    private final static Logger logger = LoggerFactory.getLogger(SecondaryIndexQueryOperation.class);"], [63, "            if (o instanceof RiakKvPB.RpbIndexBodyResp)"], [64, "            {"], [65, "                assert pbReq.getReturnBody();"], [66, "                final RiakKvPB.RpbIndexBodyResp bodyResp = (RiakKvPB.RpbIndexBodyResp)o;"], [67, "                convertBodies(responseBuilder, bodyResp);"], [69, "                if (bodyResp.hasContinuation())"], [70, "                {"], [71, "                    responseBuilder.withContinuation("], [72, "                            BinaryValue.unsafeCreate(bodyResp.getContinuation().toByteArray()));"], [73, "                }"], [74, "                continue;"], [75, "            }"], [77, "            final RiakKvPB.RpbIndexResp pbEntry = (RiakKvPB.RpbIndexResp) o;"], [79, "            /**"], [80, "             * The 2i API is inconsistent on the Riak side. If it's not"], [81, "             * a range query, return_terms is ignored it only returns the"], [82, "             * list of object keys and you have to have"], [83, "             * preserved the index key if you want to return it to the user"], [84, "             * with the results."], [85, "             *"], [86, "             * Also, the $key index queries just ignore return_terms altogether."], [87, "             */"], [89, "            if (pbReq.getReturnTerms() && !query.indexName.toString().equalsIgnoreCase(IndexNames.KEY))"], [90, "            {"], [91, "                convertTerms(responseBuilder, pbEntry);"], [92, "            }"], [93, "            else"], [94, "            {"], [95, "                convertKeys(responseBuilder, pbEntry);"], [96, "            }"], [98, "            if (pbEntry.hasContinuation())"], [99, "            {"], [100, "                responseBuilder.withContinuation("], [101, "                        BinaryValue.unsafeCreate(pbEntry.getContinuation().toByteArray()));"], [102, "            }"], [104, "        return responseBuilder.build();"]]}, "num_lines_added": 136, "num_lines_removed": 42}