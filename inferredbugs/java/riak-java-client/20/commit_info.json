{"hash": "4262c6edefed2a2b046dda5d810238da895b0e2b", "message": "PB client connection pool optimization\n\nThis is a small optimization to the old underlying Riak PB client's\nconnection pool. The semaphore permits were used for connection\ncreation rather than access to the pool itself.\n\nIn an edge case where the pool was at max number of connections and\nall connections were checked out, a thread would wait for a permit,\ntime out (because the pool was at max) then throw an exception. If a\nconnection had been returned to the pool in the meantime it would\ngo unnoticed.\n\nThis is not really a big issue as the current IRiakClient implementations\nat the top of the client stack would simply retry the operation. The only\nreal impact is that any FIFO guarantees would then be lost affecting the\npredictability of which thread (if any) would not get a connection and the\ntime spent trying to do so.\n\nThis change makes the semaphore permit responsible fo access to the pool\nitself; it now represents how many connections are checked out. Barring\nan issue in creating a new connection once you have a permit you will\nreceive a connection. When a connection is released by the client a permit\nis also released.", "file_num_lines": 264, "diff_parsed": {"added": [[300, ""], [301, "        for (int i = 0; i < this.initialSize; i++) {"], [302, "            RiakConnection c = getConnection();"], [303, "            c.beginIdle();"], [304, "            available.add(c);"], [306, ""], [377, "        RiakConnection c = null;"], [378, "        for (int i = 0; c == null && i < CONNECTION_ACQUIRE_ATTEMPTS; i++) {"], [379, "            try {"], [380, "                if (permits.tryAcquire(connectionWaitTimeoutNanos, TimeUnit.NANOSECONDS)) {"], [381, "                    c = available.poll();"], [382, "                    if (c == null) {"], [383, "                        boolean releasePermit = true;"], [384, "                        try {"], [385, "                            c = new RiakConnection(host, port, bufferSizeKb, this, TimeUnit.MILLISECONDS.convert(connectionWaitTimeoutNanos, TimeUnit.NANOSECONDS), requestTimeoutMillis);"], [386, "                            releasePermit = false;"], [387, "                        } catch (SocketTimeoutException e) {"], [388, "                            throw new AcquireConnectionTimeoutException(\"timeout from socket connection \" + e.getMessage(), e);"], [389, "                        } catch (IOException e) {"], [390, "                            throw e;"], [391, "                        } finally {"], [392, "                            if (releasePermit) {"], [393, "                                permits.release();"], [394, "                            }"], [395, "                        }"], [397, "                } else {"], [398, "                    throw new AcquireConnectionTimeoutException(\"timeout acquiring connection permit from pool\");"], [400, "            } catch (InterruptedException e) {"], [401, "                Thread.currentThread().interrupt();"], [404, ""], [405, "        if (c == null) {"], [406, "            throw new IOException(\"repeatedly interrupted whilst waiting to acquire connection\");"], [407, "        } else {"], [408, "            inUse.offer(c);"], [409, "            return c;"], [410, "        }"], [434, "            // don't put a closed connection in the pool"], [438, "            }"], [439, "            permits.release();"]], "deleted": [[300, "        if (permits.tryAcquire(initialSize)) {"], [301, "            for (int i = 0; i < this.initialSize; i++) {"], [302, "                RiakConnection c ="], [303, "                    new RiakConnection(this.host, this.port,"], [304, "                                       this.bufferSizeKb, this,"], [305, "                                       TimeUnit.MILLISECONDS.convert(connectionWaitTimeoutNanos, TimeUnit.NANOSECONDS),"], [306, "                                       requestTimeoutMillis);"], [307, "                c.beginIdle();"], [308, "                available.add(c);"], [309, "            }"], [310, "        } else {"], [311, "            throw new RuntimeException(\"Unable to create initial connections\");"], [383, "        RiakConnection c = available.poll();"], [384, ""], [385, "        if (c == null) {"], [386, "           c = createConnection(CONNECTION_ACQUIRE_ATTEMPTS);"], [387, "        }"], [388, ""], [389, "        inUse.offer(c);"], [390, "        return c;"], [391, "    }"], [392, ""], [393, "    /**"], [394, "     * @param attempts"], [395, "     * @return"], [396, "     */"], [397, "    private RiakConnection createConnection(int attempts) throws IOException {"], [398, "        try {"], [399, "            if (permits.tryAcquire(connectionWaitTimeoutNanos, TimeUnit.NANOSECONDS)) {"], [400, "                boolean releasePermit = true;"], [401, "                try {"], [402, "                    RiakConnection connection = new RiakConnection(host, port, bufferSizeKb, this, TimeUnit.MILLISECONDS.convert(connectionWaitTimeoutNanos, TimeUnit.NANOSECONDS), requestTimeoutMillis);"], [403, "                    releasePermit = false;"], [404, "                    return connection;"], [405, "                } catch (SocketTimeoutException e) {"], [406, "                    throw new AcquireConnectionTimeoutException(\"timeout from socket connection \" + e.getMessage(), e);"], [407, "                } catch (IOException e) {"], [408, "                    throw e;"], [409, "                } finally {"], [410, "                    if (releasePermit) {"], [411, "                        permits.release();"], [414, "            } else {"], [415, "                throw new AcquireConnectionTimeoutException(\"timeout acquiring connection permit from pool\");"], [416, "            }"], [417, "        } catch (InterruptedException e) {"], [418, "            Thread.currentThread().interrupt();"], [419, ""], [420, "            if (attempts > 0) {"], [421, "                return createConnection(attempts - 1);"], [422, "            } else {"], [423, "                throw new IOException(\"repeatedly interrupted whilst waiting to acquire connection\");"], [452, "            } else {"], [453, "                // don't put a closed connection in the pool, release a permit"], [454, "                permits.release();"], [455, "            }"]]}, "num_lines_added": 39, "num_lines_removed": 55}