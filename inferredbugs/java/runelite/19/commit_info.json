{"hash": "61f6191228bd0c196cababd3250fa28224dff91a", "message": "invoker injection.", "file_num_lines": 374, "diff_parsed": {"added": [[20, "import net.runelite.deob.attributes.code.instructions.BiPush;"], [21, "import net.runelite.deob.attributes.code.instructions.DLoad;"], [22, "import net.runelite.deob.attributes.code.instructions.FLoad;"], [25, "import net.runelite.deob.attributes.code.instructions.ILoad;"], [27, "import net.runelite.deob.attributes.code.instructions.InvokeVirtual;"], [30, "import net.runelite.deob.attributes.code.instructions.LLoad;"], [33, "import net.runelite.deob.attributes.code.instructions.SiPush;"], [46, "\tprivate static final Type OBFUSCATED_SIGNATURE = new Type(\"Lnet/runelite/mapping/ObfuscatedSignature;\");"], [104, "\t\t\tif (an == null)"], [105, "\t\t\t\tcontinue;"], [106, ""], [161, ""], [162, "\t\t\t\t// XXX static methods can be in any class not just 'other' so the below finding won't work."], [163, "\t\t\t\t// XXX static methods can also be totally inlined by the obfuscator and thus removed by the dead code remover,"], [164, "\t\t\t\t// so exporting them maybe wouldn't work anyway?"], [165, "\t\t\t\tassert !m.isStatic();"], [170, "\t\t\t\tMethod otherm;"], [171, ""], [172, "\t\t\t\tAnnotation obfuscatedSignature = an.find(OBFUSCATED_SIGNATURE);"], [173, ""], [174, "\t\t\t\tString garbage = null;"], [175, "\t\t\t\tif (obfuscatedSignature != null)"], [176, "\t\t\t\t{"], [177, "\t\t\t\t\tString signatureString = obfuscatedSignature.getElements().get(0).getString();"], [178, "\t\t\t\t\tgarbage = obfuscatedSignature.getElements().get(1).getString();"], [179, ""], [180, "\t\t\t\t\tSignature signature = new Signature(signatureString); // parse signature"], [181, ""], [182, "\t\t\t\t\t// The obfuscated signature annotation is generated post rename unique, so class"], [183, "\t\t\t\t\t// names in the signature match our class names and not theirs, so we toObSignature() it"], [184, "\t\t\t\t\totherm = other.findMethod(new NameAndType(obfuscatedName, toObSignature(signature)));"], [185, "\t\t\t\t}"], [186, "\t\t\t\telse"], [187, "\t\t\t\t{"], [188, "\t\t\t\t\t// No obfuscated signature annotation, so the annotation wasn't changed during deobfuscation."], [189, "\t\t\t\t\t// We should be able to just find it normally."], [190, "\t\t\t\t\totherm = other.findMethod(new NameAndType(obfuscatedName, toObSignature(m.getDescriptor())));"], [191, "\t\t\t\t}"], [192, ""], [194, ""], [195, "\t\t\t\tjava.lang.reflect.Method apiMethod = findImportMethodOnApi(implementingClass, exportedName); // api method to invoke 'otherm'"], [196, "\t\t\t\tif (apiMethod == null)"], [197, "\t\t\t\t{"], [198, "\t\t\t\t\tSystem.out.println(\"no api method\");"], [199, "\t\t\t\t\tcontinue;"], [200, "\t\t\t\t}"], [201, ""], [202, "\t\t\t\tinjectInvoker(other, apiMethod, m, otherm, garbage);"], [331, ""], [332, "\tprivate void injectInvoker(ClassFile clazz, java.lang.reflect.Method method, Method deobfuscatedMethod, Method invokeMethod, String garbage)"], [333, "\t{"], [334, "\t\t// clazz = clazz to add invoker to"], [335, "\t\t// method = api method to override"], [336, "\t\t// deobfuscatedMethod = deobfuscated method, used to get the deobfuscated signature"], [337, "\t\t// invokeMethod = method to invoke, obfuscated"], [338, ""], [339, "\t\tassert clazz.findMethod(method.getName()) == null;"], [340, "\t\tassert !invokeMethod.isStatic();"], [341, "\t\tassert invokeMethod.getMethods().getClassFile() == clazz;"], [342, ""], [343, "\t\tType lastGarbageArgumentType = null;"], [344, ""], [345, "\t\tif (!deobfuscatedMethod.getDescriptor().equals(invokeMethod.getDescriptor()))"], [346, "\t\t{"], [347, "\t\t\t// allow for obfuscated method to have a single bogus signature at the end"], [348, "\t\t\tassert deobfuscatedMethod.getDescriptor().size() + 1 == invokeMethod.getDescriptor().size();"], [349, ""], [350, "\t\t\tList<Type> arguments = invokeMethod.getDescriptor().getArguments();"], [351, "\t\t\tlastGarbageArgumentType = arguments.get(arguments.size() - 1);"], [352, "\t\t}"], [353, ""], [354, "\t\tMethod invokerMethodSignature = new Method(clazz.getMethods(), method.getName(), deobfuscatedMethod.getDescriptor());"], [355, "\t\tinvokerMethodSignature.setAccessFlags(Method.ACC_PUBLIC);"], [356, ""], [357, "\t\tAttributes methodAttributes = invokerMethodSignature.getAttributes();"], [358, ""], [359, "\t\t// create code attribute"], [360, "\t\tCode code = new Code(methodAttributes);"], [361, "\t\tmethodAttributes.addAttribute(code);"], [362, ""], [363, "\t\tInstructions instructions = code.getInstructions();"], [364, "\t\tList<Instruction> ins = instructions.getInstructions();"], [365, ""], [366, "\t\tcode.setMaxStack(1 + invokeMethod.getDescriptor().size()); // this + arguments"], [367, ""], [368, "\t\t// load function arguments onto the stack."], [369, ""], [370, "\t\tint index = 0;"], [371, "\t\tins.add(new ALoad(instructions, index++)); // this"], [372, ""], [373, "\t\tfor (int i = 0; i < deobfuscatedMethod.getDescriptor().size(); ++i)"], [374, "\t\t{"], [375, "\t\t\tType type = deobfuscatedMethod.getDescriptor().getTypeOfArg(i);"], [376, ""], [377, "\t\t\tif (type.getArrayDims() > 0 || !type.isPrimitive())"], [378, "\t\t\t{"], [379, "\t\t\t\tins.add(new ALoad(instructions, index++));"], [380, "\t\t\t}"], [381, "\t\t\telse"], [382, "\t\t\t{"], [383, "\t\t\t\tswitch (type.getType())"], [384, "\t\t\t\t{"], [385, "\t\t\t\t\tcase \"B\":"], [386, "\t\t\t\t\tcase \"C\":"], [387, "\t\t\t\t\tcase \"I\":"], [388, "\t\t\t\t\tcase \"S\":"], [389, "\t\t\t\t\tcase \"Z\":"], [390, "\t\t\t\t\t\tins.add(new ILoad(instructions, index++));"], [391, "\t\t\t\t\t\tbreak;"], [392, "\t\t\t\t\tcase \"D\":"], [393, "\t\t\t\t\t\tins.add(new DLoad(instructions, index++));"], [394, "\t\t\t\t\t\t++index; // takes two slots"], [395, "\t\t\t\t\t\tbreak;"], [396, "\t\t\t\t\tcase \"F\":"], [397, "\t\t\t\t\t\tins.add(new FLoad(instructions, index++));"], [398, "\t\t\t\t\t\tbreak;"], [399, "\t\t\t\t\tcase \"J\":"], [400, "\t\t\t\t\t\tins.add(new LLoad(instructions, index++));"], [401, "\t\t\t\t\t\t++index;"], [402, "\t\t\t\t\t\tbreak;"], [403, "\t\t\t\t\tdefault:"], [404, "\t\t\t\t\t\tthrow new RuntimeException(\"Unknown type\");"], [405, "\t\t\t\t}"], [406, "\t\t\t}"], [407, "\t\t}"], [408, ""], [409, "\t\tif (lastGarbageArgumentType != null)"], [410, "\t\t{"], [411, "\t\t\t// function requires garbage value"], [412, ""], [413, "\t\t\tswitch (lastGarbageArgumentType.getType())"], [414, "\t\t\t{"], [415, "\t\t\t\tcase \"Z\":"], [416, "\t\t\t\tcase \"B\":"], [417, "\t\t\t\tcase \"C\":"], [418, "\t\t\t\t\tins.add(new BiPush(instructions, Byte.parseByte(garbage)));"], [419, "\t\t\t\t\tbreak;"], [420, "\t\t\t\tcase \"S\":"], [421, "\t\t\t\t\tins.add(new SiPush(instructions, Short.parseShort(garbage)));"], [422, "\t\t\t\t\tbreak;"], [423, "\t\t\t\tcase \"I\":"], [424, "\t\t\t\t\tins.add(new LDC_W(instructions, Integer.parseInt(garbage)));"], [425, "\t\t\t\t\tbreak;"], [426, "\t\t\t\tcase \"D\":"], [427, "\t\t\t\t\tins.add(new LDC2_W(instructions, Double.parseDouble(garbage)));"], [428, "\t\t\t\t\tbreak;"], [429, "\t\t\t\tcase \"F\":"], [430, "\t\t\t\t\tins.add(new LDC_W(instructions, Float.parseFloat(garbage)));"], [431, "\t\t\t\t\tbreak;"], [432, "\t\t\t\tcase \"J\":"], [433, "\t\t\t\t\tins.add(new LDC2_W(instructions, Long.parseLong(garbage)));"], [434, "\t\t\t\t\tbreak;"], [435, "\t\t\t\tdefault:"], [436, "\t\t\t\t\tthrow new RuntimeException(\"Unknown type\");"], [437, "\t\t\t}"], [438, "\t\t}"], [439, ""], [440, "\t\tins.add(new InvokeVirtual(instructions, invokeMethod.getPoolMethod()));"], [441, ""], [442, "\t\tType returnValue = invokeMethod.getDescriptor().getReturnValue();"], [443, "\t\tInstructionType returnType;"], [444, ""], [445, "\t\tif (returnValue.isPrimitive() && returnValue.getArrayDims() == 0)"], [446, "\t\t{"], [447, "\t\t\tswitch (returnValue.getType())"], [448, "\t\t\t{"], [449, "\t\t\t\tcase \"Z\":"], [450, "\t\t\t\tcase \"I\":"], [451, "\t\t\t\t\treturnType = InstructionType.IRETURN;"], [452, "\t\t\t\t\tbreak;"], [453, "\t\t\t\tcase \"J\":"], [454, "\t\t\t\t\treturnType = InstructionType.LRETURN;"], [455, "\t\t\t\t\tbreak;"], [456, "\t\t\t\tcase \"F\":"], [457, "\t\t\t\t\treturnType = InstructionType.FRETURN;"], [458, "\t\t\t\t\tbreak;"], [459, "\t\t\t\tcase \"D\":"], [460, "\t\t\t\t\treturnType = InstructionType.DRETURN;"], [461, "\t\t\t\t\tbreak;"], [462, "\t\t\t\tcase \"V\":"], [463, "\t\t\t\t\treturnType = InstructionType.RETURN;"], [464, "\t\t\t\t\tbreak;"], [465, "\t\t\t\tdefault:"], [466, "\t\t\t\t\tassert false;"], [467, "\t\t\t\t\treturn;"], [468, "\t\t\t}"], [469, "\t\t}"], [470, "\t\telse"], [471, "\t\t{"], [472, "\t\t\treturnType = InstructionType.ARETURN;"], [473, "\t\t}"], [474, ""], [475, "\t\tins.add(new Return(instructions, returnType));"], [476, ""], [477, "\t\tclazz.getMethods().addMethod(invokerMethodSignature);"], [478, "\t}"]], "deleted": [[127, "\t\t\t\tif (otherf == null)"], [128, "\t\t\t\t\totherf = other.findField(new NameAndType(obfuscatedName, obType));"], [133, "\t\t\t\t//"], [134, ""], [158, "\t\t\t\t// XXX static methods don't have to be in the same class, so we should have @ObfuscatedClass or something"], [159, ""], [160, "\t\t\t\tMethod otherm = other.findMethod(new NameAndType(obfuscatedName, toObSignature(m.getDescriptor())));"]]}, "num_lines_added": 196, "num_lines_removed": 7}