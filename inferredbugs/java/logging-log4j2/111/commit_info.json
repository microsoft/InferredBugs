{"hash": "69ddae41d605d98893e00364db7c517fcfdc6853", "message": "LOG4J2-1297 latency test improvements", "file_num_lines": 104, "diff_parsed": {"added": [[25, "import org.apache.logging.log4j.Level;"], [29, "import org.apache.logging.log4j.core.async.DefaultAsyncEventRouter;"], [30, "import org.apache.logging.log4j.core.async.EventRoute;"], [62, "// -DAsyncLogger.WaitStrategy=busywait"], [63, "//-XX:+UnlockDiagnosticVMOptions -verbose:gc -XX:+PrintGCDetails -XX:+PrintGCDateStamps -XX:+PrintTenuringDistribution -XX:+PrintGCApplicationConcurrentTime -XX:+PrintGCApplicationStoppedTime"], [68, "        if (args.length < 2) {"], [69, "            System.out.println(\"Please specify thread count and interval (us)\");"], [70, "            return;"], [71, "        }"], [72, "//        double targetLoadLevel = Double.parseDouble(args[0]);"], [73, "        final int threadCount = Integer.parseInt(args[0]);"], [74, "        final int intervalMicros = Integer.parseInt(args[1]);"], [75, ""], [76, "        System.setProperty(\"log4j2.AsyncEventRouter\", PrintingDefaultAsyncEventRouter.class.getName());"], [77, "        System.setProperty(\"AsyncLogger.RingBufferSize\", String.valueOf(256 * 1024));"], [86, "        System.out.println(\"nanoTimeCost=\" + nanoTimeCost);"], [87, ""], [88, "//        long maxOpsPerSec = 1000 * 1000; // just assume... TODO make parameter"], [89, "//"], [90, "//        long oneOpDurationNanos = TimeUnit.SECONDS.toNanos(1) / maxOpsPerSec;"], [91, "//        long idleTimeNanos = (long) ((1.0 - targetLoadLevel) * oneOpDurationNanos);"], [92, "//        idleTimeNanos *= 10;"], [93, "//        System.out.printf(\"Idle time is %d nanos at %,f load level%n\", idleTimeNanos, targetLoadLevel);"], [94, ""], [95, "        final long interval = TimeUnit.MICROSECONDS.toNanos(intervalMicros);// * threadCount;"], [96, "        System.out.printf(\"%d threads, interval is %d nanos%n\", threadCount, interval);"], [97, ""], [98, "        final long WARMUP_DURATION_MILLIS = TimeUnit.MINUTES.toMillis(1);"], [99, "        List<Histogram> warmupHistograms = new ArrayList<>(threadCount);"], [100, ""], [101, "        final int WARMUP_COUNT = 50000 / threadCount;"], [102, "        final IdleStrategy idleStrategy = new YieldIdleStrategy();"], [103, "        runLatencyTest(logger, WARMUP_DURATION_MILLIS, WARMUP_COUNT, interval, idleStrategy, warmupHistograms, nanoTimeCost, threadCount);"], [104, "        Thread.sleep(1000);"], [107, "        List<Histogram> histograms = new ArrayList<>(threadCount);"], [108, ""], [109, "        final long TEST_DURATION_MILLIS = TimeUnit.MINUTES.toMillis(4);"], [110, "        final int COUNT = 5000000 / threadCount;"], [111, "        runLatencyTest(logger, TEST_DURATION_MILLIS, COUNT, interval, idleStrategy, histograms, nanoTimeCost, threadCount);"], [115, "        for (Histogram hist : histograms) {"], [116, "            result.add(hist);"], [122, "    public static void runLatencyTest(final Logger logger, final long durationMillis, final int samples,"], [123, "            final long intervalNanos,"], [142, "                    long start = System.currentTimeMillis();"], [143, "                    do {"], [144, "                        runLatencyTest(samples, logger, nanoTimeCost, hist, intervalNanos, idleStrategy);"], [145, "                    } while (System.currentTimeMillis() - start < durationMillis);"], [154, ""], [155, "    private static void runLatencyTest(int samples, Logger logger, long nanoTimeCost, Histogram hist, long intervalNanos, IdleStrategy idleStrategy) {"], [156, "        for (int i = 0; i < samples; i++) {"], [157, "            final long s1 = System.nanoTime();"], [158, "            logger.info(LATENCY_MSG);"], [159, "            final long s2 = System.nanoTime();"], [160, "            final long value = s2 - s1 - nanoTimeCost;"], [161, "            if (value > 0) {"], [162, "                hist.recordValueWithExpectedInterval(value, intervalNanos);"], [163, "            }"], [164, "            while (System.nanoTime() - s2 < intervalNanos) {"], [165, "                idleStrategy.idle();"], [166, "            }"], [167, "        }"], [168, "    }"], [169, ""], [170, "    public static class PrintingDefaultAsyncEventRouter extends DefaultAsyncEventRouter {"], [171, "        @Override"], [172, "        public EventRoute getRoute(long backgroundThreadId, Level level) {"], [173, "            System.out.println(\"RINGBUFFER FULL!\");"], [174, "            return super.getRoute(backgroundThreadId, level);"], [175, "        }"], [176, "    }"], [177, ""]], "deleted": [[71, "        System.out.println(nanoTimeCost);"], [72, ""], [73, "        long maxOpsPerSec = 1000 * 1000; // just assume... TODO make parameter"], [74, "        double targetLoadLevel = 0.05; // TODO make parameter"], [75, ""], [76, "        long oneOpDurationNanos = TimeUnit.SECONDS.toNanos(1) / maxOpsPerSec;"], [77, "        long idleTimeNanos = (long) ((1.0 - targetLoadLevel) * oneOpDurationNanos);"], [78, "        System.out.printf(\"Idle time is %d nanos at %,f load level%n\", idleTimeNanos, targetLoadLevel);"], [79, ""], [80, "        final int WARMUP_ITERATIONS = 5;"], [81, "        final int threadCount = 8;"], [82, "        List<List<Histogram>> warmups = new ArrayList<>();"], [83, "        for (int i = 0; i < WARMUP_ITERATIONS; i++) {"], [84, "            List<Histogram> warmupHistograms = new ArrayList<>(threadCount);"], [85, ""], [86, "            final int WARMUP_COUNT = 500000;"], [87, "            final long interval = idleTimeNanos;"], [88, "            final IdleStrategy idleStrategy = new NoOpIdleStrategy();"], [89, "            runLatencyTest(logger, WARMUP_COUNT, interval, idleStrategy, warmupHistograms, nanoTimeCost, threadCount);"], [90, "            warmups.add(warmupHistograms);"], [91, "        }"], [94, "        final int MEASURED_ITERATIONS = 5;"], [95, "        List<List<Histogram>> tests = new ArrayList<>();"], [96, "        for (int i = 0; i < MEASURED_ITERATIONS; i++) {"], [97, "            List<Histogram> histograms = new ArrayList<>(threadCount);"], [98, ""], [99, "            final int COUNT = 5000000;"], [100, "            final long interval = idleTimeNanos;"], [101, "            final IdleStrategy idleStrategy = new NoOpIdleStrategy();"], [102, "            runLatencyTest(logger, COUNT, interval, idleStrategy, histograms, nanoTimeCost, threadCount);"], [103, "            tests.add(histograms);"], [104, "        }"], [108, "        for (List<Histogram> done : tests) {"], [109, "            for (Histogram hist : done) {"], [110, "                result.add(hist);"], [111, "            }"], [117, "    public static void runLatencyTest(final Logger logger, final int samples, final long intervalNanos,"], [136, "                    for (int i = 0; i < samples; i++) {"], [137, "                        final long s1 = System.nanoTime();"], [138, "                        logger.info(LATENCY_MSG);"], [139, "                        final long s2 = System.nanoTime();"], [140, "                        final long value = s2 - s1 - nanoTimeCost;"], [141, "                        if (value > 0) {"], [142, "                            hist.recordValueWithExpectedInterval(value, intervalNanos);"], [143, "                        }"], [144, "                        while (System.nanoTime() - s2 < intervalNanos) {"], [145, "                            idleStrategy.idle();"], [146, "                        }"], [147, "                    }"]]}, "num_lines_added": 71, "num_lines_removed": 49}