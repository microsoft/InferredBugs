{"hash": "b687abcb9aa2cc283a4977ad538d8a41f2041f7f", "message": "LOG4J2-196, LOG4J2-198 - Use Flume RPCClient - upgrade to Flume 1.3.1\n\ngit-svn-id: https://svn.apache.org/repos/asf/logging/log4j/log4j2/trunk@1468306 13f79535-47bb-0310-9956-ffa450edef68", "file_num_lines": 169, "diff_parsed": {"added": [[19, "import org.apache.flume.Event;"], [20, "import org.apache.flume.api.RpcClient;"], [21, "import org.apache.flume.api.RpcClientFactory;"], [25, "import java.util.Properties;"], [32, "    private static final int MAX_RECONNECTS = 3;"], [40, "    private final int retries;"], [41, ""], [42, "    private final int connectTimeout;"], [43, ""], [44, "    private final int requestTimeout;"], [48, "    private RpcClient rpcClient = null;"], [55, "     * @param retries The number of times to retry connecting before giving up."], [56, "     * @param connectTimeout The connection timeout in ms."], [57, "     * @param requestTimeout The request timeout in ms."], [58, "     *"], [60, "    protected FlumeAvroManager(final String name, final String shortName, final Agent[] agents, final int batchSize,"], [61, "                               final int retries, final int connectTimeout, final int requestTimeout) {"], [65, "        this.retries = retries;"], [66, "        this.connectTimeout = connectTimeout;"], [67, "        this.requestTimeout = requestTimeout;"], [68, "        this.rpcClient = connect(agents, retries, connectTimeout, requestTimeout);"], [78, "    public static FlumeAvroManager getManager(final String name, final Agent[] agents, int batchSize,"], [79, "                                              final int retries, final int connectTimeout, final int requestTimeout) {"], [98, "        return (FlumeAvroManager) getManager(sb.toString(), factory, new FactoryData(name, agents, batchSize, retries,"], [99, "            connectTimeout, requestTimeout));"], [118, "    public int getRetries() {"], [119, "        return retries;"], [120, "    }"], [121, ""], [122, "    public int getConnectTimeout() {"], [123, "        return connectTimeout;"], [124, "    }"], [125, ""], [126, "    public int getRequestTimeout() {"], [127, "        return requestTimeout;"], [128, "    }"], [129, ""], [131, "        if (rpcClient == null) {"], [132, "            rpcClient = connect(agents, retries, connectTimeout, requestTimeout);"], [135, "        if (rpcClient != null) {"], [137, "                rpcClient.appendBatch(events.getEvents());"], [139, "                rpcClient.close();"], [140, "                rpcClient = null;"], [144, "                throw new AppenderRuntimeException(\"No Flume agents are available\");"], [150, "    public synchronized void send(final Event event)  {"], [151, "        if (rpcClient == null) {"], [152, "            rpcClient = connect(agents, retries, connectTimeout, requestTimeout);"], [155, "        if (rpcClient != null) {"], [156, "            try {"], [157, "                rpcClient.append(event);"], [158, "            } catch (final Exception ex) {"], [159, "                rpcClient.close();"], [160, "                rpcClient = null;"], [161, "                String msg = \"Unable to write to \" + getName() + \" at \" + agents[current].getHost() + \":\" +"], [162, "                    agents[current].getPort();"], [163, "                LOGGER.warn(msg, ex);"], [164, "                throw new AppenderRuntimeException(\"No Flume agents are available\");"], [174, ""], [175, "    private RpcClient connect(final Agent[] agents, int retries, int connectTimeout, int requestTimeout) {"], [176, "        Properties props = new Properties();"], [177, ""], [178, "        props.put(\"client.type\", agents.length > 1 ? \"default_failover\" : \"default\");"], [179, ""], [180, "        int count = 1;"], [181, "        StringBuilder sb = new StringBuilder();"], [182, "        for (Agent agent : agents) {"], [183, "            if (sb.length() > 0) {"], [184, "                sb.append(\" \");"], [186, "            String hostName = \"host\" + count++;"], [187, "            props.put(\"hosts.\" + hostName, agent.getHost() + \":\" + agent.getPort());"], [188, "            sb.append(hostName);"], [190, "        props.put(\"hosts\", sb.toString());"], [191, "        if (batchSize > 0) {"], [192, "            props.put(\"batch-size\", Integer.toString(batchSize));"], [193, "        }"], [194, "        if (retries > 1) {"], [195, "            if (retries > MAX_RECONNECTS) {"], [196, "                retries = MAX_RECONNECTS;"], [198, "            props.put(\"max-attempts\", Integer.toString(retries * agents.length));"], [200, "        if (requestTimeout >= 1000) {"], [201, "            props.put(\"request-timeout\", Integer.toString(requestTimeout));"], [202, "        }"], [203, "        if (connectTimeout >= 1000) {"], [204, "            props.put(\"connect-timeout\", Integer.toString(connectTimeout));"], [206, "        return RpcClientFactory.getInstance(props);"], [211, "        if (rpcClient != null) {"], [213, "                rpcClient.close();"], [214, "            } catch (final Exception ex) {"], [215, "                LOGGER.error(\"Attempt to close RPC client failed\", ex);"], [218, "        rpcClient = null;"], [228, "        private final int retries;"], [229, "        private final int conntectTimeout;"], [230, "        private final int requestTimeout;"], [238, "        public FactoryData(final String name, final Agent[] agents, final int batchSize, final int retries,"], [239, "                           final int connectTimeout, final int requestTimeout) {"], [243, "            this.retries = retries;"], [244, "            this.conntectTimeout = connectTimeout;"], [245, "            this.requestTimeout = requestTimeout;"], [263, "                return new FlumeAvroManager(name, data.name, data.agents, data.batchSize, data.retries,"], [264, "                    data.conntectTimeout, data.requestTimeout);"]], "deleted": [[19, "import org.apache.avro.AvroRemoteException;"], [20, "import org.apache.avro.ipc.NettyTransceiver;"], [21, "import org.apache.avro.ipc.Transceiver;"], [22, "import org.apache.avro.ipc.specific.SpecificRequestor;"], [23, "import org.apache.flume.event.SimpleEvent;"], [24, "import org.apache.flume.source.avro.AvroFlumeEvent;"], [25, "import org.apache.flume.source.avro.AvroSourceProtocol;"], [26, "import org.apache.flume.source.avro.Status;"], [30, "import java.io.IOException;"], [31, "import java.net.InetSocketAddress;"], [32, "import java.nio.ByteBuffer;"], [33, "import java.util.ArrayList;"], [34, "import java.util.HashMap;"], [35, "import java.util.List;"], [36, "import java.util.Map;"], [43, "    /**"], [44, "      The default reconnection delay (500 milliseconds or .5 seconds)."], [45, "     */"], [46, "    public static final int DEFAULT_RECONNECTION_DELAY   = 500;"], [47, ""], [48, "    private static final int DEFAULT_RECONNECTS = 3;"], [52, "    private AvroSourceProtocol client;"], [53, ""], [58, "    private final EventList events = new EventList();"], [62, "    private Transceiver transceiver;"], [70, "    protected FlumeAvroManager(final String name, final String shortName, final Agent[] agents, final int batchSize) {"], [74, "        this.client = connect(agents);"], [84, "    public static FlumeAvroManager getManager(final String name, final Agent[] agents, int batchSize) {"], [103, "        return (FlumeAvroManager) getManager(sb.toString(), factory, new FactoryData(name, agents, batchSize));"], [123, "        if (client == null) {"], [124, "            client = connect(agents);"], [127, "        if (client != null) {"], [128, "            final List<SimpleEvent> list = events.getEvents();"], [129, "            final List<AvroFlumeEvent> batch = new ArrayList<AvroFlumeEvent>(list.size());"], [130, "            for (SimpleEvent event : list) {"], [131, "                final AvroFlumeEvent avroEvent = new AvroFlumeEvent();"], [132, "                avroEvent.setBody(ByteBuffer.wrap(event.getBody()));"], [133, "                avroEvent.setHeaders(new HashMap<CharSequence, CharSequence>());"], [134, ""], [135, "                for (final Map.Entry<String, String> entry : event.getHeaders().entrySet()) {"], [136, "                    avroEvent.getHeaders().put(entry.getKey(), entry.getValue());"], [137, "                }"], [138, "                batch.add(avroEvent);"], [139, "            }"], [140, ""], [142, "                final Status status = client.appendBatch(batch);"], [143, "                if (status.equals(Status.OK)) {"], [144, "                    return;"], [145, "                } else {"], [146, "                    LOGGER.warn(\"RPC communication failed to \" + agents[current].getHost() +"], [147, "                        \":\" + agents[current].getPort());"], [148, "                }"], [153, "            }"], [154, ""], [155, "            for (int index = 0; index < agents.length; ++index) {"], [156, "                if (index == current) {"], [157, "                    continue;"], [158, "                }"], [159, "                final Agent agent = agents[index];"], [160, "                try {"], [161, "                    transceiver = null;"], [162, "                    final AvroSourceProtocol c = connect(agent.getHost(), agent.getPort());"], [163, "                    final Status status = c.appendBatch(batch);"], [164, "                    if (!status.equals(Status.OK)) {"], [165, "                        final String warnMsg = \"RPC communication failed to \" + getName() + \" at \" +"], [166, "                            agent.getHost() + \":\" + agent.getPort();"], [167, "                        LOGGER.warn(warnMsg);"], [168, "                        continue;"], [169, "                    }"], [170, "                    client = c;"], [171, "                    current = index;"], [172, "                    return;"], [173, "                } catch (final Exception ex) {"], [174, "                    final String warnMsg = \"Unable to write to \" + getName() + \" at \" + agent.getHost() + \":\" +"], [175, "                        agent.getPort();"], [176, "                    LOGGER.warn(warnMsg, ex);"], [177, "                }"], [180, "        throw new AppenderRuntimeException(\"No Flume agents are available\");"], [184, "    public synchronized void send(final SimpleEvent event, int delay, int retries)  {"], [185, "        if (delay == 0) {"], [186, "            delay = DEFAULT_RECONNECTION_DELAY;"], [187, "        }"], [188, "        if (retries == 0) {"], [189, "            retries = DEFAULT_RECONNECTS;"], [191, "        if (client == null) {"], [192, "            client = connect(agents);"], [193, "        }"], [194, "        String msg = \"No Flume agents are available\";"], [195, "        if (client != null) {"], [196, "            final AvroFlumeEvent avroEvent = new AvroFlumeEvent();"], [197, "            avroEvent.setBody(ByteBuffer.wrap(event.getBody()));"], [198, "            avroEvent.setHeaders(new HashMap<CharSequence, CharSequence>());"], [199, ""], [200, "            for (final Map.Entry<String, String> entry : event.getHeaders().entrySet()) {"], [201, "                avroEvent.getHeaders().put(entry.getKey(), entry.getValue());"], [202, "            }"], [204, "            final List<AvroFlumeEvent> batch = batchSize > 1 ? events.addAndGet(avroEvent, batchSize) : null;"], [205, "            if (batch == null && batchSize > 1) {"], [206, "                return;"], [207, "            }"], [208, ""], [209, "            int i = 0;"], [210, ""], [211, "            msg = \"Error writing to \" + getName();"], [212, ""], [213, "            do {"], [214, "                try {"], [215, "                    final Status status = (batch == null) ? client.append(avroEvent) : client.appendBatch(batch);"], [216, "                    if (!status.equals(Status.OK)) {"], [217, "                        throw new AvroRemoteException(\"RPC communication failed to \" + agents[current].getHost() +"], [218, "                            \":\" + agents[current].getPort());"], [219, "                    }"], [220, "                    return;"], [221, "                } catch (final Exception ex) {"], [222, "                    if (i == retries - 1) {"], [223, "                        msg = \"Unable to write to \" + getName() + \" at \" + agents[current].getHost() + \":\" +"], [224, "                            agents[current].getPort();"], [225, "                        LOGGER.warn(msg, ex);"], [226, "                        break;"], [227, "                    }"], [228, "                    sleep(delay);"], [229, "                }"], [230, "            } while (++i < retries);"], [231, ""], [232, "            for (int index = 0; index < agents.length; ++index) {"], [233, "                if (index == current) {"], [234, "                    continue;"], [235, "                }"], [236, "                final Agent agent = agents[index];"], [237, "                i = 0;"], [238, "                do {"], [239, "                    try {"], [240, "                        transceiver = null;"], [241, "                        final AvroSourceProtocol c = connect(agent.getHost(), agent.getPort());"], [242, "                        final Status status = (batch == null) ? c.append(avroEvent) : c.appendBatch(batch);"], [243, "                        if (!status.equals(Status.OK)) {"], [244, "                            if (i == retries - 1) {"], [245, "                                final String warnMsg = \"RPC communication failed to \" + getName() + \" at \" +"], [246, "                                    agent.getHost() + \":\" + agent.getPort();"], [247, "                                LOGGER.warn(warnMsg);"], [248, "                            }"], [249, "                            continue;"], [250, "                        }"], [251, "                        client = c;"], [252, "                        current = index;"], [253, "                        return;"], [254, "                    } catch (final Exception ex) {"], [255, "                        if (i == retries - 1) {"], [256, "                            final String warnMsg = \"Unable to write to \" + getName() + \" at \" + agent.getHost() + \":\" +"], [257, "                                agent.getPort();"], [258, "                            LOGGER.warn(warnMsg, ex);"], [259, "                            break;"], [260, "                        }"], [261, "                        sleep(delay);"], [262, "                    }"], [263, "                } while (++i < retries);"], [266, ""], [267, "        throw new AppenderRuntimeException(msg);"], [268, ""], [269, "    }"], [270, ""], [271, "    private void sleep(final int delay) {"], [272, "        try {"], [273, "            Thread.sleep(delay);"], [274, "        } catch (final InterruptedException ex) {"], [275, "            Thread.currentThread().interrupt();"], [276, "        }"], [284, "    private AvroSourceProtocol connect(final Agent[] agents) {"], [285, "        int i = 0;"], [286, "        for (final Agent agent : agents) {"], [287, "            final AvroSourceProtocol server = connect(agent.getHost(), agent.getPort());"], [288, "            if (server != null) {"], [289, "                current = i;"], [290, "                return server;"], [292, "            ++i;"], [294, "        LOGGER.error(\"Flume manager \" + getName() + \" was unable to connect to any agents\");"], [295, "        return null;"], [296, "    }"], [297, ""], [298, "    private AvroSourceProtocol connect(final String hostname, final int port) {"], [299, "        try {"], [300, "            if (transceiver == null) {"], [301, "                transceiver = new NettyTransceiver(new InetSocketAddress(hostname, port));"], [303, "        } catch (final IOException ioe) {"], [304, "            LOGGER.error(\"Unable to create transceiver\", ioe);"], [305, "            return null;"], [307, "        try {"], [308, "            return SpecificRequestor.getClient(AvroSourceProtocol.class, transceiver);"], [309, "        } catch (final IOException ioe) {"], [310, "            LOGGER.error(\"Unable to create Avro client\");"], [311, "            return null;"], [317, "        if (transceiver != null) {"], [319, "                transceiver.close();"], [320, "            } catch (final IOException ioe) {"], [321, "                LOGGER.error(\"Attempt to clean up Avro transceiver failed\", ioe);"], [322, "            }"], [323, "        }"], [324, "        client = null;"], [325, "    }"], [326, ""], [327, "    /**"], [328, "     * Thread-safe List management of a batch."], [329, "     */"], [330, "    private static class EventList extends ArrayList<AvroFlumeEvent> {"], [331, ""], [332, "        /**"], [333, "         * Generated serial version ID."], [334, "         */"], [335, "        private static final long serialVersionUID = -1599817377315957495L;"], [336, ""], [337, "        public synchronized List<AvroFlumeEvent> addAndGet(final AvroFlumeEvent event, final int batchSize) {"], [338, "            super.add(event);"], [339, "            if (this.size() >= batchSize) {"], [340, "                final List<AvroFlumeEvent> events = new ArrayList<AvroFlumeEvent>();"], [341, "                events.addAll(this);"], [342, "                clear();"], [343, "                return events;"], [344, "            } else {"], [345, "                return null;"], [364, "        public FactoryData(final String name, final Agent[] agents, final int batchSize) {"], [385, "                return new FlumeAvroManager(name, data.name, data.agents, data.batchSize);"]]}, "num_lines_added": 100, "num_lines_removed": 221}