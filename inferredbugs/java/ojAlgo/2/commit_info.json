{"hash": "b8bb36d27348a718091197ef3e6b1e94e7427054", "message": "2016-04-24", "file_num_lines": 260, "diff_parsed": {"added": [[28, "import org.ojalgo.function.BinaryFunction;"], [33, "import org.ojalgo.scalar.Scalar;"], [101, "        return this.getInverse(this.preallocate(new Structure2D() {"], [102, ""], [103, "            public long countRows() {"], [104, "                return myTransposed ? myBidiagonal.getColDim() : myBidiagonal.getRowDim();"], [105, "            }"], [106, ""], [107, "            public long countColumns() {"], [108, "                return myTransposed ? myBidiagonal.getRowDim() : myBidiagonal.getColDim();"], [109, "            }"], [110, "        }));"], [111, "    }"], [112, ""], [113, "    public MatrixStore<N> getInverse(final DecompositionStore<N> preallocated) {"], [114, ""], [118, "            final Array1D<Double> tmpSingulars = this.getSingularValues();"], [119, "            final MatrixStore<N> tmpQ2 = this.getQ2();"], [121, "            final int tmpRowDim = (int) tmpSingulars.count();"], [125, "            double tmpValue;"], [128, "                tmpValue = tmpSingulars.doubleValue(i);"], [130, "                    tmpMtrx.set(i, j, tmpQ1.toScalar(j, i).conjugate().divide(tmpValue).getNumber());"], [134, "            preallocated.fillByMultiplying(tmpQ2, tmpMtrx);"], [135, "            myInverse = preallocated;"], [141, "    private MatrixStore<N> getTruncatedInverse(final DecompositionStore<N> preallocated) {"], [146, "            final Array1D<Double> tmpSingulars = this.getSingularValues();"], [147, "            final MatrixStore<N> tmpQ2 = this.getQ2();"], [149, "            final PhysicalStore<N> tmpMtrx = tmpQ2.copy();"], [150, ""], [151, "            final Scalar.Factory<N> tmpScalar = this.scalar();"], [152, "            final BinaryFunction<N> tmpDivide = this.function().divide();"], [153, "            final N tmpZero = tmpScalar.zero().getNumber();"], [157, "                tmpMtrx.modifyColumn(0L, i, tmpDivide.second(tmpScalar.cast(tmpSingulars.doubleValue(i))));"], [158, "            }"], [159, "            final long tmpCountColumns = tmpMtrx.countColumns();"], [160, "            for (int i = rank; i < tmpCountColumns; i++) {"], [161, "                tmpMtrx.fillColumn(0L, i, tmpZero);"], [164, "            preallocated.fillByMultiplying(tmpMtrx, tmpQ1.conjugate());"], [165, "            myInverse = preallocated;"], [261, "        return this.allocate(template.countColumns(), template.countRows());"]], "deleted": [[102, "            final MatrixStore<N> tmpD = this.getD();"], [104, "            final int tmpRowDim = (int) tmpD.countRows();"], [108, "            double tmpSingularValue;"], [111, "                tmpSingularValue = tmpD.doubleValue(i, i);"], [113, "                    tmpMtrx.set(i, j, tmpQ1.toScalar(j, i).conjugate().divide(tmpSingularValue).getNumber());"], [117, "            myInverse = this.getQ2().multiply(tmpMtrx);"], [123, "    public MatrixStore<N> getInverse(final DecompositionStore<N> preallocated) {"], [127, "            preallocated.fillAll(this.scalar().zero().getNumber());"], [128, "            final PhysicalStore<N> tmpMtrx = preallocated;"], [129, ""], [131, "            final MatrixStore<N> tmpD = this.getD();"], [133, "            final int tmpColDim = (int) tmpQ1.countRows();"], [135, "            double tmpSingularValue;"], [138, "                tmpSingularValue = tmpD.doubleValue(i, i);"], [139, "                for (int j = 0; j < tmpColDim; j++) {"], [140, "                    tmpMtrx.set(i, j, tmpQ1.toScalar(j, i).conjugate().divide(tmpSingularValue).getNumber());"], [141, "                }"], [144, "            myInverse = this.getQ2().multiply(tmpMtrx);"], [240, "        final long tmpCountRows = template.countRows();"], [241, "        return this.allocate(tmpCountRows, tmpCountRows);"]]}, "num_lines_added": 40, "num_lines_removed": 20}