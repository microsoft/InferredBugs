{"hash": "8006fefdfb0e2573b27736279fbe4955270cde99", "message": "2016-04-26", "file_num_lines": 263, "diff_parsed": {"added": [[75, "    public MatrixStore<N> getD(final int rank) {"], [77, "        final int tmpColumns = Math.min(rank, myBidiagonal.getMinDim());"], [78, ""], [79, "        if (this.isComputed() && ((myD == null) || (myD.countColumns() != tmpColumns))) {"], [80, "            myD = this.makeD(tmpColumns);"], [109, "            public long countRows() {"], [110, "                return myTransposed ? myBidiagonal.getColDim() : myBidiagonal.getRowDim();"], [112, "        }));"], [115, "    public MatrixStore<N> getInverse(final DecompositionStore<N> preallocated) {"], [162, "    public MatrixStore<N> getQ1(final int rank) {"], [163, ""], [164, "        final int tmpColumns = Math.min(rank, myBidiagonal.getMinDim());"], [165, ""], [166, "        if (!mySingularValuesOnly && this.isComputed() && ((myQ1 == null) || (myQ1.countColumns() != tmpColumns))) {"], [169, "                myQ1 = this.makeQ2(tmpColumns);"], [171, "                myQ1 = this.makeQ1(tmpColumns);"], [178, "    public MatrixStore<N> getQ2(final int rank) {"], [180, "        final int tmpColumns = Math.min(rank, myBidiagonal.getMinDim());"], [181, ""], [182, "        if (!mySingularValuesOnly && this.isComputed() && ((myQ2 == null) || (myQ2.countColumns() != tmpColumns))) {"], [184, "                myQ2 = this.makeQ1(tmpColumns);"], [186, "                myQ2 = this.makeQ2(tmpColumns);"], [287, "    private MatrixStore<N> getInverseOldVersion(final DecompositionStore<N> preallocated) {"], [288, ""], [289, "        if (myInverse == null) {"], [290, ""], [291, "            final MatrixStore<N> tmpQ1 = this.getQ1();"], [292, "            final Array1D<Double> tmpSingulars = this.getSingularValues();"], [293, "            final MatrixStore<N> tmpQ2 = this.getQ2();"], [294, ""], [295, "            final int tmpRowDim = (int) tmpSingulars.count();"], [296, "            final int tmpColDim = (int) tmpQ1.countRows();"], [297, "            final PhysicalStore<N> tmpMtrx = this.makeZero(tmpRowDim, tmpColDim);"], [298, ""], [299, "            double tmpValue;"], [300, "            final int rank = this.getRank();"], [301, "            for (int i = 0; i < rank; i++) {"], [302, "                tmpValue = tmpSingulars.doubleValue(i);"], [303, "                for (int j = 0; j < tmpColDim; j++) {"], [304, "                    tmpMtrx.set(i, j, tmpQ1.toScalar(j, i).conjugate().divide(tmpValue).getNumber());"], [305, "                }"], [306, "            }"], [307, ""], [308, "            preallocated.fillByMultiplying(tmpQ2, tmpMtrx);"], [309, "            myInverse = preallocated;"], [310, "        }"], [311, ""], [312, "        return myInverse;"], [313, "    }"], [314, ""], [368, "    protected abstract MatrixStore<N> makeD(int columns);"], [370, "    protected abstract MatrixStore<N> makeQ1(int columns);"], [372, "    protected abstract MatrixStore<N> makeQ2(int columns);"]], "deleted": [[75, "    public MatrixStore<N> getD() {"], [77, "        if ((myD == null) && this.isComputed()) {"], [78, "            myD = this.makeD();"], [103, "            public long countRows() {"], [104, "                return myTransposed ? myBidiagonal.getColDim() : myBidiagonal.getRowDim();"], [105, "            }"], [106, ""], [110, "        }));"], [111, "    }"], [112, ""], [113, "    public MatrixStore<N> getInverse(final DecompositionStore<N> preallocated) {"], [115, "        if (myInverse == null) {"], [116, ""], [117, "            final MatrixStore<N> tmpQ1 = this.getQ1();"], [118, "            final Array1D<Double> tmpSingulars = this.getSingularValues();"], [119, "            final MatrixStore<N> tmpQ2 = this.getQ2();"], [120, ""], [121, "            final int tmpRowDim = (int) tmpSingulars.count();"], [122, "            final int tmpColDim = (int) tmpQ1.countRows();"], [123, "            final PhysicalStore<N> tmpMtrx = this.makeZero(tmpRowDim, tmpColDim);"], [124, ""], [125, "            double tmpValue;"], [126, "            final int rank = this.getRank();"], [127, "            for (int i = 0; i < rank; i++) {"], [128, "                tmpValue = tmpSingulars.doubleValue(i);"], [129, "                for (int j = 0; j < tmpColDim; j++) {"], [130, "                    tmpMtrx.set(i, j, tmpQ1.toScalar(j, i).conjugate().divide(tmpValue).getNumber());"], [131, "                }"], [133, ""], [134, "            preallocated.fillByMultiplying(tmpQ2, tmpMtrx);"], [135, "            myInverse = preallocated;"], [136, "        }"], [137, ""], [138, "        return myInverse;"], [141, "    private MatrixStore<N> getTruncatedInverse(final DecompositionStore<N> preallocated) {"], [188, "    public MatrixStore<N> getQ1() {"], [190, "        if ((myQ1 == null) && !mySingularValuesOnly && this.isComputed()) {"], [192, "                myQ1 = this.makeQ2();"], [194, "                myQ1 = this.makeQ1();"], [201, "    public MatrixStore<N> getQ2() {"], [203, "        if ((myQ2 == null) && !mySingularValuesOnly && this.isComputed()) {"], [205, "                myQ2 = this.makeQ1();"], [207, "                myQ2 = this.makeQ2();"], [361, "    protected abstract MatrixStore<N> makeD();"], [363, "    protected abstract MatrixStore<N> makeQ1();"], [365, "    protected abstract MatrixStore<N> makeQ2();"]]}, "num_lines_added": 53, "num_lines_removed": 46}