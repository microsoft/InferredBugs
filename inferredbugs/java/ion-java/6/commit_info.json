{"hash": "fa374ac22f18432338b9e88a20c8f32de91cb3cb", "message": "Disables LST append writing by default and adds option to enable it (#278)", "file_num_lines": 263, "diff_parsed": {"added": [[31, "import com.amazon.ion.system.IonBinaryWriterBuilder;"], [45, "        IonBinaryWriterBuilder builder = IonBinaryWriterBuilder.standard()"], [46, "                .withImports(imports);"], [47, "        builder.setLocalSymbolTableAppendEnabled(myLstAppendEnabled);"], [48, "        return builder.build(out);"], [130, "        byte[] bytes = flushUnlockedSymtab(false);"], [131, "        assertEquals(0, bytes.length);"], [132, "    }"], [133, ""], [134, "    @Test"], [135, "    public void testFlushingUnlockedSymtabWithLSTAppend()"], [136, "    throws Exception"], [137, "    {"], [138, "        byte[] bytes = flushUnlockedSymtab(true);"], [139, ""], [140, "        // iw.flush() should have caused an appended LST to be written before the next value."], [141, "        IonReader reader = IonReaderBuilder.standard().build(bytes);"], [142, "        assertEquals(IonType.SYMBOL, reader.next());"], [143, "        assertEquals(\"force a local symtab\", reader.stringValue());"], [144, "        assertEquals(IonType.SYMBOL, reader.next());"], [145, "        assertEquals(\"fred_1\", reader.stringValue());"], [146, "        assertNull(reader.next());"], [147, "    }"], [148, ""], [149, "    private byte[] flushUnlockedSymtab(boolean lstAppendEnabled)"], [150, "    throws Exception"], [151, "    {"], [152, "        myLstAppendEnabled = lstAppendEnabled;"], [161, "        return myOutputStream.toByteArray();"], [169, "        byte[] bytes = flushUnlockedSymtabWithImports(catalog, false);"], [170, "        assertEquals(0, bytes.length);"], [171, "    }"], [172, ""], [173, "    @Test"], [174, "    public void testFlushingUnlockedSymtabWithImportsWithLSTAppend()"], [175, "    throws Exception"], [176, "    {"], [177, "        SimpleCatalog catalog = catalog();"], [178, "        byte[] bytes = flushUnlockedSymtabWithImports(catalog, true);"], [179, ""], [180, "        IonReader reader = IonReaderBuilder.standard().withCatalog(catalog).build(bytes);"], [181, "        assertEquals(IonType.SYMBOL, reader.next());"], [182, "        assertEquals(\"fred_1\", reader.stringValue());"], [183, "        assertNull(reader.next());"], [184, "    }"], [185, ""], [186, ""], [187, "    private byte[] flushUnlockedSymtabWithImports(SimpleCatalog catalog, boolean lstAppendEnabled)"], [188, "    throws Exception"], [189, "    {"], [191, "        myLstAppendEnabled = lstAppendEnabled;"], [196, "        return myOutputStream.toByteArray();"]], "deleted": [[44, "        return system().newBinaryWriter(out, imports);"], [133, "        // This would cause an appended LST to be written before the next value."], [135, "        IonReader reader = IonReaderBuilder.standard().build(myOutputStream.toByteArray());"], [136, "        assertEquals(IonType.SYMBOL, reader.next());"], [137, "        assertEquals(\"force a local symtab\", reader.stringValue());"], [138, "        assertEquals(IonType.SYMBOL, reader.next());"], [139, "        assertEquals(\"fred_1\", reader.stringValue());"], [140, "        assertNull(reader.next());"], [153, "        IonReader reader = IonReaderBuilder.standard().withCatalog(catalog).build(myOutputStream.toByteArray());"], [154, "        assertEquals(IonType.SYMBOL, reader.next());"], [155, "        assertEquals(\"fred_1\", reader.stringValue());"], [156, "        assertNull(reader.next());"]]}, "num_lines_added": 52, "num_lines_removed": 12}