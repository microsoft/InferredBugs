{"hash": "23b412f108279b38a03ada0d76cab4d8d07bfe77", "message": "Makes IonRawBinaryWriter reuse ContainerInfo objects, reducing allocations and garbage. (#244)", "file_num_lines": 1291, "diff_parsed": {"added": [[238, "        public ContainerType type;"], [240, "        public long position;"], [246, "        public ContainerInfo()"], [248, "            type = null;"], [249, "            position = -1;"], [250, "            length = -1;"], [251, "            patches = null;"], [275, "        public void initialize(final ContainerType type, final long offset) {"], [276, "            this.type = type;"], [277, "            this.position = offset;"], [278, "            this.patches = null;"], [279, "            this.length = 0;"], [280, "        }"], [281, ""], [477, "    private final List<ContainerInfo>           containers;"], [478, "    private int                                 currentContainerIndex;"], [513, "        this.containers        = new ArrayList<ContainerInfo>(10);"], [514, "        // Note: this is not the same as depth because ContainerInfo is used for annotations and certain scalars"], [515, "        // in addition to container types."], [516, "        this.currentContainerIndex            = -1;"], [665, "        if (currentContainerIndex < 0)"], [670, "        containers.get(currentContainerIndex).length += length;"], [676, "        currentContainerIndex++;"], [677, "        ContainerInfo info;"], [678, "        if (currentContainerIndex >= containers.size()) {"], [679, "            info = new ContainerInfo();"], [680, "            containers.add(info);"], [681, "        }  else {"], [682, "            info = containers.get(currentContainerIndex);"], [683, "        }"], [684, "        info.initialize(type, buffer.position() + 1);"], [689, "        return currentContainerIndex < 0 ? null : containers.get(currentContainerIndex);"], [734, "        currentContainerIndex--;"], [898, "        return currentContainerIndex >= 0 && currentContainer().type == ContainerType.STRUCT;"], [1521, "        if (currentContainerIndex >= 0 || depth > 0)"]], "deleted": [[238, "        public final ContainerType type;"], [240, "        public final long position;"], [246, "        public ContainerInfo(final ContainerType type, final long offset)"], [248, "            this.type = type;"], [249, "            this.position = offset;"], [250, "            this.patches = null;"], [469, "    private final LinkedList<ContainerInfo>     containers;"], [504, "        this.containers        = new LinkedList<ContainerInfo>();"], [505, ""], [654, "        if (containers.isEmpty())"], [659, "        containers.getLast().length += length;"], [665, "        containers.add(new ContainerInfo(type, buffer.position() + 1));"], [670, "        return containers.isEmpty() ? null : containers.getLast();"], [715, "        containers.removeLast();"], [879, "        return !containers.isEmpty() && currentContainer().type == ContainerType.STRUCT;"], [1502, "        if (!containers.isEmpty())"]]}, "num_lines_added": 35, "num_lines_removed": 16}