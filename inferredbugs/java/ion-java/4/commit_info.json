{"hash": "9dc90d41f43b23c8fa9382d9e696665b0054810b", "message": "Memleak gzip (#204)\n\n* Fixing memleak when auto detecting gzipped bytes\r\n\r\nCorrectly closes the created IonReader in order to free the memory\r\nallocated outside the heap by GzipInputStream.\r\n\r\nFor methods that return an iterator changed the signature to\r\nreturn a CloseableIterator which is closeable permiting users to\r\nclose the iterator. This iterator also closes itself when there are\r\nno more values next to return.\r\n\r\nThe gzip auto detect functionality should be removed from this package\r\nas it is an orthogonal concern to reading/writing Ion data. Right now\r\nour API has to close streams created by users to guaranteed that the\r\ninternal wrapped Gzip stream is correctly closed.\r\n\r\nhttps://github.com/amzn/ion-java/issues/198", "file_num_lines": 621, "diff_parsed": {"added": [[17, "import software.amazon.ion.CloseableIterator;"], [174, "    public CloseableIterator<IonValue> iterate(Reader ionText)"], [181, "    public CloseableIterator<IonValue> iterate(InputStream ionData)"], [188, "    public CloseableIterator<IonValue> iterate(String ionText)"], [195, "    public CloseableIterator<IonValue> iterate(byte[] ionData)"], [475, "    private IonValue singleValue(CloseableIterator<IonValue> it)"], [478, "            IonValue value = it.next();"], [479, "            if (it.hasNext()) {"], [480, "                throw new IonException(\"not a single value\");"], [481, "            }"], [482, "            return value;"], [487, "        finally {"], [488, "            try {"], [489, "                it.close();"], [490, "            }"], [491, "            catch (IOException e) {"], [492, "                throw new IonException(e);"], [493, "            }"], [499, "        CloseableIterator<IonValue> it = iterate(ionText);"], [505, "        CloseableIterator<IonValue> iterator = iterate(ionData);"], [506, "        return singleValue(iterator);"], [521, "        implements CloseableIterator<IonValue>"], [542, "            boolean hasNext = _next != null;"], [543, ""], [544, "            if (!hasNext) {"], [545, "                try {"], [546, "                    close();"], [547, "                }"], [548, "                catch (IOException e) {"], [549, "                    throw new IonException(e);"], [550, "                }"], [551, "            }"], [552, ""], [553, "            return hasNext;"], [589, "            _reader.close();"]], "deleted": [[173, "    public Iterator<IonValue> iterate(Reader ionText)"], [180, "    public Iterator<IonValue> iterate(InputStream ionData)"], [187, "    public Iterator<IonValue> iterate(String ionText)"], [194, "    public Iterator<IonValue> iterate(byte[] ionData)"], [474, "    private IonValue singleValue(Iterator<IonValue> it)"], [476, "        IonValue value;"], [478, "            value = it.next();"], [483, "        if (it.hasNext()) {"], [484, "            throw new IonException(\"not a single value\");"], [486, "        return value;"], [491, "        Iterator<IonValue> it = iterate(ionText);"], [497, "        Iterator<IonValue> it = iterate(ionData);"], [498, "        return singleValue(it);"], [513, "        implements Iterator<IonValue>, Closeable"], [534, "            return (_next != null);"], [570, "            // TODO _reader.close();"], [574, ""]]}, "num_lines_added": 35, "num_lines_removed": 17}