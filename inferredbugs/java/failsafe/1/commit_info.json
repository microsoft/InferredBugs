{"hash": "5a137ef9db4a0579d9564777e42adb798bf9c658", "message": "Made future completion/cancellation threadsafe with scheduling\nAdded a bit more testing", "file_num_lines": 182, "diff_parsed": {"added": [[3, "import static net.jodah.recurrent.Asserts.assertMatches;"], [5, "import static net.jodah.recurrent.Testing.getThrowable;"], [6, "import static net.jodah.recurrent.Testing.ignoreExceptions;"], [18, "import java.util.concurrent.ExecutionException;"], [29, "  private RetryPolicy retryAlways = new RetryPolicy();"], [32, "  // Results from a synchronous Recurrent call"], [33, "  @SuppressWarnings(\"unchecked\") Class<? extends Throwable>[] syncThrowables = new Class[] { RuntimeException.class,"], [34, "      SocketException.class };"], [35, "  // Results from a get against a future that wraps a synchronous Recurrent call"], [36, "  @SuppressWarnings(\"unchecked\") Class<? extends Throwable>[] futureSyncThrowables = new Class[] {"], [37, "      ExecutionException.class, RuntimeException.class, SocketException.class };"], [38, "  // Results from a get against a future that wraps an asynchronous Recurrent call"], [39, "  @SuppressWarnings(\"unchecked\") Class<? extends Throwable>[] futureAsyncThrowables = new Class[] {"], [40, "      ExecutionException.class, SocketException.class };"], [41, ""], [44, ""], [45, "    boolean disconnect();"], [74, "      assertThrows(() -> Recurrent.run((Runnable) runnable, retryTwice, executor).get(), futureAsyncThrowables);"], [76, "      assertThrows(() -> Recurrent.run((ContextualRunnable) runnable, retryTwice, executor).get(),"], [77, "          futureAsyncThrowables);"], [92, "    assertThrows(() -> Recurrent.run(runnable, retryTwice), syncThrowables);"], [124, "    assertThrows(() -> Recurrent.get(callable, retryTwice), syncThrowables);"], [144, "    assertMatches(failure, futureAsyncThrowables);"], [182, "    assertMatches(failure, futureAsyncThrowables);"], [203, ""], [204, "  public void testFutureStages() throws Throwable {"], [205, "    // Fail twice then succeed"], [206, "    when(service.connect()).thenThrow(failures(2, SocketException.class)).thenReturn(true);"], [207, "    when(service.disconnect()).thenThrow(failures(2, SocketException.class)).thenReturn(true);"], [208, "    CompletableFuture.supplyAsync(() -> Recurrent.get(() -> service.connect(), retryAlways))"], [209, "        .thenRun(() -> Recurrent.get(() -> service.disconnect(), retryAlways))"], [210, "        .get();"], [211, "    verify(service, times(3)).connect();"], [212, "    verify(service, times(3)).disconnect();"], [213, ""], [214, "    // Fail three times"], [215, "    reset(service);"], [216, "    when(service.connect()).thenThrow(failures(10, SocketException.class)).thenReturn(true);"], [217, "    assertThrows(() -> CompletableFuture.supplyAsync(() -> Recurrent.get(() -> service.connect(), retryTwice)).get(),"], [218, "        futureSyncThrowables);"], [219, "    verify(service, times(3)).connect();"], [220, "  }"], [221, ""], [222, "  public void shouldCancelFuture() throws Throwable {"], [223, "    RecurrentFuture<?> future = Recurrent.run(() -> ignoreExceptions(() -> Thread.sleep(10000)), retryAlways, executor);"], [224, "    future.cancel(true);"], [225, "    assertTrue(future.isCancelled());"], [226, "  }"]], "deleted": [[4, "import static net.jodah.recurrent.Asserts.getThrowable;"], [58, "      assertThrows(SocketException.class, () -> Recurrent.run((Runnable) runnable, retryTwice, executor).get());"], [60, "      assertThrows(SocketException.class,"], [61, "          () -> Recurrent.run((ContextualRunnable) runnable, retryTwice, executor).get());"], [76, "    assertThrows(SocketException.class, () -> Recurrent.run(runnable, retryTwice));"], [108, "    assertThrows(SocketException.class, () -> Recurrent.get(callable, retryTwice));"], [128, "    assertTrue(SocketException.class.isAssignableFrom(failure.getClass()));"], [166, "    assertTrue(SocketException.class.isAssignableFrom(failure.getClass()));"]]}, "num_lines_added": 48, "num_lines_removed": 8}