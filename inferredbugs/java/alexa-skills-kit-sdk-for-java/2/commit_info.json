{"hash": "85fd0f0ef70f73ff3065ed69cf35ebf4cf5d95ae", "message": "Make signature verifier more resiliant to HTTP retrieval errors (#230)", "file_num_lines": 192, "diff_parsed": {"added": [[18, "import org.apache.commons.io.IOUtils;"], [25, "import java.net.HttpURLConnection;"], [38, "import java.util.Date;"], [53, "    private static final int CERT_RETRIEVAL_RETRY_COUNT = 5;"], [54, "    private static final int DELAY_BETWEEN_RETRIES_MS = 500;"], [85, "            X509Certificate signingCertificate = CERTIFICATE_CACHE.get(signingCertificateChainUrl);"], [86, "            if (signingCertificate != null && signingCertificate.getNotAfter().after(new Date())) {"], [126, "        for (int attempt = 0; attempt <= CERT_RETRIEVAL_RETRY_COUNT; attempt++) {"], [127, "            InputStream in = null;"], [128, "            try {"], [129, "                HttpURLConnection connection ="], [130, "                        proxy != null ? (HttpURLConnection)getAndVerifySigningCertificateChainUrl(signingCertificateChainUrl).openConnection(proxy)"], [131, "                                : (HttpURLConnection)getAndVerifySigningCertificateChainUrl(signingCertificateChainUrl).openConnection();"], [132, ""], [133, "                if (connection.getResponseCode() != 200) {"], [134, "                    if (waitForRetry(attempt)) {"], [135, "                        continue;"], [136, "                    } else {"], [137, "                        throw new CertificateException(\"Got a non-200 status code when retrieving certificate at URL: \" + signingCertificateChainUrl);"], [138, "                    }"], [141, "                in = connection.getInputStream();"], [142, "                CertificateFactory certificateFactory ="], [143, "                        CertificateFactory.getInstance(ServletConstants.SIGNATURE_CERTIFICATE_TYPE);"], [144, "                @SuppressWarnings(\"unchecked\")"], [145, "                Collection<X509Certificate> certificateChain ="], [146, "                        (Collection<X509Certificate>) certificateFactory.generateCertificates(in);"], [147, "                /*"], [148, "                 * check the before/after dates on the certificate date to confirm that it is valid on"], [149, "                 * the current date"], [150, "                 */"], [151, "                X509Certificate signingCertificate = certificateChain.iterator().next();"], [152, "                signingCertificate.checkValidity();"], [153, ""], [154, "                // check the certificate chain"], [155, "                TrustManagerFactory trustManagerFactory ="], [156, "                        TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());"], [157, "                trustManagerFactory.init((KeyStore) null);"], [159, "                X509TrustManager x509TrustManager = null;"], [160, "                for (TrustManager trustManager : trustManagerFactory.getTrustManagers()) {"], [161, "                    if (trustManager instanceof X509TrustManager) {"], [162, "                        x509TrustManager = (X509TrustManager) trustManager;"], [163, "                    }"], [164, "                }"], [165, ""], [166, "                if (x509TrustManager == null) {"], [167, "                    throw new IllegalStateException("], [168, "                            \"No X509 TrustManager available. Unable to check certificate chain\");"], [169, "                } else {"], [170, "                    x509TrustManager.checkServerTrusted("], [171, "                            certificateChain.toArray(new X509Certificate[certificateChain.size()]),"], [172, "                            ServletConstants.SIGNATURE_TYPE);"], [173, "                }"], [174, ""], [175, "                /*"], [176, "                 * verify Echo API's hostname is specified as one of subject alternative names on the"], [177, "                 * signing certificate"], [178, "                 */"], [179, "                if (!subjectAlernativeNameListContainsEchoSdkDomainName(signingCertificate"], [180, "                        .getSubjectAlternativeNames())) {"], [181, "                    throw new CertificateException("], [182, "                            \"The provided certificate is not valid for the ASK SDK\");"], [183, "                }"], [184, ""], [185, "                return signingCertificate;"], [186, "            } catch (IOException e) {"], [187, "                if (!waitForRetry(attempt)) {"], [188, "                    throw new CertificateException(\"Unable to retrieve certificate from URL: \" + signingCertificateChainUrl, e);"], [189, "                }"], [190, "            } catch (Exception e) {"], [191, "                throw new CertificateException(\"Unable to verify certificate at URL: \" + signingCertificateChainUrl, e);"], [192, "            } finally {"], [193, "                if (in != null) {"], [194, "                    IOUtils.closeQuietly(in);"], [195, "                }"], [197, "        }"], [198, "        throw new RuntimeException(\"Unable to retrieve signing certificate due to an unhandled exception\");"], [199, "    }"], [201, "    private boolean waitForRetry(int attempt) {"], [202, "        if (attempt < CERT_RETRIEVAL_RETRY_COUNT) {"], [203, "            try {"], [204, "                Thread.sleep(DELAY_BETWEEN_RETRIES_MS);"], [205, "                return true;"], [206, "            } catch (InterruptedException ex) {"], [207, "                throw new RuntimeException(\"Interrupted while waiting for certificate retrieval retry attempt\", ex);"], [208, "            }"], [209, "        } else {"], [210, "            return false;"], [287, "}"]], "deleted": [[31, "import java.security.KeyStoreException;"], [32, "import java.security.NoSuchAlgorithmException;"], [82, "            X509Certificate signingCertificate;"], [83, "            if (CERTIFICATE_CACHE.containsKey(signingCertificateChainUrl)) {"], [84, "                signingCertificate = CERTIFICATE_CACHE.get(signingCertificateChainUrl);"], [124, "        try (InputStream in ="], [125, "                proxy != null ? getAndVerifySigningCertificateChainUrl(signingCertificateChainUrl).openConnection(proxy).getInputStream()"], [126, "                : getAndVerifySigningCertificateChainUrl(signingCertificateChainUrl).openConnection().getInputStream()) {"], [127, "            CertificateFactory certificateFactory ="], [128, "                    CertificateFactory.getInstance(ServletConstants.SIGNATURE_CERTIFICATE_TYPE);"], [129, "            @SuppressWarnings(\"unchecked\")"], [130, "            Collection<X509Certificate> certificateChain ="], [131, "                    (Collection<X509Certificate>) certificateFactory.generateCertificates(in);"], [132, "            /*"], [133, "             * check the before/after dates on the certificate date to confirm that it is valid on"], [134, "             * the current date"], [135, "             */"], [136, "            X509Certificate signingCertificate = certificateChain.iterator().next();"], [137, "            signingCertificate.checkValidity();"], [138, ""], [139, "            // check the certificate chain"], [140, "            TrustManagerFactory trustManagerFactory ="], [141, "                    TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());"], [142, "            trustManagerFactory.init((KeyStore) null);"], [143, ""], [144, "            X509TrustManager x509TrustManager = null;"], [145, "            for (TrustManager trustManager : trustManagerFactory.getTrustManagers()) {"], [146, "                if (trustManager instanceof X509TrustManager) {"], [147, "                    x509TrustManager = (X509TrustManager) trustManager;"], [149, "            }"], [151, "            if (x509TrustManager == null) {"], [152, "                throw new IllegalStateException("], [153, "                        \"No X509 TrustManager available. Unable to check certificate chain\");"], [154, "            } else {"], [155, "                x509TrustManager.checkServerTrusted("], [156, "                        certificateChain.toArray(new X509Certificate[certificateChain.size()]),"], [157, "                        ServletConstants.SIGNATURE_TYPE);"], [158, "            }"], [160, "            /*"], [161, "             * verify Echo API's hostname is specified as one of subject alternative names on the"], [162, "             * signing certificate"], [163, "             */"], [164, "            if (!subjectAlernativeNameListContainsEchoSdkDomainName(signingCertificate"], [165, "                    .getSubjectAlternativeNames())) {"], [166, "                throw new CertificateException("], [167, "                        \"The provided certificate is not valid for the Echo SDK\");"], [170, "            return signingCertificate;"], [171, "        } catch (KeyStoreException | IOException | NoSuchAlgorithmException ex) {"], [172, "            throw new CertificateException(\"Unable to verify certificate at URL: \""], [173, "                    + signingCertificateChainUrl, ex);"], [250, "}"]]}, "num_lines_added": 88, "num_lines_removed": 51}