{"hash": "eb315f513133bb599d94af33b6b28f718b084d4f", "message": "Don't load the DTD.  See issue #13.", "file_num_lines": 107, "diff_parsed": {"added": [[29, "import java.util.ArrayList;"], [30, "import java.util.List;"], [37, "import org.xml.sax.EntityResolver;"], [38, "import org.xml.sax.InputSource;"], [59, "\tdocBuilder.setEntityResolver(new EntityResolver() {"], [60, "\t\tpublic InputSource resolveEntity(String publicId, String systemId) {"], [61, "\t\t    if (publicId.equals(\"-//Apple Computer//DTD PLIST 1.0//EN\") || // older publicId"], [62, "\t\t\tpublicId.equals(\"-//Apple//DTD PLIST 1.0//EN\")) { // newer publicId"], [63, "\t\t\t// return a dummy, zero length DTD so we don't have to fetch"], [64, "\t\t\t// it from the network."], [65, "\t\t\treturn new InputSource(new ByteArrayInputStream(new byte[0]));"], [66, "\t\t    }"], [67, "\t\t    return null;"], [68, "\t\t}"], [69, "\t    });"], [121, "        List<Node> rootNodes = filterElementNodes(doc.getDocumentElement().getChildNodes());"], [122, "        if(rootNodes.size() > 0)"], [123, "            return parseObject(rootNodes.get(0));"], [138, "            List<Node> children = filterElementNodes(n.getChildNodes());"], [139, "\t    for (int i = 0; i < children.size(); i += 2) {"], [140, "\t\tNode key = children.get(i);"], [141, "\t\tNode val = children.get(i+1);"], [142, "\t\tdict.put(key.getChildNodes().item(0).getNodeValue(), parseObject(val));"], [146, "            List<Node> children = filterElementNodes(n.getChildNodes());"], [147, "\t    NSArray array = new NSArray(children.size());"], [148, "\t    for (int i = 0; i < children.size(); i++) {"], [149, "\t\tarray.setValue(i, parseObject(children.get(i)));"], [150, "\t    }"], [151, "\t    return array;"], [176, "     * Returns all element nodes that are contained in a list of nodes."], [178, "     * @return The sublist of nodes which have an element type."], [180, "    private static List<Node> filterElementNodes(NodeList list) {"], [181, "\tList<Node> result = new ArrayList<Node>();"], [182, "\tfor (int i=0; i<list.getLength(); i++) {"], [183, "\t    if (list.item(i).getNodeType()==Node.ELEMENT_NODE) {"], [184, "\t\tresult.add(list.item(i));"], [185, "\t    }"], [186, "\t}"], [187, "\treturn result;"]], "deleted": [[29, "import java.util.LinkedList;"], [44, "    private static boolean skipTextNodes = false;"], [53, "        boolean offline = false;"], [54, "        try {"], [55, "            URL dtdUrl = new URL(\"http://www.apple.com/DTDs/PropertyList-1.0.dtd\");"], [56, "            InputStream dtdIs = dtdUrl.openStream();"], [57, "            dtdIs.read();"], [58, "            dtdIs.close();"], [59, "            //If we came this far the DTD is accessible"], [60, "        } catch (Exception ex) {"], [61, "            System.out.println(\"DTD is not accessible: \"+ex.getLocalizedMessage());"], [62, "            System.out.println(\"Switching to offline parsing\");"], [63, "            offline = true;"], [64, "        }"], [66, ""], [67, "        if(System.getProperty(\"java.vendor\").toLowerCase().contains(\"android\")) {"], [68, "            //The Android parser works differently"], [69, "            //See discussion around issue 13 (https://code.google.com/p/plist/issues/detail?id=13)"], [70, "            docBuilderFactory.setValidating(false);"], [71, "            skipTextNodes = true;"], [72, "        } else {"], [73, "            if(offline) {"], [74, "                docBuilderFactory.setFeature(\"http://apache.org/xml/features/nonvalidating/load-external-dtd\", false);"], [75, "                docBuilderFactory.setValidating(false);"], [76, "                skipTextNodes = true;"], [77, "            } else {"], [78, "                docBuilderFactory.setValidating(true);"], [79, "                docBuilderFactory.setIgnoringElementContentWhitespace(true);"], [80, "                skipTextNodes = false;"], [81, "            }"], [82, "        }"], [83, ""], [84, ""], [139, "        NodeList rootNodes = doc.getDocumentElement().getChildNodes();"], [140, "        int rootIndex = getNextElementNode(rootNodes, 0);"], [141, "        if(rootIndex!=-1)"], [142, "            return parseObject(rootNodes.item(rootIndex));"], [157, "            NodeList children = n.getChildNodes();"], [158, "            if(skipTextNodes) {"], [159, "                for (int i = getNextElementNode(children, 0); i != -1; i = getNextElementNode(children, i+1)) {"], [160, "                    Node key = children.item(i);"], [161, "                    i = getNextElementNode(children, i+1);"], [162, "                    Node val = children.item(i);"], [163, ""], [164, "                    dict.put(key.getChildNodes().item(0).getNodeValue(), parseObject(val));"], [165, "                }"], [166, "            } else {"], [167, "                for (int i = 0; i < children.getLength(); i += 2) {"], [168, "                    Node key = children.item(i);"], [169, "                    Node val = children.item(i+1);"], [170, ""], [171, "                    dict.put(key.getChildNodes().item(0).getNodeValue(), parseObject(val));"], [172, "                }"], [176, "            NodeList children = n.getChildNodes();"], [177, "            if(skipTextNodes) {"], [178, "                LinkedList<NSObject> objects = new LinkedList<NSObject>();"], [179, "                for (int i = getNextElementNode(children, 0); i != -1; i = getNextElementNode(children,i+1)) {"], [180, "                    objects.add(parseObject(children.item(i)));"], [181, "                }"], [182, "                return new NSArray(objects.toArray(new NSObject[objects.size()]));"], [183, "            }"], [184, "            else {"], [185, "                NSArray array = new NSArray(children.getLength());"], [186, "                for (int i = 0; i < children.getLength(); i++) {"], [187, "                    array.setValue(i, parseObject(children.item(i)));"], [188, "                }"], [189, "                return array;"], [190, "            }"], [215, "     * Finds the next element node, starting from the given index."], [217, "     * @param startIndex The index from where to start searching"], [218, "     * @return The next index of an element node or -1 if none is found."], [220, "    private static int getNextElementNode(NodeList list, int startIndex) {"], [221, "        for(int i=startIndex;i<list.getLength();i++) {"], [222, "            if(list.item(i).getNodeType()==Node.ELEMENT_NODE)"], [223, "                return i;"], [224, "        }"], [225, "        return -1;"]]}, "num_lines_added": 39, "num_lines_removed": 77}