{"hash": "6a434603addd734c7da065dbe76596bf07b01e58", "message": "use correlationId to identify RpcFuture, logId can be set by application (#115)\n\n* bugfix: healthy checktimer checks instances which are deleted by NamingService\r\n\r\n* add serviceId to NamingOptions\r\n\r\n* optimize: add exception stack trace to RpcException\r\n\r\n* add attachment to http headers for http protocol\r\n\r\n* add isShutdown\r\n\r\n* use correlationId to identify RpcFuture, logId can be set by application", "file_num_lines": 637, "diff_parsed": {"added": [[96, "    private static final String CORRELATION_ID = \"correlationId\";"], [124, "        prohibitedHeaders.add(CORRELATION_ID);"], [166, "        boolean decodeSuccess = false;"], [189, "                decodeSuccess = true;"], [194, "            if (decodeSuccess) {"], [236, "            nettyHttpRequest.headers().set(CORRELATION_ID, httpRequest.getCorrelationId());"], [283, "            Long correlationId = parseCorrelationId(httpResponse.headers().get(CORRELATION_ID), channelInfo.getCorrelationId());"], [285, "            response.setCorrelationId(correlationId);"], [286, "            RpcFuture future = channelInfo.removeRpcFuture(response.getCorrelationId());"], [356, "            long correlationId = parseCorrelationId(httpRequest.headers().get(CORRELATION_ID), null);"], [357, "            httpRequest.setCorrelationId(correlationId);"], [605, "        fullHttpResponse.headers().set(HttpHeaderNames.CONTENT_TYPE,"], [606, "                fullHttpRequest.headers().get(HttpHeaderNames.CONTENT_TYPE));"], [610, "        if (fullHttpRequest.headers().contains(CORRELATION_ID)) {"], [611, "            fullHttpResponse.headers().set(CORRELATION_ID, fullHttpRequest.headers().get(CORRELATION_ID));"], [676, "    // \u89e3\u6790correlationId"], [677, "    public long parseCorrelationId(String headerCorrelationId, Long channelAttachCorrelationId) {"], [678, "        // \u4ee5headerCorrelationId\u4e3a\u51c6\uff0cheaderCorrelationId\u4e3anull\u5219\u4ee5channelAttachCorrelationId\u4e3a\u51c6"], [679, "        if (headerCorrelationId != null) {"], [680, "            return Long.valueOf(headerCorrelationId);"], [681, "        } else if (channelAttachCorrelationId != null) {"], [682, "            return channelAttachCorrelationId;"]], "deleted": [[96, "    private static final String LOG_ID = \"log-id\";"], [124, "        prohibitedHeaders.add(LOG_ID);"], [166, ""], [193, "            if (httpMessage != null) {"], [194, "                // decode success"], [236, "            nettyHttpRequest.headers().set(LOG_ID, httpRequest.getLogId());"], [283, "            Long logId = parseLogId(httpResponse.headers().get(LOG_ID), channelInfo.getLogId());"], [285, "            response.setLogId(logId);"], [286, "            RpcFuture future = channelInfo.removeRpcFuture(response.getLogId());"], [349, ""], [357, "            long logId = parseLogId(httpRequest.headers().get(LOG_ID), null);"], [358, "            httpRequest.setLogId(logId);"], [391, ""], [393, "            httpRequest.setLogId(logId);"], [608, "        fullHttpResponse.headers().set(HttpHeaderNames.CONTENT_TYPE, fullHttpRequest.headers().get(HttpHeaderNames.CONTENT_TYPE));"], [612, "        if (fullHttpRequest.headers().contains(LOG_ID)) {"], [613, "            fullHttpResponse.headers().set(LOG_ID, fullHttpRequest.headers().get(LOG_ID));"], [678, "    // \u89e3\u6790log_id"], [679, "    public long parseLogId(String headerLogId, Long channelAttachLogId) {"], [680, "        // \u4ee5headerLogId\u4e3a\u51c6\uff0cheaderLogId\u4e3anull\u5219\u4ee5channelAttachLogId\u4e3a\u51c6"], [681, "        if (headerLogId != null) {"], [682, "            return Long.valueOf(headerLogId);"], [683, "        } else if (channelAttachLogId != null) {"], [684, "            return channelAttachLogId;"]]}, "num_lines_added": 22, "num_lines_removed": 24}