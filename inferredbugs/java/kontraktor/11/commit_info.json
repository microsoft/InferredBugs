{"hash": "def480129a7c5777f7fd4135e5bf9d02e00873b1", "message": "scheduler fully working", "file_num_lines": 285, "diff_parsed": {"added": [[7, "import java.util.*;"], [8, "import java.util.concurrent.ConcurrentLinkedQueue;"], [55, "    private Scheduler scheduler;"], [60, "    private Actor actors[] = new Actor[0];"], [61, "    ConcurrentLinkedQueue<Actor> toAdd = new ConcurrentLinkedQueue<>();"], [76, "    public void addActor(Actor act) {"], [77, "        toAdd.offer(act);"], [80, "    // removes immediate must be called from this thread"], [81, "    void removeActorImmediate(Actor act) {"], [82, "        if ( Thread.currentThread() != this )"], [83, "            throw new RuntimeException(\"wrong thread\");"], [84, "        Actor newAct[] = new Actor[actors.length-1];"], [85, "        int idx = 0;"], [86, "        for (int i = 0; i < actors.length; i++) {"], [87, "            Actor actor = actors[i];"], [88, "            if ( actor != act)"], [89, "                newAct[idx++] = actor;"], [91, "        if ( idx != newAct.length )"], [92, "            throw new RuntimeException(\"could not remove actor\");"], [93, "        actors = newAct;"], [98, "        int scheduleNewActorCount = 0;"], [103, "                scheduleNewActorCount++;"], [104, "                if ( scheduleNewActorCount > 500 ) {"], [105, "                    scheduleNewActorCount = 0;"], [106, "                    schedulePendingAdds();"], [107, "                }"], [114, "                if ( scheduler.getBackoffStrategy().isSleeping(emptyCount) ) {"], [115, "                    scheduleNewActorCount = 0;"], [116, "                    schedulePendingAdds();"], [117, "                    if ( System.currentTimeMillis()-created > 3000 ) {"], [118, "                        if ( actors.length == 0 && toAdd.peek() == null ) {"], [119, "                            shutDown();"], [120, "                        } else {"], [121, "                            scheduler.tryStopThread(this);"], [122, "                        }"], [130, "            if ( actors.length > 0 ) {"], [132, "                scheduler.tryStopThread(this);"], [133, "                i = 0;"], [139, "    private void schedulePendingAdds() {"], [140, "        ArrayList<Actor> newOnes = new ArrayList<>();"], [141, "        Actor a;"], [142, "        while ( (a=toAdd.poll()) != null ) {"], [143, "            newOnes.add(a);"], [144, "        }"], [145, "        if ( newOnes.size() > 0 ) {"], [146, "            Actor newQueue[] = new Actor[newOnes.size()+actors.length];"], [147, "            System.arraycopy(actors,0,newQueue,0,actors.length);"], [148, "            for (int i = 0; i < newOnes.size(); i++) {"], [149, "                Actor actor = newOnes.get(i);"], [150, "                newQueue[actors.length+i] = actor;"], [152, "            actors = newQueue;"], [154, ""], [157, "    // poll all actors in queue arr round robin"], [159, "    protected CallEntry pollQueues(Actor[] actors) {"], [160, "        if ( count >= actors.length ) {"], [163, "            if ( actors.length == 0 ) {"], [167, "        CallEntry res = (CallEntry) actors[count].__cbQueue.poll();"], [169, "            res = (CallEntry) actors[count].__mailbox.poll();"], [183, "        CallEntry poll = pollQueues(actors); // first callback actors"], [189, "                if (  profileCounter > nextProfile && poll.getTarget() instanceof Actor ) {"], [212, "                    removeActorImmediate(actor);"], [244, "        if (load > 80 && actors.length > 1 && System.currentTimeMillis()-created > 1000 ) { // FIXME: constant"], [246, "            if (loadCounter > 2) { // FIXME: constant"], [253, "    // must be called in thread. newOne is expected to not yet started"], [254, "    void splitTo( DispatcherThread newOne ) {"], [256, "        long myTime = 0;"], [257, "        long otherTime = 0;"], [258, "        Arrays.sort(actors, new Comparator() {"], [259, "            @Override"], [260, "            public int compare(Object o1, Object o2) {"], [261, "                return (((Actor)o1).__nanos - ((Actor)o2).__nanos) > 0 ? -1 : 1;"], [263, "        });"], [264, "        for (int i = 0; i < actors.length; i++) {"], [265, "            Actor act = (Actor) actors[i];"], [266, "            long nan = act.__nanos;"], [267, "            if (otherTime < myTime) {"], [268, "                otherTime += nan;"], [269, "            } else {"], [270, "                myTime += nan;"], [273, "        //if ( 8*myTime > otherTime && 8*otherTime > myTime )"], [274, "        //                                    {"], [275, "        myTime = otherTime = 0;"], [276, "        ArrayList<Actor> new2ScheduleOnMe = new ArrayList<>();"], [277, "        ArrayList<Actor> new2ScheduleOnOther = new ArrayList<>();"], [278, "        for (int i = 0; i < actors.length; i++) {"], [279, "            Actor act = (Actor) actors[i];"], [280, "            long nan = act.__nanos;"], [281, "            if (otherTime < myTime) {"], [282, "                new2ScheduleOnOther.add(act);"], [283, "                otherTime += nan;"], [284, "                act.__currentDispatcher = newOne;"], [285, "            } else {"], [286, "                new2ScheduleOnMe.add(act);"], [287, "                myTime += nan;"], [288, "            }"], [289, "        }"], [290, "        actors = new Actor[new2ScheduleOnMe.size()];"], [291, "        new2ScheduleOnMe.toArray(actors);"], [292, "        newOne.actors = new Actor[new2ScheduleOnOther.size()];"], [293, "        new2ScheduleOnOther.toArray(newOne.actors);"], [294, "        System.out.println(\"distributeion \" + myTime + \":\" + otherTime + \" actors \" + actors.length);"], [295, "        created = System.currentTimeMillis();"], [303, "        final Actor actors[] = this.actors;"], [304, "        for (int i = 0; i < actors.length; i++) {"], [305, "            MpscConcurrentQueue queue = (MpscConcurrentQueue) actors[i].__mailbox;"], [318, "        final Actor actors[] = this.actors;"], [319, "        for (int i = 0; i < actors.length; i++) {"], [320, "            Actor a = actors[i];"], [329, "        final Actor actors[] = this.actors;"], [330, "        for (int i = 0; i < actors.length; i++) {"], [331, "            Actor a = actors[i];"], [332, "            res+=a.__mailbox.size();"], [333, "            res+=a.__cbQueue.size();"], [360, "        for (int i = 0; i < actors.length; i++) {"], [361, "            Actor act = actors[i];"], [362, "            if ( ! act.__mailbox.isEmpty() || ! act.__cbQueue.isEmpty() )"], [379, ""], [380, "    public Actor[] getActors() {"], [381, "        Actor actors[] = this.actors;"], [382, "        Actor res[] = new Actor[actors.length];"], [383, "        System.arraycopy(actors,0,res,0,res.length);"], [384, "        return res;"], [385, "    }"]], "deleted": [[7, "import java.util.ArrayList;"], [8, "import java.util.Collections;"], [9, "import java.util.Comparator;"], [10, "import java.util.Queue;"], [55, ""], [58, "    Scheduler scheduler;"], [63, "    ArrayList<Actor> queueList = new ArrayList<>();"], [64, "    Queue queues[] = new Queue[0];"], [65, "    Queue cbQueues[]= new Queue[0];"], [66, ""], [67, "    protected int instanceNum;"], [82, "    public void addActor(Actor a) {"], [83, "        synchronized (queueList) {"], [84, "            queueList.add(a);"], [85, "        }"], [88, "    public void removeActor(Actor a) {"], [89, "        synchronized (queueList) {"], [90, "            queueList.remove(a);"], [98, ""], [107, "                if ( scheduler.getBackoffStrategy().isSleeping(emptyCount) && System.currentTimeMillis()-created > 3000 ) {"], [108, "                    if ( queueList.size() == 0 ) {"], [109, "                        shutDown = true;"], [110, "                    } else {"], [111, "                        scheduler.tryStopThread(this);"], [119, "            if ( queueList.size() > 0 ) {"], [121, "                run(); // for now keep things going .."], [122, "                break;"], [128, "    // if list of queues to schedule has changed,"], [129, "    // apply the change. needs to be done in thread"], [130, "    void applyQueueList() {"], [131, "        synchronized (queueList) {"], [132, "            Queue queues[] = new Queue[queueList.size()];"], [133, "            Queue cbQueues[] = new Queue[queueList.size()];"], [134, "            for (int i = 0; i < queues.length; i++) {"], [135, "                queues[i] = queueList.get(i).__mailbox;"], [136, "                cbQueues[i] = queueList.get(i).__cbQueue;"], [138, "            this.queues = queues;"], [139, "            this.cbQueues = cbQueues;"], [143, "    // poll all queues in queue arr round robin"], [145, "    protected CallEntry pollQueues(Queue[] cbQueues, Queue[] queueArr) {"], [146, "        if ( count >= queueArr.length ) {"], [149, "            if ( queueArr.length != queueList.size() ) {"], [150, "                applyQueueList();"], [151, "            }"], [152, "            if ( queueArr.length == 0 ) {"], [156, "        CallEntry res = (CallEntry) cbQueues[count].poll();"], [158, "            res = (CallEntry) queueArr[count].poll();"], [159, ""], [173, "        CallEntry poll = pollQueues(cbQueues, queues); // first callback queues"], [179, "                if (  profileCounter > nextProfile && queueList.size() > 1 && poll.getTarget() instanceof Actor ) {"], [202, "                    removeActor(actor);"], [203, "                    applyQueueList();"], [235, "        if (load > 80 && queueList.size() > 1 && System.currentTimeMillis()-created > 1000 ) {"], [237, "            if (loadCounter > 2) {"], [244, "    // must be called in thread"], [245, "    public void splitTo( DispatcherThread newOne ) {"], [247, "        synchronized (queueList) {"], [248, "            long myTime = 0;"], [249, "            long otherTime = 0;"], [250, "            Collections.sort(queueList, new Comparator<Actor>() {"], [251, "                @Override"], [252, "                public int compare(Actor o1, Actor o2) {"], [253, "                    return (o1.__nanos - o2.__nanos) > 0 ? -1 : 1;"], [254, "                }"], [255, "            });"], [256, "            for (int i = 0; i < queueList.size(); i++) {"], [257, "                Actor act = queueList.get(i);"], [258, "                long nan = act.__nanos;"], [259, "                if (otherTime < myTime) {"], [260, "                    otherTime += nan;"], [261, "                } else {"], [262, "                    myTime += nan;"], [263, "                }"], [265, "            //if ( 8*myTime > otherTime && 8*otherTime > myTime )"], [266, "            //                                    {"], [267, "            myTime = otherTime = 0;"], [268, "            for (int i = 0; i < queueList.size(); i++) {"], [269, "                Actor act = queueList.get(i);"], [270, "                long nan = act.__nanos;"], [271, "                if (otherTime < myTime) {"], [272, "                    newOne.queueList.add(act);"], [273, "                    queueList.remove(act);"], [274, "                    i--;"], [275, "                    otherTime += nan;"], [276, "                    act.__currentDispatcher = newOne;"], [277, "                } else {"], [278, "                    myTime += nan;"], [279, "                }"], [281, "            System.out.println(\"distributeion \" + myTime + \":\" + otherTime + \" actors \" + queues.length);"], [282, "            created = System.currentTimeMillis();"], [283, "            applyQueueList();"], [284, "            newOne.applyQueueList();"], [293, "        for (int i = 0; i < queues.length; i++) {"], [294, "            MpscConcurrentQueue queue = (MpscConcurrentQueue) queues[i];"], [307, "        for (int i = 0; i < queueList.size(); i++) {"], [308, "            Actor a = queueList.get(i);"], [317, "        for (int i = 0; i < queues.length; i++) {"], [318, "            Queue queue = queues[i];"], [319, "            res+=queue.size();"], [320, "        }"], [321, "        for (int i = 0; i < queues.length; i++) {"], [322, "            Queue queue = cbQueues[i];"], [323, "            res+=queue.size();"], [350, "        for (int i = 0; i < queues.length; i++) {"], [351, "            Queue queue = queues[i];"], [352, "            if ( ! queue.isEmpty() )"], [353, "                return false;"], [354, "        }"], [355, "        for (int i = 0; i < cbQueues.length; i++) {"], [356, "            Queue queue = cbQueues[i];"], [357, "            if ( ! queue.isEmpty() )"]]}, "num_lines_added": 123, "num_lines_removed": 111}