{"hash": "328b572ec806a4d38451342846320b122c99c43f", "message": "scheduler impl, global 2 schedule q required", "file_num_lines": 273, "diff_parsed": {"added": [[8, "import java.util.ArrayList;"], [21, "    public static final int DEFQSIZE = 16384;"], [22, ""], [25, "    volatile DispatcherThread threads[];"], [27, "    int defQSize = DEFQSIZE;"], [31, "    public ElasticScheduler(int maxThreads) {"], [32, "        this(maxThreads, DEFQSIZE);"], [33, "    }"], [34, ""], [41, "    public int getActiveThreads() {"], [42, "        int res = 0;"], [43, "        for (int i = 0; i < threads.length; i++) {"], [44, "            if ( threads[i] != null ) {"], [45, "                res++;"], [46, "            }"], [47, ""], [48, "        }"], [49, "        return res;"], [50, "    }"], [51, ""], [219, "            DispatcherThread minThread = findMinLoadThread(minLoad, null);"], [232, "    private DispatcherThread findMinLoadThread(long minLoad, DispatcherThread dispatcherThread) {"], [237, "                if (thread != null && thread != dispatcherThread) {"], [238, "                    long load = thread.getLoadNanos();"], [263, "    Object balanceLock = new Object();"], [264, ""], [271, "        synchronized (balanceLock) {"], [272, "            long load = dispatcherThread.getLoadNanos();"], [273, "            DispatcherThread minLoadThread = createNewThreadIfPossible();"], [274, "            if (minLoadThread != null) {"], [275, "                // split"], [276, "                dispatcherThread.splitTo(minLoadThread);"], [277, "                minLoadThread.start();"], [278, "                return;"], [279, "            }"], [280, "            minLoadThread = findMinLoadThread(2 * load / 3, null);"], [281, "            if (minLoadThread == null || minLoadThread == dispatcherThread) {"], [282, "                // does not pay off. stay on current"], [283, "                //            System.out.println(\"no rebalance possible\");"], [284, "                return;"], [285, "            }"], [286, "            // move cheapest actor"], [287, "            synchronized (dispatcherThread.queueList) {"], [288, "                ArrayList<Actor> qList = new ArrayList<>(dispatcherThread.queueList);"], [289, "                long otherLoad = minLoadThread.getLoadNanos();"], [290, "                for (int i = 0; i < qList.size(); i++) {"], [291, "                    Actor actor = qList.get(i);"], [292, "                    if (otherLoad + actor.__nanos < load - actor.__nanos) {"], [293, "                        otherLoad += actor.__nanos;"], [294, "                        load -= actor.__nanos;"], [295, "                        System.out.println(\"move for idle \" + actor.__nanos + \" myload \" + load + \" otherlOad \" + otherLoad);"], [296, "                        dispatcherThread.removeActor(actor);"], [297, "                        minLoadThread.addActor(actor);"], [298, "                        dispatcherThread.applyQueueList();"], [299, "                    }"], [302, "        }"], [303, "    }"], [304, ""], [305, "    public void tryStopThread(DispatcherThread dispatcherThread) {"], [306, "        synchronized (balanceLock) {"], [307, "            // move cheapest actor"], [308, "            synchronized (dispatcherThread.queueList) {"], [309, "                ArrayList<Actor> qList = new ArrayList<>(dispatcherThread.queueList);"], [310, "                DispatcherThread minLoadThread = findMinLoadThread(Long.MAX_VALUE, dispatcherThread);"], [311, "                if (minLoadThread == null)"], [312, "                    return;"], [313, "                for (int i = 0; i < qList.size(); i++) {"], [314, "                    Actor actor = qList.get(i);"], [315, "                    dispatcherThread.removeActor(actor);"], [316, "                    minLoadThread.addActor(actor);"], [317, "                    dispatcherThread.applyQueueList();"], [318, "                }"], [323, "    @Override"], [324, "    public BackOffStrategy getBackoffStrategy() {"], [325, "        return backOffStrategy;"], [326, "    }"], [327, ""]], "deleted": [[22, "    DispatcherThread threads[];"], [24, "    int defQSize = 30000;"], [201, "            DispatcherThread minThread = findMinLoadThread(minLoad);"], [214, "    private DispatcherThread findMinLoadThread(int minLoad) {"], [219, "                if (thread != null) {"], [220, "                    int load = thread.getLoad();"], [251, "        int load = dispatcherThread.getLoad();"], [252, "        DispatcherThread minLoadThread = createNewThreadIfPossible();"], [253, "        if ( minLoadThread != null ) {"], [254, "            // split"], [255, "            dispatcherThread.splitTo(minLoadThread);"], [256, "            minLoadThread.start();"], [257, "            return;"], [258, "        }"], [259, "        minLoadThread = findMinLoadThread(load / 4);"], [260, "        if ( minLoadThread == null ) {"], [261, "            // does not pay off. stay on current"], [262, "//            System.out.println(\"no rebalance possible\");"], [263, "            return;"], [264, "        }"], [265, "        // move cheapest actor up to half load"], [266, "        synchronized (dispatcherThread.queueList) {"], [267, "            long minNanos = Long.MAX_VALUE;"], [268, "            Actor minActor = null;"], [269, "            for (int i = 0; i < dispatcherThread.queueList.size(); i++) {"], [270, "                Actor actor = dispatcherThread.queueList.get(i);"], [271, "                if (actor.__nanos < minNanos) {"], [272, "                    minNanos = actor.__nanos;"], [273, "                    minActor = actor;"], [276, "            if (minActor != null) {"], [277, "                //                System.out.println(\"move \"+minActor+\" from \"+dispatcherThread+\" to \"+minLoadThread);"], [278, "                dispatcherThread.removeActor(minActor);"], [279, "                minLoadThread.addActor(minActor);"], [280, "                dispatcherThread.applyQueueList();"]]}, "num_lines_added": 77, "num_lines_removed": 34}