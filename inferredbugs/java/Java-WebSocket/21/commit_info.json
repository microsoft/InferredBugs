{"hash": "c9447016df6f74bd04bbd7589643493ea03f1a7e", "message": "enabled the server to decode using several threads\nstarted some experiments on how to write out data the best way", "file_num_lines": 229, "diff_parsed": {"added": [[16, "import java.util.concurrent.Callable;"], [17, "import java.util.concurrent.ExecutorService;"], [18, "import java.util.concurrent.Executors;"], [33, "\tpublic int DECODERS = Runtime.getRuntime().availableProcessors();"], [34, ""], [36, "\t * Holds the list of active_websocktes WebSocket connections. \"Active\" means WebSocket"], [58, "\tprivate Thread selectorthread;"], [59, ""], [60, "\tprivate ExecutorService decoders = Executors.newFixedThreadPool( DECODERS );"], [61, "\tprivate ExecutorService flusher = Executors.newSingleThreadExecutor();"], [62, ""], [63, "\tprivate Set<WebSocket> active_websocktes = new HashSet<WebSocket>();"], [64, "\tprivate Set<WebSocket> write_demands = new HashSet<WebSocket>();"], [101, "\t * Starts the server selectorthread that binds to the currently set port number and"], [107, "\t\tif( selectorthread != null )"], [114, "\t * ServerSocketChannel, effectively killing the server socket selectorthread and"], [126, "\t\tselectorthread.interrupt();"], [171, "\t\tif( selectorthread != null )"], [173, "\t\tselectorthread = Thread.currentThread();"], [185, "\t\ttry {"], [186, "\t\t\twhile ( !selectorthread.isInterrupted() ) {"], [187, "\t\t\t\tSelectionKey key = null;"], [188, "\t\t\t\tWebSocket conn = null;"], [189, "\t\t\t\ttry {"], [190, "\t\t\t\t\tselector.select();"], [191, "\t\t\t\t\tSet<SelectionKey> keys = selector.selectedKeys();"], [192, "\t\t\t\t\tIterator<SelectionKey> i = keys.iterator();"], [193, ""], [194, "\t\t\t\t\twhile ( i.hasNext() ) {"], [195, "\t\t\t\t\t\tkey = i.next();"], [196, ""], [197, "\t\t\t\t\t\ti.remove();"], [198, "\t\t\t\t\t\tif( !key.isValid() ) {"], [199, "\t\t\t\t\t\t\tcontinue;"], [200, "\t\t\t\t\t\t}"], [202, "\t\t\t\t\t\tif( key.isAcceptable() ) {"], [203, "\t\t\t\t\t\t\tSocketChannel client = server.accept();"], [204, "\t\t\t\t\t\t\tclient.configureBlocking( false );"], [205, "\t\t\t\t\t\t\tWebSocket c = new WebSocket( this, Collections.singletonList( draft ), client );"], [206, "\t\t\t\t\t\t\tclient.register( selector, SelectionKey.OP_READ, c );"], [207, "\t\t\t\t\t\t}"], [209, "\t\t\t\t\t\t// if isReadable == true"], [210, "\t\t\t\t\t\t// then the server is ready to read"], [211, "\t\t\t\t\t\tif( key.isReadable() ) {"], [212, "\t\t\t\t\t\t\tconn = (WebSocket) key.attachment();"], [213, "\t\t\t\t\t\t\tasyncQueueRead( conn );"], [214, "\t\t\t\t\t\t\t// conn.handleRead();"], [215, "\t\t\t\t\t\t}"], [217, "\t\t\t\t\t\t// if isWritable == true"], [218, "\t\t\t\t\t\t// then we need to send the rest of the data to the client"], [219, "\t\t\t\t\t\t/*if( key.isValid() && key.isWritable() ) {"], [220, "\t\t\t\t\t\t\tconn = (WebSocket) key.attachment();"], [222, "\t\t\t\t\t\t\tkey.channel().register( selector, SelectionKey.OP_READ, conn );"], [223, "\t\t\t\t\t\t}*/"], [225, "\t\t\t\t\t/*synchronized ( connections ) {"], [226, "\t\t\t\t\t\tIterator<WebSocket> it = this.connections.iterator();"], [227, "\t\t\t\t\t\twhile ( it.hasNext() ) {"], [228, "\t\t\t\t\t\t\t// We have to do this check here, and not in the selectorthread that"], [229, "\t\t\t\t\t\t\t// adds the buffered data to the WebSocket, because the"], [230, "\t\t\t\t\t\t\t// Selector is not selectorthread-safe, and can only be accessed"], [231, "\t\t\t\t\t\t\t// by this selectorthread."], [232, "\t\t\t\t\t\t\tconn = it.next();"], [233, "\t\t\t\t\t\t\tif( conn.hasBufferedData() ) {"], [234, "\t\t\t\t\t\t\t\tconn.flush();"], [235, "\t\t\t\t\t\t\t\t// key.channel().register( selector, SelectionKey.OP_READ | SelectionKey.OP_WRITE, conn );"], [236, "\t\t\t\t\t\t\t}"], [237, "\t\t\t\t\t\t}"], [238, "\t\t\t\t\t}*/"], [239, "\t\t\t\t} catch ( IOException ex ) {"], [240, "\t\t\t\t\tif( key != null )"], [241, "\t\t\t\t\t\tkey.cancel();"], [242, "\t\t\t\t\thandleIOException( conn, ex );"], [245, "\t\t} catch ( RuntimeException e ) {"], [246, "\t\t\t// should hopefully never occur"], [247, "\t\t\tonError( null, e );"], [248, "\t\t\ttry {"], [249, "\t\t\t\tselector.close();"], [250, "\t\t\t} catch ( IOException e1 ) {"], [251, "\t\t\t\tonError( null, e1 );"], [252, "\t\t\t}"], [253, "\t\t\tdecoders.shutdown();"], [254, "\t\t}"], [255, "\t}"], [256, ""], [257, "\tprivate void handleIOException( WebSocket conn, IOException ex ) {"], [258, "\t\tonWebsocketError( conn, ex );// conn may be null here"], [259, "\t\tif( conn != null ) {"], [260, "\t\t\tconn.close( CloseFrame.ABNROMAL_CLOSE );"], [320, "\t\ttry {"], [321, "\t\t\tconn.flush();"], [322, "\t\t} catch ( IOException e ) {"], [323, "\t\t\thandleIOException( conn, e );"], [324, "\t\t}"], [325, "\t\t/*synchronized ( write_demands ) {"], [326, "\t\t\tif( !write_demands.contains( conn ) ) {"], [327, "\t\t\t\twrite_demands.add( conn );"], [328, "\t\t\t\tflusher.submit( new WebsocketWriteTask( conn ) );"], [329, "\t\t\t}"], [330, "\t\t}*/"], [341, "\tprivate boolean asyncQueueRead( WebSocket ws ) {"], [342, "\t\tsynchronized ( active_websocktes ) {"], [343, "\t\t\tif( active_websocktes.contains( ws ) ) {"], [344, "\t\t\t\treturn false;"], [345, "\t\t\t}"], [346, "\t\t\tactive_websocktes.add( ws );// will add ws only if it is not already added"], [347, "\t\t\tdecoders.submit( new WebsocketReadTask( ws ) );"], [348, "\t\t\treturn true;"], [349, "\t\t}"], [350, "\t}"], [351, "\tclass WebsocketReadTask implements Callable<Boolean> {"], [352, ""], [353, "\t\tprivate WebSocket ws;"], [354, ""], [355, "\t\tprivate WebsocketReadTask( WebSocket ws ) {"], [356, "\t\t\tthis.ws = ws;"], [357, "\t\t}"], [358, ""], [359, "\t\t@Override"], [360, "\t\tpublic Boolean call() throws Exception {"], [361, "\t\t\ttry {"], [362, "\t\t\t\tws.handleRead();"], [363, "\t\t\t} catch ( IOException e ) {"], [364, "\t\t\t\te.printStackTrace();"], [365, "\t\t\t\treturn false;"], [366, "\t\t\t} finally {"], [367, "\t\t\t\tsynchronized ( active_websocktes ) {"], [368, "\t\t\t\t\tactive_websocktes.remove( ws );"], [369, "\t\t\t\t}"], [370, "\t\t\t\tselector.wakeup();"], [371, "\t\t\t}"], [372, "\t\t\treturn true;"], [373, "\t\t}"], [374, "\t}"], [375, ""], [376, "\tclass WebsocketWriteTask implements Callable<Boolean> {"], [377, ""], [378, "\t\tprivate WebSocket ws;"], [379, ""], [380, "\t\tprivate WebsocketWriteTask( WebSocket ws ) {"], [381, "\t\t\tthis.ws = ws;"], [382, "\t\t}"], [383, ""], [384, "\t\t@Override"], [385, "\t\tpublic Boolean call() throws Exception {"], [386, "\t\t\ttry {"], [387, "\t\t\t\tws.flush();"], [388, "\t\t\t} catch ( IOException e ) {"], [389, "\t\t\t\thandleIOException( ws, e );"], [390, "\t\t\t} finally {"], [391, "\t\t\t}"], [392, "\t\t\tsynchronized ( write_demands ) {"], [393, "\t\t\t\twrite_demands.remove( ws );"], [394, "\t\t\t}"], [395, "\t\t\treturn true;"], [396, "\t\t}"], [397, "\t}"], [398, ""]], "deleted": [[30, "\t// INSTANCE PROPERTIES /////////////////////////////////////////////////////"], [32, "\t * Holds the list of active WebSocket connections. \"Active\" means WebSocket"], [54, "\tprivate Thread thread;"], [91, "\t * Starts the server thread that binds to the currently set port number and"], [97, "\t\tif( thread != null )"], [104, "\t * ServerSocketChannel, effectively killing the server socket thread and"], [116, "\t\tthread.interrupt();"], [161, "\t\tif( thread != null )"], [163, "\t\tthread = Thread.currentThread();"], [176, "\t\twhile ( !thread.isInterrupted() ) {"], [177, "\t\t\tSelectionKey key = null;"], [178, "\t\t\tWebSocket conn = null;"], [179, "\t\t\ttry {"], [180, "\t\t\t\tselector.select();"], [181, "\t\t\t\tSet<SelectionKey> keys = selector.selectedKeys();"], [182, "\t\t\t\tIterator<SelectionKey> i = keys.iterator();"], [183, ""], [184, "\t\t\t\twhile ( i.hasNext() ) {"], [185, "\t\t\t\t\tkey = i.next();"], [186, ""], [187, "\t\t\t\t\t// Remove the current key"], [188, "\t\t\t\t\ti.remove();"], [189, ""], [190, "\t\t\t\t\t// if isAcceptable == true"], [191, "\t\t\t\t\t// then a client required a connection"], [192, "\t\t\t\t\tif( key.isAcceptable() ) {"], [193, "\t\t\t\t\t\tSocketChannel client = server.accept();"], [194, "\t\t\t\t\t\tclient.configureBlocking( false );"], [195, "\t\t\t\t\t\tWebSocket c = new WebSocket( this, Collections.singletonList( draft ), client );"], [196, "\t\t\t\t\t\tclient.register( selector, SelectionKey.OP_READ, c );"], [197, "\t\t\t\t\t}"], [199, "\t\t\t\t\t// if isReadable == true"], [200, "\t\t\t\t\t// then the server is ready to read"], [201, "\t\t\t\t\tif( key.isReadable() ) {"], [202, "\t\t\t\t\t\tconn = (WebSocket) key.attachment();"], [203, "\t\t\t\t\t\tconn.handleRead();"], [204, "\t\t\t\t\t}"], [206, "\t\t\t\t\t// if isWritable == true"], [207, "\t\t\t\t\t// then we need to send the rest of the data to the client"], [208, "\t\t\t\t\tif( key.isValid() && key.isWritable() ) {"], [209, "\t\t\t\t\t\tconn = (WebSocket) key.attachment();"], [210, "\t\t\t\t\t\tconn.flush();"], [211, "\t\t\t\t\t\tkey.channel().register( selector, SelectionKey.OP_READ, conn );"], [212, "\t\t\t\t\t}"], [213, "\t\t\t\t}"], [214, "\t\t\t\tsynchronized ( connections ) {"], [215, "\t\t\t\t\tIterator<WebSocket> it = this.connections.iterator();"], [216, "\t\t\t\t\twhile ( it.hasNext() ) {"], [217, "\t\t\t\t\t\t// We have to do this check here, and not in the thread that"], [218, "\t\t\t\t\t\t// adds the buffered data to the WebSocket, because the"], [219, "\t\t\t\t\t\t// Selector is not thread-safe, and can only be accessed"], [220, "\t\t\t\t\t\t// by this thread."], [221, "\t\t\t\t\t\tconn = it.next();"], [222, "\t\t\t\t\t\tif( conn.hasBufferedData() ) {"], [224, "\t\t\t\t\t\t\t// key.channel().register( selector, SelectionKey.OP_READ | SelectionKey.OP_WRITE, conn );"], [225, "\t\t\t\t\t\t}"], [227, "\t\t\t\t}"], [228, "\t\t\t} catch ( IOException ex ) {"], [229, "\t\t\t\tif( key != null )"], [230, "\t\t\t\t\tkey.cancel();"], [231, "\t\t\t\tonWebsocketError( conn, ex );// conn may be null here"], [232, "\t\t\t\tif( conn != null ) {"], [233, "\t\t\t\t\tconn.close( CloseFrame.ABNROMAL_CLOSE );"], [295, "\t\tselector.wakeup();"]]}, "num_lines_added": 157, "num_lines_removed": 64}