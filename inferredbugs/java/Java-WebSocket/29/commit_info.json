{"hash": "7ed502d529877012d0acf3ce4f5b68c22328ad34", "message": "further cleanup", "file_num_lines": 261, "diff_parsed": {"added": [[5, "import java.net.Socket;"], [21, "import org.java_websocket.SocketChannelIOHelper;"], [47, "\t * The URI this channel is supposed to connect to."], [51, "\t * The WebSocket instance this channel object wraps."], [55, "\t * The SocketChannel instance this channel uses."], [57, "\tprivate SocketChannel channel = null;"], [73, "\t\tpublic WebSocket createWebSocket( WebSocketAdapter a, Draft d, Socket s ) {"], [74, "\t\t\treturn new WebSocketImpl( WebSocketClient.this, d, s );"], [78, "\t\tpublic WebSocket createWebSocket( WebSocketAdapter a, List<Draft> d, Socket s ) {"], [79, "\t\t\treturn new WebSocketImpl( WebSocketClient.this, d, s );"], [89, "\t * specified URI. The channel does not attampt to connect automatically. You"], [117, "\t/** Returns the protocol version this channel uses. */"], [173, "\t\tchannel = SocketChannel.open();"], [174, "\t\tchannel.configureBlocking( false );"], [175, "\t\tchannel.connect( remote );"], [177, "\t\tchannel.register( selector, SelectionKey.OP_CONNECT );"], [204, "\t\tconn = (WebSocketImpl) wf.createWebSocket( this, draft, channel.socket() );"], [212, "\t\t\t\tSocketChannelIOHelper.batch( conn, channel );"], [219, "\t\t\t\t\tif( key.isReadable() && SocketChannelIOHelper.read( buff, this.conn, channel ) ) {"], [243, "\t\t\tconn.eot( e );"], [255, "\t\t\tchannel.close();"], [259, "\t\tchannel = null;"], [268, "\t\tif( channel.isConnectionPending() ) {"], [269, "\t\t\tchannel.finishConnect();"], [273, "\t\tchannel.register( selector, SelectionKey.OP_READ );"]], "deleted": [[45, "\t * The URI this client is supposed to connect to."], [49, "\t * The WebSocket instance this client object wraps."], [53, "\t * The SocketChannel instance this client uses."], [55, "\tprivate SocketChannel client = null;"], [71, "\t\tpublic WebSocket createWebSocket( WebSocketAdapter a, Draft d, SocketChannel c ) {"], [72, "\t\t\treturn new WebSocketImpl( WebSocketClient.this, d, c );"], [76, "\t\tpublic WebSocket createWebSocket( WebSocketAdapter a, List<Draft> d, SocketChannel c ) {"], [77, "\t\t\treturn new WebSocketImpl( WebSocketClient.this, d, c );"], [87, "\t * specified URI. The client does not attampt to connect automatically. You"], [115, "\t/** Returns the protocol version this client uses. */"], [171, "\t\tclient = SocketChannel.open();"], [172, "\t\tclient.configureBlocking( false );"], [173, "\t\tclient.connect( remote );"], [175, "\t\tclient.register( selector, SelectionKey.OP_CONNECT );"], [202, "\t\tconn = (WebSocketImpl) wf.createWebSocket( this, draft, client );"], [210, "\t\t\t\tconn.flush();"], [217, "\t\t\t\t\tif( key.isReadable() && conn.read( buff ) ) {"], [223, "\t\t\t\t\tif( key.isWritable() ) {"], [224, "\t\t\t\t\t\tconn.flush();"], [225, "\t\t\t\t\t}"], [234, "\t\t\t\t\t\t\tconn.flush();"], [242, "\t\t\treturn;"], [246, "\t\t\tconn.closeConnection( CloseFrame.BUGGYCLOSE, e.toString(), false );"], [247, "\t\t\treturn;"], [259, "\t\t\tclient.close();"], [263, "\t\tclient = null;"], [272, "\t\tif( client.isConnectionPending() ) {"], [273, "\t\t\tclient.finishConnect();"], [277, "\t\tclient.register( selector, SelectionKey.OP_READ );"], [318, "\t * Amount of data buffered/queued but not sent yet."], [319, "\t *"], [320, "\t * In details, it returns the number of bytes of application data (UTF-8 text and binary data)"], [321, "\t * that have been queued using send() but that, as of the last time the event loop"], [322, "\t * started executing a task, had not yet been transmitted to the network."], [323, "\t *"], [324, "\t * @return Amount still buffered/queued but not sent yet."], [325, "\t */"], [326, "\tpublic long getBufferedAmount() {"], [327, "\t\treturn conn.bufferedDataAmount();"], [328, "\t}"], [329, ""], [330, "\t/**"]]}, "num_lines_added": 25, "num_lines_removed": 42}