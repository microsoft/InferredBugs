{"hash": "fa6a335429b12d4189aa99d56c3cf48e98193907", "message": "worked on breaking onWebsocketClose up into onWebsocketCloseInitiated, onWebsocketClosing, onWebsocketClose to give the user more insights/control over the different steps  during the close handshake. This is especially necessary because of the asynchronous nature of the implementation.", "file_num_lines": 524, "diff_parsed": {"added": [[75, "\tprivate volatile boolean closeHandshakeSubmitted = false;"], [76, ""], [77, "\t/** When true no further frames may be submitted to be sent */"], [78, "\tprivate volatile boolean flushandclosestate = false;"], [79, ""], [80, "\t/** When true the socket has been closed */"], [81, "\tprivate volatile boolean isclosed = false;"], [103, "\tprivate String closemessage = null;"], [104, "\tprivate Integer closecode = null;"], [105, "\tprivate Boolean closedremotely = null;"], [106, ""], [144, "\t\tif( !socketBuffer.hasRemaining() || flushandclosestate )"], [157, "\t\tassert ( isClosing() || isFlushAndClose() || !socketBuffer.hasRemaining() );"], [201, "\t\t\t\t\t\t\t\t\tflushAndClose( CloseFrame.PROTOCOL_ERROR, \"wrong http function\", false );"], [211, "\t\t\t\t\t\t\t\t\t\tflushAndClose( e.getCloseCode(), e.getMessage(), false );"], [231, "\t\t\t\t\t\t\tflushAndClose( CloseFrame.PROTOCOL_ERROR, \"wrong http function\", false );"], [249, "\t\t\t\t\t\tflushAndClose( CloseFrame.PROTOCOL_ERROR, \"Wwrong http function\", false );"], [258, "\t\t\t\t\t\t\tflushAndClose( e.getCloseCode(), e.getMessage(), false );"], [292, "\t\tif( flushandclosestate )"], [293, "\t\t\treturn;"], [294, "\t\tassert ( isOpen() );"], [301, "\t\t\t\tif( flushandclosestate )"], [302, "\t\t\t\t\treturn;"], [312, "\t\t\t\t\tif( closeHandshakeSubmitted ) {"], [318, "\t\t\t\t\t\t\tclose( code, reason, true );"], [319, "\t\t\t\t\t\tflushAndClose( code, reason, false );"], [358, ""], [359, "\tprivate void close( int code, String message, boolean remote ) {"], [360, "\t\tif( !closeHandshakeSubmitted ) {"], [363, "\t\t\t\t\tassert ( remote == false );"], [364, "\t\t\t\t\tflushAndClose( code, message, false );"], [365, "\t\t\t\t\tcloseHandshakeSubmitted = true;"], [371, "\t\t\t\t\t\twsl.onWebsocketCloseInitiated( this, code, message );"], [374, "\t\t\t\t\t\tflushAndClose( CloseFrame.ABNORMAL_CLOSE, \"generated frame is invalid\", false );"], [377, "\t\t\t\t\tflushAndClose( code, message, false );"], [380, "\t\t\t\tassert ( remote );"], [381, "\t\t\t\tflushAndClose( CloseFrame.FLASHPOLICY, message, true );"], [383, "\t\t\t\tflushAndClose( CloseFrame.NEVERCONNECTED, message, false );"], [386, "\t\t\t\tflushAndClose( code, message, remote );"], [387, "\t\t\tcloseHandshakeSubmitted = true;"], [393, "\t@Override"], [394, "\tpublic void close( int code, String message ) {"], [395, "\t\tclose( code, message, false );"], [396, "\t}"], [397, ""], [408, "\t\tif( isclosed ) {"], [412, "\t\tif( key != null ) {"], [420, "\t\t}"], [426, ""], [427, "\t\tisclosed = true;"], [428, ""], [434, ""], [435, "\tpublic void closeConnection() {"], [436, "\t\tif( closedremotely == null ) {"], [437, "\t\t\tthrow new IllegalStateException( \"this method must be used in conjuction with flushAndClose\" );"], [438, "\t\t}"], [439, "\t\tcloseConnection( closecode, closemessage, closedremotely );"], [440, "\t}"], [441, ""], [442, "\tpublic void closeConnection( int code, String message ) {"], [443, "\t\tcloseConnection( code, message, false );"], [444, "\t}"], [445, ""], [446, "\tprotected synchronized void flushAndClose( int code, String message, boolean remote ) {"], [447, "\t\tif( flushandclosestate ) {"], [448, "\t\t\treturn;"], [449, "\t\t}"], [450, "\t\tclosecode = code;"], [451, "\t\tclosemessage = message;"], [452, "\t\tclosedremotely = remote;"], [453, ""], [454, "\t\tflushandclosestate = true;"], [455, ""], [456, "\t\twsl.onWriteDemand( this ); // ensures that all outgoing frames are flushed before closing the connection"], [457, ""], [458, "\t\tthis.wsl.onWebsocketCloseInitiated( this, code, message );"], [459, "\t\tif( draft != null )"], [460, "\t\t\tdraft.reset();"], [461, "\t\ttempContiniousFrame = null;"], [462, "\t\thandshakerequest = null;"], [463, "\t}"], [482, "\t\tclose( code, \"\", false );"], [487, "\t\tclose( e.getCloseCode(), e.getMessage(), false );"], [625, "\t\treturn ( !flushandclosestate && !closeHandshakeSubmitted && !handshakeComplete );"], [630, "\t\treturn ( !flushandclosestate && !isclosed && !closeHandshakeSubmitted && handshakeComplete );"], [635, "\t\treturn ( !isclosed && closeHandshakeSubmitted );"], [636, "\t}"], [637, ""], [638, "\t@Override"], [639, "\tpublic boolean isFlushAndClose() {"], [640, "\t\treturn flushandclosestate;"], [645, "\t\treturn isclosed;"], [663, "\t\t} else if( isFlushAndClose() ) {"]], "deleted": [[44, " * This is an inner class, used by <tt>WebSocketClient</tt> and <tt>WebSocketServer</tt>, and should never need to be instantiated directly"], [45, " * by your code. However, instances are exposed in <tt>WebSocketServer</tt> through the <i>onClientOpen</i>, <i>onClientClose</i>,"], [46, " * <i>onClientMessage</i> callbacks."], [47, " *"], [79, "\tprivate volatile boolean closeHandshakeSent = false;"], [80, "\t/**"], [81, "\t * Determines whether the connection is open or not"], [82, "\t */"], [83, "\tprivate volatile boolean connectionClosed = false;"], [142, "\t\tif( !socketBuffer.hasRemaining() || connectionClosed )"], [155, "\t\tassert ( isClosing() || isClosed() || !socketBuffer.hasRemaining() );"], [199, "\t\t\t\t\t\t\t\t\tcloseConnection( CloseFrame.PROTOCOL_ERROR, \"wrong http function\", false );"], [209, "\t\t\t\t\t\t\t\t\t\tcloseConnection( e.getCloseCode(), e.getMessage(), false );"], [229, "\t\t\t\t\t\t\tcloseConnection( CloseFrame.PROTOCOL_ERROR, \"wrong http function\", false );"], [247, "\t\t\t\t\t\tcloseConnection( CloseFrame.PROTOCOL_ERROR, \"Wwrong http function\", false );"], [256, "\t\t\t\t\t\t\tcloseConnection( e.getCloseCode(), e.getMessage(), false );"], [305, "\t\t\t\t\tif( closeHandshakeSent ) {"], [311, "\t\t\t\t\t\t\tclose( code, reason );"], [312, "\t\t\t\t\t\tcloseConnection( code, reason, false );"], [351, "\t@Override"], [352, "\tpublic void close( int code, String message ) {"], [353, "\t\tif( !closeHandshakeSent ) {"], [356, "\t\t\t\t\tcloseConnection( code, true );"], [357, "\t\t\t\t\tcloseHandshakeSent = true;"], [365, "\t\t\t\t\t\tcloseConnection( CloseFrame.ABNORMAL_CLOSE, \"generated frame is invalid\", false );"], [368, "\t\t\t\t\tcloseConnection( code, false );"], [371, "\t\t\t\tcloseConnection( CloseFrame.FLASHPOLICY, true );"], [373, "\t\t\t\tcloseConnection( CloseFrame.NEVERCONNECTED, false );"], [376, "\t\t\t\tcloseConnection( code, false );"], [377, "\t\t\tcloseHandshakeSent = true;"], [384, "\t * closes the socket no matter if the closing handshake completed."], [385, "\t * Does not send any not yet written data before closing."], [386, "\t * Calling this method more than once will have no effect."], [396, "\t\tif( connectionClosed ) {"], [399, "\t\tconnectionClosed = true;"], [401, "\t\t/*if( key != null ) {"], [409, "\t\t}*/"], [410, "\t\twsl.onWriteDemand( this ); // ensures that all outgoing frames are flushed before closing the connection"], [411, ""], [440, "\t\tclose( code, \"\" );"], [445, "\t\tclose( e.getCloseCode(), e.getMessage() );"], [583, "\t\treturn ( !connectionClosed && !closeHandshakeSent && !handshakeComplete );"], [588, "\t\treturn ( !connectionClosed && !closeHandshakeSent && handshakeComplete );"], [593, "\t\treturn ( !connectionClosed && closeHandshakeSent );"], [598, "\t\treturn connectionClosed;"], [616, "\t\t} else if( isClosed() ) {"]]}, "num_lines_added": 93, "num_lines_removed": 46}