{"hash": "513fb588d65de5a1437f50c51313a98a1fe18e58", "message": "Stun client transaction re-transmission based on `ScheduledThreadPoolExecutor` (#153)\n\n* Hide Runnable interface in StunClientTransaction class.\r\n\r\n* Use CustomizableThreadFactory to give custom names to threads.\r\n\r\n* Extracted retransmission logic into separate class.\r\n\r\n* Re-implement Retransmitter with ScheduledThreadPoolExecutor.\r\n\r\n* Fixed retransmissionCounter increment.\r\n\r\n* Directly call logger fine methods instead overload with Level.", "file_num_lines": 289, "diff_parsed": {"added": [[22, "import java.util.concurrent.atomic.*;"], [27, "import org.ice4j.util.*;"], [54, "    private static final java.util.logging.Logger logger"], [55, "        = java.util.logging.Logger.getLogger(StunClientTransaction.class.getName());"], [80, "    private static final ScheduledExecutorService retransmissionThreadPool;"], [81, ""], [82, "    static {"], [83, "        CustomizableThreadFactory threadFactory"], [84, "            = new CustomizableThreadFactory(\"ice4j.StunClientTransaction-\", true);"], [85, ""], [86, "        final ScheduledThreadPoolExecutor terminationExecutor"], [87, "            = new ScheduledThreadPoolExecutor(0, threadFactory);"], [88, "        terminationExecutor.setKeepAliveTime(60, TimeUnit.SECONDS);"], [89, "        terminationExecutor.setRemoveOnCancelPolicy(true);"], [90, "        retransmissionThreadPool"], [91, "            = Executors.unconfigurableScheduledExecutorService("], [92, "            terminationExecutor);"], [93, "    }"], [149, "    private final AtomicBoolean cancelled = new AtomicBoolean(false);"], [152, "     * A transaction request retransmitter"], [154, "    private final Retransmitter retransmitter = new Retransmitter();"], [245, "        this.retransmitter.schedule();"], [259, "        if (cancelled.get())"], [286, "    void cancel()"], [288, "        // The cancelled field is initialized to false and then the one and"], [290, "        // code just checks whether it has become true."], [291, "        cancelled.set(true);"], [293, "        this.retransmitter.cancel();"], [304, "        TransactionID transactionID = getTransactionID();"], [305, ""], [306, "        logger.fine(\"handleResponse tid \" + transactionID);"], [307, "        if(!Boolean.getBoolean(StackProperties.KEEP_CRANS_AFTER_A_RESPONSE))"], [309, "            cancel();"], [311, ""], [312, "        responseCollector.processResponse("], [313, "            new StunResponseEvent("], [314, "                stackCallback,"], [315, "                evt.getRawMessage(),"], [316, "                (Response) evt.getMessage(),"], [317, "                request,"], [318, "                transactionID));"], [420, ""], [421, "    /**"], [422, "     * Implements the retransmissions algorithm. Retransmits the request"], [423, "     * starting with an interval of 100ms, doubling every retransmit until the"], [424, "     * interval reaches 1.6s.  Retransmissions continue with intervals of 1.6s"], [425, "     * until a response is received, or a total of 7 requests have been sent."], [426, "     * If no response is received by 1.6 seconds after the last request has been"], [427, "     * sent, we consider the transaction to have failed."], [428, "     */"], [429, "    private final class Retransmitter"], [430, "    {"], [431, "        /**"], [432, "         * Current number of retransmission attempts"], [433, "         */"], [434, "        private int retransmissionCounter = 0;"], [435, ""], [436, "        /**"], [437, "         * Delay before attempting next retransmission"], [438, "         */"], [439, "        private int nextRetransmissionDelay = originalWaitInterval;"], [440, ""], [441, "        /**"], [442, "         * Currently scheduled retransmission task"], [443, "         */"], [444, "        private ScheduledFuture<?> retransmissionFuture;"], [445, ""], [446, "        /**"], [447, "         * The scheduled runnable that perform retransmit attempt"], [448, "         */"], [449, "        private final Runnable retransmissionAttempt = new Runnable()"], [450, "        {"], [451, "            @Override"], [452, "            public void run()"], [453, "            {"], [454, "                if (cancelled.get())"], [455, "                {"], [456, "                    return;"], [457, "                }"], [458, ""], [459, "                retransmissionCounter++;"], [460, ""], [461, "                int curWaitInterval = nextRetransmissionDelay;"], [462, "                nextRetransmissionDelay"], [463, "                    = Math.min(maxWaitInterval, 2 * nextRetransmissionDelay);"], [464, ""], [465, "                try"], [466, "                {"], [467, "                    logger.fine("], [468, "                        \"retrying STUN tid \" + transactionID + \" from \""], [469, "                            + localAddress + \" to \" + requestDestination"], [470, "                            + \" waited \" + curWaitInterval + \" ms retrans \""], [471, "                            + retransmissionCounter + \" of \""], [472, "                            + maxRetransmissions);"], [473, "                    sendRequest0();"], [474, "                }"], [475, "                catch (Exception ex)"], [476, "                {"], [477, "                    //I wonder whether we should notify anyone that a retransmission"], [478, "                    // has failed"], [479, "                    logger.log("], [480, "                        Level.INFO,"], [481, "                        \"A client tran retransmission failed\","], [482, "                        ex);"], [483, "                }"], [484, ""], [485, "                if(!cancelled.get())"], [486, "                {"], [487, "                    reschedule();"], [488, "                }"], [489, "            }"], [490, ""], [491, "            private void reschedule()"], [492, "            {"], [493, "                if (retransmissionCounter < maxRetransmissions)"], [494, "                {"], [495, "                    retransmissionFuture = retransmissionThreadPool.schedule("], [496, "                        retransmissionAttempt,"], [497, "                        nextRetransmissionDelay,"], [498, "                        TimeUnit.MILLISECONDS);"], [499, "                }"], [500, "                else"], [501, "                {"], [502, "                    // before stating that a transaction has timeout-ed we"], [503, "                    // should first wait for a reception of the response"], [504, "                    nextRetransmissionDelay ="], [505, "                        Math.min(maxWaitInterval, 2* nextRetransmissionDelay);"], [506, ""], [507, "                    retransmissionFuture = retransmissionThreadPool.schedule("], [508, "                        transactionTimedOut,"], [509, "                        nextRetransmissionDelay,"], [510, "                        TimeUnit.MILLISECONDS);"], [511, "                }"], [512, "            }"], [513, "        };"], [514, ""], [515, "        /**"], [516, "         * Scheduled runnable to time-out STUN transaction"], [517, "         */"], [518, "        private final Runnable transactionTimedOut = new Runnable()"], [519, "        {"], [520, "            @Override"], [521, "            public void run()"], [522, "            {"], [523, "                if (cancelled.get())"], [524, "                {"], [525, "                    return;"], [526, "                }"], [527, ""], [528, "                stackCallback.removeClientTransaction("], [529, "                    StunClientTransaction.this);"], [530, ""], [531, "                responseCollector.processTimeout("], [532, "                    new StunTimeoutEvent("], [533, "                        stackCallback,"], [534, "                        getRequest(), getLocalAddress(), getTransactionID()));"], [535, "            }"], [536, "        };"], [537, ""], [538, "        /**"], [539, "         * Schedules STUN transaction retransmission"], [540, "         */"], [541, "        void schedule()"], [542, "        {"], [543, "            if (retransmissionFuture != null)"], [544, "            {"], [545, "                return;"], [546, "            }"], [547, ""], [548, "            retransmissionFuture = retransmissionThreadPool.schedule("], [549, "                retransmissionAttempt,"], [550, "                nextRetransmissionDelay,"], [551, "                TimeUnit.MILLISECONDS);"], [552, "        }"], [553, ""], [554, "        /**"], [555, "         * Cancels the transaction. Once this method is called the transaction"], [556, "         * is considered terminated and will stop retransmissions."], [557, "         */"], [558, "        void cancel()"], [559, "        {"], [560, "            final ScheduledFuture<?> retransmissionFuture ="], [561, "                this.retransmissionFuture;"], [562, "            if (retransmissionFuture != null)"], [563, "            {"], [564, "                retransmissionFuture.cancel(true);"], [565, "            }"], [566, "        }"], [567, "    }"]], "deleted": [[22, "import java.util.concurrent.locks.*;"], [49, "    implements Runnable"], [54, "    private static final Logger logger"], [55, "        = Logger.getLogger(StunClientTransaction.class.getName());"], [80, "    private static final ExecutorService retransmissionThreadPool"], [81, "        = Executors.newCachedThreadPool("], [82, "                new ThreadFactory()"], [83, "                {"], [84, "                    /**"], [85, "                     * The default {@code ThreadFactory} implementation which is"], [86, "                     * augmented by this instance to create daemon"], [87, "                     * {@code Thread}s."], [88, "                     */"], [89, "                    private final ThreadFactory defaultThreadFactory"], [90, "                        = Executors.defaultThreadFactory();"], [91, ""], [92, "                    @Override"], [93, "                    public Thread newThread(Runnable r)"], [94, "                    {"], [95, "                        Thread t = defaultThreadFactory.newThread(r);"], [96, ""], [97, "                        if (t != null)"], [98, "                        {"], [99, "                            t.setDaemon(true);"], [100, ""], [101, "                            // Additionally, make it known through the name of"], [102, "                            // the Thread that it is associated with the"], [103, "                            // StunClientTransaction class for"], [104, "                            // debugging/informational purposes."], [105, "                            String name = t.getName();"], [106, ""], [107, "                            if (name == null)"], [108, "                                name = \"\";"], [109, "                            t.setName(\"StunClientTransaction-\" + name);"], [110, "                        }"], [111, "                        return t;"], [112, "                    }"], [113, "                });"], [169, "    private boolean cancelled = false;"], [170, ""], [171, "    /**"], [172, "     * The <tt>Lock</tt> which synchronizes the access to the state of this"], [173, "     * instance. Introduced along with {@link #lockCondition} in order to allow"], [174, "     * the invocation of {@link #cancel(boolean)} without a requirement to"], [175, "     * acquire the synchronization root. Otherwise, callers of"], [176, "     * <tt>cancel(boolean)</tt> may (and have be reported multiple times to)"], [177, "     * fall into a deadlock merely because they want to cancel this"], [178, "     * <tt>StunClientTransaction</tt>."], [179, "     */"], [180, "    private final Lock lock = new ReentrantLock();"], [183, "     * The <tt>Condition</tt> of {@link #lock} which this instance uses to wait"], [184, "     * for either the next retransmission interval or the cancellation of this"], [185, "     * <tt>StunClientTransaction</tt>."], [187, "    private final Condition lockCondition = lock.newCondition();"], [260, "     * Implements the retransmissions algorithm. Retransmits the request"], [261, "     * starting with an interval of 100ms, doubling every retransmit until the"], [262, "     * interval reaches 1.6s.  Retransmissions continue with intervals of 1.6s"], [263, "     * until a response is received, or a total of 7 requests have been sent."], [264, "     * If no response is received by 1.6 seconds after the last request has been"], [265, "     * sent, we consider the transaction to have failed."], [266, "     * <p>"], [267, "     * The method acquires {@link #lock} and invokes {@link #runLocked()}."], [268, "     * </p>"], [269, "     */"], [270, "    @Override"], [271, "    public void run()"], [272, "    {"], [273, "        lock.lock();"], [274, "        try"], [275, "        {"], [276, "            runLocked();"], [277, "        }"], [278, "        finally"], [279, "        {"], [280, "            lock.unlock();"], [281, "        }"], [282, "    }"], [283, ""], [284, "    /**"], [285, "     * Implements the retransmissions algorithm. Retransmits the request"], [286, "     * starting with an interval of 100ms, doubling every retransmit until the"], [287, "     * interval reaches 1.6s.  Retransmissions continue with intervals of 1.6s"], [288, "     * until a response is received, or a total of 7 requests have been sent."], [289, "     * If no response is received by 1.6 seconds after the last request has been"], [290, "     * sent, we consider the transaction to have failed."], [291, "     * <p>"], [292, "     * The method assumes that the current thread has already acquired"], [293, "     * {@link #lock}."], [294, "     * </p>"], [295, "     */"], [296, "    private void runLocked()"], [297, "    {"], [298, "        // Indicates how many times we have retransmitted so far."], [299, "        int retransmissionCounter = 0;"], [300, "        // How much did we wait after our last retransmission?"], [301, "        int nextWaitInterval = originalWaitInterval;"], [302, ""], [303, "        for (retransmissionCounter = 0;"], [304, "             retransmissionCounter < maxRetransmissions;"], [305, "             retransmissionCounter ++)"], [306, "        {"], [307, "            waitFor(nextWaitInterval);"], [308, ""], [309, "            //did someone tell us to get lost?"], [310, "            if(cancelled)"], [311, "                return;"], [312, ""], [313, "            int curWaitInterval = nextWaitInterval;"], [314, "            if(nextWaitInterval < maxWaitInterval)"], [315, "                nextWaitInterval *= 2;"], [316, ""], [317, "            try"], [318, "            {"], [319, "                logger.fine("], [320, "                        \"retrying STUN tid \" + transactionID + \" from \""], [321, "                            + localAddress + \" to \" + requestDestination"], [322, "                            + \" waited \" + curWaitInterval + \" ms retrans \""], [323, "                            + (retransmissionCounter + 1) + \" of \""], [324, "                            + maxRetransmissions);"], [325, "                sendRequest0();"], [326, "            }"], [327, "            catch (Exception ex)"], [328, "            {"], [329, "                //I wonder whether we should notify anyone that a retransmission"], [330, "                // has failed"], [331, "                logger.log("], [332, "                        Level.INFO,"], [333, "                        \"A client tran retransmission failed\","], [334, "                        ex);"], [335, "            }"], [336, "        }"], [337, ""], [338, "        //before stating that a transaction has timeout-ed we should first wait"], [339, "        //for a reception of the response"], [340, "        if(nextWaitInterval < maxWaitInterval)"], [341, "            nextWaitInterval *= 2;"], [342, ""], [343, "        waitFor(nextWaitInterval);"], [344, ""], [345, "        if(cancelled)"], [346, "            return;"], [347, ""], [348, "        stackCallback.removeClientTransaction(this);"], [349, "        responseCollector.processTimeout("], [350, "                new StunTimeoutEvent("], [351, "                        stackCallback,"], [352, "                        this.request, getLocalAddress(), transactionID));"], [353, "    }"], [354, ""], [355, "    /**"], [374, "        retransmissionThreadPool.execute(this);"], [388, "        if(cancelled)"], [412, "     * Waits until next retransmission is due or until the transaction is"], [413, "     * cancelled (whichever comes first)."], [414, "     *"], [415, "     * @param millis the number of milliseconds to wait for."], [416, "     */"], [417, "    void waitFor(long millis)"], [418, "    {"], [419, "        lock.lock();"], [420, "        try"], [421, "        {"], [422, "            lockCondition.await(millis, TimeUnit.MILLISECONDS);"], [423, "        }"], [424, "        catch (InterruptedException ex)"], [425, "        {"], [426, "            throw new RuntimeException(ex);"], [427, "        }"], [428, "        finally"], [429, "        {"], [430, "            lock.unlock();"], [431, "        }"], [432, "    }"], [433, ""], [434, "    /**"], [437, "     *"], [438, "     * @param waitForResponse indicates whether we should wait for the current"], [439, "     * RTO to expire before ending the transaction or immediately terminate."], [441, "    void cancel(boolean waitForResponse)"], [443, "        // XXX The cancelled field is initialized to false and then the one and"], [445, "        // code just checks whether it has become true. Consequently, there"], [446, "        // shouldn't be a problem if the set is outside a synchronized block."], [447, "        // However, it being outside a synchronized block will decrease the risk"], [448, "        // of deadlocks."], [449, "        cancelled = true;"], [450, ""], [451, "        if(!waitForResponse)"], [452, "        {"], [453, "            // Try to interrupt #waitFor(long) if possible. But don't risk a"], [454, "            // deadlock. It is not a problem if it is not possible to interrupt"], [455, "            // #waitFor(long) here because it will complete in finite time and"], [456, "            // this StunClientTransaction will eventually notice that it has"], [457, "            // been cancelled."], [458, "            if (lock.tryLock())"], [459, "            {"], [460, "                try"], [461, "                {"], [462, "                    lockCondition.signal();"], [463, "                }"], [464, "                finally"], [465, "                {"], [466, "                    lock.unlock();"], [467, "                }"], [468, "            }"], [469, "        }"], [470, "    }"], [472, "    /**"], [473, "     * Cancels the transaction. Once this method is called the transaction is"], [474, "     * considered terminated and will stop retransmissions."], [475, "     */"], [476, "    void cancel()"], [477, "    {"], [478, "        cancel(false);"], [489, "        lock.lock();"], [490, "        try"], [491, "        {"], [492, "            TransactionID transactionID = getTransactionID();"], [493, ""], [494, "            logger.log(Level.FINE, \"handleResponse tid \" + transactionID);"], [495, "            if(!Boolean.getBoolean(StackProperties.KEEP_CRANS_AFTER_A_RESPONSE))"], [496, "                cancel();"], [497, ""], [498, "            responseCollector.processResponse("], [499, "                    new StunResponseEvent("], [500, "                            stackCallback,"], [501, "                            evt.getRawMessage(),"], [502, "                            (Response) evt.getMessage(),"], [503, "                            request,"], [504, "                            transactionID));"], [505, "        }"], [506, "        finally"], [508, "            lock.unlock();"]]}, "num_lines_added": 189, "num_lines_removed": 232}