{"hash": "6bed63795f5666a2e34bda80904103f438ad6042", "message": "Reduce number of threads created by ice4j. Eliminate StunKeepAliveThread. (#151)\n\n* Use ScheduleExecutorService to run STUN keep alives.\r\n\r\n* Mark threads as daemon threads.\r\n\r\n* Fixed comments. Rearranged properties read in keep alive runnable.\r\n\r\n* Added early check that keep alives must not be sent\r\n\r\n* Renamed method to check keep alive condition.\r\n\r\n* Fixed formatting.\r\n\r\n* Renamed metrod which check if KA should run.\r\n\r\n* Created CustomizableThreadFactory which support thread name prefixes and if threads are daemons.\r\n\r\n* Created dedicated runnable class which perform STUN keep-alive checks.\r\n\r\n* Minor comments fixes.\r\n\r\n* Do not expose Runnable interface from StunKeepAliveRunner.\r\n\r\n* Mark CustomizableThreadFactory fields as final.\r\n\r\n* Added java doc to CustomizableThreadFactory", "file_num_lines": 1299, "diff_parsed": {"added": [[32, "import org.ice4j.util.*;"], [120, "     *  The ScheduledExecutorService to execute Agent's scheduled tasks"], [122, "    private static final ScheduledExecutorService agentTasksScheduler;"], [126, "        CustomizableThreadFactory threadFactory"], [127, "            = new CustomizableThreadFactory(\"ice4j.Agent-\", true);"], [128, ""], [130, "            = new ScheduledThreadPoolExecutor(0, threadFactory);"], [133, "        agentTasksScheduler"], [155, "     * An instance to schedule STUN checks for selected pair."], [156, "     */"], [157, "    private final StunKeepAliveRunner stunKeepAliveRunner"], [158, "        = new StunKeepAliveRunner();"], [159, ""], [160, "    /**"], [1983, "        scheduleStunKeepAlive();"], [2211, "                        = agentTasksScheduler.schedule("], [2230, "     * Schedules repeated background task which sends STUN keep-alives"], [2231, "     * once this <tt>Agent</tt> is <tt>COMPLETED</tt>."], [2235, "        boolean noKeepAlives"], [2236, "            = StackProperties.getBoolean("], [2237, "                StackProperties.NO_KEEP_ALIVES,"], [2238, "                false);"], [2239, "        if (noKeepAlives || !stunKeepAliveRunner.shouldRunStunKeepAlive())"], [2241, "            return;"], [2243, ""], [2244, "        stunKeepAliveRunner.schedule();"], [2355, "        stunKeepAliveRunner.cancel();"], [2696, ""], [2697, "    /**"], [2698, "     * A class to schedule and perform Stun keep-alive checks"], [2699, "     */"], [2700, "    private final class StunKeepAliveRunner"], [2701, "    {"], [2702, "        private final long consentFreshnessInterval = Long.getLong("], [2703, "            StackProperties.CONSENT_FRESHNESS_INTERVAL,"], [2704, "            DEFAULT_CONSENT_FRESHNESS_INTERVAL);"], [2705, ""], [2706, "        private final int originalConsentFreshnessWaitInterval = Integer.getInteger("], [2707, "            StackProperties.CONSENT_FRESHNESS_ORIGINAL_WAIT_INTERVAL,"], [2708, "            DEFAULT_CONSENT_FRESHNESS_ORIGINAL_WAIT_INTERVAL);"], [2709, ""], [2710, "        private final int maxConsentFreshnessWaitInterval = Integer.getInteger("], [2711, "            StackProperties.CONSENT_FRESHNESS_MAX_WAIT_INTERVAL,"], [2712, "            DEFAULT_CONSENT_FRESHNESS_MAX_WAIT_INTERVAL);"], [2713, ""], [2714, "        private final int consentFreshnessMaxRetransmissions = Integer.getInteger("], [2715, "            StackProperties.CONSENT_FRESHNESS_MAX_RETRANSMISSIONS,"], [2716, "            DEFAULT_CONSENT_FRESHNESS_MAX_RETRANSMISSIONS);"], [2717, ""], [2718, "        /**"], [2719, "         * The scheduled task which sends periodic STUN keep-alive checks."], [2720, "         */"], [2721, "        private ScheduledFuture<?> stunKeepAliveFuture;"], [2722, ""], [2723, "        /**"], [2724, "         * The object used to synchronize access to {@link #stunKeepAliveFuture}."], [2725, "         */"], [2726, "        private final Object stunKeepAliveFutureSyncRoot = new Object();"], [2727, ""], [2728, "        /**"], [2729, "         * Execute STUN keep-alive checks"], [2730, "         */"], [2731, "        private final Runnable runnableCheck = new Runnable()"], [2732, "        {"], [2733, "            @Override"], [2734, "            public void run()"], [2735, "            {"], [2736, "                for (IceMediaStream stream : getStreams())"], [2737, "                {"], [2738, "                    for (Component component : stream.getComponents())"], [2739, "                    {"], [2740, "                        for (CandidatePair pair : component.getKeepAlivePairs())"], [2741, "                        {"], [2742, "                            if (pair != null)"], [2743, "                            {"], [2744, "                                if (performConsentFreshness)"], [2745, "                                {"], [2746, "                                    connCheckClient.startCheckForPair("], [2747, "                                        pair,"], [2748, "                                        originalConsentFreshnessWaitInterval,"], [2749, "                                        maxConsentFreshnessWaitInterval,"], [2750, "                                        consentFreshnessMaxRetransmissions);"], [2751, "                                }"], [2752, "                                else"], [2753, "                                {"], [2754, "                                    connCheckClient"], [2755, "                                        .sendBindingIndicationForPair(pair);"], [2756, "                                }"], [2757, "                            }"], [2758, "                        }"], [2759, "                    }"], [2760, "                }"], [2761, ""], [2762, "                if (!shouldRunStunKeepAlive())"], [2763, "                {"], [2764, "                    cancel();"], [2765, "                }"], [2766, "            }"], [2767, "        };"], [2768, ""], [2769, "        /**"], [2770, "         * Schedules execution of periodic task which performs"], [2771, "         * STUN keep-alive checks"], [2772, "         */"], [2773, "        void schedule()"], [2774, "        {"], [2775, "            if (stunKeepAliveFuture == null)"], [2776, "            {"], [2777, "                synchronized (stunKeepAliveFutureSyncRoot)"], [2778, "                {"], [2779, "                    if (stunKeepAliveFuture == null)"], [2780, "                    {"], [2781, "                        logger.info(\"Starting periodic Stun Keep Alive.\");"], [2782, ""], [2783, "                        stunKeepAliveFuture"], [2784, "                            = agentTasksScheduler.scheduleWithFixedDelay("], [2785, "                            runnableCheck,"], [2786, "                            0,"], [2787, "                            consentFreshnessInterval,"], [2788, "                            TimeUnit.MILLISECONDS);"], [2789, "                    }"], [2790, "                }"], [2791, "            }"], [2792, "        }"], [2793, ""], [2794, "        /**"], [2795, "         * Cancel scheduled periodic task which performs"], [2796, "         * STUN keep-alive checks"], [2797, "         */"], [2798, "        void cancel()"], [2799, "        {"], [2800, "            if (stunKeepAliveFuture != null)"], [2801, "            {"], [2802, "                synchronized (stunKeepAliveFutureSyncRoot)"], [2803, "                {"], [2804, "                    if (stunKeepAliveFuture != null)"], [2805, "                    {"], [2806, "                        stunKeepAliveFuture.cancel(false);"], [2807, "                        stunKeepAliveFuture = null;"], [2808, "                        logger.info(\"Stop periodic Stun Keep Alive.\");"], [2809, "                    }"], [2810, "                }"], [2811, "            }"], [2812, "        }"], [2813, ""], [2814, "        /**"], [2815, "         * Determines whether {@link #stunKeepAliveRunner} should run."], [2816, "         *"], [2817, "         * @return <tt>true</tt> if <tt>{@link #stunKeepAliveRunner}</tt>"], [2818, "         * should run otherwise, <tt>false</tt>"], [2819, "         */"], [2820, "        boolean shouldRunStunKeepAlive()"], [2821, "        {"], [2822, "            IceProcessingState state = Agent.this.state;"], [2823, ""], [2824, "            return"], [2825, "                (IceProcessingState.COMPLETED.equals(state)"], [2826, "                    || IceProcessingState.TERMINATED.equals(state))"], [2827, "                    && !shutdown;"], [2828, "        }"], [2829, "    }"]], "deleted": [[119, "     *  The ScheduledExecutorService to execute planned agent termination"], [121, "    private static final ScheduledExecutorService agentTerminationScheduler;"], [126, "            = new ScheduledThreadPoolExecutor(0);"], [129, "        agentTerminationScheduler"], [292, "     * The thread that we use for STUN keep-alive."], [293, "     */"], [294, "    private Thread stunKeepAliveThread;"], [295, ""], [296, "    /**"], [1978, "        if (stunKeepAliveThread == null"], [1979, "                && !StackProperties.getBoolean("], [1980, "                        StackProperties.NO_KEEP_ALIVES,"], [1981, "                        false))"], [1982, "        {"], [1983, "            // schedule STUN checks for selected candidates"], [1984, "            scheduleStunKeepAlive();"], [1985, "        }"], [2213, "                        = agentTerminationScheduler.schedule("], [2232, "     * Initializes and starts the background <tt>Thread</tt> which is to send"], [2233, "     * STUN keep-alives once this <tt>Agent</tt> is <tt>COMPLETED</tt>."], [2237, "        if (stunKeepAliveThread == null)"], [2239, "            stunKeepAliveThread"], [2240, "                = new Thread()"], [2241, "                        {"], [2242, "                            @Override"], [2243, "                            public void run()"], [2244, "                            {"], [2245, "                                runInStunKeepAliveThread();"], [2246, "                            }"], [2247, "                        };"], [2248, "            stunKeepAliveThread.setDaemon(true);"], [2249, "            stunKeepAliveThread.setName(\"StunKeepAliveThread\");"], [2250, "            stunKeepAliveThread.start();"], [2362, "        if (stunKeepAliveThread != null)"], [2363, "            stunKeepAliveThread.interrupt();"], [2445, "     * Schedule STUN checks for selected pair."], [2446, "     */"], [2447, "    private void runInStunKeepAliveThread()"], [2448, "    {"], [2449, "        long consentFreshnessInterval = Long.getLong("], [2450, "                StackProperties.CONSENT_FRESHNESS_INTERVAL,"], [2451, "                DEFAULT_CONSENT_FRESHNESS_INTERVAL);"], [2452, ""], [2453, "        int originalConsentFreshnessWaitInterval = Integer.getInteger("], [2454, "                StackProperties.CONSENT_FRESHNESS_ORIGINAL_WAIT_INTERVAL,"], [2455, "                DEFAULT_CONSENT_FRESHNESS_ORIGINAL_WAIT_INTERVAL);"], [2456, ""], [2457, "        int maxConsentFreshnessWaitInterval = Integer.getInteger("], [2458, "                StackProperties.CONSENT_FRESHNESS_MAX_WAIT_INTERVAL,"], [2459, "                DEFAULT_CONSENT_FRESHNESS_MAX_WAIT_INTERVAL);"], [2460, ""], [2461, "        int consentFreshnessMaxRetransmissions = Integer.getInteger("], [2462, "                StackProperties.CONSENT_FRESHNESS_MAX_RETRANSMISSIONS,"], [2463, "                DEFAULT_CONSENT_FRESHNESS_MAX_RETRANSMISSIONS);"], [2464, ""], [2465, "        while (runInStunKeepAliveThreadCondition())"], [2466, "        {"], [2467, "            for (IceMediaStream stream : getStreams())"], [2468, "            {"], [2469, "                for (Component component : stream.getComponents())"], [2470, "                {"], [2471, "                    for (CandidatePair pair : component.getKeepAlivePairs())"], [2472, "                    {"], [2473, ""], [2474, "                        if (pair != null)"], [2475, "                        {"], [2476, "                            if (performConsentFreshness)"], [2477, "                            {"], [2478, "                                connCheckClient.startCheckForPair("], [2479, "                                    pair,"], [2480, "                                    originalConsentFreshnessWaitInterval,"], [2481, "                                    maxConsentFreshnessWaitInterval,"], [2482, "                                    consentFreshnessMaxRetransmissions);"], [2483, "                            }"], [2484, "                            else"], [2485, "                            {"], [2486, "                                connCheckClient"], [2487, "                                    .sendBindingIndicationForPair(pair);"], [2488, "                            }"], [2489, "                        }"], [2490, "                    }"], [2491, "                }"], [2492, "            }"], [2493, ""], [2494, "            if (!runInStunKeepAliveThreadCondition())"], [2495, "            {"], [2496, "                break;"], [2497, "            }"], [2498, ""], [2499, "            try"], [2500, "            {"], [2501, "                Thread.sleep(consentFreshnessInterval);"], [2502, "                Thread.yield();"], [2503, "            }"], [2504, "            catch(InterruptedException e)"], [2505, "            {"], [2506, "            }"], [2507, "        }"], [2508, "        logger.info(Thread.currentThread().getName() + \" ends.\");"], [2509, "    }"], [2510, ""], [2511, "    /**"], [2512, "     * Determines whether {@link #runInStunKeepAliveThread()} is to run."], [2513, "     *"], [2514, "     * @return <tt>true</tt> if <tt>runInStunKeepAliveThread()</tt> is to run;"], [2515, "     * otherwise, <tt>false</tt>"], [2516, "     */"], [2517, "    private boolean runInStunKeepAliveThreadCondition()"], [2518, "    {"], [2519, "        IceProcessingState state = this.state;"], [2520, ""], [2521, "        return"], [2522, "            (IceProcessingState.COMPLETED.equals(state)"], [2523, "                    || IceProcessingState.TERMINATED.equals(state))"], [2524, "                && !shutdown;"], [2525, "    }"], [2526, ""], [2527, "    /**"]]}, "num_lines_added": 161, "num_lines_removed": 118}