{"hash": "58b549c1f6bfd704fdf9d8c36ec51123a6b16e6a", "message": "Fixed a nullPointerException", "file_num_lines": 124, "diff_parsed": {"added": [[50, "public class ECDHClientKeyExchangeHandler extends ClientKeyExchangeHandler<ECDHClientKeyExchangeMessage> {"], [54, "    public ECDHClientKeyExchangeHandler(TlsContext tlsContext) {"], [55, "\tsuper(tlsContext);"], [56, "\tthis.correctProtocolMessageClass = ECDHClientKeyExchangeMessage.class;"], [57, "\tthis.keyExchangeAlgorithm = KeyExchangeAlgorithm.EC_DIFFIE_HELLMAN;"], [61, "    public int parseKeyExchangeMessage(byte[] message, int pointer) {"], [62, "\tthrow new UnsupportedOperationException(\"Not supported yet.\");"], [66, "    byte[] prepareKeyExchangeMessage() {"], [67, "\tECPublicKeyParameters parameters = null;"], [68, "\tAsymmetricCipherKeyPair kp = null;"], [69, "\tif (tlsContext.getEcContext().getServerPublicKeyParameters() == null) {"], [70, "\t    // we are probably handling a simple ECDH ciphersuite, we try to"], [71, "\t    // establish server public key parameters from the server"], [72, "\t    // certificate message"], [73, "\t    Certificate x509Cert = tlsContext.getServerCertificate();"], [74, ""], [75, "\t    SubjectPublicKeyInfo keyInfo = x509Cert.getSubjectPublicKeyInfo();"], [76, ""], [77, "\t    if (!keyInfo.getAlgorithm().getAlgorithm().equals(X9ObjectIdentifiers.id_ecPublicKey)) {"], [78, "\t\tif (protocolMessage.isFuzzingMode()) {"], [79, "\t\t    kp = RandomKeyGeneratorHelper.generateECPublicKey();"], [80, "\t\t    parameters = (ECPublicKeyParameters) kp.getPublic();"], [81, "\t\t    LOGGER.debug(\"Generating EC domain parameters on the fly: \");"], [82, "\t\t} else {"], [83, "\t\t    throw new WorkflowExecutionException("], [84, "\t\t\t    \"Invalid KeyType, not in FuzzingMode so no Keys are generated on the fly\");"], [85, "\t\t}"], [86, "\t    } else {"], [87, "\t\ttry {"], [88, "\t\t    parameters = (ECPublicKeyParameters) PublicKeyFactory.createKey(keyInfo);"], [89, ""], [90, "                    kp = TlsECCUtils.generateECKeyPair(new SecureRandom(), parameters.getParameters());"], [91, ""], [92, "\t\t} catch (NoSuchMethodError e) {"], [93, "\t\t    LOGGER.debug(\"The method was not found. It is possible that it is because an older bouncy castle\""], [94, "\t\t\t    + \" library was used. We try to proceed the workflow.\", e);"], [95, "\t\t} catch (IOException e) {"], [96, "\t\t    throw new WorkflowExecutionException(\"Problem in parsing public key parameters from certificate\", e);"], [97, "\t\t}"], [98, "\t    }"], [99, "\t    tlsContext.getEcContext().setServerPublicKeyParameters(parameters);"], [100, "\t    LOGGER.debug(\"Parsed the following EC domain parameters from the certificate: \");"], [101, "\t    LOGGER.debug(\"  Curve order: {}\", parameters.getParameters().getCurve().getOrder());"], [102, "\t    LOGGER.debug(\"  Parameter A: {}\", parameters.getParameters().getCurve().getA());"], [103, "\t    LOGGER.debug(\"  Parameter B: {}\", parameters.getParameters().getCurve().getB());"], [104, "\t    LOGGER.debug(\"  Base point: {} \", parameters.getParameters().getG());"], [105, "\t    LOGGER.debug(\"  Public key point Q: {} \", parameters.getQ());"], [106, "\t} else {"], [107, "\t    kp = TlsECCUtils.generateECKeyPair(new SecureRandom(), tlsContext.getEcContext()"], [108, "\t\t    .getServerPublicKeyParameters().getParameters());"], [109, "\t}"], [110, ""], [111, "\tECPublicKeyParameters ecPublicKey = (ECPublicKeyParameters) kp.getPublic();"], [112, "\tECPrivateKeyParameters ecPrivateKey = (ECPrivateKeyParameters) kp.getPrivate();"], [113, ""], [114, "\t// do some ec point modification"], [115, "\tprotocolMessage.setPublicKeyBaseX(ecPublicKey.getQ().getAffineXCoord().toBigInteger());"], [116, "\tprotocolMessage.setPublicKeyBaseY(ecPublicKey.getQ().getAffineYCoord().toBigInteger());"], [117, ""], [118, "\tECCurve curve = ecPublicKey.getParameters().getCurve();"], [119, "\tECPoint point = curve.createPoint(protocolMessage.getPublicKeyBaseX().getValue(), protocolMessage"], [120, "\t\t.getPublicKeyBaseY().getValue());"], [121, ""], [122, "\tLOGGER.debug(\"Using the following point:\");"], [123, "\tLOGGER.debug(\"X: \" + protocolMessage.getPublicKeyBaseX().getValue().toString());"], [124, "\tLOGGER.debug(\"Y: \" + protocolMessage.getPublicKeyBaseY().getValue().toString());"], [125, ""], [126, "\t// System.out.println(\"-----------------\\nUsing the following point:\");"], [127, "\t// System.out.println(\"X: \" + point.getAffineXCoord());"], [128, "\t// System.out.println(\"Y: \" + point.getAffineYCoord());"], [129, "\t// System.out.println(\"-----------------\\n\");"], [130, "\tECPointFormat[] pointFormats = tlsContext.getEcContext().getServerPointFormats();"], [131, ""], [132, "\ttry {"], [133, "\t    byte[] serializedPoint = ECCUtilsBCWrapper.serializeECPoint(pointFormats, point);"], [134, "\t    protocolMessage.setEcPointFormat(serializedPoint[0]);"], [135, "\t    protocolMessage.setEcPointEncoded(Arrays.copyOfRange(serializedPoint, 1, serializedPoint.length));"], [136, "\t    protocolMessage.setPublicKeyLength(serializedPoint.length);"], [137, ""], [138, "\t    byte[] result = ArrayConverter.concatenate(new byte[] { protocolMessage.getPublicKeyLength().getValue()"], [139, "\t\t    .byteValue() }, new byte[] { protocolMessage.getEcPointFormat().getValue() }, protocolMessage"], [140, "\t\t    .getEcPointEncoded().getValue());"], [141, ""], [142, "\t    byte[] premasterSecret = TlsECCUtils.calculateECDHBasicAgreement(tlsContext.getEcContext()"], [143, "\t\t    .getServerPublicKeyParameters(), ecPrivateKey);"], [144, "\t    byte[] random = tlsContext.getClientServerRandom();"], [145, "\t    protocolMessage.setPremasterSecret(premasterSecret);"], [146, "\t    LOGGER.debug(\"Computed PreMaster Secret: {}\","], [147, "\t\t    ArrayConverter.bytesToHexString(protocolMessage.getPremasterSecret().getValue()));"], [148, "\t    LOGGER.debug(\"Client Server Random: {}\", ArrayConverter.bytesToHexString(random));"], [149, ""], [150, "\t    PRFAlgorithm prfAlgorithm = AlgorithmResolver.getPRFAlgorithm(tlsContext.getProtocolVersion(),"], [151, "\t\t    tlsContext.getSelectedCipherSuite());"], [152, "\t    byte[] masterSecret = PseudoRandomFunction.compute(prfAlgorithm, protocolMessage.getPremasterSecret()"], [153, "\t\t    .getValue(), PseudoRandomFunction.MASTER_SECRET_LABEL, random, HandshakeByteLength.MASTER_SECRET);"], [154, "\t    LOGGER.debug(\"Computed Master Secret: {}\", ArrayConverter.bytesToHexString(masterSecret));"], [155, ""], [156, "\t    protocolMessage.setMasterSecret(masterSecret);"], [157, "\t    tlsContext.setMasterSecret(protocolMessage.getMasterSecret().getValue());"], [158, ""], [159, "\t    return result;"], [160, ""], [161, "\t} catch (IOException ex) {"], [162, "\t    throw new WorkflowExecutionException(\"EC point serialization failure\", ex);"], [163, "\t}"]], "deleted": [[50, "public class ECDHClientKeyExchangeHandler extends ClientKeyExchangeHandler<ECDHClientKeyExchangeMessage>"], [51, "{"], [55, "    public ECDHClientKeyExchangeHandler(TlsContext tlsContext)"], [56, "    {"], [57, "        super(tlsContext);"], [58, "        this.correctProtocolMessageClass = ECDHClientKeyExchangeMessage.class;"], [59, "        this.keyExchangeAlgorithm = KeyExchangeAlgorithm.EC_DIFFIE_HELLMAN;"], [63, "    public int parseKeyExchangeMessage(byte[] message, int pointer)"], [64, "    {"], [65, "        throw new UnsupportedOperationException(\"Not supported yet.\");"], [69, "    byte[] prepareKeyExchangeMessage()"], [70, "    {"], [71, "        ECPublicKeyParameters parameters = null;"], [72, "        AsymmetricCipherKeyPair kp = null;"], [73, "        if (tlsContext.getEcContext().getServerPublicKeyParameters() == null)"], [74, "        {"], [75, "            // we are probably handling a simple ECDH ciphersuite, we try to"], [76, "            // establish server public key parameters from the server"], [77, "            // certificate message"], [78, "            Certificate x509Cert = tlsContext.getServerCertificate();"], [79, ""], [80, "            SubjectPublicKeyInfo keyInfo = x509Cert.getSubjectPublicKeyInfo();"], [81, ""], [82, "            if (!keyInfo.getAlgorithm().getAlgorithm().equals(X9ObjectIdentifiers.id_ecPublicKey))"], [83, "            {"], [84, "                if (protocolMessage.isFuzzingMode())"], [85, "                {"], [86, "                    kp = RandomKeyGeneratorHelper.generateECPublicKey();"], [87, "                    parameters = (ECPublicKeyParameters) kp.getPublic();"], [88, "                    LOGGER.debug(\"Generating EC domain parameters on the fly: \");"], [89, "                }"], [90, "                else"], [91, "                {"], [92, "                    throw new WorkflowExecutionException(\"Invalid KeyType, not in FuzzingMode so no Keys are generated on the fly\");"], [93, "                }"], [94, "            }"], [95, "            else"], [96, "            {"], [97, "                try"], [98, "                {"], [99, "                    parameters = (ECPublicKeyParameters) PublicKeyFactory.createKey(keyInfo);"], [100, "                    kp = TlsECCUtils.generateECKeyPair(new SecureRandom(), tlsContext.getEcContext()"], [101, "                            .getServerPublicKeyParameters().getParameters());"], [102, ""], [103, "                }"], [104, "                catch (NoSuchMethodError e)"], [105, "                {"], [106, "                    LOGGER.debug(\"The method was not found. It is possible that it is because an older bouncy castle\""], [107, "                            + \" library was used. We try to proceed the workflow.\", e);"], [108, "                }"], [109, "                catch (IOException e)"], [110, "                {"], [111, "                    throw new WorkflowExecutionException(\"Problem in parsing public key parameters from certificate\", e);"], [112, "                }"], [113, "            }"], [114, "            tlsContext.getEcContext().setServerPublicKeyParameters(parameters);"], [115, "            LOGGER.debug(\"Parsed the following EC domain parameters from the certificate: \");"], [116, "            LOGGER.debug(\"  Curve order: {}\", parameters.getParameters().getCurve().getOrder());"], [117, "            LOGGER.debug(\"  Parameter A: {}\", parameters.getParameters().getCurve().getA());"], [118, "            LOGGER.debug(\"  Parameter B: {}\", parameters.getParameters().getCurve().getB());"], [119, "            LOGGER.debug(\"  Base point: {} \", parameters.getParameters().getG());"], [120, "            LOGGER.debug(\"  Public key point Q: {} \", parameters.getQ());"], [121, "        }"], [122, "        else"], [123, "        {"], [124, "            kp = TlsECCUtils.generateECKeyPair(new SecureRandom(), tlsContext.getEcContext()"], [125, "                            .getServerPublicKeyParameters().getParameters());"], [126, "        }"], [127, ""], [128, "        ECPublicKeyParameters ecPublicKey = (ECPublicKeyParameters) kp.getPublic();"], [129, "        ECPrivateKeyParameters ecPrivateKey = (ECPrivateKeyParameters) kp.getPrivate();"], [130, ""], [131, "        // do some ec point modification"], [132, "        protocolMessage.setPublicKeyBaseX(ecPublicKey.getQ().getAffineXCoord().toBigInteger());"], [133, "        protocolMessage.setPublicKeyBaseY(ecPublicKey.getQ().getAffineYCoord().toBigInteger());"], [134, ""], [135, "        ECCurve curve = ecPublicKey.getParameters().getCurve();"], [136, "        ECPoint point = curve.createPoint(protocolMessage.getPublicKeyBaseX().getValue(), protocolMessage"], [137, "                .getPublicKeyBaseY().getValue());"], [138, ""], [139, "        LOGGER.debug(\"Using the following point:\");"], [140, "        LOGGER.debug(\"X: \" + protocolMessage.getPublicKeyBaseX().getValue().toString());"], [141, "        LOGGER.debug(\"Y: \" + protocolMessage.getPublicKeyBaseY().getValue().toString());"], [142, ""], [143, "        // System.out.println(\"-----------------\\nUsing the following point:\");"], [144, "        // System.out.println(\"X: \" + point.getAffineXCoord());"], [145, "        // System.out.println(\"Y: \" + point.getAffineYCoord());"], [146, "        // System.out.println(\"-----------------\\n\");"], [147, "        ECPointFormat[] pointFormats = tlsContext.getEcContext().getServerPointFormats();"], [148, ""], [149, "        try"], [150, "        {"], [151, "            byte[] serializedPoint = ECCUtilsBCWrapper.serializeECPoint(pointFormats, point);"], [152, "            protocolMessage.setEcPointFormat(serializedPoint[0]);"], [153, "            protocolMessage.setEcPointEncoded(Arrays.copyOfRange(serializedPoint, 1, serializedPoint.length));"], [154, "            protocolMessage.setPublicKeyLength(serializedPoint.length);"], [155, ""], [156, "            byte[] result = ArrayConverter.concatenate(new byte[]"], [157, "            {"], [158, "                protocolMessage.getPublicKeyLength().getValue()"], [159, "                .byteValue()"], [160, "            }, new byte[]"], [161, "            {"], [162, "                protocolMessage.getEcPointFormat().getValue()"], [163, "            }, protocolMessage"], [164, "                    .getEcPointEncoded().getValue());"], [165, ""], [166, "            byte[] premasterSecret = TlsECCUtils.calculateECDHBasicAgreement(tlsContext.getEcContext()"], [167, "                    .getServerPublicKeyParameters(), ecPrivateKey);"], [168, "            byte[] random = tlsContext.getClientServerRandom();"], [169, "            protocolMessage.setPremasterSecret(premasterSecret);"], [170, "            LOGGER.debug(\"Computed PreMaster Secret: {}\","], [171, "                    ArrayConverter.bytesToHexString(protocolMessage.getPremasterSecret().getValue()));"], [172, "            LOGGER.debug(\"Client Server Random: {}\", ArrayConverter.bytesToHexString(random));"], [173, ""], [174, "            PRFAlgorithm prfAlgorithm = AlgorithmResolver.getPRFAlgorithm(tlsContext.getProtocolVersion(),"], [175, "                    tlsContext.getSelectedCipherSuite());"], [176, "            byte[] masterSecret = PseudoRandomFunction.compute(prfAlgorithm, protocolMessage.getPremasterSecret()"], [177, "                    .getValue(), PseudoRandomFunction.MASTER_SECRET_LABEL, random, HandshakeByteLength.MASTER_SECRET);"], [178, "            LOGGER.debug(\"Computed Master Secret: {}\", ArrayConverter.bytesToHexString(masterSecret));"], [179, ""], [180, "            protocolMessage.setMasterSecret(masterSecret);"], [181, "            tlsContext.setMasterSecret(protocolMessage.getMasterSecret().getValue());"], [182, ""], [183, "            return result;"], [184, ""], [185, "        }"], [186, "        catch (IOException ex)"], [187, "        {"], [188, "            throw new WorkflowExecutionException(\"EC point serialization failure\", ex);"], [189, "        }"]]}, "num_lines_added": 105, "num_lines_removed": 131}