{"hash": "623acb6f10c5fec3cdba1c09a3422ecfac170454", "message": "#79 Some typo fixes, simplifications and comment improvements", "file_num_lines": 169, "diff_parsed": {"added": [[24, ""], [36, ""], [72, "    private final Type parameter;"], [77, "    private final Map<TypeVariable, TypeMirror> genericTypesMap = new HashMap<TypeVariable, TypeMirror>();"], [79, "    public MethodMatcher(Types typeUtils, Method candidateMethod, Type returnType, Type parameter) {"], [82, "        this.parameter = parameter;"], [89, ""], [90, "        if ( candidateParameters.size() != 1 ) {"], [91, "            typesMatch = false;"], [94, "            TypeMatcher parameterMatcher = new TypeMatcher();"], [95, "            typesMatch = parameterMatcher.visit("], [96, "                candidateParameters.iterator().next().asType(),"], [97, "                parameter.getTypeMirror()"], [98, "            );"], [115, "                if (!isWithinBounds( entry.getValue(), getTypeParamFromCandidate( entry.getKey() ) ) ) {"], [203, "                        // for example method: <T extends String & Serializable> T method(? extends T)"], [206, "                        return isWithinBounds( p, getTypeParamFromCandidate( extendsBound ) );"], [226, "                        TypeParameterElement typeParameter = getTypeParamFromCandidate( superBound );"], [227, "                        // for example method: <T extends String & Serializable> T method(? super T)"], [232, "                        // now, it becomes a bit more hairy. We have the relation (? super T). From T we know that"], [259, "    private TypeParameterElement getTypeParamFromCandidate(TypeMirror t) {"], [280, "                        typeUtils.isSubtype( t, bound ) ) ) {"]], "deleted": [[30, "import static javax.lang.model.type.TypeKind.DECLARED;"], [71, "    private final Type[] parameters;"], [76, "    private Map<TypeVariable, TypeMirror> genericTypesMap = new HashMap<TypeVariable, TypeMirror>();"], [78, "    public MethodMatcher(Types typeUtils, Method candidateMethod, Type returnType, Type... arguments) {"], [81, "        this.parameters = arguments;"], [86, ""], [89, "        if ( candidateParameters.size() == parameters.length ) {"], [90, "            for ( int i = 0; i < parameters.length; i++ ) {"], [91, "                TypeMatcher parameterMatcher = new TypeMatcher();"], [92, "                typesMatch = parameterMatcher.visit( candidateParameters.get( i ).asType(),"], [93, "                        parameters[i].getTypeMirror() );"], [94, "                if ( !typesMatch ) {"], [95, "                    break;"], [96, "                }"], [97, "            }"], [100, "            typesMatch = false;"], [117, "                if (!isWithinBounds( entry.getValue(), getTypeParamFromCandite( entry.getKey() ) ) ) {"], [205, "                        // for exampe method: <T extends String & Serializable> T method(? extends T)"], [208, "                        return isWithinBounds( p, getTypeParamFromCandite( extendsBound ) );"], [228, "                        TypeParameterElement typeParameter = getTypeParamFromCandite( superBound );"], [229, "                        // for exampe method: <T extends String & Serializable> T method(? super T)"], [234, "                        // now, it becoms a bit more hairy. We have the relation (? super T). From T we know that"], [261, "    private TypeParameterElement getTypeParamFromCandite(TypeMirror t) {"], [282, "                        typeUtils.isSubtype( t, (DeclaredType) bound ) ) ) {"]]}, "num_lines_added": 22, "num_lines_removed": 24}