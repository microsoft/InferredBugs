{"hash": "672e058c758fe5f60bcddc4ac86f4e91b3112a40", "message": "Adding settings", "file_num_lines": 653, "diff_parsed": {"added": [[55, " * <h3>Context listener</h3>"], [56, " * The context listener has a number of settings that can be configured with context parameters in <code>web.xml</code>,"], [57, " * i.e.:"], [58, " *"], [59, " * <pre>"], [60, " *   &lt;context-param&gt;"], [61, " *     &lt;param-name&gt;ClassLoaderLeakPreventor.stopThreads&lt;/param-name&gt;"], [62, " *     &lt;param-value&gt;false&lt;/param-value&gt;"], [63, " *   &lt;/context-param&gt;"], [64, " * </pre>"], [65, " *"], [66, " * The available settings are"], [67, " * <table border=\"1\">"], [68, " *   <tr>"], [69, " *     <th>Parameter name</th>"], [70, " *     <th>Default value</th>"], [71, " *     <th>Description</th>"], [72, " *   </tr>"], [73, " *   <tr>"], [74, " *     <td><code>ClassLoaderLeakPreventor.stopThreads</code></td>"], [75, " *     <td><code>true</code></td>"], [76, " *     <td>Should threads tied to the web app classloader be forced to stop at application shutdown?</td>"], [77, " *   </tr>"], [78, " *   <tr>"], [79, " *     <td><code>ClassLoaderLeakPreventor.stopTimerThreads</code></td>"], [80, " *     <td><code>true</code></td>"], [81, " *     <td>Should Timer threads tied to the web app classloader be forced to stop at application shutdown?</td>"], [82, " *   </tr>"], [83, " *   <tr>"], [84, " *     <td><code>ClassLoaderLeakPreventor.executeShutdownHooks</td>"], [85, " *     <td><code>true</code></td>"], [86, " *     <td>Should shutdown hooks registered from the application be executed at application shutdown?</td>"], [87, " *   </tr>"], [88, " *   <tr>"], [89, " *     <td><code>ClassLoaderLeakPreventor.threadWaitMs</td>"], [90, " *     <td><code>5000</code> (5 seconds)</td>"], [91, " *     <td>No of milliseconds to wait for threads to finish execution, before stopping them.</td>"], [92, " *   </tr>"], [93, " *   <tr>"], [94, " *     <td><code>ClassLoaderLeakPreventor.shutdownHookWaitMs</code></td>"], [95, " *     <td><code>10000</code> (10 seconds)</td>"], [96, " *     <td>"], [97, " *       No of milliseconds to wait for shutdown hooks to finish execution, before stopping them."], [98, " *       If set to -1 there will be no waiting at all, but Thread is allowed to run until finished."], [99, " *     </td>"], [100, " *   </tr>"], [101, " * </table>"], [102, " *"], [103, " *"], [155, "  /** Default no of milliseconds to wait for threads to finish execution */"], [156, "  public static final int THREAD_WAIT_MS_DEFAULT = 5 * 1000; // 5 seconds"], [157, ""], [158, "  /** Default no of milliseconds to wait for shutdown hook to finish execution */"], [159, "  public static final int SHUTDOWN_HOOK_WAIT_MS_DEFAULT = 10 * 1000; // 10 seconds"], [160, ""], [161, "  ///////////"], [162, "  // Settings"], [163, ""], [164, ""], [165, "  /** Should threads tied to the web app classloader be forced to stop at application shutdown? */"], [166, "  protected boolean stopThreads = true;"], [167, ""], [168, "  /** Should Timer threads tied to the web app classloader be forced to stop at application shutdown? */"], [169, "  protected boolean stopTimerThreads = true;"], [170, ""], [171, "  /** Should shutdown hooks registered from the application be executed at application shutdown? */"], [172, "  protected boolean executeShutdownHooks = true;"], [173, ""], [174, "  /**"], [175, "   * No of milliseconds to wait for threads to finish execution, before stopping them."], [176, "   */"], [177, "  protected int threadWaitMs = SHUTDOWN_HOOK_WAIT_MS_DEFAULT;"], [178, ""], [179, "  /**"], [180, "   * No of milliseconds to wait for shutdown hooks to finish execution, before stopping them."], [181, "   * If set to -1 there will be no waiting at all, but Thread is allowed to run until finished."], [182, "   */"], [183, "  protected int shutdownHookWaitMs = SHUTDOWN_HOOK_WAIT_MS_DEFAULT;"], [271, ""], [272, "    final ServletContext servletContext = servletContextEvent.getServletContext();"], [273, "    stopThreads = ! \"false\".equals(servletContext.getInitParameter(\"ClassLoaderLeakPreventor.stopThreads\"));"], [274, "    stopTimerThreads = ! \"false\".equals(servletContext.getInitParameter(\"ClassLoaderLeakPreventor.stopTimerThreads\"));"], [275, "    executeShutdownHooks = ! \"false\".equals(servletContext.getInitParameter(\"ClassLoaderLeakPreventor.executeShutdownHooks\"));"], [276, "    threadWaitMs = getIntInitParameter(servletContext, \"ClassLoaderLeakPreventor.threadWaitMs\", THREAD_WAIT_MS_DEFAULT);"], [277, "    shutdownHookWaitMs = getIntInitParameter(servletContext, \"ClassLoaderLeakPreventor.shutdownHookWaitMs\", SHUTDOWN_HOOK_WAIT_MS_DEFAULT);"], [279, "    info(\"Settings for \" + this.getClass().getName() + \":\");"], [280, "    info(\"  stopThreads = \" + stopThreads);"], [281, "    info(\"  stopTimerThreads = \" + stopTimerThreads);"], [282, "    info(\"  executeShutdownHooks = \" + executeShutdownHooks);"], [283, "    info(\"  threadWaitMs = \" + threadWaitMs + \" ms\");"], [284, "    info(\"  shutdownHookWaitMs = \" + shutdownHookWaitMs + \" ms\");"], [285, ""], [286, ""], [287, "    info(\"Initializing context by loading some known offenders with system classloader\");"], [530, "    if(executeShutdownHooks) { // Shutdown hooks should be executed"], [531, ""], [532, "      info(\"Executing shutdown hook now: \" + displayString);"], [533, "      // Make sure it's from this web app instance"], [534, "      shutdownHook.start(); // Run cleanup immediately"], [535, ""], [536, "      if(shutdownHookWaitMs > 0) { // Wait for shutdown hook to finish"], [537, "        try {"], [538, "          shutdownHook.join(shutdownHookWaitMs); // Wait for thread to run"], [539, "        }"], [540, "        catch (InterruptedException e) {"], [541, "          // Do nothing"], [542, "        }"], [543, "        if(shutdownHook.isAlive()) {"], [544, "          warn(shutdownHook + \"still running after \" + shutdownHookWaitMs + \" ms - Stopping!\");"], [545, "          shutdownHook.stop();"], [546, "        }"], [547, "      }"], [630, "            if(stopTimerThreads) {"], [631, "              warn(\"Stopping Timer thread running in classloader.\");"], [632, "              stopTimerThread(thread);"], [633, "            }"], [634, "            else {"], [635, "              info(\"Timer thread is running in classloader, but will not be stopped\");"], [636, "            }"], [642, "              if(stopThreads) {"], [643, "                warn(\"Shutting down \" + ThreadPoolExecutor.class.getName() + \" running within the classloader.\");"], [644, "                try {"], [645, "                  // java.util.concurrent.ThreadPoolExecutor, introduced in Java 1.5"], [646, "                  final Field workerExecutor = findField(workerClass, \"this$0\");"], [647, "                  final ThreadPoolExecutor executor = getFieldValue(workerExecutor, target);"], [648, "                  executor.shutdownNow();"], [649, "                }"], [650, "                catch (Exception ex) {"], [651, "                  error(ex);"], [652, "                }"], [654, "              else"], [655, "                info(ThreadPoolExecutor.class.getName() + \" running within the classloader will not be shut down.\");"], [659, ""], [660, "            if(stopThreads) {"], [661, "              final String waitString = (threadWaitMs > 0) ? \"after \" + threadWaitMs + \" ms \" : \"\";"], [662, "              warn(\"Stopping Thread \" + displayString + \" running in web app \" + waitString);"], [663, ""], [664, "              if(threadWaitMs > 0) {"], [665, "                try {"], [666, "                  thread.join(threadWaitMs); // Wait for thread to run"], [667, "                }"], [668, "                catch (InterruptedException e) {"], [669, "                  // Do nothing"], [670, "                }"], [671, "              }"], [672, ""], [673, "              // Normally threads should not be stopped (method is deprecated), since it may cause an inconsistent state."], [674, "              // In this case however, the alternative is a classloader leak, which may or may not be considered worse."], [675, "              if(thread.isAlive())"], [676, "                thread.stop();"], [677, "            }"], [678, "            else {"], [679, "              warn(\"Thread \" + displayString + \" is still running in web app\");"], [680, "            }"], [681, ""], [689, "    // Seems it is not possible to access Timer of TimerThread, so we need to mimic Timer.cancel()"], [707, "      // Do what java.util.Timer.cancel() does"], [1041, "  /** Parse init parameter for integer value, returning default if not found or invalid */"], [1042, "  private static int getIntInitParameter(ServletContext servletContext, String parameterName, int defaultValue) {"], [1043, "    final String parameterString = servletContext.getInitParameter(parameterName);"], [1044, "    if(parameterString != null && parameterString.trim().length() > 0) {"], [1045, "      try {"], [1046, "        return Integer.parseInt(parameterString);"], [1047, "      }"], [1048, "      catch (NumberFormatException e) {"], [1049, "        // Do nothing, return default value"], [1050, "      }"], [1051, "    }"], [1052, "    return defaultValue;"], [1053, "  }"], [1054, ""]], "deleted": [[106, "  /** No of ms to wait for shutdown hook to finish execution */"], [107, "  private static final int TIME_TO_WAIT_FOR_SHUTDOWN_HOOKS_MS = 60 * 1000;"], [196, "    info(getClass().getName() + \" initializing context by loading some known offenders with system classloader\");"], [439, "    info(\"Executing shutdown hook now: \" + displayString);"], [440, "    // Make sure it's from this web app instance"], [441, "    shutdownHook.start(); // Run cleanup immediately"], [442, "    try {"], [443, "      shutdownHook.join(TIME_TO_WAIT_FOR_SHUTDOWN_HOOKS_MS); // Wait for thread to run TODO: Create setting"], [444, "    }"], [445, "    catch (InterruptedException e) {"], [446, "      // Do nothing"], [447, "    }"], [448, "    if(shutdownHook.isAlive()) {"], [449, "      error(\"Still running after \" + TIME_TO_WAIT_FOR_SHUTDOWN_HOOKS_MS + \" ms! \" + shutdownHook);"], [450, "      error(\"  Stopping!\");"], [451, "      shutdownHook.stop(); // TODO: Setting"], [534, "            // TODO: Create setting whether to actually stop"], [535, "            stopTimerThread(thread);"], [541, "              // TODO: Make setting?"], [542, "              try {"], [543, "                // java.util.concurrent.ThreadPoolExecutor, introduced in Java 1.5"], [544, "                final Field workerExecutor = findField(workerClass, \"this$0\");"], [545, "                final ThreadPoolExecutor executor = getFieldValue(workerExecutor, target);"], [546, "                executor.shutdownNow();"], [547, "              }"], [548, "              catch (Exception ex) {"], [549, "                error(ex);"], [554, "            error(\"Thread \" + displayString + \" is still running in web app\");"], [555, ""], [556, "            // TODO: Make setting for stopping"], [557, "            info(\"Stopping Thread \" + displayString);"], [558, "            // Normally threads should not be stopped (method is deprecated), since it may cause an inconsistent state."], [559, "            // In this case however, the alternative is a classloader leak, which may or may not be considered worse."], [560, "            // TODO: Give it some time first?"], [561, "            thread.stop();"], [569, "    // Seems it is not possible to access Timer of TimerThread, so we need to mimick Timer.cancel()"], [587, "      // Do that java.util.Timer.cancel() does"]]}, "num_lines_added": 171, "num_lines_removed": 37}