{"hash": "6a03291323b0686fdfdf47a1737978018069af65", "message": "Change to have only have one blocking queue to handle get tasks", "file_num_lines": 178, "diff_parsed": {"added": [[29, "import java.util.concurrent.BlockingQueue;"], [30, "import java.util.concurrent.LinkedBlockingQueue;"], [42, "  private final BlockingQueue<GetTask> getTasks;"], [51, "    getTasks = new LinkedBlockingQueue<GetTask> ();"], [61, "        //dispatcherThread.interrupt();"], [71, "    private final GetCallback resultHandler;"], [75, "    private Long startNanoTime;"], [84, "      this.resultHandler = resultHandler;"], [87, "      this.startNanoTime = null;"], [90, "    public void disconnect() {"], [91, "      if (hostConnectionAndHostIndex != null && hostConnectionAndHostIndex.hostConnection != null) {"], [92, "        hostConnectionAndHostIndex.hostConnection.attemptDisconnect();"], [93, "      }"], [97, "      if (hostConnectionAndHostIndex != null && hostConnectionAndHostIndex.hostConnection != null) {"], [102, "    public void execute() {"], [103, "      if (hasTimedout()) {"], [104, "        // If we timedout just complete the task with timeout response"], [105, "        response = TIMEOUT_RESPONSE;"], [106, "        doCompleted();"], [108, "        if (hostConnectionAndHostIndex == null) {"], [109, "          hostConnectionAndHostIndex = hostConnectionPool.findConnectionToUse();"], [110, "        } else {"], [111, "          hostConnectionAndHostIndex = hostConnectionPool.findConnectionToUse(hostConnectionAndHostIndex.hostIndex);"], [112, "        }"], [114, "        if (hostConnectionAndHostIndex == null) {"], [115, "          // All connections are busy, add it back to the dispatcher queue"], [116, "          addTask(this);"], [117, "        } else if (hostConnectionAndHostIndex.hostConnection == null) {"], [118, "          // All hosts were in standby, set the response appropriately and complete task"], [119, "          response = NO_CONNECTION_AVAILABLE_RESPONSE;"], [120, "          doCompleted();"], [121, "        } else {"], [122, "          // Claim connection"], [123, "          hostConnectionAndHostIndex.hostConnection.setIsBusy(true);"], [124, "          // Execute asynchronous task"], [125, "          hostConnectionAndHostIndex.hostConnection.get(domainId, key, new GetTask.Callback());"], [126, "        }"], [128, "    }"], [130, "    private void doCompleted() {"], [131, "      resultHandler.onComplete(response);"], [132, "    }"], [134, "    private void transition() {"], [135, "      ++tryCount;"], [136, "      if (response.is_set_xception() && tryCount < queryMaxNumTries) {"], [137, "        // Error: add it back to the dispatcher queue"], [138, "        addTask(this);"], [139, "      } else {"], [140, "        // Success"], [141, "        doCompleted();"], [142, "      }"], [145, "    private long getNanoTimeBeforeTimeout(long currentNanoTime) {"], [150, "    private boolean hasTimedout() {"], [151, "      if (queryTimeoutNano != 0) {"], [152, "        long currentNanoTime = System.nanoTime();"], [153, "        long taskNanoTimeBeforeTimeout = getNanoTimeBeforeTimeout(currentNanoTime);"], [154, "        if (taskNanoTimeBeforeTimeout == 0) {"], [155, "          return true;"], [156, "        }"], [157, "      }"], [158, "      return false;"], [159, "    }"], [160, ""], [165, ""], [166, "    private class Callback implements HostConnectionGetCallback {"], [167, ""], [168, "      @Override"], [169, "      public void onComplete(PartitionServer.AsyncClient.get_call response) {"], [170, "        try {"], [171, "          GetTask.this.response = response.getResult();"], [172, "        } catch (TException e) {"], [173, "          // Always disconnect in case of Thrift error"], [174, "          disconnect();"], [175, "          String errMsg = \"Failed to load GET result: \" + e.getMessage();"], [176, "          LOG.error(errMsg);"], [177, "          GetTask.this.response = HankResponse.xception(HankException.internal_error(errMsg));"], [178, "        } finally {"], [179, "          // Always release the connection and transition"], [180, "          releaseConnection();"], [181, "          GetTask.this.transition();"], [182, "        }"], [183, "      }"], [184, ""], [185, "      @Override"], [186, "      public void onError(Exception e) {"], [187, "        // Always disconnect in case of Thrift error"], [188, "        disconnect();"], [189, "        try {"], [190, "          String errMsg = \"Failed to execute GET: \" + e.getMessage();"], [191, "          LOG.error(errMsg);"], [192, "          GetTask.this.response = HankResponse.xception(HankException.internal_error(errMsg));"], [193, "        } finally {"], [194, "          // Always release the connection and transition"], [195, "          releaseConnection();"], [196, "          GetTask.this.transition();"], [197, "        }"], [198, "      }"], [199, "    }"], [215, "    try {"], [216, "      // TODO: remove trace"], [217, "      //LOG.trace(\"Adding task with state \" + task.state);"], [218, "      if (task.startNanoTime == null) {"], [219, "        task.startNanoTime = System.nanoTime();"], [220, "      }"], [221, "      getTasks.put(task);"], [222, "      //LOG.trace(\"Get Task is now \" + getTasks.size());"], [223, "    } catch (InterruptedException e) {"], [224, "      // Someone is trying to stop Dispatcher"], [231, "      try {"], [232, "        GetTask task = getTasks.take();"], [233, "        // TODO: remove trace"], [234, "        //LOG.trace(\"Acquire task with state \" + task.state);"], [235, "        task.execute();"], [236, "      } catch (InterruptedException e) {"], [237, "        // Someone is trying to stop Dispatcher"]], "deleted": [[29, "import java.util.Iterator;"], [30, "import java.util.LinkedList;"], [42, "  private final LinkedList<GetTask> getTasks;"], [43, "  private final LinkedList<GetTask> getTasksComplete;"], [49, "  private long sleepNanoTime;"], [53, "    getTasks = new LinkedList<GetTask>();"], [54, "    getTasksComplete = new LinkedList<GetTask>();"], [64, "        dispatcherThread.interrupt();"], [74, "    private final GetCallback resultHanlder;"], [78, "    private long startNanoTime;"], [79, ""], [80, "    public void disconnect() {"], [81, "      if (hostConnectionAndHostIndex != null && hostConnectionAndHostIndex.hostConnection != null) {"], [82, "        hostConnectionAndHostIndex.hostConnection.attemptDisconnect();"], [83, "      }"], [84, "    }"], [85, ""], [86, "    private class Callback implements HostConnectionGetCallback {"], [87, ""], [88, "      @Override"], [89, "      public void onComplete(PartitionServer.AsyncClient.get_call response) {"], [90, "        try {"], [91, "          GetTask.this.response = response.getResult();"], [92, "        } catch (TException e) {"], [93, "          String errMsg = \"Failed to load GET result: \" + e.getMessage();"], [94, "          LOG.error(errMsg);"], [95, "          GetTask.this.response = HankResponse.xception(HankException.internal_error(errMsg));"], [96, "        } finally {"], [97, "          addCompleteTask(GetTask.this);"], [98, "        }"], [99, "      }"], [100, ""], [101, "      @Override"], [102, "      public void onError(Exception e) {"], [103, "        try {"], [104, "          String errMsg = \"Failed to execute GET: \" + e.getMessage();"], [105, "          LOG.error(errMsg);"], [106, "          GetTask.this.response = HankResponse.xception(HankException.internal_error(errMsg));"], [107, "        } finally {"], [108, "          addCompleteTask(GetTask.this);"], [109, "        }"], [110, "      }"], [111, "    }"], [120, "      this.resultHanlder = resultHandler;"], [123, "      this.startNanoTime = 0;"], [124, "    }"], [125, ""], [126, "    public void complete() {"], [127, "      resultHanlder.onComplete(response);"], [130, "    public void completeWithTimeout() {"], [131, "      response = TIMEOUT_RESPONSE;"], [132, "      addCompleteTask(GetTask.this);"], [136, "      if (hostConnectionAndHostIndex.hostConnection != null) {"], [141, "    public boolean execute() {"], [142, "      if (hostConnectionAndHostIndex == null) {"], [143, "        hostConnectionAndHostIndex = hostConnectionPool.findConnectionToUse();"], [145, "        hostConnectionAndHostIndex = hostConnectionPool.findConnectionToUse(hostConnectionAndHostIndex.hostIndex);"], [146, "      }"], [148, "      if (hostConnectionAndHostIndex == null) {"], [149, "        return false;"], [152, "      // All hosts were in standby, set the response appropriately and complete task"], [153, "      if (hostConnectionAndHostIndex.hostConnection == null) {"], [154, "        response = NO_CONNECTION_AVAILABLE_RESPONSE;"], [155, "        addCompleteTask(this);"], [156, "        return true;"], [157, "      }"], [159, "      // Claim connection"], [160, "      hostConnectionAndHostIndex.hostConnection.setIsBusy(true);"], [161, "      // Execute asynchronous task"], [162, "      hostConnectionAndHostIndex.hostConnection.get(domainId, key, new GetTask.Callback());"], [163, "      return true;"], [166, "    public long getNanoTimeBeforeTimeout(long currentNanoTime) {"], [190, "    synchronized (getTasks) {"], [191, "      task.startNanoTime = System.nanoTime();"], [192, "      getTasks.addLast(task);"], [193, "    }"], [194, "    dispatcherThread.interrupt();"], [195, "  }"], [196, ""], [197, "  public void addCompleteTask(GetTask task) {"], [198, "    synchronized (getTasksComplete) {"], [199, "      getTasksComplete.addLast(task);"], [201, "    dispatcherThread.interrupt();"], [207, "      completeTasks();"], [208, "      startTasks();"], [209, "      // Make sure that we don't go to sleep if task have been added while executing them."], [210, "      if (!Thread.interrupted()) {"], [211, "        try {"], [212, "          Thread.sleep(sleepNanoTime / 1000000);"], [213, "        } catch (InterruptedException e) {"], [214, "          // There is work to do"], [215, "        }"], [219, ""], [220, "  private void completeTasks() {"], [221, "    synchronized (getTasksComplete) {"], [222, "      for (GetTask task : getTasksComplete) {"], [223, ""], [224, "        if (task.response.is_set_xception()) {"], [225, "          // Error"], [226, "          ++task.tryCount;"], [227, "          task.disconnect();"], [228, "          if (task.tryCount < queryMaxNumTries) {"], [229, "            addTask(task);"], [230, "          } else {"], [231, "            task.complete();"], [232, "          }"], [233, "        } else {"], [234, "          // Success"], [235, "          task.complete();"], [236, "        }"], [237, ""], [238, "        // Release connection"], [239, "        task.releaseConnection();"], [240, ""], [241, "      }"], [242, "      getTasksComplete.clear();"], [243, "    }"], [244, "  }"], [245, ""], [246, "  private void startTasks() {"], [247, "    long currentNanoTime = System.nanoTime();"], [248, "    // sleep forever by default"], [249, "    sleepNanoTime = Long.MAX_VALUE;"], [250, "    synchronized (getTasks) {"], [251, "      Iterator<GetTask> iterator = getTasks.iterator();"], [252, "      while (iterator.hasNext()) {"], [253, "        GetTask task = iterator.next();"], [254, ""], [255, "        // If we have queryTimeoutNano set, keep track of the next task to queryTimeoutNano to adjust sleep time."], [256, "        if (queryTimeoutNano != 0) {"], [257, "          long taskNanoTimeBeforeTimeout = task.getNanoTimeBeforeTimeout(currentNanoTime);"], [258, "          sleepNanoTime = Math.min(sleepNanoTime, taskNanoTimeBeforeTimeout);"], [259, "          if (taskNanoTimeBeforeTimeout == 0) {"], [260, "            iterator.remove();"], [261, "            task.completeWithTimeout();"], [262, "            continue;"], [263, "          }"], [264, "        }"], [265, ""], [266, "        if (task.execute()) {"], [267, "          iterator.remove();"], [268, "        }"], [269, "      }"], [270, ""], [271, "    }"], [272, "  }"]]}, "num_lines_added": 114, "num_lines_removed": 146}