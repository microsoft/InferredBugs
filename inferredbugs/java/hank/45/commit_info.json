{"hash": "40936c9c177bc71ef051cc10210ea49688e6b858", "message": "Revamped DoublePopulationStatisticsAggregator. Use reservoir sampling.", "file_num_lines": 199, "diff_parsed": {"added": [[21, "import java.util.Random;"], [25, "  private static int POPULATION_RANDOM_SAMPLE_MAX_SIZE = 100;"], [26, ""], [35, "  private final ReservoirSample reservoirSample = new ReservoirSample(POPULATION_RANDOM_SAMPLE_MAX_SIZE);"], [36, "  private final Random random = new Random();"], [39, "    clear();"], [46, "                                              double[] randomSample) {"], [51, "    this.reservoirSample.sample(randomSample, random);"], [59, "    reservoirSample.clear();"], [62, "  public void aggregate(double minimum, double maximum, long numValues, double total, double[] randomSample) {"], [71, "    this.reservoirSample.sample(randomSample, random);"], [83, "    this.reservoirSample.sample(other.reservoirSample, random);"], [108, "  public double[] computeDeciles() {"], [109, "    double[] result = new double[9];"], [110, "    Arrays.fill(result, 0.0);"], [111, "    if (reservoirSample.getSize() > 0) {"], [112, "      // Sort valid reservoir values first"], [113, "      Arrays.sort(reservoirSample.getReservoir(), 0, reservoirSample.getSize());"], [114, "      // Compute deciles"], [115, "      for (int i = 0; i < 9; ++i) {"], [116, "        result[i] = getSortedPopulationDecile(reservoirSample.getReservoir(), i + 1, reservoirSample.getSize());"], [117, "      }"], [118, "    }"], [119, "    return result;"], [131, "    for (int i = 0; i < populationStatistics.reservoirSample.getSize(); ++i) {"], [133, "      result.append(populationStatistics.reservoirSample.getReservoir()[i]);"], [149, "    double[] deciles = computeDeciles();"], [151, "    // Compute median"], [153, "    // Compute 90% percentile"], [164, "  public class ReservoirSample {"], [165, ""], [166, "    private final double[] reservoir;"], [167, "    private int size;"], [168, "    private int count;"], [169, ""], [170, "    public ReservoirSample(int reservoirMaxSize) {"], [171, "      reservoir = new double[reservoirMaxSize];"], [172, "      clear();"], [173, "    }"], [174, ""], [175, "    public void sample(double[] values, Random random) {"], [176, "      for (double value : values) {"], [177, "        sample(value, random);"], [178, "      }"], [179, "    }"], [180, ""], [181, "    public void sample(double value, Random random) {"], [182, "      if (count < reservoir.length) {"], [183, "        reservoir[size++] = value;"], [184, "      } else {"], [185, "        if (random.nextInt(count) < reservoir.length) {"], [186, "          reservoir[random.nextInt(reservoir.length)] = value;"], [187, "        }"], [188, "      }"], [189, "      ++count;"], [190, "    }"], [192, "    public void sample(ReservoirSample other, Random random) {"], [193, "      for (int i = 0; i < other.getSize(); ++i) {"], [194, "        sample(other.getReservoir()[i], random);"], [195, "      }"], [196, "    }"], [198, "    public double[] getReservoir() {"], [199, "      return reservoir;"], [202, "    public int getSize() {"], [203, "      return size;"], [206, "    public void clear() {"], [207, "      size = 0;"], [208, "      count = 0;"], [212, "  public static double getSortedPopulationDecile(double[] population, int decile, int endIndex) {"], [213, "    return getInterpolatedValueAtIndex(population, getDecileIndex(endIndex, decile));"], [214, "  }"], [215, ""], [216, "  public static double getSortedPopulationDecile(long[] population, int decile, int endIndex) {"], [217, "    return getInterpolatedValueAtIndex(population, getDecileIndex(endIndex, decile));"], [218, "  }"], [219, ""], [221, "    return getInterpolatedValueAtIndex(population, getDecileIndex(population.length, decile));"], [225, "    return getInterpolatedValueAtIndex(population, getDecileIndex(population.length, decile));"], [228, "  public static double getDecileIndex(long size, int decile) {"], [232, "    return ((size - 1) / 10.0) * decile;"], [239, "    if (remainder == 0 || ((int) rankFloored) == population.length - 1) {"], [240, "      return population[(int) rankFloored];"], [241, "    }"], [242, ""], [251, "    if (remainder == 0 || ((int) rankFloored) == population.length - 1) {"], [252, "      return population[(int) rankFloored];"], [253, "    }"], [254, ""]], "deleted": [[32, "  private double[] deciles;"], [35, "    minimum = Double.MAX_VALUE;"], [36, "    maximum = Double.MIN_VALUE;"], [37, "    numValues = 0;"], [38, "    total = 0.0;"], [39, "    deciles = new double[]{0, 0, 0, 0, 0, 0, 0, 0, 0};"], [46, "                                              double[] deciles) {"], [47, "    if (deciles.length != 9) {"], [48, "      throw new RuntimeException(\"Invalid population statistics: num deciles =\" + deciles.length);"], [49, "    }"], [54, "    this.deciles = deciles;"], [62, "    Arrays.fill(deciles, 0);"], [65, "  public void aggregate(double minimum, double maximum, long numValues, double total, double[] deciles) {"], [66, "    if (numValues < 10 || deciles.length != 9) {"], [67, "      throw new RuntimeException(\"Invalid population statistics to aggregate. numValues=\""], [68, "          + numValues + \", deciles.length=\" + deciles.length);"], [69, "    }"], [70, "    if (this.numValues == 0) {"], [71, "      // Copy deciles directly"], [72, "      System.arraycopy(deciles, 0, this.deciles, 0, 9);"], [73, "    } else if (numValues == 0) {"], [74, "      // Do nothing"], [75, "    } else {"], [76, "      aggregateDeciles(this.deciles, this.numValues, this.getMaximum(),"], [77, "          deciles, numValues, maximum,"], [78, "          this.deciles);"], [79, "    }"], [91, "    if (numValues == 0) {"], [92, "      // Copy deciles directly"], [93, "      System.arraycopy(other.deciles, 0, deciles, 0, 9);"], [94, "    } else if (other.numValues == 0) {"], [95, "      // Keep this deciles unchanged"], [96, "    } else {"], [97, "      // Aggregate both deciles"], [98, "      aggregateDeciles(this.deciles, this.numValues, this.getMaximum(),"], [99, "          other.deciles, other.numValues, other.getMaximum(),"], [100, "          this.deciles);"], [101, "    }"], [110, "  }"], [111, ""], [112, "  private static void aggregateDeciles(double[] decilesA, long numValuesA, double maximumA,"], [113, "                                       double[] decilesB, long numValuesB, double maximumB,"], [114, "                                       double[] outputDeciles) {"], [115, "    // Compute all deciles"], [116, "    ValueAndCount[] allDeciles = new ValueAndCount[2 * 10];"], [117, "    // Load all decile values and counts into one array"], [118, "    for (int i = 0; i < 9; ++i) {"], [119, "      allDeciles[i] = new ValueAndCount(decilesA[i], numValuesA);"], [120, "      allDeciles[i + 9] = new ValueAndCount(decilesB[i], numValuesB);"], [121, "    }"], [122, ""], [123, "    // Fake deciles to fill in voids"], [124, "    allDeciles[18] = new ValueAndCount(maximumA, numValuesA);"], [125, "    allDeciles[19] = new ValueAndCount(maximumB, numValuesB);"], [126, ""], [127, "    // Sort all deciles"], [128, "    Arrays.sort(allDeciles);"], [129, ""], [130, "    // Update deciles"], [131, "    final long numValuesCombined = 10 * (numValuesA + numValuesB);"], [132, "    long previousRank = 0;"], [133, "    int j = 0;"], [134, "    for (int i = 0; i < 9; ++i) {"], [135, "      final long decileRank = Math.round(getDecileRank(numValuesCombined, i + 1));"], [136, "      while (previousRank + allDeciles[j].count < decileRank) {"], [137, "        previousRank += allDeciles[j].count;"], [138, "        j += 1;"], [139, "      }"], [140, ""], [141, "      // j point to the current segment where the correct decile rank lies"], [142, "      if (j == 0) {"], [143, "        // For the first decile, consider all value to be equal (no interpolation)"], [144, "        outputDeciles[i] = allDeciles[j].value;"], [145, "      } else {"], [146, "        // Interpolate value for other deciles"], [147, "        outputDeciles[i] ="], [148, "            interpolateValueWithinValueAndCounts(allDeciles[j - 1].value,"], [149, "                allDeciles[j],"], [150, "                decileRank - previousRank);"], [151, "      }"], [152, "    }"], [153, "  }"], [154, ""], [155, "  public static double interpolateValueWithinValueAndCounts(double value, ValueAndCount segment, long indexInSegment) {"], [156, "    double remainder = (double) (indexInSegment + 1) / (double) segment.count;"], [157, "    return value + remainder * (segment.value - value);"], [182, "  public double[] getDeciles() {"], [183, "    return deciles;"], [195, "    for (int i = 0; i < 9; ++i) {"], [197, "      result.append(populationStatistics.deciles[i]);"], [214, "    // Compute median on the fly"], [216, "    // Compute 90% percentile on the fly"], [227, "  public static class ValueAndCount implements Comparable<ValueAndCount> {"], [229, "    public final double value;"], [230, "    public final long count;"], [232, "    public ValueAndCount(double value, long count) {"], [233, "      this.value = value;"], [234, "      this.count = count;"], [237, "    @Override"], [238, "    public int compareTo(DoublePopulationStatisticsAggregator.ValueAndCount other) {"], [239, "      return Double.compare(value, other.value);"], [242, "    @Override"], [243, "    public String toString() {"], [244, "      return value + \"(\" + count + \")\";"], [249, "    return getInterpolatedValueAtIndex(population, getDecileRank(population.length, decile));"], [253, "    return getInterpolatedValueAtIndex(population, getDecileRank(population.length, decile));"], [256, "  public static double getDecileRank(long size, int decile) {"], [260, "    if (size < 10) {"], [261, "      throw new RuntimeException(\"Population is too small to compute deciles. Size: \" + size);"], [262, "    }"], [263, "    return ((size / 10.0) * decile) - 1;"]]}, "num_lines_added": 88, "num_lines_removed": 111}