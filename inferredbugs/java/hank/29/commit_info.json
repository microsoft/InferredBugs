{"hash": "bed103b5a58a14f0af78fa5b5b8800d6ae610afd", "message": "Factor out the merge sort logic from CueballMerger to the new class\nCueballStreamBufferMergeSort", "file_num_lines": 36, "diff_parsed": {"added": [[37, "    CueballStreamBufferMergeSort cueballStreamBufferMergeSort = new CueballStreamBufferMergeSort(base,"], [38, "        deltas,"], [39, "        keyHashSize,"], [40, "        hashIndexBits,"], [41, "        valueSize,"], [42, "        compressionCodec,"], [43, "        transformer);"], [53, "      CueballStreamBufferMergeSort.KeyHashValuePair keyValuePair = cueballStreamBufferMergeSort.nextKeyValuePair();"], [54, "      if (keyValuePair == null) {"], [59, "      newCueballBaseWriter.writeHash(keyValuePair.keyHash, keyValuePair.value);"], [63, "    cueballStreamBufferMergeSort.close();"]], "deleted": [[23, "import java.nio.ByteBuffer;"], [37, "    // Array of stream buffers for the base and all deltas in order"], [38, "    CueballStreamBuffer[] cueballStreamBuffers = new CueballStreamBuffer[deltas.size() + 1];"], [40, "    // Open the current base"], [41, "    CueballStreamBuffer cueballBaseStreamBuffer = new CueballStreamBuffer(base.getPath(), 0,"], [42, "        keyHashSize, valueSize, hashIndexBits, compressionCodec);"], [43, "    cueballStreamBuffers[0] = cueballBaseStreamBuffer;"], [44, ""], [45, "    // Open all the deltas"], [46, "    int i = 1;"], [47, "    for (CueballFilePath delta : deltas) {"], [48, "      CueballStreamBuffer cueballStreamBuffer ="], [49, "          new CueballStreamBuffer(delta.getPath(), i, keyHashSize, valueSize, hashIndexBits, compressionCodec);"], [50, "      cueballStreamBuffers[i++] = cueballStreamBuffer;"], [51, "    }"], [61, "      // Find the stream buffer with the next smallest key hash"], [62, "      CueballStreamBuffer cueballStreamBufferToUse = null;"], [63, "      for (i = 0; i < cueballStreamBuffers.length; i++) {"], [64, "        if (cueballStreamBuffers[i].anyRemaining()) {"], [65, "          if (cueballStreamBufferToUse == null) {"], [66, "            cueballStreamBufferToUse = cueballStreamBuffers[i];"], [67, "          } else {"], [68, "            int comparison = cueballStreamBufferToUse.compareTo(cueballStreamBuffers[i]);"], [69, "            if (comparison == 0) {"], [70, "              // If two equal key hashes are found, use the most recent value (i.e. the one from the lastest delta)"], [71, "              // and skip (consume) the older ones"], [72, "              cueballStreamBufferToUse.consume();"], [73, "              cueballStreamBufferToUse = cueballStreamBuffers[i];"], [74, "            } else if (comparison == 1) {"], [75, "              // Found a stream buffer with a smaller key hash"], [76, "              cueballStreamBufferToUse = cueballStreamBuffers[i];"], [77, "            }"], [78, "          }"], [79, "        }"], [80, "      }"], [81, ""], [82, "      if (cueballStreamBufferToUse == null) {"], [83, "        // Nothing more to write"], [87, "      // Transform if necessary"], [88, "      if (transformer != null) {"], [89, "        transformer.transform(cueballStreamBufferToUse.getBuffer(),"], [90, "            cueballStreamBufferToUse.getCurrentOffset() + keyHashSize,"], [91, "            cueballStreamBufferToUse.getIndex());"], [92, "      }"], [93, ""], [94, "      // Get next key hash and value"], [95, "      final ByteBuffer keyHash = ByteBuffer.wrap(cueballStreamBufferToUse.getBuffer(),"], [96, "          cueballStreamBufferToUse.getCurrentOffset(), keyHashSize);"], [97, "      final ByteBuffer valueBytes = ByteBuffer.wrap(cueballStreamBufferToUse.getBuffer(),"], [98, "          cueballStreamBufferToUse.getCurrentOffset() + keyHashSize, valueSize);"], [99, ""], [101, "      newCueballBaseWriter.writeHash(keyHash, valueBytes);"], [102, "      cueballStreamBufferToUse.consume();"], [106, "    for (CueballStreamBuffer cueballStreamBuffer : cueballStreamBuffers) {"], [107, "      cueballStreamBuffer.close();"], [108, "    }"]]}, "num_lines_added": 11, "num_lines_removed": 56}