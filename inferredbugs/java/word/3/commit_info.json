{"hash": "e7de13e14184f0c15da46cfd6ac35f5dfd955348", "message": "\u4f7f\u7528\u6700\u77ed\u8def\u5f84\u7b97\u6cd5", "file_num_lines": 143, "diff_parsed": {"added": [[23, "import org.apdplat.word.corpus.Bigram;"], [26, ""], [27, "import java.util.*;"], [39, "        //\u6587\u672c\u957f\u5ea6"], [40, "        final int textLen = text.length();"], [41, "        //\u5f00\u59cb\u865a\u62df\u8282\u70b9\uff0c\u6ce8\u610f\u503c\u7684\u957f\u5ea6\u53ea\u80fd\u4e3a1"], [42, "        Node start = new Node(\"S\", 0);"], [43, "        start.score = 1F;"], [44, "        //\u7ed3\u675f\u865a\u62df\u8282\u70b9"], [45, "        Node end = new Node(\"END\", textLen+1);"], [46, "        //\u4ee5\u6587\u672c\u4e2d\u6bcf\u4e00\u4e2a\u5b57\u7684\u4f4d\u7f6e\uff08\u4ece1\u5f00\u59cb\uff09\u4f5c\u4e3a\u4e8c\u7ef4\u6570\u7ec4\u7684\u6a2a\u5750\u6807"], [47, "        //\u4ee5\u6bcf\u4e00\u4e2a\u5b57\u5f00\u59cb\u6240\u80fd\u5207\u5206\u51fa\u6765\u7684\u6240\u6709\u7684\u8bcd\u7684\u987a\u5e8f\u4f5c\u4e3a\u7eb5\u5750\u6807\uff08\u4ece0\u5f00\u59cb\uff09"], [48, "        Node[][] dag = new Node[textLen+2][0];"], [49, "        dag[0] = new Node[] { start };"], [50, "        dag[textLen+1] = new Node[] { end };"], [51, "        for(int i=0; i<textLen; i++){"], [52, "            dag[i+1] = fullSeg(text, i);"], [53, "        }"], [54, "        dump(dag);"], [55, "        //\u6807\u6ce8\u8def\u5f84"], [56, "        int following = 0;"], [57, "        Node node = null;"], [58, "        for (int i = 0; i < dag.length - 1; i++) {"], [59, "            for (int j = 0; j < dag[i].length; j++) {"], [60, "                node = dag[i][j];"], [61, "                following = node.getFollowing();"], [62, "                for (int k = 0; k < dag[following].length; k++) {"], [63, "                    dag[following][k].setPrevious(node);"], [67, "        dump(dag);"], [68, "        return toWords(end);"], [70, ""], [72, "     * \u53cd\u5411\u904d\u5386\u751f\u6210\u5168\u5207\u5206\u7ed3\u679c"], [73, "     * @param node \u7ed3\u675f\u865a\u62df\u8282\u70b9"], [76, "    private List<Word> toWords(Node node){"], [77, "        Stack<String> stack = new Stack<>();"], [78, "        while ((node = node.getPrevious()) != null) {"], [79, "            if(!\"S\".equals(node.getText())) {"], [80, "                stack.push(node.getText());"], [83, "        int len = stack.size();"], [84, "        List<Word> list = new ArrayList<>(len);"], [85, "        for(int i=0; i<len; i++){"], [86, "            list.add(new Word(stack.pop()));"], [88, "        return list;"], [90, ""], [97, "    private Node[] fullSeg(final String text, final int start) {"], [98, "        List<Node> result = new LinkedList<>();"], [99, "        //\u589e\u52a0\u5355\u5b57\u8bcd"], [100, "        result.add(new Node(text.substring(start, start + 1), start+1));"], [101, "        //\u6587\u672c\u957f\u5ea6"], [112, "                result.add(new Node(text.substring(start, start + len), start+1));"], [116, "        return result.toArray(new Node[0]);"], [118, ""], [120, "     * \u8f93\u51fa\u6709\u5411\u65e0\u73af\u56fe\u7684\u7ed3\u6784"], [121, "     * @param dag"], [123, "    private void dump(Node[][] dag){"], [125, "            LOGGER.debug(\"\u5168\u5207\u5206\u6709\u5411\u65e0\u73af\u56fe\uff1a\");"], [126, "            for (Node[] nodes : dag) {"], [127, "                StringBuilder line = new StringBuilder();"], [128, "                for (Node node : nodes) {"], [129, "                    line.append(\"\u3010\")"], [130, "                            .append(node.getText())"], [131, "                            .append(\"(\").append(node.getScore()).append(\")\")"], [132, "                            .append(\"<-\").append(node.getPrevious()==null?\"\":node.getPrevious().getText())"], [133, "                            .append(\"\u3011\\t\");"], [134, "                }"], [135, "                LOGGER.debug(line.toString());"], [139, ""], [141, "     * \u6709\u5411\u65e0\u73af\u56fe \u7684 \u56fe\u8282\u70b9"], [143, "    private static class Node {"], [145, "        private Node previous;"], [146, "        private int offset;"], [147, "        private Float score;"], [148, ""], [149, "        public Node(String text, int offset) {"], [151, "            this.offset = offset;"], [153, ""], [157, ""], [161, ""], [162, "        public int getOffset() {"], [163, "            return offset;"], [164, "        }"], [165, ""], [166, "        public void setOffset(int offset) {"], [167, "            this.offset = offset;"], [168, "        }"], [169, ""], [170, "        public Float getScore() {"], [171, "            return score;"], [172, "        }"], [173, ""], [174, "        public void setScore(Float score) {"], [175, "            this.score = score;"], [176, "        }"], [177, ""], [178, "        public Node getPrevious() {"], [179, "            return previous;"], [181, ""], [182, "        public void setPrevious(Node previous) {"], [183, "            float distance = 1 - Bigram.getScore(previous.getText(), this.getText());"], [184, "            if (this.score == null) {"], [185, "                this.score = previous.score + distance;"], [186, "                this.previous = previous;"], [187, "            } else if (previous.score + distance < this.score) {"], [188, "                //\u53d1\u73b0\u66f4\u77ed\u7684\u8def\u5f84"], [189, "                this.score = previous.score + distance;"], [190, "                this.previous = previous;"], [191, "            }"], [193, ""], [194, "        public int getFollowing() {"], [195, "            return this.offset + text.length();"], [196, "        }"], [197, ""], [200, "            return \"Node{\" +"], [201, "                    \"text='\" + text + '\\'' +"], [202, "                    \", previous=\" + previous +"], [203, "                    \", offset=\" + offset +"], [204, "                    \", score=\" + score +"], [205, "                    '}';"], [208, ""], [211, "        if(args !=null && args.length > 0){"], [212, "            System.out.println(m.seg(Arrays.asList(args).toString()));"], [213, "            return;"], [214, "        }"], [215, "        String text = \"\u8776\u821e\u6253\u626e\u5f97\u6f02\u6f02\u4eae\u4eae\u51fa\u73b0\u5728\u5f20\u516c\u516c\u9762\u524d\";"], [216, "        System.out.println(m.seg(text));"]], "deleted": [[23, "import java.util.ArrayList;"], [24, "import java.util.Iterator;"], [25, "import java.util.LinkedList;"], [26, "import java.util.List;"], [27, "import java.util.Map;"], [28, "import java.util.Map.Entry;"], [29, "import java.util.Stack;"], [31, "import org.apdplat.word.segmentation.SegmentationAlgorithm;"], [32, "import org.apdplat.word.segmentation.SegmentationFactory;"], [34, "import org.apdplat.word.util.Utils;"], [44, "    private static final AbstractSegmentation RMM = (AbstractSegmentation)SegmentationFactory.getSegmentation(SegmentationAlgorithm.ReverseMaximumMatching);"], [45, "    //\u5728\u8bc4\u4f30\u91c7\u7528\u7684\u6d4b\u8bd5\u6587\u672c253 3709\u884c2837 4490\u4e2a\u5b57\u7b26\u4e2d,\u884c\u957f\u5ea6\u5c0f\u4e8e\u7b49\u4e8e50\u7684\u5360\u4e8699.932465%"], [46, "    //\u5927\u4e8e50\u7684\u884c\u957f\u5ea6\u6587\u672c\u91c7\u7528\u9006\u5411\u6700\u5927\u5339\u914d\u7b97\u6cd5\u5207\u5206\u6587\u672c"], [47, "    private static final int PROCESS_TEXT_LENGTH_LESS_THAN = 50;"], [48, "    //\u957f\u5ea6\u5c0f\u4e8e\u7b49\u4e8e18\u7684\u6587\u672c\u5355\u5b57\u6210\u8bcd\uff0c\u5927\u4e8e18\u7684\u6587\u672c\u53ea\u6709\u65e0\u8bcd\u65f6\u624d\u5355\u5b57\u6210\u8bcd"], [49, "    private static final int CHAR_IS_WORD_LENGTH_LESS_THAN = 18;"], [52, "        if(text.length() > PROCESS_TEXT_LENGTH_LESS_THAN){"], [53, "            return RMM.segImpl(text);"], [54, "        }"], [55, "        //\u83b7\u53d6\u5168\u5207\u5206\u7ed3\u679c"], [56, "        List<Word>[] array = fullSeg(text);"], [57, "        //\u5229\u7528ngram\u8ba1\u7b97\u5206\u503c"], [58, "        Map<List<Word>, Float> words = ngram(array);"], [59, "        //\u6b67\u4e49\u6d88\u89e3\uff08ngram\u5206\u503c\u4f18\u5148\u3001\u8bcd\u4e2a\u6570\u5c11\u4f18\u5148\uff09"], [60, "        List<Word> result = disambiguity(words);"], [61, "        return result;"], [62, "    }"], [63, "    private List<Word> disambiguity(Map<List<Word>, Float> words){"], [64, "        //\u6309\u5206\u503c\u6392\u5e8f"], [65, "        List<Entry<List<Word>, Float>> entrys = Utils.getSortedMapByValue(words);"], [66, "        if(LOGGER.isDebugEnabled()){"], [67, "            LOGGER.debug(\"ngram\u5206\u503c\uff1a\");"], [68, "            int i=1;"], [69, "            for(Entry<List<Word>, Float> entry : entrys){"], [70, "                LOGGER.debug(\"\\t\"+(i++)+\"\u3001\"+\"\u8bcd\u4e2a\u6570=\"+entry.getKey().size()+\"\\tngram\u5206\u503c=\"+entry.getValue()+\"\\t\"+entry.getKey());"], [71, "            }"], [72, "        }"], [73, "        //\u79fb\u9664\u5c0f\u4e8e\u6700\u5927\u5206\u503c\u7684\u5207\u5206\u7ed3\u679c"], [74, "        float maxScore=entrys.get(0).getValue();"], [75, "        Iterator<Entry<List<Word>, Float>> iter = entrys.iterator();"], [76, "        while(iter.hasNext()){"], [77, "            Entry<List<Word>, Float> entry = iter.next();"], [78, "            if(entry.getValue() < maxScore){"], [79, "                entry.getKey().clear();"], [80, "                iter.remove();"], [81, "            }"], [82, "        }"], [83, "        if(LOGGER.isDebugEnabled()){"], [84, "            LOGGER.debug(\"\u53ea\u4fdd\u7559\u6700\u5927\u5206\u503c\uff1a\");"], [85, "            int i=1;"], [86, "            for(Entry<List<Word>, Float> entry : entrys){"], [87, "                LOGGER.debug(\"\\t\"+(i++)+\"\u3001\"+\"\u8bcd\u4e2a\u6570=\"+entry.getKey().size()+\"\\tngram\u5206\u503c=\"+entry.getValue()+\"\\t\"+entry.getKey());"], [88, "            }"], [89, "        }"], [90, "        //\u5982\u679c\u6709\u591a\u4e2a\u5206\u503c\u4e00\u6837\u7684\u5207\u5206\u7ed3\u679c\uff0c\u5219\u9009\u62e9\u8bcd\u4e2a\u6570\u6700\u5c11\u7684\uff08\u6700\u5c11\u5206\u8bcd\u539f\u5219\uff09"], [91, "        int minSize=Integer.MAX_VALUE;"], [92, "        List<Word> minSizeList = null;"], [93, "        iter = entrys.iterator();"], [94, "        while(iter.hasNext()){"], [95, "            Entry<List<Word>, Float> entry = iter.next();"], [96, "            if(entry.getKey().size() < minSize){"], [97, "                minSize = entry.getKey().size();"], [98, "                if(minSizeList != null){"], [99, "                    minSizeList.clear();"], [101, "                minSizeList = entry.getKey();"], [102, "            }else{"], [103, "                entry.getKey().clear();"], [104, "                iter.remove();"], [107, "        if(LOGGER.isDebugEnabled()){"], [108, "            LOGGER.debug(\"\u6700\u5927\u5206\u503c\uff1a\"+maxScore+\", \u6d88\u6b67\u7ed3\u679c\uff1a\"+minSizeList+\"\uff0c\u8bcd\u4e2a\u6570\uff1a\"+minSize);"], [109, "        }"], [110, "        return minSizeList;"], [113, "     * \u83b7\u53d6\u6587\u672c\u7684\u6240\u6709\u53ef\u80fd\u5207\u5206\u7ed3\u679c"], [114, "     * @param text \u6587\u672c"], [117, "    private List<Word>[] fullSeg(String text){"], [118, "        //\u6587\u672c\u957f\u5ea6"], [119, "        final int textLen = text.length();"], [120, "        //\u4ee5\u6bcf\u4e00\u4e2a\u5b57\u4f5c\u4e3a\u8bcd\u7684\u5f00\u59cb\uff0c\u6240\u80fd\u5207\u5206\u7684\u8bcd"], [121, "        List<String>[] sequence = new LinkedList[textLen];"], [122, "        for(int start=0; start<textLen; start++){"], [123, "            sequence[start] = fullSeg(text, start);"], [124, "        }"], [125, "        if(LOGGER.isDebugEnabled()){"], [126, "            LOGGER.debug(\"\u5168\u5207\u5206\u4e2d\u95f4\u7ed3\u679c\uff1a\");"], [127, "            int i=1;"], [128, "            for(List<String> list : sequence){"], [129, "                LOGGER.debug(\"\\t\"+(i++)+\"\u3001\"+list);"], [132, "        //\u6811\u53f6"], [133, "        List<Node> leaf = new LinkedList<>();"], [134, "        for(String word : sequence[0]){"], [135, "            //\u6811\u6839"], [136, "            Node node = new Node(word);"], [137, "            //\u628a\u5168\u5207\u5206\u4e2d\u95f4\u7ed3\u679c\uff08\u4e8c\u7ef4\u6570\u7ec4\uff09\u8f6c\u6362\u4e3a\u5408\u7406\u5207\u5206"], [138, "            buildNode(node, sequence, word.length(), leaf);"], [139, "        }"], [140, "        //\u6e05\u7406\u65e0\u7528\u6570\u636e"], [141, "        for(int j=0; j<sequence.length; j++){"], [142, "            sequence[j].clear();"], [143, "            sequence[j] = null;"], [145, "        sequence = null;"], [146, "        //\u4ece\u6240\u6709\u6811\u53f6\u5f00\u59cb\u53cd\u5411\u904d\u5386\u51fa\u5168\u5207\u5206\u7ed3\u679c"], [147, "        List<Word>[] res = toWords(leaf);"], [148, "        leaf.clear();"], [149, "        return res;"], [157, "    private List<String> fullSeg(final String text, final int start) {"], [158, "        List<String> result = new LinkedList<>();"], [169, "                result.add(text.substring(start, start + len));"], [173, "        if(textLen <= CHAR_IS_WORD_LENGTH_LESS_THAN || result.isEmpty()){"], [174, "            //\u589e\u52a0\u5355\u5b57\u8bcd"], [175, "            result.add(text.substring(start, start + 1));"], [176, "        }"], [177, "        return result;"], [178, "    }"], [179, "    /**"], [180, "     * \u6839\u636e\u5168\u5207\u5206\u4e2d\u95f4\u7ed3\u679c\u6784\u9020\u5207\u5206\u6811"], [181, "     * @param parent \u7236\u8282\u70b9"], [182, "     * @param sequence \u5168\u5207\u5206\u4e2d\u95f4\u7ed3\u679c"], [183, "     * @param from \u5168\u5207\u5206\u4e2d\u95f4\u7ed3\u679c\u6570\u7ec4\u4e0b\u6807\u7d22\u5f15"], [184, "     * @param leaf \u53f6\u5b50\u8282\u70b9\u96c6\u5408"], [185, "     */"], [186, "    private void buildNode(Node parent, List<String>[] sequence, int from, List<Node> leaf){"], [187, "        //\u9012\u5f52\u9000\u51fa\u6761\u4ef6\uff1a\u4e8c\u7ef4\u6570\u7ec4\u904d\u5386\u5b8c\u6bd5"], [188, "        if(from >= sequence.length){"], [189, "            //\u8bb0\u4f4f\u53f6\u5b50\u8282\u70b9"], [190, "            leaf.add(parent);"], [191, "            return;"], [192, "        }"], [193, "        for(String item : sequence[from]){"], [194, "            Node child = new Node(item, parent);"], [195, "            buildNode(child, sequence, from+item.length(), leaf);"], [196, "        }"], [199, "     * \u4ece\u6811\u53f6\u5f00\u59cb\u53cd\u5411\u904d\u5386\u751f\u6210\u5168\u5207\u5206\u7ed3\u679c"], [200, "     * @param leaf \u6811\u53f6\u8282\u70b9\u96c6\u5408"], [201, "     * @return \u5168\u5207\u5206\u7ed3\u679c\u96c6\u5408"], [203, "    private List<Word>[] toWords(List<Node> leaf){"], [204, "        List<Word>[] result = new ArrayList[leaf.size()];"], [205, "        int i = 0;"], [207, "            LOGGER.debug(\"\u5168\u5207\u5206\u7ed3\u679c\uff1a\");"], [208, "        }"], [209, "        for(Node node : leaf){"], [210, "            result[i++] = toWords(node);"], [211, "            if(LOGGER.isDebugEnabled()) {"], [212, "                LOGGER.debug(\"\\t\" + i + \"\uff1a\" + result[i - 1]);"], [215, "        return result;"], [216, "    }"], [217, "    /**"], [218, "     * \u4ece\u6811\u53f6\u5f00\u59cb\u53cd\u5411\u904d\u5386\u751f\u6210\u5168\u5207\u5206\u7ed3\u679c"], [219, "     * @param node \u6811\u53f6\u8282\u70b9"], [220, "     * @return \u5168\u5207\u5206\u7ed3\u679c"], [221, "     */"], [222, "    private List<Word> toWords(Node node){"], [223, "        Stack<String> stack = new Stack<>();"], [224, "        while(node != null){"], [225, "            stack.push(node.getText());"], [226, "            node = node.getParent();"], [227, "        }"], [228, "        int len = stack.size();"], [229, "        List<Word> list = new ArrayList<>(len);"], [230, "        for(int i=0; i<len; i++){"], [231, "            list.add(new Word(stack.pop()));"], [232, "        }"], [233, "        return list;"], [236, "     * \u6811\u8282\u70b9"], [237, "     * \u53ea\u9700\u8981\u53cd\u5411\u904d\u5386"], [238, "     * \u4e0d\u9700\u8981\u8bb0\u4f4f\u5b50\u8282\u70b9\uff0c\u77e5\u9053\u7236\u8282\u70b9\u5373\u53ef"], [240, "    private static class Node{"], [242, "        private Node parent;"], [243, "        public Node(String text) {"], [244, "            this.text = text;"], [245, "        }"], [246, "        public Node(String text, Node parent) {"], [248, "            this.parent = parent;"], [256, "        public Node getParent() {"], [257, "            return parent;"], [259, "        public void setParent(Node parent) {"], [260, "            this.parent = parent;"], [264, "            return this.text;"], [268, "        String text = \"\u4e2d\u56fd\u4eba\u6c11\u5171\u548c\u56fd\";"], [269, "        if(args !=null && args.length == 1){"], [270, "            text = args[0];"], [271, "        }"], [273, "        System.out.println(m.seg(text).toString());"]]}, "num_lines_added": 125, "num_lines_removed": 182}