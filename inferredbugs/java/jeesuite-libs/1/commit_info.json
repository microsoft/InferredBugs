{"hash": "e53ad5c8f5f34ad094a209b872c6ac4acc6512ed", "message": "+", "file_num_lines": 192, "diff_parsed": {"added": [[51, "\tprivate List<ConsumerWorker> consumerWorks = new ArrayList<>();"], [53, "\tprivate KafkaConsumer<String, DefaultMessage> consumer;"], [67, "\t\tcreateKafkaConsumer();"], [68, "\t\t//\u6309\u4e3b\u9898\u6570\u521b\u5efaConsumerWorker\u7ebf\u7a0b"], [70, "\t\t\tConsumerWorker consumer = new ConsumerWorker();"], [71, "\t\t\tconsumerWorks.add(consumer);"], [78, "\t\tfor (int i = 0; i < consumerWorks.size(); i++) {"], [79, "\t\t\tconsumerWorks.get(i).close();"], [80, "\t\t\tconsumerWorks.remove(i);"], [85, "\t\tconsumer.close();"], [88, "\tfinal Map<TopicPartition, Long> partitionToUncommittedOffsetMap = new ConcurrentHashMap<>();"], [89, "\tfinal List<Future<Boolean>> futures = new ArrayList<>();"], [90, ""], [91, "\tprivate <K extends Serializable, V extends DefaultMessage> void createKafkaConsumer(){"], [92, "\t\tconsumer = new KafkaConsumer<>(configs);"], [93, "\t\tConsumerRebalanceListener listener = new ConsumerRebalanceListener() {"], [95, "\t\t\t@Override"], [96, "\t\t\tpublic void onPartitionsRevoked(Collection<TopicPartition> partitions) {"], [97, "\t\t\t\tif (!futures.isEmpty())"], [98, "\t\t\t\t\tfutures.get(0).cancel(true);"], [100, "\t\t\t\tcommitOffsets(partitionToUncommittedOffsetMap);"], [101, "\t\t\t}"], [103, "\t\t\t@Override"], [104, "\t\t\tpublic void onPartitionsAssigned(Collection<TopicPartition> partitions) {"], [105, "\t\t\t\tfor (TopicPartition tp : partitions) {"], [106, "\t\t\t\t\tOffsetAndMetadata offsetAndMetaData = consumer.committed(tp);"], [107, "\t\t\t\t\tlong startOffset = offsetAndMetaData != null ? offsetAndMetaData.offset() : -1L;"], [108, "\t\t\t\t\tlogger.info(\"Assigned topicPartion : {} offset : {}\", tp, startOffset);"], [109, ""], [110, "\t\t\t\t\tif (startOffset >= 0)"], [111, "\t\t\t\t\t\tconsumer.seek(tp, startOffset);"], [112, "\t\t\t\t}"], [113, "\t\t\t}"], [114, "\t\t};"], [116, "\t\tList<String> topics = new ArrayList<>(topicHandlers.keySet());"], [117, "\t\tconsumer.subscribe(topics, listener);"], [118, "\t}"], [119, ""], [120, ""], [121, "\tprivate void commitOffsets(Map<TopicPartition, Long> partitionToOffsetMap) {"], [122, ""], [123, "\t\tif (!partitionToOffsetMap.isEmpty()) {"], [124, "\t\t\tMap<TopicPartition, OffsetAndMetadata> partitionToMetadataMap = new HashMap<>();"], [125, "\t\t\tfor (Entry<TopicPartition, Long> e : partitionToOffsetMap.entrySet()) {"], [126, "\t\t\t\tpartitionToMetadataMap.put(e.getKey(), new OffsetAndMetadata(e.getValue() + 1));"], [127, "\t\t\t}"], [128, ""], [129, "\t\t\tlogger.info(\"committing the offsets : {}\", partitionToMetadataMap);"], [130, "\t\t\tconsumer.commitSync(partitionToMetadataMap);"], [131, "\t\t\tpartitionToOffsetMap.clear();"], [133, "\t}"], [134, ""], [135, "\tprivate class ConsumerWorker implements Runnable {"], [136, ""], [137, "\t\tprivate AtomicBoolean closed = new AtomicBoolean();"], [138, "\t\tprivate CountDownLatch shutdownLatch = new CountDownLatch(1);"], [147, "\t\t\t\tConsumerRecords<String,DefaultMessage> records = consumer.poll(1500);"], [165, "\t\t\t\t\t\tlogger.debug(\"heartbeats the coordinator\");"], [169, "\t\t\t\t\t\tlogger.debug(\"ConsumeRecords Job got cancelled\");"], [172, "\t\t\t\t\t\tlogger.error(\"Error while consuming records\", e);"], [186, "\t\t\t\tlogger.error(\"Error while exiting the consumer\");"], [190, "\t\t\tlogger.info(\"C : {}, consumer exited\");"], [204, "\t\t\tConsumerRecords<String,DefaultMessage> records;"], [207, "\t\t\tpublic ConsumeRecords(ConsumerRecords<String,DefaultMessage> records,"], [216, "\t\t\t\tlogger.info(\"Number of records received : {}\", records.count());"], [218, "\t\t\t\t\tfor (final ConsumerRecord<String,DefaultMessage> record : records) {"], [220, "\t\t\t\t\t\tlogger.info(\"Record received topicPartition : {}, offset : {}\", tp,record.offset());"], [223, "\t\t\t\t\t\tfinal MessageHandler messageHandler = topicHandlers.get(record.topic());"]], "deleted": [[23, "import org.apache.kafka.clients.consumer.ConsumerConfig;"], [52, "\tprivate List<ConsumerWorker<String, DefaultMessage>> consumers = new ArrayList<>();"], [67, ""], [69, "\t\t\tConsumerWorker<String, DefaultMessage> consumer = new ConsumerWorker<>(configs, topicHandlers,processExecutor);"], [70, "\t\t\tconsumers.add(consumer);"], [77, "\t\tfor (int i = 0; i < consumers.size(); i++) {"], [78, "\t\t\tconsumers.get(i).close();"], [79, "\t\t\tconsumers.remove(i);"], [86, "\tprivate class ConsumerWorker<K extends Serializable, V extends DefaultMessage> implements Runnable {"], [88, "\t\tprivate KafkaConsumer<K, V> consumer;"], [89, "\t\tprivate final String clientId;"], [90, "\t\tprivate Map<String, MessageHandler> topicProcessers;"], [91, ""], [92, "\t\tprivate ExecutorService processExecutor;"], [94, "\t\tprivate AtomicBoolean closed = new AtomicBoolean();"], [95, "\t\tprivate CountDownLatch shutdownLatch = new CountDownLatch(1);"], [97, "\t\tpublic ConsumerWorker(Properties configs, Map<String, MessageHandler> topicProcessers,ExecutorService processExecutor) {"], [99, "\t\t\tthis.clientId = configs.getProperty(ConsumerConfig.CLIENT_ID_CONFIG);"], [100, "\t\t\tthis.topicProcessers = topicProcessers;"], [101, "\t\t\tconfigs.put(ConsumerConfig.CLIENT_ID_CONFIG, clientId);"], [102, "\t\t\tthis.consumer = new KafkaConsumer<>(configs);"], [103, "\t\t\tthis.processExecutor = processExecutor;"], [109, "\t\t\tlogger.info(\"Starting consumer : {}\", clientId);"], [110, ""], [112, "\t\t\tfinal Map<TopicPartition, Long> partitionToUncommittedOffsetMap = new ConcurrentHashMap<>();"], [113, "\t\t\tfinal List<Future<Boolean>> futures = new ArrayList<>();"], [114, ""], [115, "\t\t\tConsumerRebalanceListener listener = new ConsumerRebalanceListener() {"], [116, ""], [117, "\t\t\t\t@Override"], [118, "\t\t\t\tpublic void onPartitionsRevoked(Collection<TopicPartition> partitions) {"], [119, "\t\t\t\t\tif (!futures.isEmpty())"], [120, "\t\t\t\t\t\tfutures.get(0).cancel(true);"], [121, ""], [122, "\t\t\t\t\tlogger.info(\"C : {}, Revoked topicPartitions : {}\", clientId, partitions);"], [123, "\t\t\t\t\tcommitOffsets(partitionToUncommittedOffsetMap);"], [124, "\t\t\t\t}"], [125, ""], [126, "\t\t\t\t@Override"], [127, "\t\t\t\tpublic void onPartitionsAssigned(Collection<TopicPartition> partitions) {"], [128, "\t\t\t\t\tfor (TopicPartition tp : partitions) {"], [129, "\t\t\t\t\t\tOffsetAndMetadata offsetAndMetaData = consumer.committed(tp);"], [130, "\t\t\t\t\t\tlong startOffset = offsetAndMetaData != null ? offsetAndMetaData.offset() : -1L;"], [131, "\t\t\t\t\t\tlogger.info(\"C : {}, Assigned topicPartion : {} offset : {}\", clientId, tp, startOffset);"], [132, ""], [133, "\t\t\t\t\t\tif (startOffset >= 0)"], [134, "\t\t\t\t\t\t\tconsumer.seek(tp, startOffset);"], [135, "\t\t\t\t\t}"], [136, "\t\t\t\t}"], [137, "\t\t\t};"], [138, ""], [139, "\t\t\tList<String> topics = new ArrayList<>(topicProcessers.keySet());"], [140, "\t\t\tconsumer.subscribe(topics, listener);"], [141, "\t\t\tlogger.info(\"Started to process records for consumer : {}\", clientId);"], [145, "\t\t\t\tConsumerRecords<K, V> records = consumer.poll(1500);"], [163, "\t\t\t\t\t\tlogger.debug(\"C : {}, heartbeats the coordinator\", clientId);"], [167, "\t\t\t\t\t\tlogger.debug(\"C : {}, ConsumeRecords Job got cancelled\", clientId);"], [170, "\t\t\t\t\t\tlogger.error(\"C : {}, Error while consuming records\", clientId, e);"], [184, "\t\t\t\tlogger.error(\"C : {}, Error while exiting the consumer\", clientId, e);"], [188, "\t\t\tlogger.info(\"C : {}, consumer exited\", clientId);"], [189, "\t\t}"], [190, ""], [191, "\t\tprivate void commitOffsets(Map<TopicPartition, Long> partitionToOffsetMap) {"], [192, ""], [193, "\t\t\tif (!partitionToOffsetMap.isEmpty()) {"], [194, "\t\t\t\tMap<TopicPartition, OffsetAndMetadata> partitionToMetadataMap = new HashMap<>();"], [195, "\t\t\t\tfor (Entry<TopicPartition, Long> e : partitionToOffsetMap.entrySet()) {"], [196, "\t\t\t\t\tpartitionToMetadataMap.put(e.getKey(), new OffsetAndMetadata(e.getValue() + 1));"], [197, "\t\t\t\t}"], [198, ""], [199, "\t\t\t\tlogger.info(\"C : {}, committing the offsets : {}\", clientId, partitionToMetadataMap);"], [200, "\t\t\t\tconsumer.commitSync(partitionToMetadataMap);"], [201, "\t\t\t\tpartitionToOffsetMap.clear();"], [202, "\t\t\t}"], [216, "\t\t\tConsumerRecords<K, V> records;"], [219, "\t\t\tpublic ConsumeRecords(ConsumerRecords<K, V> records,"], [228, "\t\t\t\tlogger.info(\"C : {}, Number of records received : {}\", clientId, records.count());"], [230, "\t\t\t\t\tfor (final ConsumerRecord<K, V> record : records) {"], [232, "\t\t\t\t\t\tlogger.info(\"C : {}, Record received topicPartition : {}, offset : {}\", clientId, tp,record.offset());"], [236, "\t\t\t\t\t\tfinal MessageHandler messageHandler = topicProcessers.get(record.topic());"]]}, "num_lines_added": 68, "num_lines_removed": 80}