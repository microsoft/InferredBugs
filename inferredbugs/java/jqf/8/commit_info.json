{"hash": "d6a66e5208a4b928301d4cfe3361424f11ebe1c6", "message": "ExecutionIndexing: Save unique failures to disk", "file_num_lines": 585, "diff_parsed": {"added": [[43, "import java.util.Arrays;"], [51, "import java.util.List;"], [106, "    /** The directory where fuzzing results are written. */"], [109, "    /** The directory where saved inputs are written. */"], [110, "    private File savedInputsDirectory;"], [111, ""], [112, "    /** The directory where saved inputs are written. */"], [113, "    private File savedFailuresDirectory;"], [114, ""], [145, "    /** The set of unique failures found so far. */"], [146, "    Set<List<StackTraceElement>> uniqueFailures = new HashSet<>();"], [147, ""], [249, "        // Name files and directories after AFL"], [250, "        this.savedInputsDirectory = new File(outputDirectory, \"queue\");"], [251, "        this.savedInputsDirectory.mkdirs();"], [252, "        this.savedFailuresDirectory = new File(outputDirectory, \"crashes\");"], [253, "        this.savedFailuresDirectory.mkdirs();"], [257, ""], [258, ""], [259, "        // Delete everything that we may have created in a previous run."], [260, "        // Trying to stay away from recursive delete of parent output directory in case there was a"], [261, "        // typo and that was not a directory we wanted to nuke."], [262, "        // We also do not check if the deletes are actually successful."], [263, "        statsFile.delete();"], [264, "        logFile.delete();"], [265, "        for (File file : savedInputsDirectory.listFiles()) {"], [266, "            file.delete();"], [267, "        }"], [268, "        for (File file : savedFailuresDirectory.listFiles()) {"], [269, "            file.delete();"], [270, "        }"], [271, ""], [338, "        console.printf(\"Queue size:           %,d\\n\", savedInputs.size());"], [339, "        console.printf(\"Unique failures:      %,d\\n\", uniqueFailures.size());"], [340, "        console.printf(\"Number of executions: %,d\\n\", numTrials);"], [342, "        console.printf(\"Execution speed:      %,d/sec now | %,d/sec overall\\n\", intervalExecsPerSec, execsPerSec);"], [343, "        console.printf(\"Covered branches:     %,d (%.2f%% of map)\\n\", nonZeroCount, nonZeroFraction);"], [347, "                savedInputs.size(), 0, 0, nonZeroFraction, uniqueFailures.size(), 0, 0, intervalExecsPerSecDouble);"], [411, "            if (numTrials > 100_000) {"], [521, ""], [522, "            // Get the root cause of the failure"], [523, "            Throwable rootCause = error;"], [524, "            while (rootCause.getCause() != null) {"], [525, "                rootCause = rootCause.getCause();"], [526, "            }"], [527, ""], [528, "            // Attempt to add this to the set of unique failures"], [529, "            if (uniqueFailures.add(Arrays.asList(rootCause.getStackTrace()))) {"], [530, ""], [531, "                // Save crash to disk"], [532, "                try {"], [533, "                    int crashIdx = uniqueFailures.size()-1;"], [534, "                    String saveFileName = String.format(\"id:%06d,%s\", crashIdx, currentInput.desc);"], [535, "                    File saveFile = new File(savedFailuresDirectory, saveFileName);"], [536, "                    writeCurrentInputToFile(saveFile);"], [537, "                } catch (IOException e) {"], [538, "                    throw new GuidanceException(e);"], [539, "                }"], [540, ""], [541, "                infoLog(\"Found crash: \" + error.getClass() + \" - \" + (msg != null ? msg : \"\"));"], [542, "            }"], [602, "    private void writeCurrentInputToFile(File saveFile) throws IOException {"], [603, "        try (BufferedOutputStream out = new BufferedOutputStream(new FileOutputStream(saveFile))) {"], [604, "            for (Object key : currentInput.orderedKeys) {"], [605, "                int b = currentInput.valuesMap.get(key);"], [606, "                assert (b >= 0 && b < 256);"], [607, "                out.write(b);"], [608, "            }"], [609, "        }"], [610, ""], [611, "    }"], [612, ""], [620, "        File saveFile = new File(savedInputsDirectory, saveFileName);"], [621, "        writeCurrentInputToFile(saveFile);"], [625, "        currentInput.saveFile = saveFile;"]], "deleted": [[104, "    /** The directory where saved inputs are written. */"], [238, "        // Delete everything in the output directory (for cases where we re-use an existing dir)"], [239, "        for (File file : outputDirectory.listFiles()) {"], [240, "            file.delete(); // We do not check if this was successful"], [241, "        }"], [242, ""], [312, "        console.printf(\"Queue size:           %d\\n\", savedInputs.size());"], [314, "        console.printf(\"Number of executions: %d\\n\", numTrials);"], [315, "        console.printf(\"Execution speed:      %d/sec now | %d/sec overall\\n\", intervalExecsPerSec, execsPerSec);"], [316, "        console.printf(\"Covered branches:     %d (%.2f%% of map)\\n\", nonZeroCount, nonZeroFraction);"], [320, "                savedInputs.size(), 0, 0, nonZeroFraction, 0, 0, 0, intervalExecsPerSecDouble);"], [384, "            if (numTrials > 100) {"], [494, "            infoLog(\"Found crash: \" + error.getClass() + \" - \" + (msg != null ? msg : \"\"));"], [561, "        File outputFile = new File(outputDirectory, saveFileName);"], [562, "        try (BufferedOutputStream out = new BufferedOutputStream(new FileOutputStream(outputFile))) {"], [563, "            for (Object key : currentInput.orderedKeys) {"], [564, "                int b = currentInput.valuesMap.get(key);"], [565, "                assert (b >= 0 && b < 256);"], [566, "                out.write(b);"], [567, "            }"], [568, "        }"], [572, "        currentInput.saveFile = outputFile;"]]}, "num_lines_added": 75, "num_lines_removed": 22}