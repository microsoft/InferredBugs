{"hash": "3c45435c6ac67758b1015c2c8185e6a4c9436179", "message": "Fixed ResourceHandler to correctly handle resource from classpath", "file_num_lines": 67, "diff_parsed": {"added": [[33, "import io.netty.handler.stream.ChunkedStream;"], [34, "import io.netty.handler.stream.ChunkedWriteHandler;"], [37, "import java.io.InputStream;"], [42, "public class ResourceHandler extends ChunkedWriteHandler {"], [48, "    private final Map<String, String> resources = new HashMap<String, String>();"], [58, "    \tresources.put(pathPart, resourcePath);"], [67, "\t\t\tString resource = resources.get(queryDecoder.path());"], [69, "\t\t\t\t// create ok response"], [71, "\t\t\t\t// set content type"], [72, "\t\t\t\tHttpHeaders.setHeader(res, HttpHeaders.Names.CONTENT_TYPE, \"application/octet-stream\");"], [73, "\t\t\t\t// write header"], [74, "\t\t\t\tctx.write(res);"], [75, "\t\t\t\t// create resource inputstream and check"], [76, "\t\t\t\tInputStream is = getClass().getResourceAsStream(resource);"], [77, "\t\t\t\tif (is == null) {"], [81, "\t\t\t\t// write the stream"], [82, "\t\t\t\tChannelFuture writeFuture = ctx.channel().write(new ChunkedStream(is));"], [83, "\t\t\t\t// close the channel on finish"], [89, "\t\tctx.fireChannelRead(msg);"], [93, ""], [94, "    \tHttpResponse response = new DefaultHttpResponse(HTTP_1_1, status);"], [96, "        ByteBuf content = Unpooled.copiedBuffer( \"Failure: \" + status.toString() + \"\\r\\n\", CharsetUtil.UTF_8);"], [97, "        // write response"]], "deleted": [[18, "import static io.netty.handler.codec.http.HttpHeaders.setContentLength;"], [24, "import io.netty.channel.Channel;"], [29, "import io.netty.channel.ChannelInboundHandlerAdapter;"], [30, "import io.netty.channel.DefaultFileRegion;"], [31, "import io.netty.channel.FileRegion;"], [35, "import io.netty.handler.codec.http.HttpRequest;"], [39, "import io.netty.handler.ssl.SslHandler;"], [40, "import io.netty.handler.stream.ChunkedFile;"], [43, "import java.io.File;"], [44, "import java.io.FileNotFoundException;"], [45, "import java.io.IOException;"], [46, "import java.io.RandomAccessFile;"], [47, "import java.net.URL;"], [48, "import java.text.ParseException;"], [49, "import java.text.SimpleDateFormat;"], [50, "import java.util.Calendar;"], [51, "import java.util.Date;"], [52, "import java.util.GregorianCalendar;"], [54, "import java.util.Locale;"], [56, "import java.util.TimeZone;"], [57, ""], [58, "import javax.activation.MimetypesFileTypeMap;"], [61, "public class ResourceHandler extends ChannelInboundHandlerAdapter {"], [67, "    private final Map<String, File> resources = new HashMap<String, File>();"], [77, "        URL resource = getClass().getResource(resourcePath);"], [78, "        // in case of usage exclude-swf-files profile"], [79, "        if (resource != null) {"], [80, "            File file = new File(resource.getFile());"], [81, "            resources.put(pathPart, file);"], [82, "        }"], [91, "\t\t\tFile resource = resources.get(queryDecoder.path());"], [94, ""], [95, "\t\t\t\tif (isNotModified(req, resource)) {"], [96, "\t\t\t\t\tsendNotModified(ctx);"], [97, "\t\t\t\t\treq.release();"], [98, "\t\t\t\t\treturn;"], [99, "\t\t\t\t}"], [100, ""], [101, "\t\t\t\tRandomAccessFile raf;"], [102, "\t\t\t\ttry {"], [103, "\t\t\t\t\traf = new RandomAccessFile(resource, \"r\");"], [104, "\t\t\t\t} catch (FileNotFoundException fnfe) {"], [108, "\t\t\t\tlong fileLength = raf.length();"], [109, ""], [110, "\t\t\t\tsetContentLength(res, fileLength);"], [111, "\t\t\t\tsetContentTypeHeader(res, resource);"], [112, "\t\t\t\tsetDateAndCacheHeaders(res, resource);"], [113, "\t\t\t\t// write the response header"], [114, "\t\t\t\tctx.write(res);"], [115, "\t\t\t\t// write the content to the channel"], [116, "\t\t\t\tChannelFuture writeFuture = writeContent(raf, fileLength, ctx.channel());"], [117, "\t\t\t\t// close the request channel"], [123, "\t\tsuper.channelRead(ctx, msg);"], [125, ""], [126, "    private boolean isNotModified(HttpRequest request, File file) throws ParseException {"], [127, "        String ifModifiedSince = request.headers().get(HttpHeaders.Names.IF_MODIFIED_SINCE);"], [128, "        if (ifModifiedSince != null && !ifModifiedSince.equals(\"\")) {"], [129, "            SimpleDateFormat dateFormatter = new SimpleDateFormat(HTTP_DATE_FORMAT, Locale.US);"], [130, "            Date ifModifiedSinceDate = dateFormatter.parse(ifModifiedSince);"], [131, ""], [132, "            // Only compare up to the second because the datetime format we send to the client does"], [133, "            // not have milliseconds"], [134, "            long ifModifiedSinceDateSeconds = ifModifiedSinceDate.getTime() / 1000;"], [135, "            long fileLastModifiedSeconds = file.lastModified() / 1000;"], [136, "            return ifModifiedSinceDateSeconds == fileLastModifiedSeconds;"], [137, "        }"], [138, "        return false;"], [139, "    }"], [140, ""], [141, "    private void sendNotModified(ChannelHandlerContext ctx) {"], [142, "        HttpResponse response = new DefaultHttpResponse(HTTP_1_1, HttpResponseStatus.NOT_MODIFIED);"], [143, "        setDateHeader(response);"], [144, ""], [145, "        // Close the connection as soon as the error message is sent."], [146, "        ctx.channel().write(response).addListener(ChannelFutureListener.CLOSE);"], [147, "    }"], [148, ""], [149, "    /**"], [150, "     * Sets the Date header for the HTTP response"], [151, "     *"], [152, "     * @param response"], [153, "     *            HTTP response"], [154, "     */"], [155, "    private void setDateHeader(HttpResponse response) {"], [156, "        SimpleDateFormat dateFormatter = new SimpleDateFormat(HTTP_DATE_FORMAT, Locale.US);"], [157, "        dateFormatter.setTimeZone(TimeZone.getTimeZone(HTTP_DATE_GMT_TIMEZONE));"], [158, ""], [159, "        Calendar time = new GregorianCalendar();"], [160, "        HttpHeaders.setHeader(response, HttpHeaders.Names.DATE, dateFormatter.format(time.getTime()));"], [161, "    }"], [162, ""], [163, "    private ChannelFuture writeContent(RandomAccessFile raf, long fileLength, Channel ch) throws IOException {"], [164, "        ChannelFuture writeFuture;"], [165, "        if (ch.pipeline().get(SslHandler.class) != null) {"], [166, "            // Cannot use zero-copy with HTTPS."], [167, "            writeFuture = ch.write(new ChunkedFile(raf, 0, fileLength, 8192));"], [168, "        } else {"], [169, "            // No encryption - use zero-copy."], [170, "            final FileRegion region = new DefaultFileRegion(raf.getChannel(), 0, fileLength);"], [171, "            writeFuture = ch.write(region);"], [172, "        }"], [173, ""], [174, "        return writeFuture;"], [175, "    }"], [178, "        HttpResponse response = new DefaultHttpResponse(HTTP_1_1, status);"], [180, "        ByteBuf content = Unpooled.copiedBuffer("], [181, "                \"Failure: \" + status.toString() + \"\\r\\n\","], [182, "                CharsetUtil.UTF_8);"], [183, ""], [185, ""], [189, ""], [190, "    /**"], [191, "     * Sets the Date and Cache headers for the HTTP Response"], [192, "     *"], [193, "     * @param response"], [194, "     *            HTTP response"], [195, "     * @param fileToCache"], [196, "     *            file to extract content type"], [197, "     */"], [198, "    private void setDateAndCacheHeaders(HttpResponse response, File fileToCache) {"], [199, "        SimpleDateFormat dateFormatter = new SimpleDateFormat(HTTP_DATE_FORMAT, Locale.US);"], [200, "        dateFormatter.setTimeZone(TimeZone.getTimeZone(HTTP_DATE_GMT_TIMEZONE));"], [201, ""], [202, "        // Date header"], [203, "        Calendar time = new GregorianCalendar();"], [204, "        HttpHeaders.setHeader(response, HttpHeaders.Names.DATE, dateFormatter.format(time.getTime()));"], [205, ""], [206, "        // Add cache headers"], [207, "        time.add(Calendar.SECOND, HTTP_CACHE_SECONDS);"], [208, "        HttpHeaders.setHeader(response, HttpHeaders.Names.EXPIRES, dateFormatter.format(time.getTime()));"], [209, "        HttpHeaders.setHeader(response, HttpHeaders.Names.CACHE_CONTROL, \"private, max-age=\" + HTTP_CACHE_SECONDS);"], [210, "        HttpHeaders.setHeader(response,"], [211, "                HttpHeaders.Names.LAST_MODIFIED, dateFormatter.format(new Date(fileToCache.lastModified())));"], [212, "    }"], [213, ""], [214, "    /**"], [215, "     * Sets the content type header for the HTTP Response"], [216, "     *"], [217, "     * @param response"], [218, "     *            HTTP response"], [219, "     * @param file"], [220, "     *            file to extract content type"], [221, "     */"], [222, "    private void setContentTypeHeader(HttpResponse response, File file) {"], [223, "        MimetypesFileTypeMap mimeTypesMap = new MimetypesFileTypeMap();"], [224, "        HttpHeaders.setHeader(response, HttpHeaders.Names.CONTENT_TYPE, mimeTypesMap.getContentType(file.getPath()));"], [225, "    }"]]}, "num_lines_added": 23, "num_lines_removed": 147}