{"hash": "998e927dfb49b535d893e55f020044b4d699c161", "message": "develop Geomem", "file_num_lines": 61, "diff_parsed": {"added": [[3, "import java.util.Collections;"], [6, "import java.util.concurrent.ConcurrentSkipListMap;"], [8, "import com.github.davidmoten.geo.Base32;"], [12, "import com.google.common.base.Predicate;"], [13, "import com.google.common.collect.Iterables;"], [16, "/**"], [17, " * Provides fast concurrent querying using in memory Concurrent data with time"], [18, " * and position."], [19, " *"], [20, " * @author dxm"], [21, " *"], [22, " * @param <T>"], [23, " */"], [26, "    private final Map<Long, SortedMap<Long, Info<T>>> map = Maps"], [27, "            .newConcurrentMap();"], [29, "    public Geomem(Optional<Integer> maxSize) {"], [30, "        // TODO implement maxSize"], [31, "    }"], [33, "    public Iterable<Info<T>> find(double topLeftLat, double topLeftLong,"], [34, "            double bottomRightLat, double bottomRightLong, long start,"], [35, "            long finish) {"], [37, "        Coverage cover = GeoHash.coverBoundingBox(topLeftLat, topLeftLong,"], [38, "                bottomRightLat, bottomRightLong);"], [39, "        Iterable<Info<T>> it = Collections.emptyList();"], [40, "        for (String hash : cover.getHashes()) {"], [41, "            it = Iterables.concat("], [42, "                    it,"], [43, "                    find(topLeftLat, topLeftLong, bottomRightLat,"], [44, "                            bottomRightLong, start, finish, hash));"], [45, "        }"], [46, "        return it;"], [47, "    }"], [49, "    public Iterable<Info<T>> find(final double topLeftLat,"], [50, "            final double topLeftLong, final double bottomRightLat,"], [51, "            final double bottomRightLong, long start, long finish,"], [52, "            String withinHash) {"], [53, ""], [54, "        Iterable<Info<T>> it = find(start, finish, withinHash);"], [55, "        return Iterables.filter(it, new Predicate<Info<T>>() {"], [56, ""], [57, "            @Override"], [58, "            public boolean apply(Info<T> info) {"], [59, "                return info.lat() >= bottomRightLat && info.lat() <= topLeftLat"], [60, "                        && info.lon() >= topLeftLong"], [61, "                        && info.lon() <= bottomRightLong;"], [62, "            }"], [63, "        });"], [64, "    }"], [65, ""], [66, "    public Iterable<Info<T>> find(long start, long finish, String withinHash) {"], [67, "        long key = Base32.decodeBase32(withinHash);"], [68, "        SortedMap<Long, Info<T>> sortedByTime = map.get(key);"], [69, "        return sortedByTime.subMap(start, finish).values();"], [70, "    }"], [71, ""], [72, "    public void add(double lat, double lon, long time, T t, long expiryTime) {"], [73, "        String hash = GeoHash.encodeHash(lat, lon);"], [74, "        // full hash length is 12 so this will insert 12 entries"], [75, "        for (int i = 1; i <= hash.length(); i++) {"], [76, "            long key = Base32.decodeBase32(hash.substring(0, i));"], [77, "            if (map.get(key) == null) {"], [78, "                map.put(key, new ConcurrentSkipListMap<Long, Info<T>>());"], [79, "            }"], [80, "            map.get(key).put(time, new Info<T>(key, lat, lon, time, t));"], [81, "        }"], [82, "    }"]], "deleted": [[13, "\tprivate final Map<String, SortedMap<Long, T>> map = Maps.newConcurrentMap();"], [15, "\tpublic Geomem(Optional<Integer> maxSize) {"], [17, "\t}"], [19, "\tpublic Iterable<T> find(double topLeftLat, double topLeftLong,"], [20, "\t\t\tdouble bottomRightLat, double bottomRightLong, long start,"], [21, "\t\t\tlong finish) {"], [23, "\t\tCoverage cover = GeoHash.coverBoundingBox(topLeftLat, topLeftLong,"], [24, "\t\t\t\tbottomRightLat, bottomRightLong);"], [25, "\t\tcover.getHashes();"], [26, "\t\treturn null;"], [27, "\t}"], [29, "\tpublic void add(double lat, double lon, long time, T t, long expiryTime) {"], [30, "\t\tString hash = GeoHash.encodeHash(lat, lon);"], [31, "\t\tfor (int i = 1; i <= hash.length(); i++) {"], [32, "\t\t\tString key = hash.substring(0, i);"], [33, "\t\t\tif (map.get(key) == null) {"], [34, "\t\t\t\tmap.put(key, Maps.<Long, T> newTreeMap());"], [35, "\t\t\t}"], [36, "\t\t\tmap.get(key).put(time, t);"], [37, "\t\t}"], [38, "\t}"]]}, "num_lines_added": 66, "num_lines_removed": 21}