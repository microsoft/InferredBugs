{"hash": "7849eee948c47d5a1763fc4d2cb85de164c8f98c", "message": "RATIS-1186. Change the FileStore CLI to use Streaming (#325)\n\n* RATIS-1186. Change the FileStore CLI to use Streaming\r\n\r\n* fix code review", "file_num_lines": 71, "diff_parsed": {"added": [[24, "import java.io.File;"], [25, "import java.io.FileInputStream;"], [29, "import java.util.HashMap;"], [31, "import java.util.Map;"], [42, "    List<String> paths = generateFiles();"], [44, "    System.out.println(\"Starting Async write now \");"], [48, "    long totalWrittenBytes = waitWriteFinish(writeByHeapByteBuffer(paths, fileStoreClient));"], [49, ""], [52, "    System.out.println(\"Total files written: \" + getNumFiles());"], [53, "    System.out.println(\"Each files size: \" + getFileSizeInBytes());"], [54, "    System.out.println(\"Total data written: \" + totalWrittenBytes + \" bytes\");"], [60, ""], [61, "  private Map<String, List<CompletableFuture<Long>>> writeByHeapByteBuffer("], [62, "      List<String> paths, FileStoreClient fileStoreClient) throws IOException {"], [63, "    Map<String, List<CompletableFuture<Long>>> fileMap = new HashMap<>();"], [64, ""], [65, "    for(String path : paths) {"], [66, "      List<CompletableFuture<Long>> futures = new ArrayList<>();"], [67, "      File file = new File(path);"], [68, "      FileInputStream fis = new FileInputStream(file);"], [69, ""], [70, "      int bytesToRead = getBufferSizeInBytes();"], [71, "      if (getFileSizeInBytes() > 0L && getFileSizeInBytes() < (long)getBufferSizeInBytes()) {"], [72, "        bytesToRead = getFileSizeInBytes();"], [73, "      }"], [74, ""], [75, "      byte[] buffer = new byte[bytesToRead];"], [76, "      long offset = 0L;"], [77, "      while(fis.read(buffer, 0, bytesToRead) > 0) {"], [78, "        ByteBuffer b = ByteBuffer.wrap(buffer);"], [79, "        futures.add(fileStoreClient.writeAsync(path, offset, offset + bytesToRead == getFileSizeInBytes(), b));"], [80, "        offset += bytesToRead;"], [81, "        bytesToRead = (int)Math.min(getFileSizeInBytes() - offset, getBufferSizeInBytes());"], [82, "        if (bytesToRead > 0) {"], [83, "          buffer = new byte[bytesToRead];"], [84, "        }"], [85, "      }"], [86, ""], [87, "      fileMap.put(path, futures);"], [88, "    }"], [89, ""], [90, "    return fileMap;"], [91, "  }"], [92, ""], [93, "  private long waitWriteFinish(Map<String, List<CompletableFuture<Long>>> fileMap) {"], [94, "    long totalBytes = 0;"], [95, "    for (List<CompletableFuture<Long>> futures : fileMap.values()) {"], [96, "      long writtenLen = 0;"], [97, "      for (CompletableFuture<Long> future : futures) {"], [98, "        writtenLen += future.join();"], [99, "      }"], [100, ""], [101, "      if (writtenLen != getFileSizeInBytes()) {"], [102, "        System.out.println(\"File written:\" + writtenLen + \" does not match expected:\" + getFileSizeInBytes());"], [103, "      }"], [104, ""], [105, "      totalBytes += writtenLen;"], [106, "    }"], [107, "    return totalBytes;"], [108, "  }"]], "deleted": [[20, "import com.beust.jcommander.Parameter;"], [22, "import org.apache.commons.lang3.RandomStringUtils;"], [27, "import java.io.UnsupportedEncodingException;"], [29, "import java.nio.charset.StandardCharsets;"], [33, "import java.util.concurrent.atomic.AtomicLong;"], [41, "  private static final String UTF8_CSN = StandardCharsets.UTF_8.name();"], [42, ""], [43, "  @Parameter(names = {\"--size\"}, description = \"Size of each file\", required = true)"], [44, "  private String size;"], [45, ""], [46, "  @Parameter(names = {\"--numFiles\"}, description = \"Number of files\", required = true)"], [47, "  private String numFiles;"], [48, ""], [49, "  private static byte[] string2Bytes(String str) {"], [50, "    try {"], [51, "      return str.getBytes(UTF8_CSN);"], [52, "    } catch (UnsupportedEncodingException e) {"], [53, "      throw new IllegalArgumentException(\"UTF8 decoding is not supported\", e);"], [54, "    }"], [55, "  }"], [56, ""], [59, "    int length = Integer.parseInt(size);"], [60, "    int num = Integer.parseInt(numFiles);"], [61, "    AtomicLong totalBytes = new AtomicLong(0);"], [62, "    String entropy = RandomStringUtils.randomAlphanumeric(10);"], [63, ""], [64, "    byte[] fileValue = string2Bytes(RandomStringUtils.randomAscii(length));"], [67, "    System.out.println(\"Starting load now \");"], [69, "    List<CompletableFuture<Long>> futures = new ArrayList<>();"], [70, "    for (int i = 0; i < num; i++) {"], [71, "      String path = \"file-\" + entropy + \"-\" + i;"], [72, "      ByteBuffer b = ByteBuffer.wrap(fileValue);"], [73, "      futures.add(fileStoreClient.writeAsync(path, 0, true, b));"], [74, "    }"], [76, "    for (CompletableFuture<Long> future : futures) {"], [77, "      Long writtenLen = future.join();"], [78, "      totalBytes.addAndGet(writtenLen);"], [79, "      if (writtenLen != length) {"], [80, "        System.out.println(\"File length written is wrong: \" + writtenLen + length);"], [81, "      }"], [82, "    }"], [85, "    System.out.println(\"Total files written: \" + futures.size());"], [86, "    System.out.println(\"Each files size: \" + length);"], [87, "    System.out.println(\"Total data written: \" + totalBytes + \" bytes\");"]]}, "num_lines_added": 60, "num_lines_removed": 44}