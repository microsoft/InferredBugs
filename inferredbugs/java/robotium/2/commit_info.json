{"hash": "4b9568a3e418a2d64f67d77a258ec7228b6fc4f5", "message": "Workaround for Activity Monitor not returning the correct\nactivity after calling goBack()", "file_num_lines": 172, "diff_parsed": {"added": [[4, "import java.util.List;"], [5, "import java.util.Stack;"], [6, "import java.util.Timer;"], [7, "import java.util.TimerTask;"], [32, "\tprivate static final int ACTIVITYSYNCTIME = 50;"], [33, "\tprivate Stack<Activity> activityStack;"], [34, "\tprivate Timer activitySyncTimer;"], [35, "\tprivate List<Activity> destroyedActivities;"], [50, "\t\tactivityStack = new Stack<Activity>();"], [51, "\t\tactivitySyncTimer = new Timer();"], [52, "\t\tdestroyedActivities=new ArrayList<Activity>();"], [54, "\t\tsetupActivityStackListener();"], [66, "\t\treturn new ArrayList<Activity>(activityStack);"], [86, "\t * This is were the activityStack listener is set up. The listener will keep track of the"], [87, "\t * opened activities and their positions."], [88, "\t */"], [89, ""], [90, "\tprivate void setupActivityStackListener() {"], [91, "\t\tTimerTask activitySyncTimerTask = new TimerTask() {"], [92, "\t\t\t@Override"], [93, "\t\t\tpublic void run() {"], [94, "\t\t\t\tif (activityMonitor != null)"], [95, "\t\t\t\t\tif ((activityMonitor.getLastActivity() != null)"], [96, "\t\t\t\t\t\t\t&& (!activityStack.contains(activityMonitor"], [97, "\t\t\t\t\t\t\t\t\t.getLastActivity()))) {"], [98, "\t\t\t\t\t\tif (!destroyedActivities.contains(activityMonitor"], [99, "\t\t\t\t\t\t\t\t.getLastActivity()))"], [100, "\t\t\t\t\t\t\tactivityStack.push(activityMonitor"], [101, "\t\t\t\t\t\t\t\t\t.getLastActivity());"], [102, "\t\t\t\t\t}"], [103, "\t\t\t}"], [104, "\t\t};"], [105, "\t\tactivitySyncTimer.schedule(activitySyncTimerTask, 0, ACTIVITYSYNCTIME);"], [106, "\t}"], [107, ""], [108, "\t/**"], [176, "\t\tif(!activityStack.isEmpty())"], [177, "\t\t\tactivity=activityStack.peek();"], [250, "\t\t// Stops the activityStack listener"], [251, "\t\tactivitySyncTimer.cancel();"], [268, "\t\tactivityStack.clear();"], [285, "\t/**"], [286, "\t * Simulates pressing the hardware back key."], [287, "\t *"], [288, "\t */"], [290, "\tpublic void goBack() {"], [291, "\t\tif(!activityStack.isEmpty()){"], [292, "\t\t\tdestroyedActivities.add(activityStack.pop());"], [293, "\t    }"], [294, "\t\tsleeper.sleep();"], [295, "\t\ttry {"], [296, "\t\t\tinst.sendKeyDownUpSync(KeyEvent.KEYCODE_BACK);"], [297, "\t\t\tsleeper.sleep();"], [298, "\t\t} catch (Throwable e) {}"], [299, "\t\twhile(destroyedActivities.size()>2){"], [300, "\t\t\tdestroyedActivities.remove(0);"], [301, "\t\t}"], [302, "\t}"]], "deleted": [[4, "import java.util.Iterator;"], [5, "import java.util.LinkedHashSet;"], [28, "\tprivate LinkedHashSet<Activity> activityList;"], [45, "\t\tactivityList = new LinkedHashSet<Activity>();"], [58, "\t\treturn new ArrayList<Activity>(activityList);"], [61, ""], [146, ""], [147, "\t\tif (activityMonitor != null) {"], [148, "\t\t\tif (activityMonitor.getLastActivity() != null)"], [149, "\t\t\t\tactivity = activityMonitor.getLastActivity();"], [150, "\t\t}"], [151, "\t\t\tactivityList.add(activity);"], [155, ""], [241, "\t\tactivityList.clear();"], [242, "\t}"], [243, ""], [244, "\t/**"], [245, "\t * All inactive activities are finished."], [246, "\t */"], [247, ""], [248, "\tpublic void finishInactiveActivities() {"], [249, "\t\tfor (Iterator<Activity> iter = activityList.iterator(); iter.hasNext();) {"], [250, "\t\t\tActivity activity = iter.next();"], [251, "\t\t\tif (activity != getCurrentActivity()) {"], [252, "\t\t\t\tfinishActivity(activity);"], [253, "\t\t\t\titer.remove();"], [254, "\t\t\t}"], [255, "\t\t}"]]}, "num_lines_added": 58, "num_lines_removed": 28}