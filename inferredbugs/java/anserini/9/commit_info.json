{"hash": "4408bf6d54f8630106eb35c29e1f634313a71078", "message": "Index logging and counter cleanup (#277)", "file_num_lines": 265, "diff_parsed": {"added": [[124, "    /**"], [125, "     * Counter for successfully indexed documents."], [126, "     */"], [127, "    public AtomicLong indexed = new AtomicLong();"], [128, ""], [129, "    /**"], [130, "     * Counter for empty documents that are not indexed. Empty documents are not necessary errors;"], [131, "     * it could be the case, for example, that a document is comprised solely of stopwords."], [132, "     */"], [133, "    public AtomicLong empty = new AtomicLong();"], [134, ""], [135, "    /**"], [136, "     * Counter for unindexed documents. These are cases where the {@link SourceDocument} returned"], [137, "     * by {@link Collection.FileSegment} is {@code null} or the {@link LuceneDocumentGenerator}"], [138, "     * returned {@code null}. These are not necessarily errors."], [139, "     */"], [140, "    public AtomicLong unindexed = new AtomicLong();"], [141, ""], [142, "    /**"], [143, "     * Counter for unindexable documents. These are cases where {@link SourceDocument#indexable()}"], [144, "     * returns false."], [145, "     */"], [146, "    public AtomicLong unindexable = new AtomicLong();"], [147, ""], [148, "    /**"], [149, "     * Counter for skipped documents. These are cases documents are skipped as part of normal"], [150, "     * processing logic, e.g., using a whitelist, not indexing retweets or deleted tweets."], [151, "     */"], [152, "    public AtomicLong skipped = new AtomicLong();"], [153, ""], [154, "    /**"], [155, "     * Counter for unexpected errors."], [156, "     */"], [175, "        LuceneDocumentGenerator generator ="], [176, "            (LuceneDocumentGenerator) generatorClass"], [185, "            // Current implementation can't distinguish between end-of-iterator vs. actual error,"], [186, "            // so don't update counters."], [190, "            counters.unindexable.incrementAndGet();"], [195, "          Document doc = generator.createDocument(d);"], [196, "          if (doc == null) {"], [197, "            counters.unindexed.incrementAndGet();"], [198, "            continue;"], [199, "          }"], [200, "          if (whitelistDocids != null && !whitelistDocids.contains(d.id())) {"], [201, "            counters.skipped.incrementAndGet();"], [202, "            continue;"], [204, ""], [205, "          if (args.uniqueDocid) {"], [206, "            writer.updateDocument(new Term(\"id\", d.id()), doc);"], [207, "          } else {"], [208, "            writer.addDocument(doc);"], [209, "          }"], [210, "          cnt++;"], [215, "        counters.indexed.addAndGet(cnt);"], [227, "  private final Class generatorClass;"], [258, "    this.generatorClass = Class.forName(\"io.anserini.index.generator.\" + args.generatorClass);"], [339, "    if (numIndexed != counters.indexed.get()) {"], [340, "      LOG.warn(\"Unexpected difference between number of indexed documents and index maxDoc.\");"], [341, "    }"], [342, ""], [343, "    LOG.info(\"# Final Counter Values\");"], [344, "    LOG.info(String.format(\"indexed:     %,12d\", counters.indexed.get()));"], [345, "    LOG.info(String.format(\"empty:       %,12d\", counters.empty.get()));"], [346, "    LOG.info(String.format(\"unindexed:   %,12d\", counters.unindexed.get()));"], [347, "    LOG.info(String.format(\"unindexable: %,12d\", counters.unindexable.get()));"], [348, "    LOG.info(String.format(\"skipped:     %,12d\", counters.errors.get()));"], [349, "    LOG.info(String.format(\"errors:      %,12d\", counters.errors.get()));"], [352, "    LOG.info(String.format(\"Total %,d documents indexed in %s\", numIndexed,"], [353, "        DurationFormatUtils.formatDuration(durationMillis, \"HH:mm:ss\")));"], [372, "}"]], "deleted": [[124, "    public AtomicLong indexedDocuments = new AtomicLong();"], [125, "    public AtomicLong emptyDocuments = new AtomicLong();"], [126, "    public AtomicLong unindexableDocuments = new AtomicLong();"], [145, "        LuceneDocumentGenerator transformer ="], [146, "            (LuceneDocumentGenerator) transformerClass"], [155, "            LOG.info(\"Null document encountered\");"], [159, "            LOG.info(\"Document is not indexable\");"], [160, "            counters.unindexableDocuments.incrementAndGet();"], [165, "          Document doc = transformer.createDocument(d);"], [166, ""], [167, "          if (doc != null && (whitelistDocids == null || whitelistDocids.contains(d.id()))) {"], [168, "            if (args.uniqueDocid) {"], [169, "              writer.updateDocument(new Term(\"id\", d.id()), doc);"], [170, "            } else {"], [171, "              writer.addDocument(doc);"], [172, "            }"], [173, "            cnt++;"], [179, "        counters.indexedDocuments.addAndGet(cnt);"], [191, "  private final Class transformerClass;"], [222, "    this.transformerClass = Class.forName(\"io.anserini.index.generator.\" + args.generatorClass);"], [303, "    LOG.info(\"Indexed documents: \" + counters.indexedDocuments.get());"], [304, "    LOG.info(\"Empty documents: \" + counters.emptyDocuments.get());"], [305, "    LOG.info(\"Errors: \" + counters.errors.get());"], [308, "    LOG.info(\"Total \" + numIndexed + \" documents indexed in \" +"], [309, "        DurationFormatUtils.formatDuration(durationMillis, \"HH:mm:ss\"));"], [328, "}"]]}, "num_lines_added": 70, "num_lines_removed": 26}