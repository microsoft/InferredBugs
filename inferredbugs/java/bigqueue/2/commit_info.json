{"hash": "d6dc96a18601726f645584f8ff4149322373e317", "message": "Rewriting the future feature to work more future-like.\n\nAdding two methods dequeueAsync and peekAsync returning a future for the first item (byte[]) and not for the queue itself.\n\nAdapting tests and javadoc", "file_num_lines": 213, "diff_parsed": {"added": [[53, "    private SettableFuture<byte[]> dequeueFuture;"], [54, "    private SettableFuture<byte[]> peekFuture;"], [99, "        this.completeFutures();"], [133, "    public ListenableFuture<byte[]> dequeueAsync() {"], [134, "        this.initializeDequeueFutureIfNecessary();"], [141, "    private void completeFutures() {"], [143, "            if (peekFuture != null && !peekFuture.isDone()) {"], [144, "                try {"], [145, "                    peekFuture.set(this.peek());"], [146, "                } catch (IOException e) {"], [147, "                    peekFuture.setException(e);"], [148, "                }"], [149, "            }"], [150, "            if (dequeueFuture != null && !dequeueFuture.isDone()) {"], [151, "                try {"], [152, "                    dequeueFuture.set(this.dequeue());"], [153, "                } catch (IOException e) {"], [154, "                    dequeueFuture.setException(e);"], [155, "                }"], [163, "    private void initializeDequeueFutureIfNecessary() {"], [165, "            if (dequeueFuture == null || dequeueFuture.isDone()) {"], [169, "                try {"], [170, "                    dequeueFuture.set(this.dequeue());"], [171, "                } catch (IOException e) {"], [172, "                    dequeueFuture.setException(e);"], [173, "                }"], [179, "     * Initializes the futures if it's null at the moment"], [181, "    private void initializePeekFutureIfNecessary() {"], [183, "            if (peekFuture == null || peekFuture.isDone()) {"], [184, "                peekFuture = SettableFuture.create();"], [185, "            }"], [186, "            if (!this.isEmpty()) {"], [187, "                try {"], [188, "                    peekFuture.set(this.peek());"], [189, "                } catch (IOException e) {"], [190, "                    peekFuture.setException(e);"], [191, "                }"], [192, "            }"], [220, "    @Override"], [221, "    public ListenableFuture<byte[]> peekAsync() {"], [222, "        this.initializePeekFutureIfNecessary();"], [223, "        return peekFuture;"], [224, "    }"], [225, ""], [255, ""], [256, "        synchronized (futureLock) {"], [257, ""], [261, "            if (peekFuture != null) {"], [262, ""], [263, "                peekFuture.cancel(false);"], [264, "            }"], [265, "            if (dequeueFuture != null) {"], [266, "                dequeueFuture.cancel(false);"], [267, "            }"]], "deleted": [[53, "    private SettableFuture<IBigQueue> dequeueFuture;"], [98, "        this.completeFuture();"], [124, ""], [125, "            if (this.isEmpty()) {"], [126, "                this.invalidateFuture();"], [127, "            }"], [128, ""], [137, "    public ListenableFuture<IBigQueue> queueReadyForDequeue() {"], [138, "        this.initializeFutureIfNecessary();"], [140, ""], [146, "    private void completeFuture() {"], [148, "            if (dequeueFuture != null) {"], [149, "                dequeueFuture.set(this);"], [157, "    private void initializeFutureIfNecessary() {"], [159, "            if (dequeueFuture == null) {"], [163, "                dequeueFuture.set(this);"], [169, "     * Resets the future to null"], [171, "    private void invalidateFuture() {"], [173, "           dequeueFuture = null;"], [187, "            this.invalidateFuture();"], [231, "        if (dequeueFuture != null) {"], [235, "            dequeueFuture.cancel(false);"]]}, "num_lines_added": 54, "num_lines_removed": 22}