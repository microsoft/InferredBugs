{"hash": "e2faf42de46e8fe67b9aee429117a2910eb35c3b", "message": "Fixing buffer leak (#13)\n\n* Fixed buffer leak", "file_num_lines": 150, "diff_parsed": {"added": [[22, "import io.netty.buffer.Unpooled;"], [25, "import io.rsocket.util.ByteBufPayload;"], [49, "  private TypeReference<Map<String, String>> mapType = new TypeReference<Map<String, String>>() {};"], [61, "    ByteBuf dataBuffer = Unpooled.EMPTY_BUFFER;"], [63, "    if (message.data() instanceof ByteBuf) { // has data ?"], [64, "      dataBuffer = message.data(); // ok so use it as is"], [65, "    } else if (message.data() != null) {"], [66, "      dataBuffer = ByteBufAllocator.DEFAULT.buffer();"], [67, "      try {"], [68, "        writeTo(new ByteBufOutputStream(dataBuffer), message.data());"], [69, "      } catch (Throwable ex) {"], [70, "        LOGGER.error(\"Failed to deserialize data\", ex);"], [74, ""], [75, "    ByteBuf headersBuffer = Unpooled.EMPTY_BUFFER;"], [77, "      headersBuffer = ByteBufAllocator.DEFAULT.buffer();"], [85, ""], [86, "    return ByteBufPayload.create(dataBuffer, headersBuffer);"], [92, ""], [102, "      try (ByteBufInputStream inputStream = new ByteBufInputStream(payload.sliceMetadata(), true)) {"], [103, "        builder.headers(readFrom(inputStream, mapType));"], [109, "    payload.release();"], [117, "      try (ByteBufInputStream inputStream = new ByteBufInputStream(message.data(), true)) {"], [129, "      ByteBuf buffer = ByteBufAllocator.DEFAULT.buffer();"], [149, ""], [153, "      if (stream.available() == 0) {"], [161, ""], [176, ""]], "deleted": [[24, "import io.rsocket.util.DefaultPayload;"], [48, "  private TypeReference<Map<String, String>> mapType = new TypeReference<Map<String, String>>(){};"], [60, "    ByteBuf dataBuffer = ByteBufAllocator.DEFAULT.buffer();"], [62, "    if (message.data() != null) {               // has data ?"], [63, "      if (message.data() instanceof ByteBuf) {  // good so data is already bytebuf?"], [65, "        dataBuffer = message.data();            // ok so use it as is"], [66, "      } else {"], [67, "        try {"], [68, "          writeTo(new ByteBufOutputStream(dataBuffer), message.data());"], [69, "        } catch (Throwable ex) {"], [70, "          LOGGER.error(\"Failed to deserialize data\", ex);"], [71, "          ReferenceCountUtil.release(dataBuffer);"], [72, "        }"], [75, "    ByteBuf headersBuffer = ByteBufAllocator.DEFAULT.buffer();"], [84, "    return DefaultPayload.create(dataBuffer.nioBuffer(), headersBuffer.nioBuffer());"], [90, ""], [100, "      ByteBuf headers = payload.sliceMetadata();"], [101, "      ByteBufInputStream inputStream = new ByteBufInputStream(headers);"], [102, "      try {"], [103, "        builder.headers((Map<String, String>) (readFrom(inputStream, mapType)));"], [113, ""], [114, ""], [118, "      ByteBufInputStream inputStream = new ByteBufInputStream(message.data());"], [119, "      try {"], [128, ""], [129, ""], [132, "    ByteBuf buffer = ByteBufAllocator.DEFAULT.buffer();"], [156, "      if(stream.available() ==0) {"], [164, ""], [179, ""]]}, "num_lines_added": 27, "num_lines_removed": 30}