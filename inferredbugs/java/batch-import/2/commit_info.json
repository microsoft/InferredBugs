{"hash": "4d4462922be60667c4ab24db8fcb46dd5c629f70", "message": "skips non-existend property values\nadded type conversion", "file_num_lines": 326, "diff_parsed": {"added": [[4, "import org.neo4j.kernel.impl.util.FileUtils;"], [16, "import java.util.*;"], [17, ""], [23, "import static org.neo4j.index.impl.lucene.LuceneIndexImplementation.FULLTEXT_CONFIG;"], [38, "                fw.append( \"use_memory_mapped_buffers=true\\n\""], [39, "                        + \"neostore.nodestore.db.mapped_memory=100M\\n\""], [40, "                        + \"neostore.relationshipstore.db.mapped_memory=1G\\n\""], [41, "                        + \"neostore.propertystore.db.mapped_memory=250M\\n\""], [42, "                        + \"neostore.propertystore.db.strings.mapped_memory=100M\\n\""], [63, "            System.err.println(\"Usage java -jar batchimport.jar data/dir nodes.csv relationships.csv [node_index node-index-name fulltext|exact nodes_index.csv rel_index rel-index-name fulltext|exact rels_index.csv ....]\");"], [68, "        File indexFile;"], [69, "        String indexName;"], [70, "        String indexType;"], [72, "        if (graphDb.exists()) {"], [73, "            FileUtils.deleteRecursively(graphDb);"], [74, "        }"], [102, "        private Object[] data;"], [105, "        private final String[] fields;"], [106, "        private final String[] lineData;"], [107, "        private final Type types[];"], [108, "        private final int lineSize;"], [109, "        private int dataSize;"], [114, "            fields = header.split(delim);"], [115, "            lineSize = fields.length;"], [116, "            types = parseTypes(fields);"], [117, "            lineData = new String[lineSize];"], [118, "            createMapData(lineSize, offset);"], [119, "        }"], [120, ""], [121, "        private Object[] createMapData(int lineSize, int offset) {"], [122, "            dataSize = lineSize - offset;"], [123, "            data = new Object[dataSize*2];"], [124, "            for (int i = 0; i < dataSize; i++) {"], [127, "            return data;"], [128, "        }"], [129, ""], [130, "        private Type[] parseTypes(String[] fields) {"], [131, "            Type[] types = new Type[lineSize];"], [132, "            Arrays.fill(types, Type.STRING);"], [133, "            for (int i = 0; i < lineSize; i++) {"], [134, "                String field = fields[i];"], [135, "                int idx = field.indexOf(':');"], [136, "                if (idx!=-1) {"], [137, "                   fields[i]=field.substring(0,idx);"], [138, "                   types[i]= Type.fromString(field.substring(idx + 1));"], [139, "                }"], [140, "            }"], [141, "            return types;"], [142, "        }"], [143, ""], [144, "        private int split(String line) {"], [145, "            final StringTokenizer st = new StringTokenizer(line, delim,true);"], [146, "            int count=0;"], [147, "            for (int i = 0; i < lineSize; i++) {"], [148, "                String value = st.nextToken();"], [149, "                if (value.equals(delim)) {"], [150, "                    lineData[i] = null;"], [151, "                } else {"], [152, "                    lineData[i] = value.trim().isEmpty() ? null : value;"], [153, "                    if (i< lineSize -1) st.nextToken();"], [154, "                }"], [155, "                if (i >= offset && lineData[i]!=null) {"], [156, "                    data[count++]=fields[i];"], [157, "                    data[count++]=types[i-offset].convert(lineData[i]);"], [158, "                }"], [159, "            }"], [160, "            return count;"], [163, "        public Map<String,Object> update(String line, Object... header) {"], [164, "            int nonNullCount = split(line);"], [166, "                System.arraycopy(lineData, 0, header, 0, header.length);"], [168, ""], [169, "            if (nonNullCount == dataSize*2) {"], [170, "                return map(data);"], [172, "            Object[] newData=new Object[nonNullCount];"], [173, "            System.arraycopy(data,0,newData,0,nonNullCount);"], [174, "            return map(newData);"], [196, "            System.out.println(\"\\nTotal import time: \"+ (System.currentTimeMillis() - total) / 1000 + \" seconds \");"], [204, "            System.out.println(\" \"+ (now - batchTime) + \" ms for \"+batch);"], [219, "            db.createNode(data.update(line));"], [229, "        final RelType relType = new RelType();"], [233, "            final Map<String, Object> properties = data.update(line, rel);"], [234, "            db.createRelationship(id(rel[0]), id(rel[1]), relType.update(rel[2]), properties);"], [243, "    \t\tindex = lucene.nodeIndex( indexName, FULLTEXT_CONFIG );"], [255, "            final Map<String, Object> properties = data.update(line, node);"], [266, "    \t\tindex = lucene.relationshipIndex( indexName, FULLTEXT_CONFIG );"], [278, "            final Map<String, Object> properties = data.update(line, rel);"], [288, "    static class RelType implements RelationshipType {"], [291, "        public RelType update(Object value) {"], [301, "    enum Type {"], [302, "        BOOLEAN {"], [303, "            @Override"], [304, "            public Object convert(String value) {"], [305, "                return Boolean.valueOf(value);"], [306, "            }"], [307, "        },"], [308, "        INT {"], [309, "            @Override"], [310, "            public Object convert(String value) {"], [311, "                return Integer.valueOf(value);"], [312, "            }"], [313, "        },"], [314, "        LONG {"], [315, "            @Override"], [316, "            public Object convert(String value) {"], [317, "                return Long.valueOf(value);"], [318, "            }"], [319, "        },"], [320, "        DOUBLE {"], [321, "            @Override"], [322, "            public Object convert(String value) {"], [323, "                return Double.valueOf(value);"], [324, "            }"], [325, "        },"], [326, "        FLOAT {"], [327, "            @Override"], [328, "            public Object convert(String value) {"], [329, "                return Float.valueOf(value);"], [330, "            }"], [331, "        },"], [332, "        BYTE {"], [333, "            @Override"], [334, "            public Object convert(String value) {"], [335, "                return Byte.valueOf(value);"], [336, "            }"], [337, "        },"], [338, "        SHORT {"], [339, "            @Override"], [340, "            public Object convert(String value) {"], [341, "                return Short.valueOf(value);"], [342, "            }"], [343, "        },"], [344, "        CHAR {"], [345, "            @Override"], [346, "            public Object convert(String value) {"], [347, "                return value.charAt(0);"], [348, "            }"], [349, "        },"], [350, "        STRING {"], [351, "            @Override"], [352, "            public Object convert(String value) {"], [353, "                return value;"], [354, "            }"], [355, "        };"], [356, ""], [357, "        private static Type fromString(String typeString) {"], [358, "            if (typeString==null || typeString.isEmpty()) return Type.STRING;"], [359, "            try {"], [360, "                return valueOf(typeString.toUpperCase());"], [361, "            } catch (Exception e) {"], [362, "                throw new IllegalArgumentException(\"Unknown Type \"+typeString);"], [363, "            }"], [364, "        }"], [365, ""], [366, "        public abstract Object convert(String value);"], [367, "    }"], [368, ""]], "deleted": [[6, "import org.neo4j.unsafe.batchinsert.BatchInserterImpl;"], [16, "import java.util.HashMap;"], [17, "import java.util.Map;"], [37, "\t\t        fw.append( \"neostore.nodestore.db.mapped_memory=100M\\n\""], [38, "\t\t                 + \"neostore.relationshipstore.db.mapped_memory=1G\\n\""], [39, "\t\t                 + \"neostore.propertystore.db.mapped_memory=250M\\n\""], [40, "\t\t                 + \"neostore.propertystore.db.strings.mapped_memory=100M\\n\""], [61, "            System.err.println(\"Usage java -jar batchimport.jar data/dir nodes.csv relationships.csv\");"], [66, "        File indexFile = new File(\"\");"], [67, "        String indexName = \"\";"], [68, "        String indexType = \"\";"], [70, "        if (!graphDb.exists()) graphDb.mkdirs();"], [98, "        private final Object[] data;"], [105, "            String[] fields = header.split(delim);"], [106, "            data = new Object[(fields.length - offset) * 2];"], [107, "            for (int i = 0; i < fields.length - offset; i++) {"], [112, "        public Object[] update(String line, Object... header) {"], [113, "            final String[] values = line.split(delim);"], [115, "                System.arraycopy(values, 0, header, 0, header.length);"], [117, "            for (int i = 0; i < values.length - offset; i++) {"], [118, "                data[i * 2 + 1] = values[i + offset];"], [120, "            return data;"], [142, "            System.out.println((System.currentTimeMillis() - total) / 1000 + \" seconds \");"], [150, "            System.out.println((now - batchTime) + \" ms for \"+batch);"], [165, "            db.createNode(map(data.update(line)));"], [175, "        final Type type = new Type();"], [179, "            final Map<String, Object> properties = map(data.update(line, rel));"], [180, "            db.createRelationship(id(rel[0]), id(rel[1]), type.update(rel[2]), properties);"], [189, "    \t\tindex = lucene.nodeIndex( indexName, stringMap( \"type\", \"fulltext\" ) );"], [201, "            final Map<String, Object> properties = map(data.update(line, node));"], [212, "    \t\tindex = lucene.relationshipIndex( indexName, stringMap( \"type\", \"fulltext\" ) );"], [224, "            final Map<String, Object> properties = map(data.update(line, rel));"], [234, "    static class Type implements RelationshipType {"], [237, "        public Type update(Object value) {"]]}, "num_lines_added": 156, "num_lines_removed": 34}