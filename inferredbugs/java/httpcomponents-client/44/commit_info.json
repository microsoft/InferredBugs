{"hash": "f0f2c89ffb0651e5b8f34cae9455497b8cb632bb", "message": "Fix for HTTPCLIENT-1360.  Separate out DeflateInputStream class from DeflateEntity.\n\ngit-svn-id: https://svn.apache.org/repos/asf/httpcomponents/httpclient/trunk@1487630 13f79535-47bb-0310-9956-ffa450edef68", "file_num_lines": 23, "diff_parsed": {"added": [[71, "        return new DeflateInputStream(wrapped);"]], "deleted": [[31, "import java.io.PushbackInputStream;"], [32, "import java.util.zip.DataFormatException;"], [33, "import java.util.zip.Inflater;"], [34, "import java.util.zip.InflaterInputStream;"], [75, "        /*"], [76, "         * A zlib stream will have a header."], [77, "         *"], [78, "         * CMF | FLG [| DICTID ] | ...compressed data | ADLER32 |"], [79, "         *"], [80, "         * * CMF is one byte."], [81, "         *"], [82, "         * * FLG is one byte."], [83, "         *"], [84, "         * * DICTID is four bytes, and only present if FLG.FDICT is set."], [85, "         *"], [86, "         * Sniff the content. Does it look like a zlib stream, with a CMF, etc? c.f. RFC1950,"], [87, "         * section 2.2. http://tools.ietf.org/html/rfc1950#page-4"], [88, "         *"], [89, "         * We need to see if it looks like a proper zlib stream, or whether it is just a deflate"], [90, "         * stream. RFC2616 calls zlib streams deflate. Confusing, isn't it? That's why some servers"], [91, "         * implement deflate Content-Encoding using deflate streams, rather than zlib streams."], [92, "         *"], [93, "         * We could start looking at the bytes, but to be honest, someone else has already read"], [94, "         * the RFCs and implemented that for us. So we'll just use the JDK libraries and exception"], [95, "         * handling to do this. If that proves slow, then we could potentially change this to check"], [96, "         * the first byte - does it look like a CMF? What about the second byte - does it look like"], [97, "         * a FLG, etc."], [98, "         */"], [99, ""], [100, "        /* We read a small buffer to sniff the content. */"], [101, "        final byte[] peeked = new byte[6];"], [102, ""], [103, "        final PushbackInputStream pushback = new PushbackInputStream(wrapped, peeked.length);"], [104, ""], [105, "        final int headerLength = pushback.read(peeked);"], [106, ""], [107, "        if (headerLength == -1) {"], [108, "            throw new IOException(\"Unable to read the response\");"], [109, "        }"], [110, ""], [111, "        /* We try to read the first uncompressed byte. */"], [112, "        final byte[] dummy = new byte[1];"], [113, ""], [114, "        final Inflater inf = new Inflater();"], [115, ""], [116, "        try {"], [117, "            int n;"], [118, "            while ((n = inf.inflate(dummy)) == 0) {"], [119, "                if (inf.finished()) {"], [120, ""], [121, "                    /* Not expecting this, so fail loudly. */"], [122, "                    throw new IOException(\"Unable to read the response\");"], [123, "                }"], [124, ""], [125, "                if (inf.needsDictionary()) {"], [126, ""], [127, "                    /* Need dictionary - then it must be zlib stream with DICTID part? */"], [128, "                    break;"], [129, "                }"], [130, ""], [131, "                if (inf.needsInput()) {"], [132, "                    inf.setInput(peeked);"], [133, "                }"], [134, "            }"], [135, ""], [136, "            if (n == -1) {"], [137, "                throw new IOException(\"Unable to read the response\");"], [138, "            }"], [139, ""], [140, "            /*"], [141, "             * We read something without a problem, so it's a valid zlib stream. Just need to reset"], [142, "             * and return an unused InputStream now."], [143, "             */"], [144, "            pushback.unread(peeked, 0, headerLength);"], [145, "            return new DeflateStream(pushback, new Inflater());"], [146, "        } catch (final DataFormatException e) {"], [147, ""], [148, "            /* Presume that it's an RFC1951 deflate stream rather than RFC1950 zlib stream and try"], [149, "             * again. */"], [150, "            pushback.unread(peeked, 0, headerLength);"], [151, "            return new DeflateStream(pushback, new Inflater(true));"], [152, "        } finally {"], [153, "            inf.end();"], [154, "        }"], [177, "    static class DeflateStream extends InflaterInputStream {"], [178, ""], [179, "        private boolean closed = false;"], [180, ""], [181, "        public DeflateStream(final InputStream in, final Inflater inflater) {"], [182, "            super(in, inflater);"], [183, "        }"], [184, ""], [185, "        @Override"], [186, "        public void close() throws IOException {"], [187, "            if (closed) {"], [188, "                return;"], [189, "            }"], [190, "            closed = true;"], [191, "            inf.end();"], [192, "            super.close();"], [193, "        }"], [194, ""], [195, "    }"], [196, ""]]}, "num_lines_added": 1, "num_lines_removed": 104}