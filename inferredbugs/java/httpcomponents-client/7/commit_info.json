{"hash": "bd2f049ada455eb6949d0e9c17c6b60463ec4851", "message": "HTTPCLIENT-841: removed connection garbage collection due to a memory leak\n\ngit-svn-id: https://svn.apache.org/repos/asf/httpcomponents/httpclient/trunk@784361 13f79535-47bb-0310-9956-ffa450edef68", "file_num_lines": 109, "diff_parsed": {"added": [[44, "import net.jcip.annotations.ThreadSafe;"], [62, ""], [63, "@ThreadSafe"], [64, "@SuppressWarnings(\"deprecation\")"], [79, "    protected Set<BasicPoolEntry> leasedConnections;"], [92, "    @Deprecated"], [93, "    protected Set<BasicPoolEntryRef> issuedConnections;"], [94, ""], [95, "    @Deprecated"], [96, "    protected ReferenceQueue<Object> refQueue;"], [97, ""], [102, "        leasedConnections = new HashSet<BasicPoolEntry>();"], [110, "     * @deprecated do not sue"], [112, "    @Deprecated"], [165, "    @Deprecated"], [169, "    @Deprecated"], [170, "    protected abstract void handleLostEntry(HttpRoute route);"], [224, "            Iterator<BasicPoolEntry> iter = leasedConnections.iterator();"], [226, "                BasicPoolEntry entry = iter.next();"], [228, "                closeConnection(entry.getConnection());"]], "deleted": [[44, "import net.jcip.annotations.NotThreadSafe;"], [53, ""], [63, "@NotThreadSafe // unsynch access to refQueue, refWorker"], [73, ""], [76, "     * Objects in this set are of class"], [77, "     * {@link BasicPoolEntryRef BasicPoolEntryRef},"], [78, "     * and point to the pool entry for the issued connection."], [79, "     * GCed connections are detected by the missing pool entries."], [83, "    protected Set<BasicPoolEntryRef> issuedConnections;"], [93, "    /**"], [94, "     * A reference queue to track loss of pool entries to GC."], [95, "     * The same queue is used to track loss of the connection manager,"], [96, "     * so we cannot specialize the type."], [97, "     */"], [98, "    // TODO - this needs to be synchronized, e.g. on Pool Lock"], [99, "    protected ReferenceQueue<Object> refQueue;"], [100, ""], [101, "    /** A worker (thread) to track loss of pool entries to GC. */"], [102, "    // TODO - this needs to be synchronized, e.g. on Pool Lock"], [103, "    private RefQueueWorker refWorker;"], [104, ""], [105, ""], [113, "        issuedConnections = new HashSet<BasicPoolEntryRef>();"], [120, ""], [122, "     * Enables connection garbage collection (GC)."], [123, "     * This method must be called immediately after creating the"], [124, "     * connection pool. It is not possible to enable connection GC"], [125, "     * after pool entries have been created. Neither is it possible"], [126, "     * to disable connection GC."], [127, "     *"], [128, "     * @throws IllegalStateException"], [129, "     *         if connection GC is already enabled, or if it cannot be"], [130, "     *         enabled because there already are pool entries"], [134, ""], [135, "        if (refQueue != null) { // TODO - this access is not guaranteed protected by the pool lock"], [136, "            throw new IllegalStateException(\"Connection GC already enabled.\");"], [137, "        }"], [138, "        poolLock.lock();"], [139, "        try {"], [140, "            if (numConnections > 0) { //@@@ is this check sufficient?"], [141, "                throw new IllegalStateException(\"Pool already in use.\");"], [142, "            }"], [143, "        } finally {"], [144, "            poolLock.unlock();"], [145, "        }"], [146, ""], [147, "        refQueue  = new ReferenceQueue<Object>();"], [148, "        refWorker = new RefQueueWorker(refQueue, this);"], [149, "        Thread t = new Thread(refWorker); //@@@ use a thread factory"], [150, "        t.setDaemon(true);"], [151, "        t.setName(\"RefQueueWorker@\" + this);"], [152, "        t.start();"], [203, ""], [204, ""], [205, "    // non-javadoc, see interface RefQueueHandler"], [207, ""], [208, "        poolLock.lock();"], [209, "        try {"], [210, ""], [211, "            if (ref instanceof BasicPoolEntryRef) {"], [212, "                // check if the GCed pool entry was still in use"], [213, "                //@@@ find a way to detect this without lookup"], [214, "                //@@@ flag in the BasicPoolEntryRef, to be reset when freed?"], [215, "                final boolean lost = issuedConnections.remove(ref);"], [216, "                if (lost) {"], [217, "                    final HttpRoute route ="], [218, "                        ((BasicPoolEntryRef)ref).getRoute();"], [219, "                    if (log.isDebugEnabled()) {"], [220, "                        log.debug(\"Connection garbage collected. \" + route);"], [221, "                    }"], [222, "                    handleLostEntry(route);"], [223, "                }"], [224, "            }"], [225, ""], [226, "        } finally {"], [227, "            poolLock.unlock();"], [228, "        }"], [231, ""], [232, "    /**"], [233, "     * Handles cleaning up for a lost pool entry with the given route."], [234, "     * A lost pool entry corresponds to a connection that was"], [235, "     * garbage collected instead of being properly released."], [236, "     *"], [237, "     * @param route     the route of the pool entry that was lost"], [238, "     */"], [239, "    protected abstract void handleLostEntry(HttpRoute route)"], [240, "        ;"], [241, ""], [294, "            // no point in monitoring GC anymore"], [295, "            if (refWorker != null)"], [296, "                refWorker.shutdown();"], [297, ""], [299, "            Iterator<BasicPoolEntryRef> iter = issuedConnections.iterator();"], [301, "                BasicPoolEntryRef per = iter.next();"], [303, "                BasicPoolEntry entry = per.get();"], [304, "                if (entry != null) {"], [305, "                    closeConnection(entry.getConnection());"], [306, "                }"], [308, ""], [309, "            // remove all references to connections"], [310, "            //@@@ use this for shutting them down instead?"]]}, "num_lines_added": 20, "num_lines_removed": 101}