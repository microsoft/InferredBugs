{"hash": "9f3997fe0f9f6b9d916decea3f163011c043c8e7", "message": "Use long array for index/offset cache.", "file_num_lines": 203, "diff_parsed": {"added": [[29, "  private Cache cache;"], [61, ""], [126, "    cache = new Cache(file.length(), cachePercent);"], [131, "      seek(position);"], [137, "        cache.put(size++, position);"], [156, "    int i;"], [158, "      final Cache.Entry entry = cache.get(index);"], [159, "      i = entry.index;"], [160, "      seek(entry.position);"], [281, ""], [282, ""], [283, "  /** Cache of word indices to byte offsets where word starts in backing file. */"], [284, "  static class Cache"], [285, "  {"], [286, "    /** Cache entry that indicates cached word index and byte offset of start of word in backing file. */"], [287, "    static class Entry"], [288, "    {"], [289, "      // CheckStyle:VisibilityModifier OFF"], [290, "      /** Cached word index. */"], [291, "      int index;"], [292, ""], [293, "      /** Byte offset where word starts in backing file. */"], [294, "      long position;"], [295, "      // CheckStyle:VisibilityModifier ON"], [296, ""], [297, ""], [298, "      /**"], [299, "       * Creates a new cache entry."], [300, "       *"], [301, "       * @param  i  Cached word index."], [302, "       * @param  pos  Byte offset where word starts in backing file."], [303, "       */"], [304, "      Entry(final int i, final long pos)"], [305, "      {"], [306, "        index = i;"], [307, "        position = pos;"], [308, "      }"], [309, "    }"], [310, ""], [311, "    /** Map of word indices to the byte offset in the file where the word starts. */"], [312, "    private long[] map;"], [313, ""], [314, "    /** Modulus of indices to cache. */"], [315, "    private int modulus;"], [316, ""], [317, ""], [318, "    /**"], [319, "     * Creates a new cache instance."], [320, "     *"], [321, "     * @param  fileSize  Size of file in bytes."], [322, "     * @param  cachePercent  Percent of words to cache."], [323, "     */"], [324, "    Cache(final long fileSize, final int cachePercent)"], [325, "    {"], [326, "      if (cachePercent < 0 || cachePercent > 100) {"], [327, "        throw new IllegalArgumentException(\"cachePercent must be between 0 and 100 inclusive\");"], [328, "      }"], [329, "      final long cacheSize = (fileSize / 100) * cachePercent;"], [330, "      if (cacheSize == 0) {"], [331, "        return;"], [332, "      }"], [333, "      modulus = (int) (fileSize / cacheSize);"], [334, ""], [335, "      final long startSize = cacheSize / 6;"], [336, "      if (startSize > Integer.MAX_VALUE) {"], [337, "        throw new IllegalArgumentException(\"Cache limit exceeded. Try reducing cacheSize.\");"], [338, "      }"], [339, "      map = new long[(int) startSize];"], [340, "    }"], [341, ""], [342, ""], [343, "    /**"], [344, "     * Puts an entry that maps the word at given index to the byte offset in into the backing file."], [345, "     *"], [346, "     * @param  index  Word at index."], [347, "     * @param  position  Byte offset into backing for file where word starts."], [348, "     */"], [349, "    void put(final int index, final long position)"], [350, "    {"], [351, "      if (modulus == 0) {"], [352, "        return;"], [353, "      }"], [354, "      if (index >= map.length) {"], [355, "        final long newSize = map.length * 3L / 2;"], [356, "        if (newSize > Integer.MAX_VALUE) {"], [357, "          throw new IllegalArgumentException(\"Cache limit exceeded. Try reducing cacheSize.\");"], [358, "        }"], [359, "        final long[] temp = new long[(int) newSize];"], [360, "        System.arraycopy(map, 0, temp, 0, map.length);"], [361, "        map = temp;"], [362, "      }"], [363, "      map[index / modulus] = position;"], [364, "    }"], [365, ""], [366, ""], [367, "    /**"], [368, "     * Gets the byte offset into the backing file for the word at the given index."], [369, "     *"], [370, "     * @param  index  Word at index."], [371, "     *"], [372, "     * @return  Nearest cache entry for given index."], [373, "     */"], [374, "    Entry get(final int index)"], [375, "    {"], [376, "      if (modulus == 0) {"], [377, "        return new Entry(0, 0);"], [378, "      }"], [379, "      final int i = index / modulus;"], [380, "      if (i < map.length) {"], [381, "        return new Entry(i, map[i]);"], [382, "      }"], [383, "      throw new IndexOutOfBoundsException(index + \" out of range\");"], [384, "    }"], [385, "  }"]], "deleted": [[10, "import java.util.TreeMap;"], [30, "  // CheckStyle:IllegalType OFF"], [31, "  // uses the firstKey and floorKey implementations"], [32, "  protected TreeMap<Integer, Long> cache = new TreeMap<>();"], [33, "  // CheckStyle:IllegalType ON"], [53, "   * @param  cachePercent  Percent (0-100) of file to cache in memory for improved read performance."], [62, "    final int cachePercent,"], [66, "    if (cachePercent < 0 || cachePercent > 100) {"], [67, "      throw new IllegalArgumentException(\"cachePercent must be between 0 and 100 inclusive\");"], [68, "    }"], [134, "    final long fileBytes = file.length();"], [135, "    final long cacheSize = (fileBytes / 100) * cachePercent;"], [136, "    final long cacheModulus = cacheSize == 0 ? fileBytes : cacheSize > fileBytes ? 1 : fileBytes / cacheSize;"], [137, ""], [138, "    if (cache == null) {"], [139, "      throw new IllegalStateException(\"Cannot initialize after close has been called.\");"], [140, "    }"], [141, ""], [146, "      seek(0);"], [147, "      cache.clear();"], [153, "        if (cacheSize > 0 && size % cacheModulus == 0) {"], [154, "          cache.put(size, a.offset);"], [155, "        }"], [156, "        size++;"], [174, "    int i = 0;"], [175, "    if (!cache.isEmpty() && cache.firstKey() <= index) {"], [176, "      i = cache.floorKey(index);"], [177, "    }"], [180, "      position = i > 0 ? cache.get(i) : 0L;"], [181, "      seek(position);"]]}, "num_lines_added": 114, "num_lines_removed": 30}