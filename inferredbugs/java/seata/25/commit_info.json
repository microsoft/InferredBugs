{"hash": "90df7e210317db30e02160b8505ba28c751c9c26", "message": "Add test case for rpc protocol. (#1355)", "file_num_lines": 147, "diff_parsed": {"added": [[38, "import org.slf4j.Logger;"], [39, "import org.slf4j.LoggerFactory;"], [43, "import java.util.concurrent.ConcurrentHashMap;"], [45, "import java.util.concurrent.SynchronousQueue;"], [46, "import java.util.concurrent.ThreadPoolExecutor;"], [48, "import java.util.concurrent.atomic.AtomicLong;"], [55, "    /**"], [56, "     * Logger for ProtocolV1Client"], [57, "     **/"], [58, "    private static final Logger LOGGER = LoggerFactory.getLogger(ProtocolV1Client.class);"], [59, ""], [64, "    Map<Integer, Future> futureMap = new ConcurrentHashMap<>();"], [68, "    private DefaultEventExecutor defaultEventExecutor = new DefaultEventExecutor(eventLoopGroup);"], [69, ""], [106, "    public void close() {"], [107, "        if (channel != null) {"], [108, "            channel.close();"], [109, "        }"], [110, "        if (eventLoopGroup != null) {"], [111, "            eventLoopGroup.shutdownGracefully();"], [112, "        }"], [113, "        channel = null;"], [114, "    }"], [115, ""], [116, "    public Future sendRpc(Map<String, String> head, Object body) {"], [117, "        int msgId = idGenerator.incrementAndGet();"], [118, ""], [119, "        RpcMessage rpcMessage = new RpcMessage();"], [120, "        rpcMessage.setId(msgId);"], [121, "        rpcMessage.setCodec(CodecType.SEATA.getCode());"], [122, "        rpcMessage.setCompressor(ProtocolConstants.CONFIGURED_COMPRESSOR);"], [123, "        rpcMessage.setHeadMap(head);"], [124, "        rpcMessage.setBody(body);"], [125, "        rpcMessage.setMessageType(ProtocolConstants.MSGTYPE_RESQUEST);"], [126, ""], [127, "        if (channel != null) {"], [128, "            DefaultPromise promise = new DefaultPromise(defaultEventExecutor);"], [129, "            futureMap.put(msgId, promise);"], [130, "            channel.writeAndFlush(rpcMessage);"], [131, "            return promise;"], [132, "        } else {"], [133, "            LOGGER.warn(\"channel is null\");"], [134, "        }"], [135, "        return null;"], [136, "    }"], [137, ""], [138, "    // can test tps"], [139, "    public static void main(String[] args) {"], [154, "        final int threads = 50;"], [155, "        final AtomicLong cnt = new AtomicLong(0);"], [156, "        final ThreadPoolExecutor service1 = new ThreadPoolExecutor(threads, threads, 0L, TimeUnit.MILLISECONDS,"], [157, "                new SynchronousQueue<Runnable>(), new NamedThreadFactory(\"client-\", false));// \u65e0\u961f\u5217"], [158, "        for (int i = 0; i < threads; i++) {"], [159, "            service1.execute(() -> {"], [160, "                while (true) {"], [161, "                    try {"], [162, "                        Future future = client.sendRpc(head, body);"], [163, "                        RpcMessage resp = (RpcMessage) future.get(200, TimeUnit.MILLISECONDS);"], [164, "                        if (resp != null) {"], [165, "                            cnt.incrementAndGet();"], [166, "                        }"], [167, "                    } catch (Exception e) {"], [168, "                        // ignore"], [169, "                    }"], [170, "                }"], [171, "            });"], [172, "        }"], [174, "        Thread thread = new Thread(new Runnable() {"], [175, "            private long last = 0;"], [177, "            @Override"], [178, "            public void run() {"], [179, "                while (true) {"], [180, "                    long count = cnt.get();"], [181, "                    long tps = count - last;"], [182, "                    LOGGER.error(\"last 1s invoke: {}, queue: {}\", tps, service1.getQueue().size());"], [183, "                    last = count;"], [184, ""], [185, "                    try {"], [186, "                        Thread.sleep(1000);"], [187, "                    } catch (InterruptedException e) {"], [188, "                    }"], [189, "                }"], [190, "            }"], [191, "        }, \"Print-tps-THREAD\");"], [192, "        thread.start();"]], "deleted": [[41, "import java.util.concurrent.ExecutionException;"], [44, "import java.util.concurrent.TimeoutException;"], [55, "    Map<Integer, Future> futureMap = new HashMap<>();"], [78, ""], [83, "//            if (NetUtils.toAddressString((InetSocketAddress) channel.remoteAddress())"], [84, "//                    .equals(NetUtils.toAddressString((InetSocketAddress) channel.localAddress()))) {"], [85, "//                // \u670d\u52a1\u7aef\u4e0d\u5b58\u6d3b\u65f6\uff0c\u8fde\u63a5\u5de6\u53f3\u4e24\u4fa7\u5730\u5740\u4e00\u6837\u7684\u60c5\u51b5"], [86, "//                channel.close(); // \u5173\u6389\u91cd\u8fde"], [87, "//                throw new InitErrorException(\"Failed to connect \" + host + \":\" + port"], [88, "//                        + \". Cause by: Remote and local address are the same\");"], [89, "//            }"], [103, "    public static void main(String[] args) throws InterruptedException, TimeoutException, ExecutionException {"], [118, "        RpcMessage rpcMessage = new RpcMessage();"], [119, "        rpcMessage.setId(client.idGenerator.incrementAndGet());"], [120, "        rpcMessage.setCodec(CodecType.SEATA.getCode());"], [121, "        rpcMessage.setCompressor(ProtocolConstants.CONFIGURED_COMPRESSOR);"], [122, "        rpcMessage.setHeadMap(head);"], [123, "        rpcMessage.setBody(body);"], [124, "        rpcMessage.setMessageType(ProtocolConstants.MSGTYPE_RESQUEST);"], [126, "        Future future = client.send(rpcMessage.getId(), rpcMessage);"], [127, "        RpcMessage resp = (RpcMessage) future.get(200, TimeUnit.SECONDS);"], [129, "        System.out.println(resp.getId() + \" \" + resp.getBody());"], [133, "    private Future send(int msgId, Object msg) {"], [134, "        if (channel != null) {"], [135, "            DefaultPromise promise = new DefaultPromise(new DefaultEventExecutor(eventLoopGroup));"], [136, "            futureMap.put(msgId, promise);"], [137, "            channel.writeAndFlush(msg);"], [138, "            return promise;"], [139, "        }"], [140, "        return null;"], [141, "    }"]]}, "num_lines_added": 85, "num_lines_removed": 31}