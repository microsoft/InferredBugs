{"hash": "6e6aecfb603e557192be38dbbfd10fec1ccf03a5", "message": "Fix hang waiting on docker log pattern to match - regression introduced in 0.24.0\n\nApache HTTP Client will drain an http request upon closing the input stream.\nIn this case we consume the docker logs in 'follow' mode which will cause the docker daemon to never close the connection on its end.\nThus the close() call will block forever.\nThe main thread is responsible for calling request.abort() will will signal Apache HTTP Client to close the socket on it's end and thus the close() call can unblock.", "file_num_lines": 143, "diff_parsed": {"added": [[86, "            final HttpResponse response = client.execute(request);"], [87, "            parseResponse(response);"], [89, "            // Signifies we're finished with the log stream."], [99, "        try {"], [100, "            callback.open();"], [101, "            this.request = getLogRequest(true);"], [102, "            final HttpResponse response = client.execute(request);"], [103, "            parseResponse(response);"], [104, "        } catch (LogCallback.DoneException e) {"], [105, "            // Signifies we're finished with the log stream."], [106, "        } catch (IOException e) {"], [107, "            callback.error(\"IO Error while requesting logs: \" + e + \" \" + Thread.currentThread().getName());"], [108, "        } finally {"], [109, "            callback.close();"], [183, "        try (InputStream is = response.getEntity().getContent()) {"], [210, "        if (request != null) {"], [211, "            request.abort();"], [212, "            request = null;"]], "deleted": [[61, "    // Lock for synchronizing closing of requests"], [62, "    private final Object lock = new Object();"], [63, ""], [89, "            final HttpResponse respone = client.execute(request);"], [90, "            parseResponse(respone);"], [92, "            finish();"], [102, "        synchronized (lock) {"], [103, "            try {"], [104, "                callback.open();"], [105, ""], [106, "                this.request = getLogRequest(true);"], [107, "                final HttpResponse response = client.execute(request);"], [108, "                parseResponse(response);"], [109, "            } catch (LogCallback.DoneException e) {"], [110, "                finish();"], [111, "            } catch (IOException e) {"], [112, "                callback.error(\"IO Error while requesting logs: \" + e + \" \" + Thread.currentThread().getName());"], [113, "            } finally {"], [114, "                callback.close();"], [115, "            }"], [189, "        final InputStream is = response.getEntity().getContent();"], [190, ""], [191, "        try {"], [197, "        } finally {"], [198, "            if ((is != null) && (is.available() > 0)) {"], [199, "                is.close();"], [200, "            }"], [222, "        synchronized (lock) {"], [223, "            if (request != null) {"], [224, "                request.abort();"], [225, "                request = null;"], [226, "            }"]]}, "num_lines_added": 18, "num_lines_removed": 32}