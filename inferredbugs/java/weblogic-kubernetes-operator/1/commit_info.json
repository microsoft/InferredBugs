{"hash": "f32edf827d6508c0c75ea4c957b5763c2898da08", "message": "Fix onExit handling", "file_num_lines": 489, "diff_parsed": {"added": [[427, "      } finally {"], [428, "        synchronized (this) {"], [429, "          if (currentThread == null) {"], [430, "            triggerExitCallback();"], [431, "          }"], [432, "        }"], [476, "    if (status.get() == NOT_COMPLETE) {"], [477, "      // Clear the interrupted status, if present"], [478, "      Thread.interrupted();"], [480, "      final Fiber oldFiber = CURRENT_FIBER.get();"], [481, "      CURRENT_FIBER.set(this);"], [482, "      Container oldContainer = ContainerResolver.getDefault().enterContainer(owner.getContainer());"], [483, "      try {"], [484, "        // doRun returns true to indicate an early exit from fiber processing"], [485, "        if (!doRun(next)) {"], [486, "            completionCheck();"], [488, "      } finally {"], [489, "        ContainerResolver.getDefault().exitContainer(oldContainer);"], [490, "        CURRENT_FIBER.set(oldFiber);"], [494, ""], [571, "          triggerExitCallback();"], [578, "  private void triggerExitCallback() {"], [579, "    synchronized (this) {"], [580, "      if (exitCallback != null && exitCallback != PLACEHOLDER) {"], [581, ""], [582, "        if (LOGGER.isFineEnabled()) {"], [583, "          LOGGER.fine(\"{0} triggering exit callback\", new Object[] { getName() });"], [584, "        }"], [585, ""], [586, "        exitCallback.onExit();"], [587, "      }"], [588, "      exitCallback = PLACEHOLDER;"], [589, "    }"], [590, "  }"], [591, ""], [723, "    AtomicInteger count = new AtomicInteger(1); // ensure we don't hit zero before iterating children"], [729, "        count.incrementAndGet();"], [732, "      ExitCallback myCallback = () -> {"], [733, "        if (count.decrementAndGet() == 0) {"], [734, "          exitCallback.onExit();"], [735, "        }"], [736, "      };"], [737, ""], [740, "          if (child.cancelAndExitCallback(mayInterrupt, myCallback)) {"], [741, "            count.incrementAndGet();"], [742, "          }"], [746, "      boolean isWillCall = count.get() > 1; // more calls outstanding then our initial buffer count"], [748, "        if (this.exitCallback != null || this.exitCallback == PLACEHOLDER) {"], [749, "          throw new IllegalStateException();"], [750, "        }"], [751, "        this.exitCallback = myCallback;"], [752, "        myCallback.onExit(); // remove the buffer count"]], "deleted": [[470, "    // Clear the interrupted status, if present"], [471, "    Thread.interrupted();"], [472, ""], [473, "    final Fiber oldFiber = CURRENT_FIBER.get();"], [474, "    CURRENT_FIBER.set(this);"], [475, "    Container oldContainer = ContainerResolver.getDefault().enterContainer(owner.getContainer());"], [476, "    try {"], [477, "      // doRun returns true to indicate an early exit from fiber processing"], [478, "      if (!doRun(next)) {"], [479, "          completionCheck();"], [480, "      }"], [482, "      // Trigger exitCallback"], [483, "      synchronized (this) {"], [484, "        if (exitCallback != null && exitCallback != PLACEHOLDER) {"], [485, ""], [486, "          if (LOGGER.isFineEnabled()) {"], [487, "            LOGGER.fine(\"{0} invoking exit callback\", new Object[] { getName() });"], [488, "          }"], [489, ""], [490, "          exitCallback.onExit();"], [492, "        exitCallback = PLACEHOLDER;"], [494, "    } finally {"], [495, "      ContainerResolver.getDefault().exitContainer(oldContainer);"], [496, "      CURRENT_FIBER.set(oldFiber);"], [499, ""], [722, "          child.cancel(mayInterrupt);"], [726, "      if (this.exitCallback != null) {"], [727, "        throw new IllegalStateException();"], [728, "      }"], [729, "      boolean isWillCall = this.exitCallback != PLACEHOLDER;"], [731, "        this.exitCallback = exitCallback;"]]}, "num_lines_added": 52, "num_lines_removed": 31}