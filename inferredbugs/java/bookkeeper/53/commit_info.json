{"hash": "ccc9545c4565c337ef6ea06004149de75b4dd3af", "message": "BOOKKEEPER-611: Speed up bookkeeper tests (ivank via fpj)\n\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1488138 13f79535-47bb-0310-9956-ffa450edef68", "file_num_lines": 783, "diff_parsed": {"added": [[37, "import java.util.concurrent.CountDownLatch;"], [545, "            final CountDownLatch completeLatch = new CountDownLatch(numEntriesToWrite);"], [546, "            final AtomicInteger rc = new AtomicInteger(BKException.Code.OK);"], [547, ""], [549, "                lh.asyncAddEntry(new byte[0], new AddCallback() {"], [550, "                        public void addComplete(int rccb, LedgerHandle lh, long entryId, Object ctx) {"], [551, "                            rc.compareAndSet(BKException.Code.OK, rccb);"], [552, "                            completeLatch.countDown();"], [553, "                        }"], [554, "                    }, null);"], [555, "            }"], [556, "            completeLatch.await();"], [557, "            if (rc.get() != BKException.Code.OK) {"], [558, "                throw BKException.create(rc.get());"], [603, "            final CountDownLatch completeLatch = new CountDownLatch(numEntriesToWrite*2);"], [604, "            final AtomicInteger rc = new AtomicInteger(BKException.Code.OK);"], [605, ""], [609, "                lh.asyncAddEntry(new byte[0], new AddCallback() {"], [610, "                        public void addComplete(int rc2, LedgerHandle lh, long entryId, Object ctx) {"], [611, "                            rc.compareAndSet(BKException.Code.OK, rc2);"], [612, "                            completeLatch.countDown();"], [613, "                        }"], [614, "                    }, null);"], [615, "                lh2.asyncAddEntry(new byte[0], new AddCallback() {"], [616, "                        public void addComplete(int rc2, LedgerHandle lh, long entryId, Object ctx) {"], [617, "                            rc.compareAndSet(BKException.Code.OK, rc2);"], [618, "                            completeLatch.countDown();"], [619, "                        }"], [620, "                    }, null);"], [621, "            }"], [622, "            completeLatch.await();"], [623, "            if (rc.get() != BKException.Code.OK) {"], [624, "                throw BKException.create(rc.get());"], [717, "    private long writeNEntriesLastWriteSync(LedgerHandle lh, int numToWrite) throws Exception {"], [718, "        final CountDownLatch completeLatch = new CountDownLatch(numToWrite - 1);"], [719, "        final AtomicInteger rc = new AtomicInteger(BKException.Code.OK);"], [720, ""], [721, "        ByteBuffer entry = ByteBuffer.allocate(4);"], [722, "        for (int i = 0; i < numToWrite - 1; i++) {"], [723, "            entry = ByteBuffer.allocate(4);"], [724, "            entry.putInt(rng.nextInt(maxInt));"], [725, "            entry.position(0);"], [726, ""], [727, "            entries.add(entry.array());"], [728, "            entriesSize.add(entry.array().length);"], [729, "            lh.asyncAddEntry(entry.array(), new AddCallback() {"], [730, "                    public void addComplete(int rccb, LedgerHandle lh, long entryId, Object ctx) {"], [731, "                        rc.compareAndSet(BKException.Code.OK, rccb);"], [732, "                        completeLatch.countDown();"], [733, "                    }"], [734, "                }, null);"], [735, "        }"], [736, "        completeLatch.await();"], [737, "        if (rc.get() != BKException.Code.OK) {"], [738, "            throw BKException.create(rc.get());"], [739, "        }"], [740, ""], [741, "        entry = ByteBuffer.allocate(4);"], [742, "        entry.putInt(rng.nextInt(maxInt));"], [743, "        entry.position(0);"], [744, ""], [745, "        entries.add(entry.array());"], [746, "        entriesSize.add(entry.array().length);"], [747, "        lh.addEntry(entry.array());"], [748, "        return lh.getLastAddConfirmed();"], [749, "    }"], [750, ""], [752, "    public void testReadFromOpenLedger() throws Exception {"], [759, ""], [760, "            long lac = writeNEntriesLastWriteSync(lh, numEntriesToWrite);"], [761, ""], [762, "            LedgerHandle lhOpen = bkc.openLedgerNoRecovery(ledgerId, digestType, ledgerPassword);"], [763, "            // no recovery opened ledger 's last confirmed entry id is less than written"], [764, "            // and it just can read until (i-1)"], [765, "            long toRead = lac - 1;"], [766, ""], [767, "            Enumeration<LedgerEntry> readEntry = lhOpen.readEntries(toRead, toRead);"], [768, "            assertTrue(\"Enumeration of ledger entries has no element\", readEntry.hasMoreElements() == true);"], [769, "            LedgerEntry e = readEntry.nextElement();"], [770, "            assertEquals(toRead, e.getEntryId());"], [771, "            Assert.assertArrayEquals(entries.get((int)toRead), e.getEntry());"], [772, "            // should not written to a read only ledger"], [773, "            try {"], [778, "                lhOpen.addEntry(entry.array());"], [779, "                fail(\"Should have thrown an exception here\");"], [780, "            } catch (BKException.BKIllegalOpException bkioe) {"], [781, "                // this is the correct response"], [782, "            } catch (Exception ex) {"], [783, "                LOG.error(\"Unexpected exception\", ex);"], [784, "                fail(\"Unexpected exception\");"], [786, "            // close read only ledger should not change metadata"], [787, "            lhOpen.close();"], [789, "            lac = writeNEntriesLastWriteSync(lh, numEntriesToWrite);"], [790, ""], [791, "            assertEquals(\"Last confirmed add: \", lac, (numEntriesToWrite * 2) - 1);"], [803, "            writeNEntriesLastWriteSync(lh, numEntriesToWrite);"], [817, "            assertEquals(\"Last confirmed add\", sync.lastConfirmed, (numEntriesToWrite - 2));"], [840, "            writeNEntriesLastWriteSync(lh, numEntriesToWrite/2);"], [842, "            ByteBuffer entry = ByteBuffer.allocate(4);"], [843, "            entry.putInt(rng.nextInt(maxInt));"], [844, "            entry.position(0);"], [846, "            // no recovery opened ledger 's last confirmed entry id is"], [847, "            // less than written"], [848, "            // and it just can read until (i-1)"], [849, "            int toRead = numEntriesToWrite/2 - 2;"], [850, ""], [851, "            long readLastConfirmed = lhOpen.readLastConfirmed();"], [852, "            assertTrue(readLastConfirmed != 0);"], [853, "            Enumeration<LedgerEntry> readEntry = lhOpen.readEntries(toRead, toRead);"], [854, "            assertTrue(\"Enumeration of ledger entries has no element\", readEntry.hasMoreElements() == true);"], [855, "            LedgerEntry e = readEntry.nextElement();"], [856, "            assertEquals(toRead, e.getEntryId());"], [857, "            Assert.assertArrayEquals(entries.get(toRead), e.getEntry());"], [858, "            // should not written to a read only ledger"], [859, "            try {"], [860, "                lhOpen.addEntry(entry.array());"], [861, "                fail(\"Should have thrown an exception here\");"], [862, "            } catch (BKException.BKIllegalOpException bkioe) {"], [863, "                // this is the correct response"], [864, "            } catch (Exception ex) {"], [865, "                LOG.error(\"Unexpected exception\", ex);"], [866, "                fail(\"Unexpected exception\");"], [868, "            writeNEntriesLastWriteSync(lh, numEntriesToWrite/2);"], [869, ""], [956, "    public void testLastConfirmedAdd() throws Exception {"], [964, "            writeNEntriesLastWriteSync(lh, numEntriesToWrite);"], [978, "            writeNEntriesLastWriteSync(lh, numEntriesToWrite);"]], "deleted": [[545, "                lh.addEntry(new byte[0]);"], [593, "                lh.addEntry(new byte[0]);"], [594, "                lh2.addEntry(new byte[0]);"], [688, "    public void testReadFromOpenLedger() throws IOException {"], [695, "            for (int i = 0; i < numEntriesToWrite; i++) {"], [700, "                entries.add(entry.array());"], [701, "                entriesSize.add(entry.array().length);"], [702, "                lh.addEntry(entry.array());"], [703, "                if(i == numEntriesToWrite/2) {"], [704, "                    LedgerHandle lhOpen = bkc.openLedgerNoRecovery(ledgerId, digestType, ledgerPassword);"], [705, "                    // no recovery opened ledger 's last confirmed entry id is less than written"], [706, "                    // and it just can read until (i-1)"], [707, "                    int toRead = i - 1;"], [708, "                    Enumeration<LedgerEntry> readEntry = lhOpen.readEntries(toRead, toRead);"], [709, "                    assertTrue(\"Enumeration of ledger entries has no element\", readEntry.hasMoreElements() == true);"], [710, "                    LedgerEntry e = readEntry.nextElement();"], [711, "                    assertEquals(toRead, e.getEntryId());"], [712, "                    Assert.assertArrayEquals(entries.get(toRead), e.getEntry());"], [713, "                    // should not written to a read only ledger"], [714, "                    try {"], [715, "                        lhOpen.addEntry(entry.array());"], [716, "                        fail(\"Should have thrown an exception here\");"], [717, "                    } catch (BKException.BKIllegalOpException bkioe) {"], [718, "                        // this is the correct response"], [719, "                    } catch (Exception ex) {"], [720, "                        LOG.error(\"Unexpected exception\", ex);"], [721, "                        fail(\"Unexpected exception\");"], [722, "                    }"], [723, "                    // close read only ledger should not change metadata"], [724, "                    lhOpen.close();"], [725, "                }"], [728, "            long last = lh.readLastConfirmed();"], [729, "            assertTrue(\"Last confirmed add: \" + last, last == (numEntriesToWrite - 2));"], [740, "            LOG.info(\"Ledger ID: \" + lh.getId());"], [741, "            for (int i = 0; i < numEntriesToWrite; i++) {"], [742, "                ByteBuffer entry = ByteBuffer.allocate(4);"], [743, "                entry.putInt(rng.nextInt(maxInt));"], [744, "                entry.position(0);"], [745, ""], [746, "                entries.add(entry.array());"], [747, "                entriesSize.add(entry.array().length);"], [748, "                lh.addEntry(entry.array());"], [749, "            }"], [764, "            assertTrue(\"Last confirmed add: \" + sync.lastConfirmed, sync.lastConfirmed == (numEntriesToWrite - 2));"], [787, "            for (int i = 0; i < numEntriesToWrite; i++) {"], [788, "                ByteBuffer entry = ByteBuffer.allocate(4);"], [789, "                entry.putInt(rng.nextInt(maxInt));"], [790, "                entry.position(0);"], [792, "                entries.add(entry.array());"], [793, "                entriesSize.add(entry.array().length);"], [794, "                lh.addEntry(entry.array());"], [795, "                if (i == numEntriesToWrite / 2) {"], [796, "                    // no recovery opened ledger 's last confirmed entry id is"], [797, "                    // less than written"], [798, "                    // and it just can read until (i-1)"], [799, "                    int toRead = i - 1;"], [800, ""], [801, "                    long readLastConfirmed = lhOpen.readLastConfirmed();"], [802, "                    assertTrue(readLastConfirmed != 0);"], [803, "                    Enumeration<LedgerEntry> readEntry = lhOpen.readEntries(toRead, toRead);"], [804, "                    assertTrue(\"Enumeration of ledger entries has no element\", readEntry.hasMoreElements() == true);"], [805, "                    LedgerEntry e = readEntry.nextElement();"], [806, "                    assertEquals(toRead, e.getEntryId());"], [807, "                    Assert.assertArrayEquals(entries.get(toRead), e.getEntry());"], [808, "                    // should not written to a read only ledger"], [809, "                    try {"], [810, "                        lhOpen.addEntry(entry.array());"], [811, "                        fail(\"Should have thrown an exception here\");"], [812, "                    } catch (BKException.BKIllegalOpException bkioe) {"], [813, "                        // this is the correct response"], [814, "                    } catch (Exception ex) {"], [815, "                        LOG.error(\"Unexpected exception\", ex);"], [816, "                        fail(\"Unexpected exception\");"], [817, "                    }"], [819, "                }"], [907, "    public void testLastConfirmedAdd() throws IOException {"], [914, "            for (int i = 0; i < numEntriesToWrite; i++) {"], [915, "                ByteBuffer entry = ByteBuffer.allocate(4);"], [916, "                entry.putInt(rng.nextInt(maxInt));"], [917, "                entry.position(0);"], [918, ""], [919, "                entries.add(entry.array());"], [920, "                entriesSize.add(entry.array().length);"], [921, "                lh.addEntry(entry.array());"], [922, "            }"], [937, "            for (int i = 0; i < numEntriesToWrite; i++) {"], [938, "                ByteBuffer entry = ByteBuffer.allocate(4);"], [939, "                entry.putInt(rng.nextInt(maxInt));"], [940, "                entry.position(0);"], [941, ""], [942, "                entries.add(entry.array());"], [943, "                entriesSize.add(entry.array().length);"], [944, "                lh.addEntry(entry.array());"], [945, "            }"], [946, ""]]}, "num_lines_added": 127, "num_lines_removed": 95}