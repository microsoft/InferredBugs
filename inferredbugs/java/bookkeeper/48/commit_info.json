{"hash": "455aabfd3b6ffd4247f6df63cb29d0694b359cdd", "message": "BOOKKEEPER-581: Ledger recovery doesn't work correctly when recovery adds force changing ensembles. (sijie via ivank)\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/bookkeeper/trunk@1460765 13f79535-47bb-0310-9956-ffa450edef68", "file_num_lines": 104, "diff_parsed": {"added": [[22, "import java.util.concurrent.ScheduledExecutorService;"], [49, "    // keep a copy of metadata for recovery."], [50, "    LedgerMetadata metadataForRecovery;"], [54, "    class RecoveryReadOp extends PendingReadOp {"], [55, ""], [56, "        RecoveryReadOp(LedgerHandle lh, ScheduledExecutorService scheduler, long startEntryId,"], [57, "                long endEntryId, ReadCallback cb, Object ctx) {"], [58, "            super(lh, scheduler, startEntryId, endEntryId, cb, ctx);"], [59, "        }"], [60, ""], [61, "        @Override"], [62, "        protected LedgerMetadata getLedgerMetadata() {"], [63, "            return metadataForRecovery;"], [64, "        }"], [65, ""], [66, "    }"], [67, ""], [77, "                    public void readLastConfirmedDataComplete(int rc, RecoveryData data) {"], [78, "                        if (rc == BKException.Code.OK) {"], [79, "                            lh.lastAddPushed = lh.lastAddConfirmed = data.lastAddConfirmed;"], [80, "                            lh.length = data.length;"], [81, "                            // keep a copy of ledger metadata before proceeding"], [82, "                            // ledger recovery"], [83, "                            metadataForRecovery = new LedgerMetadata(lh.getLedgerMetadata());"], [84, "                            doRecoveryRead();"], [85, "                        } else if (rc == BKException.Code.UnauthorizedAccessException) {"], [86, "                            cb.operationComplete(rc, null);"], [87, "                        } else {"], [88, "                            cb.operationComplete(BKException.Code.ReadException, null);"], [89, "                        }"], [105, "        long nextEntry = lh.lastAddConfirmed + 1;"], [106, "        try {"], [107, "            new RecoveryReadOp(lh, lh.bk.scheduler, nextEntry, nextEntry, this, null).initiate();"], [108, "        } catch (InterruptedException e) {"], [109, "            readComplete(BKException.Code.InterruptedException, lh, null, null);"], [110, "        }"]], "deleted": [[26, "import org.apache.bookkeeper.client.AsyncCallback.ReadLastConfirmedCallback;"], [27, "import org.apache.bookkeeper.client.BKException.BKDigestMatchException;"], [28, "import org.apache.bookkeeper.client.LedgerHandle.NoopCloseCallback;"], [30, "import org.apache.bookkeeper.proto.BookieProtocol;"], [32, ""], [36, "import org.jboss.netty.buffer.ChannelBuffer;"], [66, "                public void readLastConfirmedDataComplete(int rc, RecoveryData data) {"], [67, "                    if (rc == BKException.Code.OK) {"], [68, "                        lh.lastAddPushed = lh.lastAddConfirmed = data.lastAddConfirmed;"], [69, "                        lh.length = data.length;"], [70, "                        doRecoveryRead();"], [71, "                    } else if (rc == BKException.Code.UnauthorizedAccessException) {"], [72, "                        cb.operationComplete(rc, null);"], [73, "                    } else {"], [74, "                        cb.operationComplete(BKException.Code.ReadException, null);"], [76, "                }"], [91, "        lh.lastAddConfirmed++;"], [92, "        lh.asyncReadEntries(lh.lastAddConfirmed, lh.lastAddConfirmed, this, null);"], [97, "        // get back to prev value"], [98, "        lh.lastAddConfirmed--;"], [148, ""], [150, ""]]}, "num_lines_added": 36, "num_lines_removed": 22}